; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\memp.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\memp.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\memp.crf ..\LWIP\lwip-1.4.1\src\core\memp.c]
                          THUMB

                          AREA ||i.memp_free||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  memp_free PROC
;;;449    void
;;;450    memp_free(memp_t type, void *mem)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;451    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;452      struct memp *memp;
;;;453      SYS_ARCH_DECL_PROTECT(old_level);
;;;454    
;;;455      if (mem == NULL) {
000008  b90c              CBNZ     r4,|L1.14|
                  |L1.10|
;;;456        return;
;;;457      }
;;;458      LWIP_ASSERT("memp_free: mem properly aligned",
;;;459                    ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);
;;;460    
;;;461      memp = (struct memp *)(void *)((u8_t*)mem - MEMP_SIZE);
;;;462    
;;;463      SYS_ARCH_PROTECT(old_level);
;;;464    #if MEMP_OVERFLOW_CHECK
;;;465    #if MEMP_OVERFLOW_CHECK >= 2
;;;466      memp_overflow_check_all();
;;;467    #else
;;;468      memp_overflow_check_element_overflow(memp, type);
;;;469      memp_overflow_check_element_underflow(memp, type);
;;;470    #endif /* MEMP_OVERFLOW_CHECK >= 2 */
;;;471    #endif /* MEMP_OVERFLOW_CHECK */
;;;472    
;;;473      MEMP_STATS_DEC(used, type); 
;;;474      
;;;475      memp->next = memp_tab[type]; 
;;;476      memp_tab[type] = memp;
;;;477    
;;;478    #if MEMP_SANITY_CHECK
;;;479      LWIP_ASSERT("memp sanity", memp_sanity());
;;;480    #endif /* MEMP_SANITY_CHECK */
;;;481    
;;;482      SYS_ARCH_UNPROTECT(old_level);
;;;483    }
00000a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.14|
00000e  bf00              NOP                            ;458
000010  f0040003          AND      r0,r4,#3              ;458
000014  b140              CBZ      r0,|L1.40|
000016  bf00              NOP                            ;458
000018  a30c              ADR      r3,|L1.76|
00001a  f44f72e5          MOV      r2,#0x1ca             ;458
00001e  a114              ADR      r1,|L1.112|
000020  a01b              ADR      r0,|L1.144|
000022  f7fffffe          BL       __2printf
000026  bf00              NOP                            ;458
                  |L1.40|
000028  bf00              NOP                            ;458
00002a  4626              MOV      r6,r4                 ;461
00002c  f7fffffe          BL       sys_arch_protect
000030  4607              MOV      r7,r0                 ;463
000032  4822              LDR      r0,|L1.188|
000034  f8500025          LDR      r0,[r0,r5,LSL #2]     ;475
000038  6030              STR      r0,[r6,#0]            ;475
00003a  4820              LDR      r0,|L1.188|
00003c  f8406025          STR      r6,[r0,r5,LSL #2]     ;476
000040  4638              MOV      r0,r7                 ;482
000042  f7fffffe          BL       sys_arch_unprotect
000046  bf00              NOP      
000048  e7df              B        |L1.10|
;;;484    
                          ENDP

00004a  0000              DCW      0x0000
                  |L1.76|
00004c  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\memp.c",0
000050  5749505c
000054  6c776970
000058  2d312e34
00005c  2e315c73
000060  72635c63
000064  6f72655c
000068  6d656d70
00006c  2e6300  
00006f  00                DCB      0
                  |L1.112|
000070  6d656d70          DCB      "memp_free: mem properly aligned",0
000074  5f667265
000078  653a206d
00007c  656d2070
000080  726f7065
000084  726c7920
000088  616c6967
00008c  6e656400
                  |L1.144|
000090  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000094  7274696f
000098  6e202225
00009c  73222066
0000a0  61696c65
0000a4  64206174
0000a8  206c696e
0000ac  65202564
0000b0  20696e20
0000b4  25730d0a
0000b8  00      
0000b9  00                DCB      0
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L1.188|
                          DCD      memp_tab

                          AREA ||i.memp_get_memorysize||, CODE, READONLY, ALIGN=1

                  memp_get_memorysize PROC
;;;334    //得到memp_memory数组大小
;;;335    u32_t memp_get_memorysize(void)
000000  2000              MOVS     r0,#0
;;;336    {
;;;337    	u32_t length=0;
;;;338    	length=(
000002  f2434063          MOV      r0,#0x3463
;;;339    			MEM_ALIGNMENT-1 //全局型数组 为所有POOL分配的内存空间
;;;340    			//MEMP_SIZE表示需要在每个POOL头部预留的空间  MEMP_SIZE = 0
;;;341    			#define LWIP_MEMPOOL(name,num,size,desc)+((num)*(MEMP_SIZE+MEMP_ALIGN_SIZE(size)))
;;;342    			#include "lwip/memp_std.h"
;;;1      /*
;;;2       * SETUP: Make sure we define everything we will need.
;;;3       *
;;;4       * We have create three types of pools:
;;;5       *   1) MEMPOOL - standard pools
;;;6       *   2) MALLOC_MEMPOOL - to be used by mem_malloc in mem.c
;;;7       *   3) PBUF_MEMPOOL - a mempool of pbuf's, so include space for the pbuf struct
;;;8       *
;;;9       * If the include'r doesn't require any special treatment of each of the types
;;;10      * above, then will declare #2 & #3 to be just standard mempools.
;;;11      */
;;;12     #ifndef LWIP_MALLOC_MEMPOOL
;;;13     /* This treats "malloc pools" just like any other pool.
;;;14        The pools are a little bigger to provide 'size' as the amount of user data. */
;;;15     #define LWIP_MALLOC_MEMPOOL(num, size) LWIP_MEMPOOL(POOL_##size, num, (size + sizeof(struct memp_malloc_helper)), "MALLOC_"#size)
;;;16     #define LWIP_MALLOC_MEMPOOL_START
;;;17     #define LWIP_MALLOC_MEMPOOL_END
;;;18     #endif /* LWIP_MALLOC_MEMPOOL */ 
;;;19     
;;;20     #ifndef LWIP_PBUF_MEMPOOL
;;;21     /* This treats "pbuf pools" just like any other pool.
;;;22      * Allocates buffers for a pbuf struct AND a payload size */
;;;23     #define LWIP_PBUF_MEMPOOL(name, num, payload, desc) LWIP_MEMPOOL(name, num, (MEMP_ALIGN_SIZE(sizeof(struct pbuf)) + MEMP_ALIGN_SIZE(payload)), desc)
;;;24     #endif /* LWIP_PBUF_MEMPOOL */
;;;25     
;;;26     
;;;27     /*
;;;28      * A list of internal pools used by LWIP.
;;;29      *
;;;30      * LWIP_MEMPOOL(pool_name, number_elements, element_size, pool_description)
;;;31      *     creates a pool name MEMP_pool_name. description is used in stats.c
;;;32      */
;;;33     #if LWIP_RAW
;;;34     LWIP_MEMPOOL(RAW_PCB,        MEMP_NUM_RAW_PCB,         sizeof(struct raw_pcb),        "RAW_PCB")
;;;35     #endif /* LWIP_RAW */
;;;36     
;;;37     #if LWIP_UDP
;;;38     LWIP_MEMPOOL(UDP_PCB,        MEMP_NUM_UDP_PCB,         sizeof(struct udp_pcb),        "UDP_PCB")
;;;39     #endif /* LWIP_UDP */
;;;40     
;;;41     #if LWIP_TCP
;;;42     LWIP_MEMPOOL(TCP_PCB,        MEMP_NUM_TCP_PCB,         sizeof(struct tcp_pcb),        "TCP_PCB")
;;;43     LWIP_MEMPOOL(TCP_PCB_LISTEN, MEMP_NUM_TCP_PCB_LISTEN,  sizeof(struct tcp_pcb_listen), "TCP_PCB_LISTEN")
;;;44     LWIP_MEMPOOL(TCP_SEG,        MEMP_NUM_TCP_SEG,         sizeof(struct tcp_seg),        "TCP_SEG")
;;;45     #endif /* LWIP_TCP */
;;;46     
;;;47     #if IP_REASSEMBLY
;;;48     LWIP_MEMPOOL(REASSDATA,      MEMP_NUM_REASSDATA,       sizeof(struct ip_reassdata),   "REASSDATA")
;;;49     #endif /* IP_REASSEMBLY */
;;;50     #if IP_FRAG && !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF
;;;51     LWIP_MEMPOOL(FRAG_PBUF,      MEMP_NUM_FRAG_PBUF,       sizeof(struct pbuf_custom_ref),"FRAG_PBUF")
;;;52     #endif /* IP_FRAG && !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF */
;;;53     
;;;54     #if LWIP_NETCONN
;;;55     LWIP_MEMPOOL(NETBUF,         MEMP_NUM_NETBUF,          sizeof(struct netbuf),         "NETBUF")
;;;56     LWIP_MEMPOOL(NETCONN,        MEMP_NUM_NETCONN,         sizeof(struct netconn),        "NETCONN")
;;;57     #endif /* LWIP_NETCONN */
;;;58     
;;;59     #if NO_SYS==0
;;;60     LWIP_MEMPOOL(TCPIP_MSG_API,  MEMP_NUM_TCPIP_MSG_API,   sizeof(struct tcpip_msg),      "TCPIP_MSG_API")
;;;61     #if !LWIP_TCPIP_CORE_LOCKING_INPUT
;;;62     LWIP_MEMPOOL(TCPIP_MSG_INPKT,MEMP_NUM_TCPIP_MSG_INPKT, sizeof(struct tcpip_msg),      "TCPIP_MSG_INPKT")
;;;63     #endif /* !LWIP_TCPIP_CORE_LOCKING_INPUT */
;;;64     #endif /* NO_SYS==0 */
;;;65     
;;;66     #if LWIP_ARP && ARP_QUEUEING
;;;67     LWIP_MEMPOOL(ARP_QUEUE,      MEMP_NUM_ARP_QUEUE,       sizeof(struct etharp_q_entry), "ARP_QUEUE")
;;;68     #endif /* LWIP_ARP && ARP_QUEUEING */
;;;69     
;;;70     #if LWIP_IGMP
;;;71     LWIP_MEMPOOL(IGMP_GROUP,     MEMP_NUM_IGMP_GROUP,      sizeof(struct igmp_group),     "IGMP_GROUP")
;;;72     #endif /* LWIP_IGMP */
;;;73     
;;;74     #if (!NO_SYS || (NO_SYS && !NO_SYS_NO_TIMERS)) /* LWIP_TIMERS */
;;;75     LWIP_MEMPOOL(SYS_TIMEOUT,    MEMP_NUM_SYS_TIMEOUT,     sizeof(struct sys_timeo),      "SYS_TIMEOUT")
;;;76     #endif /* LWIP_TIMERS */
;;;77     
;;;78     #if LWIP_SNMP
;;;79     LWIP_MEMPOOL(SNMP_ROOTNODE,  MEMP_NUM_SNMP_ROOTNODE,   sizeof(struct mib_list_rootnode), "SNMP_ROOTNODE")
;;;80     LWIP_MEMPOOL(SNMP_NODE,      MEMP_NUM_SNMP_NODE,       sizeof(struct mib_list_node),     "SNMP_NODE")
;;;81     LWIP_MEMPOOL(SNMP_VARBIND,   MEMP_NUM_SNMP_VARBIND,    sizeof(struct snmp_varbind),      "SNMP_VARBIND")
;;;82     LWIP_MEMPOOL(SNMP_VALUE,     MEMP_NUM_SNMP_VALUE,      SNMP_MAX_VALUE_SIZE,              "SNMP_VALUE")
;;;83     #endif /* LWIP_SNMP */
;;;84     #if LWIP_DNS && LWIP_SOCKET
;;;85     LWIP_MEMPOOL(NETDB,          MEMP_NUM_NETDB,           NETDB_ELEM_SIZE,               "NETDB")
;;;86     #endif /* LWIP_DNS && LWIP_SOCKET */
;;;87     #if LWIP_DNS && DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC
;;;88     LWIP_MEMPOOL(LOCALHOSTLIST,  MEMP_NUM_LOCALHOSTLIST,   LOCALHOSTLIST_ELEM_SIZE,       "LOCALHOSTLIST")
;;;89     #endif /* LWIP_DNS && DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
;;;90     #if PPP_SUPPORT && PPPOE_SUPPORT
;;;91     LWIP_MEMPOOL(PPPOE_IF,      MEMP_NUM_PPPOE_INTERFACES, sizeof(struct pppoe_softc),    "PPPOE_IF")
;;;92     #endif /* PPP_SUPPORT && PPPOE_SUPPORT */
;;;93     
;;;94     /*
;;;95      * A list of pools of pbuf's used by LWIP.
;;;96      *
;;;97      * LWIP_PBUF_MEMPOOL(pool_name, number_elements, pbuf_payload_size, pool_description)
;;;98      *     creates a pool name MEMP_pool_name. description is used in stats.c
;;;99      *     This allocates enough space for the pbuf struct and a payload.
;;;100     *     (Example: pbuf_payload_size=0 allocates only size for the struct)
;;;101     */
;;;102    LWIP_PBUF_MEMPOOL(PBUF,      MEMP_NUM_PBUF,            0,                             "PBUF_REF/ROM")
;;;103    LWIP_PBUF_MEMPOOL(PBUF_POOL, PBUF_POOL_SIZE,           PBUF_POOL_BUFSIZE,             "PBUF_POOL")
;;;104    
;;;105    
;;;106    /*
;;;107     * Allow for user-defined pools; this must be explicitly set in lwipopts.h
;;;108     * since the default is to NOT look for lwippools.h
;;;109     */
;;;110    #if MEMP_USE_CUSTOM_POOLS
;;;111    #include "lwippools.h"
;;;112    #endif /* MEMP_USE_CUSTOM_POOLS */
;;;113    
;;;114    /*
;;;115     * REQUIRED CLEANUP: Clear up so we don't get "multiply defined" error later
;;;116     * (#undef is ignored for something that is not defined)
;;;117     */
;;;118    #undef LWIP_MEMPOOL
;;;119    #undef LWIP_MALLOC_MEMPOOL
;;;120    #undef LWIP_MALLOC_MEMPOOL_START
;;;121    #undef LWIP_MALLOC_MEMPOOL_END
;;;122    #undef LWIP_PBUF_MEMPOOL
;;;343    			);
;;;344    	return length;
;;;345    }
000006  4770              BX       lr
;;;346    
                          ENDP


                          AREA ||i.memp_init||, CODE, READONLY, ALIGN=2

                  memp_init PROC
;;;352    void
;;;353    memp_init(void)
000000  b510              PUSH     {r4,lr}
;;;354    {
;;;355      struct memp *memp;
;;;356      u16_t i, j;
;;;357    
;;;358      for (i = 0; i < MEMP_MAX; ++i) {
000002  2000              MOVS     r0,#0
000004  e001              B        |L3.10|
                  |L3.6|
000006  1c43              ADDS     r3,r0,#1
000008  b298              UXTH     r0,r3
                  |L3.10|
00000a  280e              CMP      r0,#0xe
00000c  dbfb              BLT      |L3.6|
;;;359        MEMP_STATS_AVAIL(used, i, 0);
;;;360        MEMP_STATS_AVAIL(max, i, 0);
;;;361        MEMP_STATS_AVAIL(err, i, 0);
;;;362        MEMP_STATS_AVAIL(avail, i, memp_num[i]);
;;;363      }
;;;364    
;;;365    #if !MEMP_SEPARATE_POOLS
;;;366      memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
00000e  4b12              LDR      r3,|L3.88|
000010  681b              LDR      r3,[r3,#0]  ; memp_memory
000012  1cdb              ADDS     r3,r3,#3
000014  f0230103          BIC      r1,r3,#3
;;;367    #endif /* !MEMP_SEPARATE_POOLS */
;;;368      /* for every pool: */
;;;369      for (i = 0; i < MEMP_MAX; ++i) {
000018  2000              MOVS     r0,#0
00001a  e019              B        |L3.80|
                  |L3.28|
;;;370        memp_tab[i] = NULL;
00001c  2300              MOVS     r3,#0
00001e  4c0f              LDR      r4,|L3.92|
000020  f8443020          STR      r3,[r4,r0,LSL #2]
;;;371    #if MEMP_SEPARATE_POOLS
;;;372        memp = (struct memp*)memp_bases[i];
;;;373    #endif /* MEMP_SEPARATE_POOLS */
;;;374        /* create a linked list of memp elements */
;;;375        for (j = 0; j < memp_num[i]; ++j) {
000024  2200              MOVS     r2,#0
000026  e00c              B        |L3.66|
                  |L3.40|
;;;376          memp->next = memp_tab[i];
000028  4b0c              LDR      r3,|L3.92|
00002a  f8533020          LDR      r3,[r3,r0,LSL #2]
00002e  600b              STR      r3,[r1,#0]
;;;377          memp_tab[i] = memp;
000030  4b0a              LDR      r3,|L3.92|
000032  f8431020          STR      r1,[r3,r0,LSL #2]
;;;378          memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
000036  4b0a              LDR      r3,|L3.96|
000038  f8333010          LDRH     r3,[r3,r0,LSL #1]
00003c  4419              ADD      r1,r1,r3
00003e  1c53              ADDS     r3,r2,#1              ;375
000040  b29a              UXTH     r2,r3                 ;375
                  |L3.66|
000042  4b08              LDR      r3,|L3.100|
000044  f8333010          LDRH     r3,[r3,r0,LSL #1]     ;375
000048  4293              CMP      r3,r2                 ;375
00004a  dced              BGT      |L3.40|
00004c  1c43              ADDS     r3,r0,#1              ;369
00004e  b298              UXTH     r0,r3                 ;369
                  |L3.80|
000050  280e              CMP      r0,#0xe               ;369
000052  dbe3              BLT      |L3.28|
;;;379    #if MEMP_OVERFLOW_CHECK
;;;380            + MEMP_SANITY_REGION_AFTER_ALIGNED
;;;381    #endif
;;;382          );
;;;383        }
;;;384      }
;;;385    #if MEMP_OVERFLOW_CHECK
;;;386      memp_overflow_init();
;;;387      /* check everything a first time to see if it worked */
;;;388      memp_overflow_check_all();
;;;389    #endif /* MEMP_OVERFLOW_CHECK */
;;;390    }
000054  bd10              POP      {r4,pc}
;;;391    
                          ENDP

000056  0000              DCW      0x0000
                  |L3.88|
                          DCD      memp_memory
                  |L3.92|
                          DCD      memp_tab
                  |L3.96|
                          DCD      memp_sizes
                  |L3.100|
                          DCD      memp_num

                          AREA ||i.memp_malloc||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  memp_malloc PROC
;;;404    #if !MEMP_OVERFLOW_CHECK
;;;405    memp_malloc(memp_t type)
000000  b570              PUSH     {r4-r6,lr}
;;;406    #else
;;;407    memp_malloc_fn(memp_t type, const char* file, const int line)
;;;408    #endif
;;;409    {
000002  4605              MOV      r5,r0
;;;410      struct memp *memp;
;;;411      SYS_ARCH_DECL_PROTECT(old_level);
;;;412     
;;;413      LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
000004  bf00              NOP      
000006  2d0e              CMP      r5,#0xe
000008  db0a              BLT      |L4.32|
00000a  bf00              NOP      
00000c  a316              ADR      r3,|L4.104|
00000e  f240129d          MOV      r2,#0x19d
000012  a11e              ADR      r1,|L4.140|
000014  a025              ADR      r0,|L4.172|
000016  f7fffffe          BL       __2printf
00001a  bf00              NOP      
00001c  2000              MOVS     r0,#0
                  |L4.30|
;;;414    
;;;415      SYS_ARCH_PROTECT(old_level);
;;;416    #if MEMP_OVERFLOW_CHECK >= 2
;;;417      memp_overflow_check_all();
;;;418    #endif /* MEMP_OVERFLOW_CHECK >= 2 */
;;;419    
;;;420      memp = memp_tab[type];
;;;421      
;;;422      if (memp != NULL) {
;;;423        memp_tab[type] = memp->next;
;;;424    #if MEMP_OVERFLOW_CHECK
;;;425        memp->next = NULL;
;;;426        memp->file = file;
;;;427        memp->line = line;
;;;428    #endif /* MEMP_OVERFLOW_CHECK */
;;;429        MEMP_STATS_INC_USED(used, type);
;;;430        LWIP_ASSERT("memp_malloc: memp properly aligned",
;;;431                    ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
;;;432        memp = (struct memp*)(void *)((u8_t*)memp + MEMP_SIZE);
;;;433      } else {
;;;434        LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
;;;435        MEMP_STATS_INC(err, type);
;;;436      }
;;;437    
;;;438      SYS_ARCH_UNPROTECT(old_level);
;;;439    
;;;440      return memp;
;;;441    }
00001e  bd70              POP      {r4-r6,pc}
                  |L4.32|
000020  bf00              NOP                            ;413
000022  f7fffffe          BL       sys_arch_protect
000026  4606              MOV      r6,r0                 ;415
000028  482b              LDR      r0,|L4.216|
00002a  f8504025          LDR      r4,[r0,r5,LSL #2]     ;420
00002e  2c00              CMP      r4,#0                 ;422
000030  d013              BEQ      |L4.90|
000032  4929              LDR      r1,|L4.216|
000034  6820              LDR      r0,[r4,#0]            ;423
000036  f8410025          STR      r0,[r1,r5,LSL #2]     ;423
00003a  bf00              NOP                            ;430
00003c  f0040003          AND      r0,r4,#3              ;430
000040  2800              CMP      r0,#0                 ;430
000042  d008              BEQ      |L4.86|
000044  bf00              NOP                            ;430
000046  a308              ADR      r3,|L4.104|
000048  f44f72d7          MOV      r2,#0x1ae             ;430
00004c  a123              ADR      r1,|L4.220|
00004e  a017              ADR      r0,|L4.172|
000050  f7fffffe          BL       __2printf
000054  bf00              NOP                            ;430
                  |L4.86|
000056  bf00              NOP                            ;430
000058  e001              B        |L4.94|
                  |L4.90|
00005a  bf00              NOP                            ;434
00005c  bf00              NOP                            ;434
                  |L4.94|
00005e  4630              MOV      r0,r6                 ;438
000060  f7fffffe          BL       sys_arch_unprotect
000064  4620              MOV      r0,r4                 ;440
000066  e7da              B        |L4.30|
;;;442    
                          ENDP

                  |L4.104|
000068  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\memp.c",0
00006c  5749505c
000070  6c776970
000074  2d312e34
000078  2e315c73
00007c  72635c63
000080  6f72655c
000084  6d656d70
000088  2e6300  
00008b  00                DCB      0
                  |L4.140|
00008c  6d656d70          DCB      "memp_malloc: type < MEMP_MAX",0
000090  5f6d616c
000094  6c6f633a
000098  20747970
00009c  65203c20
0000a0  4d454d50
0000a4  5f4d4158
0000a8  00      
0000a9  00                DCB      0
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L4.172|
0000ac  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000b0  7274696f
0000b4  6e202225
0000b8  73222066
0000bc  61696c65
0000c0  64206174
0000c4  206c696e
0000c8  65202564
0000cc  20696e20
0000d0  25730d0a
0000d4  00      
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L4.216|
                          DCD      memp_tab
                  |L4.220|
0000dc  6d656d70          DCB      "memp_malloc: memp properly aligned",0
0000e0  5f6d616c
0000e4  6c6f633a
0000e8  206d656d
0000ec  70207072
0000f0  6f706572
0000f4  6c792061
0000f8  6c69676e
0000fc  656400  
0000ff  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  memp_tab
                          %        56

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  memp_sizes
000000  001c0020          DCW      0x001c,0x0020
000004  0098001c          DCW      0x0098,0x001c
000008  00140020          DCW      0x0014,0x0020
00000c  00180010          DCW      0x0018,0x0010
000010  00300014          DCW      0x0030,0x0014
000014  00140010          DCW      0x0014,0x0010
000018  00100210          DCW      0x0010,0x0210
                  memp_num
00001c  00040005          DCW      0x0004,0x0005
000020  00050006          DCW      0x0005,0x0006
000024  000a0005          DCW      0x000a,0x0005
000028  000f0002          DCW      0x000f,0x0002
00002c  00040008          DCW      0x0004,0x0008
000030  00080008          DCW      0x0008,0x0008
000034  00100014          DCW      0x0010,0x0014

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  5241575f          DCB      "RAW_PCB",0
000004  50434200
000008  5544505f          DCB      "UDP_PCB",0
00000c  50434200
000010  5443505f          DCB      "TCP_PCB",0
000014  50434200
000018  5443505f          DCB      "TCP_PCB_LISTEN",0
00001c  5043425f
000020  4c495354
000024  454e00  
000027  00                DCB      0
000028  5443505f          DCB      "TCP_SEG",0
00002c  53454700
000030  52454153          DCB      "REASSDATA",0
000034  53444154
000038  4100    
00003a  00                DCB      0
00003b  00                DCB      0
00003c  46524147          DCB      "FRAG_PBUF",0
000040  5f504255
000044  4600    
000046  00                DCB      0
000047  00                DCB      0
000048  4e455442          DCB      "NETBUF",0
00004c  554600  
00004f  00                DCB      0
000050  4e455443          DCB      "NETCONN",0
000054  4f4e4e00
000058  54435049          DCB      "TCPIP_MSG_API",0
00005c  505f4d53
000060  475f4150
000064  4900    
000066  00                DCB      0
000067  00                DCB      0
000068  54435049          DCB      "TCPIP_MSG_INPKT",0
00006c  505f4d53
000070  475f494e
000074  504b5400
000078  5359535f          DCB      "SYS_TIMEOUT",0
00007c  54494d45
000080  4f555400
000084  50425546          DCB      "PBUF_REF/ROM",0
000088  5f524546
00008c  2f524f4d
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0
000094  50425546          DCB      "PBUF_POOL",0
000098  5f504f4f
00009c  4c00    

                          AREA ||.data||, DATA, ALIGN=2

                  memp_desc
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x8
                          DCD      ||.conststring||+0x10
                          DCD      ||.conststring||+0x18
                          DCD      ||.conststring||+0x28
                          DCD      ||.conststring||+0x30
                          DCD      ||.conststring||+0x3c
                          DCD      ||.conststring||+0x48
                          DCD      ||.conststring||+0x50
                          DCD      ||.conststring||+0x58
                          DCD      ||.conststring||+0x68
                          DCD      ||.conststring||+0x78
                          DCD      ||.conststring||+0x84
                          DCD      ||.conststring||+0x94
                  memp_memory
                          DCD      0x00000000
