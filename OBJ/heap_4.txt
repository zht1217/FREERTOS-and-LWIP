; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\heap_4.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\heap_4.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\heap_4.crf ..\FreeRTOS\portable\MemMang\heap_4.c]
                          THUMB

                          AREA ||i.prvHeapInit||, CODE, READONLY, ALIGN=2

                  prvHeapInit PROC
;;;370    
;;;371    static void prvHeapInit( void )
000000  b530              PUSH     {r4,r5,lr}
;;;372    {
;;;373    BlockLink_t *pxFirstFreeBlock;
;;;374    uint8_t *pucAlignedHeap;
;;;375    size_t uxAddress;
;;;376    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
000002  f44f43a0          MOV      r3,#0x5000
;;;377    
;;;378    	/* Ensure the heap starts on a correctly aligned boundary. */
;;;379    	uxAddress = ( size_t ) ucHeap;
000006  4817              LDR      r0,|L1.100|
;;;380    
;;;381    	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
000008  f0000407          AND      r4,r0,#7
00000c  b12c              CBZ      r4,|L1.26|
;;;382    	{
;;;383    		uxAddress += ( portBYTE_ALIGNMENT - 1 );
00000e  1dc0              ADDS     r0,r0,#7
;;;384    		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
000010  f0200007          BIC      r0,r0,#7
;;;385    		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
000014  4c13              LDR      r4,|L1.100|
000016  1b04              SUBS     r4,r0,r4
000018  1b1b              SUBS     r3,r3,r4
                  |L1.26|
;;;386    	}
;;;387    
;;;388    	pucAlignedHeap = ( uint8_t * ) uxAddress;
00001a  4602              MOV      r2,r0
;;;389    
;;;390    	/* xStart is used to hold a pointer to the first item in the list of free
;;;391    	blocks.  The void cast is used to prevent compiler warnings. */
;;;392    	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
00001c  4c12              LDR      r4,|L1.104|
00001e  6022              STR      r2,[r4,#0]  ; xStart
;;;393    	xStart.xBlockSize = ( size_t ) 0;
000020  2400              MOVS     r4,#0
000022  4d11              LDR      r5,|L1.104|
000024  606c              STR      r4,[r5,#4]  ; xStart
;;;394    
;;;395    	/* pxEnd is used to mark the end of the list of free blocks and is inserted
;;;396    	at the end of the heap space. */
;;;397    	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
000026  18d0              ADDS     r0,r2,r3
;;;398    	uxAddress -= xHeapStructSize;
000028  3808              SUBS     r0,r0,#8
;;;399    	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
00002a  f0200007          BIC      r0,r0,#7
;;;400    	pxEnd = ( void * ) uxAddress;
00002e  4c0f              LDR      r4,|L1.108|
000030  6020              STR      r0,[r4,#0]  ; pxEnd
;;;401    	pxEnd->xBlockSize = 0;
000032  2400              MOVS     r4,#0
000034  4d0d              LDR      r5,|L1.108|
000036  682d              LDR      r5,[r5,#0]  ; pxEnd
000038  606c              STR      r4,[r5,#4]
;;;402    	pxEnd->pxNextFreeBlock = NULL;
00003a  4d0c              LDR      r5,|L1.108|
00003c  682d              LDR      r5,[r5,#0]  ; pxEnd
00003e  602c              STR      r4,[r5,#0]
;;;403    
;;;404    	/* To start with there is a single free block that is sized to take up the
;;;405    	entire heap space, minus the space taken by pxEnd. */
;;;406    	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
000040  4611              MOV      r1,r2
;;;407    	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
000042  1a44              SUBS     r4,r0,r1
000044  604c              STR      r4,[r1,#4]
;;;408    	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
000046  4c09              LDR      r4,|L1.108|
000048  6824              LDR      r4,[r4,#0]  ; pxEnd
00004a  600c              STR      r4,[r1,#0]
;;;409    
;;;410    	/* Only one block exists - and it covers the entire usable heap space. */
;;;411    	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
00004c  4d08              LDR      r5,|L1.112|
00004e  684c              LDR      r4,[r1,#4]
000050  602c              STR      r4,[r5,#0]  ; xMinimumEverFreeBytesRemaining
;;;412    	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
000052  4d08              LDR      r5,|L1.116|
000054  684c              LDR      r4,[r1,#4]
000056  602c              STR      r4,[r5,#0]  ; xFreeBytesRemaining
;;;413    
;;;414    	/* Work out the position of the top bit in a size_t variable. */
;;;415    	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
000058  f04f4400          MOV      r4,#0x80000000
00005c  4d06              LDR      r5,|L1.120|
00005e  602c              STR      r4,[r5,#0]  ; xBlockAllocatedBit
;;;416    }
000060  bd30              POP      {r4,r5,pc}
;;;417    /*-----------------------------------------------------------*/
                          ENDP

000062  0000              DCW      0x0000
                  |L1.100|
                          DCD      ucHeap
                  |L1.104|
                          DCD      xStart
                  |L1.108|
                          DCD      pxEnd
                  |L1.112|
                          DCD      xMinimumEverFreeBytesRemaining
                  |L1.116|
                          DCD      xFreeBytesRemaining
                  |L1.120|
                          DCD      xBlockAllocatedBit

                          AREA ||i.prvInsertBlockIntoFreeList||, CODE, READONLY, ALIGN=2

                  prvInsertBlockIntoFreeList PROC
;;;418    
;;;419    static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
000000  b510              PUSH     {r4,lr}
;;;420    {
000002  4601              MOV      r1,r0
;;;421    BlockLink_t *pxIterator;
;;;422    uint8_t *puc;
;;;423    
;;;424    	/* Iterate through the list until a block is found that has a higher address
;;;425    	than the block being inserted. */
;;;426    	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
000004  4816              LDR      r0,|L2.96|
000006  e000              B        |L2.10|
                  |L2.8|
000008  6800              LDR      r0,[r0,#0]
                  |L2.10|
00000a  6803              LDR      r3,[r0,#0]
00000c  428b              CMP      r3,r1
00000e  d3fb              BCC      |L2.8|
;;;427    	{
;;;428    		/* Nothing to do here, just iterate to the right position. */
;;;429    	}
;;;430    
;;;431    	/* Do the block being inserted, and the block it is being inserted after
;;;432    	make a contiguous block of memory? */
;;;433    	puc = ( uint8_t * ) pxIterator;
000010  4602              MOV      r2,r0
;;;434    	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
000012  6843              LDR      r3,[r0,#4]
000014  4413              ADD      r3,r3,r2
000016  428b              CMP      r3,r1
000018  d104              BNE      |L2.36|
;;;435    	{
;;;436    		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
00001a  6843              LDR      r3,[r0,#4]
00001c  684c              LDR      r4,[r1,#4]
00001e  4423              ADD      r3,r3,r4
000020  6043              STR      r3,[r0,#4]
;;;437    		pxBlockToInsert = pxIterator;
000022  4601              MOV      r1,r0
                  |L2.36|
;;;438    	}
;;;439    	else
;;;440    	{
;;;441    		mtCOVERAGE_TEST_MARKER();
;;;442    	}
;;;443    
;;;444    	/* Do the block being inserted, and the block it is being inserted before
;;;445    	make a contiguous block of memory? */
;;;446    	puc = ( uint8_t * ) pxBlockToInsert;
000024  460a              MOV      r2,r1
;;;447    	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
000026  684b              LDR      r3,[r1,#4]
000028  4413              ADD      r3,r3,r2
00002a  6804              LDR      r4,[r0,#0]
00002c  42a3              CMP      r3,r4
00002e  d111              BNE      |L2.84|
;;;448    	{
;;;449    		if( pxIterator->pxNextFreeBlock != pxEnd )
000030  4c0c              LDR      r4,|L2.100|
000032  6803              LDR      r3,[r0,#0]
000034  6824              LDR      r4,[r4,#0]  ; pxEnd
000036  42a3              CMP      r3,r4
000038  d008              BEQ      |L2.76|
;;;450    		{
;;;451    			/* Form one big block from the two blocks. */
;;;452    			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
00003a  684b              LDR      r3,[r1,#4]
00003c  6804              LDR      r4,[r0,#0]
00003e  6864              LDR      r4,[r4,#4]
000040  4423              ADD      r3,r3,r4
000042  604b              STR      r3,[r1,#4]
;;;453    			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
000044  6803              LDR      r3,[r0,#0]
000046  681b              LDR      r3,[r3,#0]
000048  600b              STR      r3,[r1,#0]
00004a  e005              B        |L2.88|
                  |L2.76|
;;;454    		}
;;;455    		else
;;;456    		{
;;;457    			pxBlockToInsert->pxNextFreeBlock = pxEnd;
00004c  4b05              LDR      r3,|L2.100|
00004e  681b              LDR      r3,[r3,#0]  ; pxEnd
000050  600b              STR      r3,[r1,#0]
000052  e001              B        |L2.88|
                  |L2.84|
;;;458    		}
;;;459    	}
;;;460    	else
;;;461    	{
;;;462    		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
000054  6803              LDR      r3,[r0,#0]
000056  600b              STR      r3,[r1,#0]
                  |L2.88|
;;;463    	}
;;;464    
;;;465    	/* If the block being inserted plugged a gab, so was merged with the block
;;;466    	before and the block after, then it's pxNextFreeBlock pointer will have
;;;467    	already been set, and should not be set here as that would make it point
;;;468    	to itself. */
;;;469    	if( pxIterator != pxBlockToInsert )
000058  4288              CMP      r0,r1
00005a  d000              BEQ      |L2.94|
;;;470    	{
;;;471    		pxIterator->pxNextFreeBlock = pxBlockToInsert;
00005c  6001              STR      r1,[r0,#0]
                  |L2.94|
;;;472    	}
;;;473    	else
;;;474    	{
;;;475    		mtCOVERAGE_TEST_MARKER();
;;;476    	}
;;;477    }
00005e  bd10              POP      {r4,pc}
;;;478    
                          ENDP

                  |L2.96|
                          DCD      xStart
                  |L2.100|
                          DCD      pxEnd

                          AREA ||i.pvPortMalloc||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pvPortMalloc PROC
;;;154    
;;;155    void *pvPortMalloc( size_t xWantedSize )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;156    {
000004  4604              MOV      r4,r0
;;;157    BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
;;;158    void *pvReturn = NULL;
000006  f04f0800          MOV      r8,#0
;;;159    
;;;160    	vTaskSuspendAll();
00000a  f7fffffe          BL       vTaskSuspendAll
;;;161    	{
;;;162    		/* If this is the first call to malloc then the heap will require
;;;163    		initialisation to setup the list of free blocks. */
;;;164    		if( pxEnd == NULL )
00000e  483e              LDR      r0,|L3.264|
000010  6800              LDR      r0,[r0,#0]  ; pxEnd
000012  b908              CBNZ     r0,|L3.24|
;;;165    		{
;;;166    			prvHeapInit();
000014  f7fffffe          BL       prvHeapInit
                  |L3.24|
;;;167    		}
;;;168    		else
;;;169    		{
;;;170    			mtCOVERAGE_TEST_MARKER();
;;;171    		}
;;;172    
;;;173    		/* Check the requested block size is not so large that the top bit is
;;;174    		set.  The top bit of the block size member of the BlockLink_t structure
;;;175    		is used to determine who owns the block - the application or the
;;;176    		kernel, so it must be free. */
;;;177    		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
000018  483c              LDR      r0,|L3.268|
00001a  6800              LDR      r0,[r0,#0]  ; xBlockAllocatedBit
00001c  4020              ANDS     r0,r0,r4
00001e  2800              CMP      r0,#0
000020  d15f              BNE      |L3.226|
;;;178    		{
;;;179    			/* The wanted size is increased so it can contain a BlockLink_t
;;;180    			structure in addition to the requested amount of bytes. */
;;;181    			if( xWantedSize > 0 )
000022  b1a4              CBZ      r4,|L3.78|
;;;182    			{
;;;183    				xWantedSize += xHeapStructSize;
000024  3408              ADDS     r4,r4,#8
;;;184    
;;;185    				/* Ensure that blocks are always aligned to the required number
;;;186    				of bytes. */
;;;187    				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
000026  f0040007          AND      r0,r4,#7
00002a  b180              CBZ      r0,|L3.78|
;;;188    				{
;;;189    					/* Byte alignment required. */
;;;190    					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
00002c  f0040007          AND      r0,r4,#7
000030  f1c00008          RSB      r0,r0,#8
000034  4404              ADD      r4,r4,r0
;;;191    					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
000036  f0040007          AND      r0,r4,#7
00003a  b908              CBNZ     r0,|L3.64|
00003c  2001              MOVS     r0,#1
00003e  e000              B        |L3.66|
                  |L3.64|
000040  2000              MOVS     r0,#0
                  |L3.66|
000042  b920              CBNZ     r0,|L3.78|
000044  22bf              MOVS     r2,#0xbf
000046  a132              ADR      r1,|L3.272|
000048  a03b              ADR      r0,|L3.312|
00004a  f7fffffe          BL       __2printf
                  |L3.78|
;;;192    				}
;;;193    				else
;;;194    				{
;;;195    					mtCOVERAGE_TEST_MARKER();
;;;196    				}
;;;197    			}
;;;198    			else
;;;199    			{
;;;200    				mtCOVERAGE_TEST_MARKER();
;;;201    			}
;;;202    
;;;203    			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
00004e  2c00              CMP      r4,#0
000050  d047              BEQ      |L3.226|
000052  483d              LDR      r0,|L3.328|
000054  6800              LDR      r0,[r0,#0]  ; xFreeBytesRemaining
000056  4284              CMP      r4,r0
000058  d843              BHI      |L3.226|
;;;204    			{
;;;205    				/* Traverse the list from the start	(lowest address) block until
;;;206    				one	of adequate size is found. */
;;;207    				pxPreviousBlock = &xStart;
00005a  4e3c              LDR      r6,|L3.332|
;;;208    				pxBlock = xStart.pxNextFreeBlock;
00005c  4630              MOV      r0,r6
00005e  6805              LDR      r5,[r0,#0]  ; xStart
;;;209    				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
000060  e001              B        |L3.102|
                  |L3.98|
;;;210    				{
;;;211    					pxPreviousBlock = pxBlock;
000062  462e              MOV      r6,r5
;;;212    					pxBlock = pxBlock->pxNextFreeBlock;
000064  682d              LDR      r5,[r5,#0]
                  |L3.102|
000066  6868              LDR      r0,[r5,#4]            ;209
000068  42a0              CMP      r0,r4                 ;209
00006a  d202              BCS      |L3.114|
00006c  6828              LDR      r0,[r5,#0]            ;209
00006e  2800              CMP      r0,#0                 ;209
000070  d1f7              BNE      |L3.98|
                  |L3.114|
;;;213    				}
;;;214    
;;;215    				/* If the end marker was reached then a block of adequate size
;;;216    				was	not found. */
;;;217    				if( pxBlock != pxEnd )
000072  4825              LDR      r0,|L3.264|
000074  6800              LDR      r0,[r0,#0]  ; pxEnd
000076  4285              CMP      r5,r0
000078  d033              BEQ      |L3.226|
;;;218    				{
;;;219    					/* Return the memory space pointed to - jumping over the
;;;220    					BlockLink_t structure at its start. */
;;;221    					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
00007a  6830              LDR      r0,[r6,#0]
00007c  f1000808          ADD      r8,r0,#8
;;;222    
;;;223    					/* This block is being returned for use so must be taken out
;;;224    					of the list of free blocks. */
;;;225    					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
000080  6828              LDR      r0,[r5,#0]
000082  6030              STR      r0,[r6,#0]
;;;226    
;;;227    					/* If the block is larger than required it can be split into
;;;228    					two. */
;;;229    					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
000084  6868              LDR      r0,[r5,#4]
000086  1b00              SUBS     r0,r0,r4
000088  2810              CMP      r0,#0x10
00008a  d913              BLS      |L3.180|
;;;230    					{
;;;231    						/* This block is to be split into two.  Create a new
;;;232    						block following the number of bytes requested. The void
;;;233    						cast is used to prevent byte alignment warnings from the
;;;234    						compiler. */
;;;235    						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
00008c  192f              ADDS     r7,r5,r4
;;;236    						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
00008e  f0070007          AND      r0,r7,#7
000092  b908              CBNZ     r0,|L3.152|
000094  2001              MOVS     r0,#1
000096  e000              B        |L3.154|
                  |L3.152|
000098  2000              MOVS     r0,#0
                  |L3.154|
00009a  b920              CBNZ     r0,|L3.166|
00009c  22ec              MOVS     r2,#0xec
00009e  a11c              ADR      r1,|L3.272|
0000a0  a025              ADR      r0,|L3.312|
0000a2  f7fffffe          BL       __2printf
                  |L3.166|
;;;237    
;;;238    						/* Calculate the sizes of two blocks split from the
;;;239    						single block. */
;;;240    						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
0000a6  6868              LDR      r0,[r5,#4]
0000a8  1b00              SUBS     r0,r0,r4
0000aa  6078              STR      r0,[r7,#4]
;;;241    						pxBlock->xBlockSize = xWantedSize;
0000ac  606c              STR      r4,[r5,#4]
;;;242    
;;;243    						/* Insert the new block into the list of free blocks. */
;;;244    						prvInsertBlockIntoFreeList( pxNewBlockLink );
0000ae  4638              MOV      r0,r7
0000b0  f7fffffe          BL       prvInsertBlockIntoFreeList
                  |L3.180|
;;;245    					}
;;;246    					else
;;;247    					{
;;;248    						mtCOVERAGE_TEST_MARKER();
;;;249    					}
;;;250    
;;;251    					xFreeBytesRemaining -= pxBlock->xBlockSize;
0000b4  4924              LDR      r1,|L3.328|
0000b6  6868              LDR      r0,[r5,#4]
0000b8  6809              LDR      r1,[r1,#0]  ; xFreeBytesRemaining
0000ba  1a08              SUBS     r0,r1,r0
0000bc  4922              LDR      r1,|L3.328|
0000be  6008              STR      r0,[r1,#0]  ; xFreeBytesRemaining
;;;252    
;;;253    					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
0000c0  4608              MOV      r0,r1
0000c2  6800              LDR      r0,[r0,#0]  ; xFreeBytesRemaining
0000c4  4922              LDR      r1,|L3.336|
0000c6  6809              LDR      r1,[r1,#0]  ; xMinimumEverFreeBytesRemaining
0000c8  4288              CMP      r0,r1
0000ca  d203              BCS      |L3.212|
;;;254    					{
;;;255    						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
0000cc  481e              LDR      r0,|L3.328|
0000ce  6800              LDR      r0,[r0,#0]  ; xFreeBytesRemaining
0000d0  491f              LDR      r1,|L3.336|
0000d2  6008              STR      r0,[r1,#0]  ; xMinimumEverFreeBytesRemaining
                  |L3.212|
;;;256    					}
;;;257    					else
;;;258    					{
;;;259    						mtCOVERAGE_TEST_MARKER();
;;;260    					}
;;;261    
;;;262    					/* The block is being returned - it is allocated and owned
;;;263    					by the application and has no "next" block. */
;;;264    					pxBlock->xBlockSize |= xBlockAllocatedBit;
0000d4  490d              LDR      r1,|L3.268|
0000d6  6868              LDR      r0,[r5,#4]
0000d8  6809              LDR      r1,[r1,#0]  ; xBlockAllocatedBit
0000da  4308              ORRS     r0,r0,r1
0000dc  6068              STR      r0,[r5,#4]
;;;265    					pxBlock->pxNextFreeBlock = NULL;
0000de  2000              MOVS     r0,#0
0000e0  6028              STR      r0,[r5,#0]
                  |L3.226|
;;;266    				}
;;;267    				else
;;;268    				{
;;;269    					mtCOVERAGE_TEST_MARKER();
;;;270    				}
;;;271    			}
;;;272    			else
;;;273    			{
;;;274    				mtCOVERAGE_TEST_MARKER();
;;;275    			}
;;;276    		}
;;;277    		else
;;;278    		{
;;;279    			mtCOVERAGE_TEST_MARKER();
;;;280    		}
;;;281    
;;;282    		traceMALLOC( pvReturn, xWantedSize );
;;;283    	}
;;;284    	( void ) xTaskResumeAll();
0000e2  f7fffffe          BL       xTaskResumeAll
;;;285    
;;;286    	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
;;;287    	{
;;;288    		if( pvReturn == NULL )
;;;289    		{
;;;290    			extern void vApplicationMallocFailedHook( void );
;;;291    			vApplicationMallocFailedHook();
;;;292    		}
;;;293    		else
;;;294    		{
;;;295    			mtCOVERAGE_TEST_MARKER();
;;;296    		}
;;;297    	}
;;;298    	#endif
;;;299    
;;;300    	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
0000e6  f0080007          AND      r0,r8,#7
0000ea  b908              CBNZ     r0,|L3.240|
0000ec  2001              MOVS     r0,#1
0000ee  e000              B        |L3.242|
                  |L3.240|
0000f0  2000              MOVS     r0,#0
                  |L3.242|
0000f2  b928              CBNZ     r0,|L3.256|
0000f4  f44f7296          MOV      r2,#0x12c
0000f8  a105              ADR      r1,|L3.272|
0000fa  a00f              ADR      r0,|L3.312|
0000fc  f7fffffe          BL       __2printf
                  |L3.256|
;;;301    	return pvReturn;
000100  4640              MOV      r0,r8
;;;302    }
000102  e8bd81f0          POP      {r4-r8,pc}
;;;303    /*-----------------------------------------------------------*/
                          ENDP

000106  0000              DCW      0x0000
                  |L3.264|
                          DCD      pxEnd
                  |L3.268|
                          DCD      xBlockAllocatedBit
                  |L3.272|
000110  2e2e5c46          DCB      "..\\FreeRTOS\\portable\\MemMang\\heap_4.c",0
000114  72656552
000118  544f535c
00011c  706f7274
000120  61626c65
000124  5c4d656d
000128  4d616e67
00012c  5c686561
000130  705f342e
000134  6300    
000136  00                DCB      0
000137  00                DCB      0
                  |L3.312|
000138  4572726f          DCB      "Error:%s,%d\r\n",0
00013c  723a2573
000140  2c25640d
000144  0a00    
000146  00                DCB      0
000147  00                DCB      0
                  |L3.328|
                          DCD      xFreeBytesRemaining
                  |L3.332|
                          DCD      xStart
                  |L3.336|
                          DCD      xMinimumEverFreeBytesRemaining

                          AREA ||i.vPortFree||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  vPortFree PROC
;;;304    
;;;305    void vPortFree( void *pv )
000000  b570              PUSH     {r4-r6,lr}
;;;306    {
000002  4606              MOV      r6,r0
;;;307    uint8_t *puc = ( uint8_t * ) pv;
000004  4635              MOV      r5,r6
;;;308    BlockLink_t *pxLink;
;;;309    
;;;310    	if( pv != NULL )
000006  2e00              CMP      r6,#0
000008  d035              BEQ      |L4.118|
;;;311    	{
;;;312    		/* The memory being freed will have an BlockLink_t structure immediately
;;;313    		before it. */
;;;314    		puc -= xHeapStructSize;
00000a  3d08              SUBS     r5,r5,#8
;;;315    
;;;316    		/* This casting is to keep the compiler from issuing warnings. */
;;;317    		pxLink = ( void * ) puc;
00000c  462c              MOV      r4,r5
;;;318    
;;;319    		/* Check the block is actually allocated. */
;;;320    		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
00000e  491a              LDR      r1,|L4.120|
000010  6860              LDR      r0,[r4,#4]
000012  6809              LDR      r1,[r1,#0]  ; xBlockAllocatedBit
000014  4008              ANDS     r0,r0,r1
000016  b108              CBZ      r0,|L4.28|
000018  2001              MOVS     r0,#1
00001a  e000              B        |L4.30|
                  |L4.28|
00001c  2000              MOVS     r0,#0
                  |L4.30|
00001e  b928              CBNZ     r0,|L4.44|
000020  f44f72a0          MOV      r2,#0x140
000024  a115              ADR      r1,|L4.124|
000026  a01f              ADR      r0,|L4.164|
000028  f7fffffe          BL       __2printf
                  |L4.44|
;;;321    		configASSERT( pxLink->pxNextFreeBlock == NULL );
00002c  6820              LDR      r0,[r4,#0]
00002e  b908              CBNZ     r0,|L4.52|
000030  2001              MOVS     r0,#1
000032  e000              B        |L4.54|
                  |L4.52|
000034  2000              MOVS     r0,#0
                  |L4.54|
000036  b928              CBNZ     r0,|L4.68|
000038  f2401241          MOV      r2,#0x141
00003c  a10f              ADR      r1,|L4.124|
00003e  a019              ADR      r0,|L4.164|
000040  f7fffffe          BL       __2printf
                  |L4.68|
;;;322    
;;;323    		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
000044  490c              LDR      r1,|L4.120|
000046  6860              LDR      r0,[r4,#4]
000048  6809              LDR      r1,[r1,#0]  ; xBlockAllocatedBit
00004a  4008              ANDS     r0,r0,r1
00004c  b198              CBZ      r0,|L4.118|
;;;324    		{
;;;325    			if( pxLink->pxNextFreeBlock == NULL )
00004e  6820              LDR      r0,[r4,#0]
000050  b988              CBNZ     r0,|L4.118|
;;;326    			{
;;;327    				/* The block is being returned to the heap - it is no longer
;;;328    				allocated. */
;;;329    				pxLink->xBlockSize &= ~xBlockAllocatedBit;
000052  4909              LDR      r1,|L4.120|
000054  6860              LDR      r0,[r4,#4]
000056  6809              LDR      r1,[r1,#0]  ; xBlockAllocatedBit
000058  4388              BICS     r0,r0,r1
00005a  6060              STR      r0,[r4,#4]
;;;330    
;;;331    				vTaskSuspendAll();
00005c  f7fffffe          BL       vTaskSuspendAll
;;;332    				{
;;;333    					/* Add this block to the list of free blocks. */
;;;334    					xFreeBytesRemaining += pxLink->xBlockSize;
000060  4914              LDR      r1,|L4.180|
000062  6860              LDR      r0,[r4,#4]
000064  6809              LDR      r1,[r1,#0]  ; xFreeBytesRemaining
000066  4408              ADD      r0,r0,r1
000068  4912              LDR      r1,|L4.180|
00006a  6008              STR      r0,[r1,#0]  ; xFreeBytesRemaining
;;;335    					traceFREE( pv, pxLink->xBlockSize );
;;;336    					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       prvInsertBlockIntoFreeList
;;;337    				}
;;;338    				( void ) xTaskResumeAll();
000072  f7fffffe          BL       xTaskResumeAll
                  |L4.118|
;;;339    			}
;;;340    			else
;;;341    			{
;;;342    				mtCOVERAGE_TEST_MARKER();
;;;343    			}
;;;344    		}
;;;345    		else
;;;346    		{
;;;347    			mtCOVERAGE_TEST_MARKER();
;;;348    		}
;;;349    	}
;;;350    }
000076  bd70              POP      {r4-r6,pc}
;;;351    /*-----------------------------------------------------------*/
                          ENDP

                  |L4.120|
                          DCD      xBlockAllocatedBit
                  |L4.124|
00007c  2e2e5c46          DCB      "..\\FreeRTOS\\portable\\MemMang\\heap_4.c",0
000080  72656552
000084  544f535c
000088  706f7274
00008c  61626c65
000090  5c4d656d
000094  4d616e67
000098  5c686561
00009c  705f342e
0000a0  6300    
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L4.164|
0000a4  4572726f          DCB      "Error:%s,%d\r\n",0
0000a8  723a2573
0000ac  2c25640d
0000b0  0a00    
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L4.180|
                          DCD      xFreeBytesRemaining

                          AREA ||i.vPortInitialiseBlocks||, CODE, READONLY, ALIGN=1

                  vPortInitialiseBlocks PROC
;;;364    
;;;365    void vPortInitialiseBlocks( void )
000000  4770              BX       lr
;;;366    {
;;;367    	/* This just exists to keep the linker quiet. */
;;;368    }
;;;369    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xPortGetFreeHeapSize||, CODE, READONLY, ALIGN=2

                  xPortGetFreeHeapSize PROC
;;;352    
;;;353    size_t xPortGetFreeHeapSize( void )
000000  4801              LDR      r0,|L6.8|
;;;354    {
;;;355    	return xFreeBytesRemaining;
000002  6800              LDR      r0,[r0,#0]  ; xFreeBytesRemaining
;;;356    }
000004  4770              BX       lr
;;;357    /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      xFreeBytesRemaining

                          AREA ||i.xPortGetMinimumEverFreeHeapSize||, CODE, READONLY, ALIGN=2

                  xPortGetMinimumEverFreeHeapSize PROC
;;;358    
;;;359    size_t xPortGetMinimumEverFreeHeapSize( void )
000000  4801              LDR      r0,|L7.8|
;;;360    {
;;;361    	return xMinimumEverFreeBytesRemaining;
000002  6800              LDR      r0,[r0,#0]  ; xMinimumEverFreeBytesRemaining
;;;362    }
000004  4770              BX       lr
;;;363    /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      xMinimumEverFreeBytesRemaining

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ucHeap
                          %        20480

                          AREA ||.data||, DATA, ALIGN=2

                  xStart
                          %        8
                  pxEnd
                          DCD      0x00000000
                  xFreeBytesRemaining
                          DCD      0x00000000
                  xMinimumEverFreeBytesRemaining
                          DCD      0x00000000
                  xBlockAllocatedBit
                          DCD      0x00000000
