; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\queue.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\queue.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\queue.crf ..\FreeRTOS\queue.c]
                          THUMB

                          AREA ||i.pcQueueGetName||, CODE, READONLY, ALIGN=2

                  pcQueueGetName PROC
;;;2297   
;;;2298   	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  4602              MOV      r2,r0
;;;2299   	{
;;;2300   	UBaseType_t ux;
;;;2301   	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000002  2000              MOVS     r0,#0
;;;2302   
;;;2303   		/* Note there is nothing here to protect against another task adding or
;;;2304   		removing entries from the registry while it is being searched. */
;;;2305   		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
000004  2100              MOVS     r1,#0
000006  e00a              B        |L1.30|
                  |L1.8|
;;;2306   		{
;;;2307   			if( xQueueRegistry[ ux ].xHandle == xQueue )
000008  4b07              LDR      r3,|L1.40|
00000a  eb0303c1          ADD      r3,r3,r1,LSL #3
00000e  685b              LDR      r3,[r3,#4]
000010  4293              CMP      r3,r2
000012  d103              BNE      |L1.28|
;;;2308   			{
;;;2309   				pcReturn = xQueueRegistry[ ux ].pcQueueName;
000014  4b04              LDR      r3,|L1.40|
000016  f8530031          LDR      r0,[r3,r1,LSL #3]
;;;2310   				break;
00001a  e002              B        |L1.34|
                  |L1.28|
00001c  1c49              ADDS     r1,r1,#1              ;2305
                  |L1.30|
00001e  2908              CMP      r1,#8                 ;2305
000020  d3f2              BCC      |L1.8|
                  |L1.34|
000022  bf00              NOP      
;;;2311   			}
;;;2312   			else
;;;2313   			{
;;;2314   				mtCOVERAGE_TEST_MARKER();
;;;2315   			}
;;;2316   		}
;;;2317   
;;;2318   		return pcReturn;
;;;2319   	}
000024  4770              BX       lr
;;;2320   
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      xQueueRegistry

                          AREA ||i.prvCopyDataFromQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataFromQueue PROC
;;;1775   
;;;1776   static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
000000  b570              PUSH     {r4-r6,lr}
;;;1777   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1778   	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
000006  6c20              LDR      r0,[r4,#0x40]
000008  b170              CBZ      r0,|L2.40|
;;;1779   	{
;;;1780   		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
00000a  6c21              LDR      r1,[r4,#0x40]
00000c  68e0              LDR      r0,[r4,#0xc]
00000e  4408              ADD      r0,r0,r1
000010  60e0              STR      r0,[r4,#0xc]
;;;1781   		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
000012  6861              LDR      r1,[r4,#4]
000014  68e0              LDR      r0,[r4,#0xc]
000016  4288              CMP      r0,r1
000018  d301              BCC      |L2.30|
;;;1782   		{
;;;1783   			pxQueue->u.pcReadFrom = pxQueue->pcHead;
00001a  6820              LDR      r0,[r4,#0]
00001c  60e0              STR      r0,[r4,#0xc]
                  |L2.30|
;;;1784   		}
;;;1785   		else
;;;1786   		{
;;;1787   			mtCOVERAGE_TEST_MARKER();
;;;1788   		}
;;;1789   		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
00001e  4628              MOV      r0,r5
000020  6c22              LDR      r2,[r4,#0x40]
000022  68e1              LDR      r1,[r4,#0xc]
000024  f7fffffe          BL       __aeabi_memcpy
                  |L2.40|
;;;1790   	}
;;;1791   }
000028  bd70              POP      {r4-r6,pc}
;;;1792   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCopyDataToQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataToQueue PROC
;;;1696   
;;;1697   static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1698   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;1699   BaseType_t xReturn = pdFALSE;
00000a  f04f0800          MOV      r8,#0
;;;1700   UBaseType_t uxMessagesWaiting;
;;;1701   
;;;1702   	/* This function is called from a critical section. */
;;;1703   
;;;1704   	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00000e  6ba6              LDR      r6,[r4,#0x38]
;;;1705   
;;;1706   	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
000010  6c20              LDR      r0,[r4,#0x40]
000012  b940              CBNZ     r0,|L3.38|
;;;1707   	{
;;;1708   		#if ( configUSE_MUTEXES == 1 )
;;;1709   		{
;;;1710   			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
000014  6820              LDR      r0,[r4,#0]
000016  bb60              CBNZ     r0,|L3.114|
;;;1711   			{
;;;1712   				/* The mutex is no longer being held. */
;;;1713   				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
000018  6860              LDR      r0,[r4,#4]
00001a  f7fffffe          BL       xTaskPriorityDisinherit
00001e  4680              MOV      r8,r0
;;;1714   				pxQueue->pxMutexHolder = NULL;
000020  2000              MOVS     r0,#0
000022  6060              STR      r0,[r4,#4]
000024  e025              B        |L3.114|
                  |L3.38|
;;;1715   			}
;;;1716   			else
;;;1717   			{
;;;1718   				mtCOVERAGE_TEST_MARKER();
;;;1719   			}
;;;1720   		}
;;;1721   		#endif /* configUSE_MUTEXES */
;;;1722   	}
;;;1723   	else if( xPosition == queueSEND_TO_BACK )
000026  b97d              CBNZ     r5,|L3.72|
;;;1724   	{
;;;1725   		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
000028  4639              MOV      r1,r7
00002a  6c22              LDR      r2,[r4,#0x40]
00002c  68a0              LDR      r0,[r4,#8]
00002e  f7fffffe          BL       __aeabi_memcpy
;;;1726   		pxQueue->pcWriteTo += pxQueue->uxItemSize;
000032  6c21              LDR      r1,[r4,#0x40]
000034  68a0              LDR      r0,[r4,#8]
000036  4408              ADD      r0,r0,r1
000038  60a0              STR      r0,[r4,#8]
;;;1727   		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
00003a  e9d41001          LDRD     r1,r0,[r4,#4]
00003e  4288              CMP      r0,r1
000040  d317              BCC      |L3.114|
;;;1728   		{
;;;1729   			pxQueue->pcWriteTo = pxQueue->pcHead;
000042  6820              LDR      r0,[r4,#0]
000044  60a0              STR      r0,[r4,#8]
000046  e014              B        |L3.114|
                  |L3.72|
;;;1730   		}
;;;1731   		else
;;;1732   		{
;;;1733   			mtCOVERAGE_TEST_MARKER();
;;;1734   		}
;;;1735   	}
;;;1736   	else
;;;1737   	{
;;;1738   		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000048  4639              MOV      r1,r7
00004a  6c22              LDR      r2,[r4,#0x40]
00004c  68e0              LDR      r0,[r4,#0xc]
00004e  f7fffffe          BL       __aeabi_memcpy
;;;1739   		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
000052  6c21              LDR      r1,[r4,#0x40]
000054  68e0              LDR      r0,[r4,#0xc]
000056  1a40              SUBS     r0,r0,r1
000058  60e0              STR      r0,[r4,#0xc]
;;;1740   		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
00005a  6821              LDR      r1,[r4,#0]
00005c  68e0              LDR      r0,[r4,#0xc]
00005e  4288              CMP      r0,r1
000060  d203              BCS      |L3.106|
;;;1741   		{
;;;1742   			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
000062  6c21              LDR      r1,[r4,#0x40]
000064  6860              LDR      r0,[r4,#4]
000066  1a40              SUBS     r0,r0,r1
000068  60e0              STR      r0,[r4,#0xc]
                  |L3.106|
;;;1743   		}
;;;1744   		else
;;;1745   		{
;;;1746   			mtCOVERAGE_TEST_MARKER();
;;;1747   		}
;;;1748   
;;;1749   		if( xPosition == queueOVERWRITE )
00006a  2d02              CMP      r5,#2
00006c  d101              BNE      |L3.114|
;;;1750   		{
;;;1751   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
00006e  b106              CBZ      r6,|L3.114|
;;;1752   			{
;;;1753   				/* An item is not being added but overwritten, so subtract
;;;1754   				one from the recorded number of items in the queue so when
;;;1755   				one is added again below the number of recorded items remains
;;;1756   				correct. */
;;;1757   				--uxMessagesWaiting;
000070  1e76              SUBS     r6,r6,#1
                  |L3.114|
;;;1758   			}
;;;1759   			else
;;;1760   			{
;;;1761   				mtCOVERAGE_TEST_MARKER();
;;;1762   			}
;;;1763   		}
;;;1764   		else
;;;1765   		{
;;;1766   			mtCOVERAGE_TEST_MARKER();
;;;1767   		}
;;;1768   	}
;;;1769   
;;;1770   	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
000072  1c70              ADDS     r0,r6,#1
000074  63a0              STR      r0,[r4,#0x38]
;;;1771   
;;;1772   	return xReturn;
000076  4640              MOV      r0,r8
;;;1773   }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;1774   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvInitialiseMutex||, CODE, READONLY, ALIGN=1

                  prvInitialiseMutex PROC
;;;475    
;;;476    	static void prvInitialiseMutex( Queue_t *pxNewQueue )
000000  b510              PUSH     {r4,lr}
;;;477    	{
000002  4604              MOV      r4,r0
;;;478    		if( pxNewQueue != NULL )
000004  b14c              CBZ      r4,|L4.26|
;;;479    		{
;;;480    			/* The queue create function will set all the queue structure members
;;;481    			correctly for a generic queue, but this function is creating a
;;;482    			mutex.  Overwrite those members that need to be set differently -
;;;483    			in particular the information required for priority inheritance. */
;;;484    			pxNewQueue->pxMutexHolder = NULL;
000006  2000              MOVS     r0,#0
000008  6060              STR      r0,[r4,#4]
;;;485    			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
00000a  6020              STR      r0,[r4,#0]
;;;486    
;;;487    			/* In case this is a recursive mutex. */
;;;488    			pxNewQueue->u.uxRecursiveCallCount = 0;
00000c  60e0              STR      r0,[r4,#0xc]
;;;489    
;;;490    			traceCREATE_MUTEX( pxNewQueue );
;;;491    
;;;492    			/* Start with the semaphore in the expected state. */
;;;493    			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
00000e  2300              MOVS     r3,#0
000010  461a              MOV      r2,r3
000012  4619              MOV      r1,r3
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       xQueueGenericSend
                  |L4.26|
;;;494    		}
;;;495    		else
;;;496    		{
;;;497    			traceCREATE_MUTEX_FAILED();
;;;498    		}
;;;499    	}
00001a  bd10              POP      {r4,pc}
;;;500    
                          ENDP


                          AREA ||i.prvInitialiseNewQueue||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewQueue PROC
;;;431    
;;;432    static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;433    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9c06              LDR      r4,[sp,#0x18]
;;;434    	/* Remove compiler warnings about unused parameters should
;;;435    	configUSE_TRACE_FACILITY not be set to 1. */
;;;436    	( void ) ucQueueType;
;;;437    
;;;438    	if( uxItemSize == ( UBaseType_t ) 0 )
00000e  b90d              CBNZ     r5,|L5.20|
;;;439    	{
;;;440    		/* No RAM was allocated for the queue storage area, but PC head cannot
;;;441    		be set to NULL because NULL is used as a key to say the queue is used as
;;;442    		a mutex.  Therefore just set pcHead to point to the queue as a benign
;;;443    		value that is known to be within the memory map. */
;;;444    		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
000010  6024              STR      r4,[r4,#0]
000012  e000              B        |L5.22|
                  |L5.20|
;;;445    	}
;;;446    	else
;;;447    	{
;;;448    		/* Set the head to the start of the queue storage area. */
;;;449    		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
000014  6027              STR      r7,[r4,#0]
                  |L5.22|
;;;450    	}
;;;451    
;;;452    	/* Initialise the queue members as described where the queue type is
;;;453    	defined. */
;;;454    	pxNewQueue->uxLength = uxQueueLength;
000016  63e6              STR      r6,[r4,#0x3c]
;;;455    	pxNewQueue->uxItemSize = uxItemSize;
000018  6425              STR      r5,[r4,#0x40]
;;;456    	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
00001a  2101              MOVS     r1,#1
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       xQueueGenericReset
;;;457    
;;;458    	#if ( configUSE_TRACE_FACILITY == 1 )
;;;459    	{
;;;460    		pxNewQueue->ucQueueType = ucQueueType;
000022  f8848050          STRB     r8,[r4,#0x50]
;;;461    	}
;;;462    	#endif /* configUSE_TRACE_FACILITY */
;;;463    
;;;464    	#if( configUSE_QUEUE_SETS == 1 )
;;;465    	{
;;;466    		pxNewQueue->pxQueueSetContainer = NULL;
000026  2000              MOVS     r0,#0
000028  64a0              STR      r0,[r4,#0x48]
;;;467    	}
;;;468    	#endif /* configUSE_QUEUE_SETS */
;;;469    
;;;470    	traceQUEUE_CREATE( pxNewQueue );
;;;471    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;472    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueEmpty||, CODE, READONLY, ALIGN=1

                  prvIsQueueEmpty PROC
;;;1913   
;;;1914   static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1915   {
000002  4605              MOV      r5,r0
;;;1916   BaseType_t xReturn;
;;;1917   
;;;1918   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1919   	{
;;;1920   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
000008  6ba8              LDR      r0,[r5,#0x38]
00000a  b908              CBNZ     r0,|L6.16|
;;;1921   		{
;;;1922   			xReturn = pdTRUE;
00000c  2401              MOVS     r4,#1
00000e  e000              B        |L6.18|
                  |L6.16|
;;;1923   		}
;;;1924   		else
;;;1925   		{
;;;1926   			xReturn = pdFALSE;
000010  2400              MOVS     r4,#0
                  |L6.18|
;;;1927   		}
;;;1928   	}
;;;1929   	taskEXIT_CRITICAL();
000012  f7fffffe          BL       vPortExitCritical
;;;1930   
;;;1931   	return xReturn;
000016  4620              MOV      r0,r4
;;;1932   }
000018  bd70              POP      {r4-r6,pc}
;;;1933   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueFull||, CODE, READONLY, ALIGN=1

                  prvIsQueueFull PROC
;;;1952   
;;;1953   static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1954   {
000002  4605              MOV      r5,r0
;;;1955   BaseType_t xReturn;
;;;1956   
;;;1957   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1958   	{
;;;1959   		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
000008  6ba8              LDR      r0,[r5,#0x38]
00000a  6be9              LDR      r1,[r5,#0x3c]
00000c  4288              CMP      r0,r1
00000e  d101              BNE      |L7.20|
;;;1960   		{
;;;1961   			xReturn = pdTRUE;
000010  2401              MOVS     r4,#1
000012  e000              B        |L7.22|
                  |L7.20|
;;;1962   		}
;;;1963   		else
;;;1964   		{
;;;1965   			xReturn = pdFALSE;
000014  2400              MOVS     r4,#0
                  |L7.22|
;;;1966   		}
;;;1967   	}
;;;1968   	taskEXIT_CRITICAL();
000016  f7fffffe          BL       vPortExitCritical
;;;1969   
;;;1970   	return xReturn;
00001a  4620              MOV      r0,r4
;;;1971   }
00001c  bd70              POP      {r4-r6,pc}
;;;1972   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvNotifyQueueSetContainer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  prvNotifyQueueSetContainer PROC
;;;2502   
;;;2503   	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
000000  e92d41f3          PUSH     {r0,r1,r4-r8,lr}
;;;2504   	{
000004  460d              MOV      r5,r1
;;;2505   	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
000006  9800              LDR      r0,[sp,#0]
000008  6c84              LDR      r4,[r0,#0x48]
;;;2506   	BaseType_t xReturn = pdFALSE;
00000a  2700              MOVS     r7,#0
;;;2507   
;;;2508   		/* This function must be called form a critical section. */
;;;2509   
;;;2510   		configASSERT( pxQueueSetContainer );
00000c  b92c              CBNZ     r4,|L8.26|
00000e  f64012ce          MOV      r2,#0x9ce
000012  a11a              ADR      r1,|L8.124|
000014  a01e              ADR      r0,|L8.144|
000016  f7fffffe          BL       __2printf
                  |L8.26|
;;;2511   		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
00001a  6ba0              LDR      r0,[r4,#0x38]
00001c  6be1              LDR      r1,[r4,#0x3c]
00001e  4288              CMP      r0,r1
000020  d201              BCS      |L8.38|
000022  2001              MOVS     r0,#1
000024  e000              B        |L8.40|
                  |L8.38|
000026  2000              MOVS     r0,#0
                  |L8.40|
000028  b928              CBNZ     r0,|L8.54|
00002a  f64012cf          MOV      r2,#0x9cf
00002e  a113              ADR      r1,|L8.124|
000030  a017              ADR      r0,|L8.144|
000032  f7fffffe          BL       __2printf
                  |L8.54|
;;;2512   
;;;2513   		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
000036  6ba0              LDR      r0,[r4,#0x38]
000038  6be1              LDR      r1,[r4,#0x3c]
00003a  4288              CMP      r0,r1
00003c  d21b              BCS      |L8.118|
;;;2514   		{
;;;2515   			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
00003e  f9946045          LDRSB    r6,[r4,#0x45]
;;;2516   
;;;2517   			traceQUEUE_SEND( pxQueueSetContainer );
;;;2518   
;;;2519   			/* The data copied is the handle of the queue that contains data. */
;;;2520   			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
000042  462a              MOV      r2,r5
000044  4669              MOV      r1,sp
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       prvCopyDataToQueue
00004c  4607              MOV      r7,r0
;;;2521   
;;;2522   			if( cTxLock == queueUNLOCKED )
00004e  1c70              ADDS     r0,r6,#1
000050  b960              CBNZ     r0,|L8.108|
;;;2523   			{
;;;2524   				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
000052  6a60              LDR      r0,[r4,#0x24]
000054  b908              CBNZ     r0,|L8.90|
000056  2001              MOVS     r0,#1
000058  e000              B        |L8.92|
                  |L8.90|
00005a  2000              MOVS     r0,#0
                  |L8.92|
00005c  b950              CBNZ     r0,|L8.116|
;;;2525   				{
;;;2526   					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
00005e  f1040024          ADD      r0,r4,#0x24
000062  f7fffffe          BL       xTaskRemoveFromEventList
000066  b128              CBZ      r0,|L8.116|
;;;2527   					{
;;;2528   						/* The task waiting has a higher priority. */
;;;2529   						xReturn = pdTRUE;
000068  2701              MOVS     r7,#1
00006a  e003              B        |L8.116|
                  |L8.108|
;;;2530   					}
;;;2531   					else
;;;2532   					{
;;;2533   						mtCOVERAGE_TEST_MARKER();
;;;2534   					}
;;;2535   				}
;;;2536   				else
;;;2537   				{
;;;2538   					mtCOVERAGE_TEST_MARKER();
;;;2539   				}
;;;2540   			}
;;;2541   			else
;;;2542   			{
;;;2543   				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
00006c  1c70              ADDS     r0,r6,#1
00006e  b240              SXTB     r0,r0
000070  f8840045          STRB     r0,[r4,#0x45]
                  |L8.116|
;;;2544   			}
;;;2545   		}
000074  bf00              NOP      
                  |L8.118|
;;;2546   		else
;;;2547   		{
;;;2548   			mtCOVERAGE_TEST_MARKER();
;;;2549   		}
;;;2550   
;;;2551   		return xReturn;
000076  4638              MOV      r0,r7
;;;2552   	}
000078  e8bd81fc          POP      {r2-r8,pc}
;;;2553   
                          ENDP

                  |L8.124|
00007c  2e2e5c46          DCB      "..\\FreeRTOS\\queue.c",0
000080  72656552
000084  544f535c
000088  71756575
00008c  652e6300
                  |L8.144|
000090  4572726f          DCB      "Error:%s,%d\r\n",0
000094  723a2573
000098  2c25640d
00009c  0a00    
00009e  00                DCB      0
00009f  00                DCB      0

                          AREA ||i.prvUnlockQueue||, CODE, READONLY, ALIGN=1

                  prvUnlockQueue PROC
;;;1793   
;;;1794   static void prvUnlockQueue( Queue_t * const pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1795   {
000002  4604              MOV      r4,r0
;;;1796   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;1797   
;;;1798   	/* The lock counts contains the number of extra data items placed or
;;;1799   	removed from the queue while the queue was locked.  When a queue is
;;;1800   	locked items can be added or removed, but the event lists cannot be
;;;1801   	updated. */
;;;1802   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1803   	{
;;;1804   		int8_t cTxLock = pxQueue->cTxLock;
000008  f9945045          LDRSB    r5,[r4,#0x45]
;;;1805   
;;;1806   		/* See if data was added to the queue while it was locked. */
;;;1807   		while( cTxLock > queueLOCKED_UNMODIFIED )
00000c  e01a              B        |L9.68|
                  |L9.14|
;;;1808   		{
;;;1809   			/* Data was posted while the queue was locked.  Are any tasks
;;;1810   			blocked waiting for data to become available? */
;;;1811   			#if ( configUSE_QUEUE_SETS == 1 )
;;;1812   			{
;;;1813   				if( pxQueue->pxQueueSetContainer != NULL )
00000e  6ca0              LDR      r0,[r4,#0x48]
000010  b138              CBZ      r0,|L9.34|
;;;1814   				{
;;;1815   					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
000012  2100              MOVS     r1,#0
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       prvNotifyQueueSetContainer
00001a  b188              CBZ      r0,|L9.64|
;;;1816   					{
;;;1817   						/* The queue is a member of a queue set, and posting to
;;;1818   						the queue set caused a higher priority task to unblock.
;;;1819   						A context switch is required. */
;;;1820   						vTaskMissedYield();
00001c  f7fffffe          BL       vTaskMissedYield
000020  e00e              B        |L9.64|
                  |L9.34|
;;;1821   					}
;;;1822   					else
;;;1823   					{
;;;1824   						mtCOVERAGE_TEST_MARKER();
;;;1825   					}
;;;1826   				}
;;;1827   				else
;;;1828   				{
;;;1829   					/* Tasks that are removed from the event list will get
;;;1830   					added to the pending ready list as the scheduler is still
;;;1831   					suspended. */
;;;1832   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000022  6a60              LDR      r0,[r4,#0x24]
000024  b908              CBNZ     r0,|L9.42|
000026  2001              MOVS     r0,#1
000028  e000              B        |L9.44|
                  |L9.42|
00002a  2000              MOVS     r0,#0
                  |L9.44|
00002c  b938              CBNZ     r0,|L9.62|
;;;1833   					{
;;;1834   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
00002e  f1040024          ADD      r0,r4,#0x24
000032  f7fffffe          BL       xTaskRemoveFromEventList
000036  b118              CBZ      r0,|L9.64|
;;;1835   						{
;;;1836   							/* The task waiting has a higher priority so record that a
;;;1837   							context	switch is required. */
;;;1838   							vTaskMissedYield();
000038  f7fffffe          BL       vTaskMissedYield
00003c  e000              B        |L9.64|
                  |L9.62|
;;;1839   						}
;;;1840   						else
;;;1841   						{
;;;1842   							mtCOVERAGE_TEST_MARKER();
;;;1843   						}
;;;1844   					}
;;;1845   					else
;;;1846   					{
;;;1847   						break;
00003e  e003              B        |L9.72|
                  |L9.64|
;;;1848   					}
;;;1849   				}
;;;1850   			}
;;;1851   			#else /* configUSE_QUEUE_SETS */
;;;1852   			{
;;;1853   				/* Tasks that are removed from the event list will get added to
;;;1854   				the pending ready list as the scheduler is still suspended. */
;;;1855   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1856   				{
;;;1857   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1858   					{
;;;1859   						/* The task waiting has a higher priority so record that
;;;1860   						a context switch is required. */
;;;1861   						vTaskMissedYield();
;;;1862   					}
;;;1863   					else
;;;1864   					{
;;;1865   						mtCOVERAGE_TEST_MARKER();
;;;1866   					}
;;;1867   				}
;;;1868   				else
;;;1869   				{
;;;1870   					break;
;;;1871   				}
;;;1872   			}
;;;1873   			#endif /* configUSE_QUEUE_SETS */
;;;1874   
;;;1875   			--cTxLock;
000040  1e68              SUBS     r0,r5,#1
000042  b245              SXTB     r5,r0
                  |L9.68|
000044  2d00              CMP      r5,#0                 ;1807
000046  dce2              BGT      |L9.14|
                  |L9.72|
000048  bf00              NOP                            ;1847
;;;1876   		}
;;;1877   
;;;1878   		pxQueue->cTxLock = queueUNLOCKED;
00004a  20ff              MOVS     r0,#0xff
00004c  f8840045          STRB     r0,[r4,#0x45]
;;;1879   	}
;;;1880   	taskEXIT_CRITICAL();
000050  f7fffffe          BL       vPortExitCritical
;;;1881   
;;;1882   	/* Do the same for the Rx lock. */
;;;1883   	taskENTER_CRITICAL();
000054  f7fffffe          BL       vPortEnterCritical
;;;1884   	{
;;;1885   		int8_t cRxLock = pxQueue->cRxLock;
000058  f9945044          LDRSB    r5,[r4,#0x44]
;;;1886   
;;;1887   		while( cRxLock > queueLOCKED_UNMODIFIED )
00005c  e010              B        |L9.128|
                  |L9.94|
;;;1888   		{
;;;1889   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00005e  6920              LDR      r0,[r4,#0x10]
000060  b908              CBNZ     r0,|L9.102|
000062  2001              MOVS     r0,#1
000064  e000              B        |L9.104|
                  |L9.102|
000066  2000              MOVS     r0,#0
                  |L9.104|
000068  b948              CBNZ     r0,|L9.126|
;;;1890   			{
;;;1891   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
00006a  f1040010          ADD      r0,r4,#0x10
00006e  f7fffffe          BL       xTaskRemoveFromEventList
000072  b108              CBZ      r0,|L9.120|
;;;1892   				{
;;;1893   					vTaskMissedYield();
000074  f7fffffe          BL       vTaskMissedYield
                  |L9.120|
;;;1894   				}
;;;1895   				else
;;;1896   				{
;;;1897   					mtCOVERAGE_TEST_MARKER();
;;;1898   				}
;;;1899   
;;;1900   				--cRxLock;
000078  1e68              SUBS     r0,r5,#1
00007a  b245              SXTB     r5,r0
00007c  e000              B        |L9.128|
                  |L9.126|
;;;1901   			}
;;;1902   			else
;;;1903   			{
;;;1904   				break;
00007e  e001              B        |L9.132|
                  |L9.128|
000080  2d00              CMP      r5,#0                 ;1887
000082  dcec              BGT      |L9.94|
                  |L9.132|
000084  bf00              NOP      
;;;1905   			}
;;;1906   		}
;;;1907   
;;;1908   		pxQueue->cRxLock = queueUNLOCKED;
000086  20ff              MOVS     r0,#0xff
000088  f8840044          STRB     r0,[r4,#0x44]
;;;1909   	}
;;;1910   	taskEXIT_CRITICAL();
00008c  f7fffffe          BL       vPortExitCritical
;;;1911   }
000090  bd70              POP      {r4-r6,pc}
;;;1912   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.ucQueueGetQueueType||, CODE, READONLY, ALIGN=1

                  ucQueueGetQueueType PROC
;;;1688   
;;;1689   	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
000000  4601              MOV      r1,r0
;;;1690   	{
;;;1691   		return ( ( Queue_t * ) xQueue )->ucQueueType;
000002  f8910050          LDRB     r0,[r1,#0x50]
;;;1692   	}
000006  4770              BX       lr
;;;1693   
                          ENDP


                          AREA ||i.uxQueueGetQueueNumber||, CODE, READONLY, ALIGN=1

                  uxQueueGetQueueNumber PROC
;;;1668   
;;;1669   	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
000000  4601              MOV      r1,r0
;;;1670   	{
;;;1671   		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
000002  6cc8              LDR      r0,[r1,#0x4c]
;;;1672   	}
000004  4770              BX       lr
;;;1673   
                          ENDP


                          AREA ||i.uxQueueMessagesWaiting||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  uxQueueMessagesWaiting PROC
;;;1578   
;;;1579   UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1580   {
000002  4604              MOV      r4,r0
;;;1581   UBaseType_t uxReturn;
;;;1582   
;;;1583   	configASSERT( xQueue );
000004  b92c              CBNZ     r4,|L12.18|
000006  f240622f          MOV      r2,#0x62f
00000a  a105              ADR      r1,|L12.32|
00000c  a009              ADR      r0,|L12.52|
00000e  f7fffffe          BL       __2printf
                  |L12.18|
;;;1584   
;;;1585   	taskENTER_CRITICAL();
000012  f7fffffe          BL       vPortEnterCritical
;;;1586   	{
;;;1587   		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
000016  6ba5              LDR      r5,[r4,#0x38]
;;;1588   	}
;;;1589   	taskEXIT_CRITICAL();
000018  f7fffffe          BL       vPortExitCritical
;;;1590   
;;;1591   	return uxReturn;
00001c  4628              MOV      r0,r5
;;;1592   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
00001e  bd70              POP      {r4-r6,pc}
;;;1593   /*-----------------------------------------------------------*/
                          ENDP

                  |L12.32|
000020  2e2e5c46          DCB      "..\\FreeRTOS\\queue.c",0
000024  72656552
000028  544f535c
00002c  71756575
000030  652e6300
                  |L12.52|
000034  4572726f          DCB      "Error:%s,%d\r\n",0
000038  723a2573
00003c  2c25640d
000040  0a00    
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.uxQueueMessagesWaitingFromISR||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  uxQueueMessagesWaitingFromISR PROC
;;;1612   
;;;1613   UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1614   {
000002  4604              MOV      r4,r0
;;;1615   UBaseType_t uxReturn;
;;;1616   
;;;1617   	configASSERT( xQueue );
000004  b92c              CBNZ     r4,|L13.18|
000006  f2406251          MOV      r2,#0x651
00000a  a103              ADR      r1,|L13.24|
00000c  a007              ADR      r0,|L13.44|
00000e  f7fffffe          BL       __2printf
                  |L13.18|
;;;1618   
;;;1619   	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
000012  6ba5              LDR      r5,[r4,#0x38]
;;;1620   
;;;1621   	return uxReturn;
000014  4628              MOV      r0,r5
;;;1622   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000016  bd70              POP      {r4-r6,pc}
;;;1623   /*-----------------------------------------------------------*/
                          ENDP

                  |L13.24|
000018  2e2e5c46          DCB      "..\\FreeRTOS\\queue.c",0
00001c  72656552
000020  544f535c
000024  71756575
000028  652e6300
                  |L13.44|
00002c  4572726f          DCB      "Error:%s,%d\r\n",0
000030  723a2573
000034  2c25640d
000038  0a00    
00003a  00                DCB      0
00003b  00                DCB      0

                          AREA ||i.uxQueueSpacesAvailable||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  uxQueueSpacesAvailable PROC
;;;1594   
;;;1595   UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1596   {
000002  4604              MOV      r4,r0
;;;1597   UBaseType_t uxReturn;
;;;1598   Queue_t *pxQueue;
;;;1599   
;;;1600   	pxQueue = ( Queue_t * ) xQueue;
000004  4625              MOV      r5,r4
;;;1601   	configASSERT( pxQueue );
000006  b92d              CBNZ     r5,|L14.20|
000008  f2406241          MOV      r2,#0x641
00000c  a106              ADR      r1,|L14.40|
00000e  a00b              ADR      r0,|L14.60|
000010  f7fffffe          BL       __2printf
                  |L14.20|
;;;1602   
;;;1603   	taskENTER_CRITICAL();
000014  f7fffffe          BL       vPortEnterCritical
;;;1604   	{
;;;1605   		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
000018  e9d5100e          LDRD     r1,r0,[r5,#0x38]
00001c  1a46              SUBS     r6,r0,r1
;;;1606   	}
;;;1607   	taskEXIT_CRITICAL();
00001e  f7fffffe          BL       vPortExitCritical
;;;1608   
;;;1609   	return uxReturn;
000022  4630              MOV      r0,r6
;;;1610   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000024  bd70              POP      {r4-r6,pc}
;;;1611   /*-----------------------------------------------------------*/
                          ENDP

000026  0000              DCW      0x0000
                  |L14.40|
000028  2e2e5c46          DCB      "..\\FreeRTOS\\queue.c",0
00002c  72656552
000030  544f535c
000034  71756575
000038  652e6300
                  |L14.60|
00003c  4572726f          DCB      "Error:%s,%d\r\n",0
000040  723a2573
000044  2c25640d
000048  0a00    
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.vQueueAddToRegistry||, CODE, READONLY, ALIGN=2

                  vQueueAddToRegistry PROC
;;;2268   
;;;2269   	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  4602              MOV      r2,r0
;;;2270   	{
;;;2271   	UBaseType_t ux;
;;;2272   
;;;2273   		/* See if there is an empty space in the registry.  A NULL name denotes
;;;2274   		a free slot. */
;;;2275   		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
000002  2000              MOVS     r0,#0
000004  e00b              B        |L15.30|
                  |L15.6|
;;;2276   		{
;;;2277   			if( xQueueRegistry[ ux ].pcQueueName == NULL )
000006  4b08              LDR      r3,|L15.40|
000008  f8533030          LDR      r3,[r3,r0,LSL #3]
00000c  b933              CBNZ     r3,|L15.28|
;;;2278   			{
;;;2279   				/* Store the information on this queue. */
;;;2280   				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
00000e  4b06              LDR      r3,|L15.40|
000010  f8431030          STR      r1,[r3,r0,LSL #3]
;;;2281   				xQueueRegistry[ ux ].xHandle = xQueue;
000014  eb0303c0          ADD      r3,r3,r0,LSL #3
000018  605a              STR      r2,[r3,#4]
;;;2282   
;;;2283   				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
;;;2284   				break;
00001a  e002              B        |L15.34|
                  |L15.28|
00001c  1c40              ADDS     r0,r0,#1              ;2275
                  |L15.30|
00001e  2808              CMP      r0,#8                 ;2275
000020  d3f1              BCC      |L15.6|
                  |L15.34|
000022  bf00              NOP      
;;;2285   			}
;;;2286   			else
;;;2287   			{
;;;2288   				mtCOVERAGE_TEST_MARKER();
;;;2289   			}
;;;2290   		}
;;;2291   	}
000024  4770              BX       lr
;;;2292   
                          ENDP

000026  0000              DCW      0x0000
                  |L15.40|
                          DCD      xQueueRegistry

                          AREA ||i.vQueueDelete||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vQueueDelete PROC
;;;1624   
;;;1625   void vQueueDelete( QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1626   {
000002  4604              MOV      r4,r0
;;;1627   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000004  4625              MOV      r5,r4
;;;1628   
;;;1629   	configASSERT( pxQueue );
000006  b92d              CBNZ     r5,|L16.20|
000008  f240625d          MOV      r2,#0x65d
00000c  a105              ADR      r1,|L16.36|
00000e  a00a              ADR      r0,|L16.56|
000010  f7fffffe          BL       __2printf
                  |L16.20|
;;;1630   	traceQUEUE_DELETE( pxQueue );
;;;1631   
;;;1632   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1633   	{
;;;1634   		vQueueUnregisterQueue( pxQueue );
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       vQueueUnregisterQueue
;;;1635   	}
;;;1636   	#endif
;;;1637   
;;;1638   	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
;;;1639   	{
;;;1640   		/* The queue can only have been allocated dynamically - free it
;;;1641   		again. */
;;;1642   		vPortFree( pxQueue );
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       vPortFree
;;;1643   	}
;;;1644   	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;;;1645   	{
;;;1646   		/* The queue could have been allocated statically or dynamically, so
;;;1647   		check before attempting to free the memory. */
;;;1648   		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
;;;1649   		{
;;;1650   			vPortFree( pxQueue );
;;;1651   		}
;;;1652   		else
;;;1653   		{
;;;1654   			mtCOVERAGE_TEST_MARKER();
;;;1655   		}
;;;1656   	}
;;;1657   	#else
;;;1658   	{
;;;1659   		/* The queue must have been statically allocated, so is not going to be
;;;1660   		deleted.  Avoid compiler warnings about the unused parameter. */
;;;1661   		( void ) pxQueue;
;;;1662   	}
;;;1663   	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;1664   }
000020  bd70              POP      {r4-r6,pc}
;;;1665   /*-----------------------------------------------------------*/
                          ENDP

000022  0000              DCW      0x0000
                  |L16.36|
000024  2e2e5c46          DCB      "..\\FreeRTOS\\queue.c",0
000028  72656552
00002c  544f535c
000030  71756575
000034  652e6300
                  |L16.56|
000038  4572726f          DCB      "Error:%s,%d\r\n",0
00003c  723a2573
000040  2c25640d
000044  0a00    
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.vQueueSetQueueNumber||, CODE, READONLY, ALIGN=1

                  vQueueSetQueueNumber PROC
;;;1678   
;;;1679   	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
000000  64c1              STR      r1,[r0,#0x4c]
;;;1680   	{
;;;1681   		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
;;;1682   	}
000002  4770              BX       lr
;;;1683   
                          ENDP


                          AREA ||i.vQueueUnregisterQueue||, CODE, READONLY, ALIGN=2

                  vQueueUnregisterQueue PROC
;;;2325   
;;;2326   	void vQueueUnregisterQueue( QueueHandle_t xQueue )
000000  4601              MOV      r1,r0
;;;2327   	{
;;;2328   	UBaseType_t ux;
;;;2329   
;;;2330   		/* See if the handle of the queue being unregistered in actually in the
;;;2331   		registry. */
;;;2332   		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
000002  2000              MOVS     r0,#0
000004  e00e              B        |L18.36|
                  |L18.6|
;;;2333   		{
;;;2334   			if( xQueueRegistry[ ux ].xHandle == xQueue )
000006  4a09              LDR      r2,|L18.44|
000008  eb0202c0          ADD      r2,r2,r0,LSL #3
00000c  6852              LDR      r2,[r2,#4]
00000e  428a              CMP      r2,r1
000010  d107              BNE      |L18.34|
;;;2335   			{
;;;2336   				/* Set the name to NULL to show that this slot if free again. */
;;;2337   				xQueueRegistry[ ux ].pcQueueName = NULL;
000012  2200              MOVS     r2,#0
000014  4b05              LDR      r3,|L18.44|
000016  f8432030          STR      r2,[r3,r0,LSL #3]
;;;2338   
;;;2339   				/* Set the handle to NULL to ensure the same queue handle cannot
;;;2340   				appear in the registry twice if it is added, removed, then
;;;2341   				added again. */
;;;2342   				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
00001a  eb0303c0          ADD      r3,r3,r0,LSL #3
00001e  605a              STR      r2,[r3,#4]
;;;2343   				break;
000020  e002              B        |L18.40|
                  |L18.34|
000022  1c40              ADDS     r0,r0,#1              ;2332
                  |L18.36|
000024  2808              CMP      r0,#8                 ;2332
000026  d3ee              BCC      |L18.6|
                  |L18.40|
000028  bf00              NOP      
;;;2344   			}
;;;2345   			else
;;;2346   			{
;;;2347   				mtCOVERAGE_TEST_MARKER();
;;;2348   			}
;;;2349   		}
;;;2350   
;;;2351   	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00002a  4770              BX       lr
;;;2352   
                          ENDP

                  |L18.44|
                          DCD      xQueueRegistry

                          AREA ||i.vQueueWaitForMessageRestricted||, CODE, READONLY, ALIGN=1

                  vQueueWaitForMessageRestricted PROC
;;;2357   
;;;2358   	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2359   	{
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;2360   	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
00000a  462c              MOV      r4,r5
;;;2361   
;;;2362   		/* This function should not be called by application code hence the
;;;2363   		'Restricted' in its name.  It is not part of the public API.  It is
;;;2364   		designed for use by kernel code, and has special calling requirements.
;;;2365   		It can result in vListInsert() being called on a list that can only
;;;2366   		possibly ever have one item in it, so the list will be fast, but even
;;;2367   		so it should be called with the scheduler locked and not from a critical
;;;2368   		section. */
;;;2369   
;;;2370   		/* Only do anything if there are no messages in the queue.  This function
;;;2371   		will not actually cause the task to block, just place it on a blocked
;;;2372   		list.  It will not block until the scheduler is unlocked - at which
;;;2373   		time a yield will be performed.  If an item is added to the queue while
;;;2374   		the queue is locked, and the calling task blocks on the queue, then the
;;;2375   		calling task will be immediately unblocked when the queue is unlocked. */
;;;2376   		prvLockQueue( pxQueue );
00000c  f7fffffe          BL       vPortEnterCritical
000010  f9940044          LDRSB    r0,[r4,#0x44]
000014  1c40              ADDS     r0,r0,#1
000016  b910              CBNZ     r0,|L19.30|
000018  2000              MOVS     r0,#0
00001a  f8840044          STRB     r0,[r4,#0x44]
                  |L19.30|
00001e  f9940045          LDRSB    r0,[r4,#0x45]
000022  1c40              ADDS     r0,r0,#1
000024  b910              CBNZ     r0,|L19.44|
000026  2000              MOVS     r0,#0
000028  f8840045          STRB     r0,[r4,#0x45]
                  |L19.44|
00002c  f7fffffe          BL       vPortExitCritical
;;;2377   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
000030  6ba0              LDR      r0,[r4,#0x38]
000032  b928              CBNZ     r0,|L19.64|
;;;2378   		{
;;;2379   			/* There is nothing in the queue, block for the specified period. */
;;;2380   			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
000034  463a              MOV      r2,r7
000036  4631              MOV      r1,r6
000038  f1040024          ADD      r0,r4,#0x24
00003c  f7fffffe          BL       vTaskPlaceOnEventListRestricted
                  |L19.64|
;;;2381   		}
;;;2382   		else
;;;2383   		{
;;;2384   			mtCOVERAGE_TEST_MARKER();
;;;2385   		}
;;;2386   		prvUnlockQueue( pxQueue );
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       prvUnlockQueue
;;;2387   	}
000046  e8bd81f0          POP      {r4-r8,pc}
;;;2388   
                          ENDP


                          AREA ||i.xQueueAddToSet||, CODE, READONLY, ALIGN=1

                  xQueueAddToSet PROC
;;;2407   
;;;2408   	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
000000  b570              PUSH     {r4-r6,lr}
;;;2409   	{
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;2410   	BaseType_t xReturn;
;;;2411   
;;;2412   		taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;2413   		{
;;;2414   			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
00000a  6ca0              LDR      r0,[r4,#0x48]
00000c  b108              CBZ      r0,|L20.18|
;;;2415   			{
;;;2416   				/* Cannot add a queue/semaphore to more than one queue set. */
;;;2417   				xReturn = pdFAIL;
00000e  2500              MOVS     r5,#0
000010  e005              B        |L20.30|
                  |L20.18|
;;;2418   			}
;;;2419   			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
000012  6ba0              LDR      r0,[r4,#0x38]
000014  b108              CBZ      r0,|L20.26|
;;;2420   			{
;;;2421   				/* Cannot add a queue/semaphore to a queue set if there are already
;;;2422   				items in the queue/semaphore. */
;;;2423   				xReturn = pdFAIL;
000016  2500              MOVS     r5,#0
000018  e001              B        |L20.30|
                  |L20.26|
;;;2424   			}
;;;2425   			else
;;;2426   			{
;;;2427   				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
00001a  64a6              STR      r6,[r4,#0x48]
;;;2428   				xReturn = pdPASS;
00001c  2501              MOVS     r5,#1
                  |L20.30|
;;;2429   			}
;;;2430   		}
;;;2431   		taskEXIT_CRITICAL();
00001e  f7fffffe          BL       vPortExitCritical
;;;2432   
;;;2433   		return xReturn;
000022  4628              MOV      r0,r5
;;;2434   	}
000024  bd70              POP      {r4-r6,pc}
;;;2435   
                          ENDP


                          AREA ||i.xQueueCreateCountingSemaphore||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  xQueueCreateCountingSemaphore PROC
;;;696    
;;;697    	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
000000  b570              PUSH     {r4-r6,lr}
;;;698    	{
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;699    	QueueHandle_t xHandle;
;;;700    
;;;701    		configASSERT( uxMaxCount != 0 );
000006  b10d              CBZ      r5,|L21.12|
000008  2001              MOVS     r0,#1
00000a  e000              B        |L21.14|
                  |L21.12|
00000c  2000              MOVS     r0,#0
                  |L21.14|
00000e  b928              CBNZ     r0,|L21.28|
000010  f24022bd          MOV      r2,#0x2bd
000014  a10c              ADR      r1,|L21.72|
000016  a011              ADR      r0,|L21.92|
000018  f7fffffe          BL       __2printf
                  |L21.28|
;;;702    		configASSERT( uxInitialCount <= uxMaxCount );
00001c  42ae              CMP      r6,r5
00001e  d801              BHI      |L21.36|
000020  2001              MOVS     r0,#1
000022  e000              B        |L21.38|
                  |L21.36|
000024  2000              MOVS     r0,#0
                  |L21.38|
000026  b928              CBNZ     r0,|L21.52|
000028  f24022be          MOV      r2,#0x2be
00002c  a106              ADR      r1,|L21.72|
00002e  a00b              ADR      r0,|L21.92|
000030  f7fffffe          BL       __2printf
                  |L21.52|
;;;703    
;;;704    		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
000034  2202              MOVS     r2,#2
000036  2100              MOVS     r1,#0
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       xQueueGenericCreate
00003e  4604              MOV      r4,r0
;;;705    
;;;706    		if( xHandle != NULL )
000040  b104              CBZ      r4,|L21.68|
;;;707    		{
;;;708    			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
000042  63a6              STR      r6,[r4,#0x38]
                  |L21.68|
;;;709    
;;;710    			traceCREATE_COUNTING_SEMAPHORE();
;;;711    		}
;;;712    		else
;;;713    		{
;;;714    			traceCREATE_COUNTING_SEMAPHORE_FAILED();
;;;715    		}
;;;716    
;;;717    		return xHandle;
000044  4620              MOV      r0,r4
;;;718    	}
000046  bd70              POP      {r4-r6,pc}
;;;719    
                          ENDP

                  |L21.72|
000048  2e2e5c46          DCB      "..\\FreeRTOS\\queue.c",0
00004c  72656552
000050  544f535c
000054  71756575
000058  652e6300
                  |L21.92|
00005c  4572726f          DCB      "Error:%s,%d\r\n",0
000060  723a2573
000064  2c25640d
000068  0a00    
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.xQueueCreateMutex||, CODE, READONLY, ALIGN=1

                  xQueueCreateMutex PROC
;;;505    
;;;506    	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;507    	{
000004  4604              MOV      r4,r0
;;;508    	Queue_t *pxNewQueue;
;;;509    	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
000006  2601              MOVS     r6,#1
000008  2700              MOVS     r7,#0
;;;510    
;;;511    		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
00000a  4622              MOV      r2,r4
00000c  2100              MOVS     r1,#0
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       xQueueGenericCreate
000014  4605              MOV      r5,r0
;;;512    		prvInitialiseMutex( pxNewQueue );
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       prvInitialiseMutex
;;;513    
;;;514    		return pxNewQueue;
00001c  4628              MOV      r0,r5
;;;515    	}
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;516    
                          ENDP


                          AREA ||i.xQueueCreateSet||, CODE, READONLY, ALIGN=1

                  xQueueCreateSet PROC
;;;2393   
;;;2394   	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
000000  b570              PUSH     {r4-r6,lr}
;;;2395   	{
000002  4604              MOV      r4,r0
;;;2396   	QueueSetHandle_t pxQueue;
;;;2397   
;;;2398   		pxQueue = xQueueGenericCreate( uxEventQueueLength, sizeof( Queue_t * ), queueQUEUE_TYPE_SET );
000004  2200              MOVS     r2,#0
000006  2104              MOVS     r1,#4
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       xQueueGenericCreate
00000e  4605              MOV      r5,r0
;;;2399   
;;;2400   		return pxQueue;
000010  4628              MOV      r0,r5
;;;2401   	}
000012  bd70              POP      {r4-r6,pc}
;;;2402   
                          ENDP


                          AREA ||i.xQueueGenericCreate||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  xQueueGenericCreate PROC
;;;385    
;;;386    	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;387    	{
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
;;;388    	Queue_t *pxNewQueue;
;;;389    	size_t xQueueSizeInBytes;
;;;390    	uint8_t *pucQueueStorage;
;;;391    
;;;392    		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
00000a  b10d              CBZ      r5,|L24.16|
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L24.18|
                  |L24.16|
000010  2000              MOVS     r0,#0
                  |L24.18|
000012  b928              CBNZ     r0,|L24.32|
000014  f44f72c4          MOV      r2,#0x188
000018  a10d              ADR      r1,|L24.80|
00001a  a012              ADR      r0,|L24.100|
00001c  f7fffffe          BL       __2printf
                  |L24.32|
;;;393    
;;;394    		if( uxItemSize == ( UBaseType_t ) 0 )
000020  b90e              CBNZ     r6,|L24.38|
;;;395    		{
;;;396    			/* There is not going to be a queue storage area. */
;;;397    			xQueueSizeInBytes = ( size_t ) 0;
000022  2700              MOVS     r7,#0
000024  e001              B        |L24.42|
                  |L24.38|
;;;398    		}
;;;399    		else
;;;400    		{
;;;401    			/* Allocate enough space to hold the maximum number of items that
;;;402    			can be in the queue at any time. */
;;;403    			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000026  fb05f706          MUL      r7,r5,r6
                  |L24.42|
;;;404    		}
;;;405    
;;;406    		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
00002a  f1070054          ADD      r0,r7,#0x54
00002e  f7fffffe          BL       pvPortMalloc
000032  4604              MOV      r4,r0
;;;407    
;;;408    		if( pxNewQueue != NULL )
000034  b144              CBZ      r4,|L24.72|
;;;409    		{
;;;410    			/* Jump past the queue structure to find the location of the queue
;;;411    			storage area. */
;;;412    			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
000036  f1040954          ADD      r9,r4,#0x54
;;;413    
;;;414    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;415    			{
;;;416    				/* Queues can be created either statically or dynamically, so
;;;417    				note this task was created dynamically in case it is later
;;;418    				deleted. */
;;;419    				pxNewQueue->ucStaticallyAllocated = pdFALSE;
;;;420    			}
;;;421    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;422    
;;;423    			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
00003a  4643              MOV      r3,r8
00003c  464a              MOV      r2,r9
00003e  4631              MOV      r1,r6
000040  4628              MOV      r0,r5
000042  9400              STR      r4,[sp,#0]
000044  f7fffffe          BL       prvInitialiseNewQueue
                  |L24.72|
;;;424    		}
;;;425    
;;;426    		return pxNewQueue;
000048  4620              MOV      r0,r4
;;;427    	}
00004a  e8bd83f8          POP      {r3-r9,pc}
;;;428    
                          ENDP

00004e  0000              DCW      0x0000
                  |L24.80|
000050  2e2e5c46          DCB      "..\\FreeRTOS\\queue.c",0
000054  72656552
000058  544f535c
00005c  71756575
000060  652e6300
                  |L24.100|
000064  4572726f          DCB      "Error:%s,%d\r\n",0
000068  723a2573
00006c  2c25640d
000070  0a00    
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.xQueueGenericReceive||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  xQueueGenericReceive PROC
;;;1236   
;;;1237   BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;1238   {
000004  b082              SUB      sp,sp,#8
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  461f              MOV      r7,r3
;;;1239   BaseType_t xEntryTimeSet = pdFALSE;
00000c  f04f0a00          MOV      r10,#0
;;;1240   TimeOut_t xTimeOut;
;;;1241   int8_t *pcOriginalReadPosition;
;;;1242   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000010  462c              MOV      r4,r5
;;;1243   
;;;1244   	configASSERT( pxQueue );
000012  b92c              CBNZ     r4,|L25.32|
000014  f24042dc          MOV      r2,#0x4dc
000018  a161              ADR      r1,|L25.416|
00001a  a066              ADR      r0,|L25.436|
00001c  f7fffffe          BL       __2printf
                  |L25.32|
;;;1245   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000020  b90e              CBNZ     r6,|L25.38|
000022  6c20              LDR      r0,[r4,#0x40]
000024  b908              CBNZ     r0,|L25.42|
                  |L25.38|
000026  2001              MOVS     r0,#1
000028  e000              B        |L25.44|
                  |L25.42|
00002a  2000              MOVS     r0,#0
                  |L25.44|
00002c  b928              CBNZ     r0,|L25.58|
00002e  f24042dd          MOV      r2,#0x4dd
000032  a15b              ADR      r1,|L25.416|
000034  a05f              ADR      r0,|L25.436|
000036  f7fffffe          BL       __2printf
                  |L25.58|
;;;1246   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1247   	{
;;;1248   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
00003a  f7fffffe          BL       xTaskGetSchedulerState
00003e  b908              CBNZ     r0,|L25.68|
000040  9804              LDR      r0,[sp,#0x10]
000042  b908              CBNZ     r0,|L25.72|
                  |L25.68|
000044  2001              MOVS     r0,#1
000046  e000              B        |L25.74|
                  |L25.72|
000048  2000              MOVS     r0,#0
                  |L25.74|
00004a  b928              CBNZ     r0,|L25.88|
00004c  f44f629c          MOV      r2,#0x4e0
000050  a153              ADR      r1,|L25.416|
000052  a058              ADR      r0,|L25.436|
000054  f7fffffe          BL       __2printf
                  |L25.88|
;;;1249   	}
;;;1250   	#endif
;;;1251   
;;;1252   	/* This function relaxes the coding standard somewhat to allow return
;;;1253   	statements within the function itself.  This is done in the interest
;;;1254   	of execution time efficiency. */
;;;1255   
;;;1256   	for( ;; )
000058  bf00              NOP      
                  |L25.90|
;;;1257   	{
;;;1258   		taskENTER_CRITICAL();
00005a  f7fffffe          BL       vPortEnterCritical
;;;1259   		{
;;;1260   			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00005e  f8d49038          LDR      r9,[r4,#0x38]
;;;1261   
;;;1262   			/* Is there data in the queue now?  To be running the calling task
;;;1263   			must be the highest priority task wanting to access the queue. */
;;;1264   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
000062  f1b90f00          CMP      r9,#0
000066  d03d              BEQ      |L25.228|
;;;1265   			{
;;;1266   				/* Remember the read position in case the queue is only being
;;;1267   				peeked. */
;;;1268   				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
000068  f8d4800c          LDR      r8,[r4,#0xc]
;;;1269   
;;;1270   				prvCopyDataFromQueue( pxQueue, pvBuffer );
00006c  4631              MOV      r1,r6
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       prvCopyDataFromQueue
;;;1271   
;;;1272   				if( xJustPeeking == pdFALSE )
000074  b9df              CBNZ     r7,|L25.174|
;;;1273   				{
;;;1274   					traceQUEUE_RECEIVE( pxQueue );
;;;1275   
;;;1276   					/* Actually removing data, not just peeking. */
;;;1277   					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
000076  f1a90001          SUB      r0,r9,#1
00007a  63a0              STR      r0,[r4,#0x38]
;;;1278   
;;;1279   					#if ( configUSE_MUTEXES == 1 )
;;;1280   					{
;;;1281   						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
00007c  6820              LDR      r0,[r4,#0]
00007e  b910              CBNZ     r0,|L25.134|
;;;1282   						{
;;;1283   							/* Record the information required to implement
;;;1284   							priority inheritance should it become necessary. */
;;;1285   							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
000080  f7fffffe          BL       pvTaskIncrementMutexHeldCount
000084  6060              STR      r0,[r4,#4]
                  |L25.134|
;;;1286   						}
;;;1287   						else
;;;1288   						{
;;;1289   							mtCOVERAGE_TEST_MARKER();
;;;1290   						}
;;;1291   					}
;;;1292   					#endif /* configUSE_MUTEXES */
;;;1293   
;;;1294   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000086  6920              LDR      r0,[r4,#0x10]
000088  b908              CBNZ     r0,|L25.142|
00008a  2001              MOVS     r0,#1
00008c  e000              B        |L25.144|
                  |L25.142|
00008e  2000              MOVS     r0,#0
                  |L25.144|
000090  bb10              CBNZ     r0,|L25.216|
;;;1295   					{
;;;1296   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000092  f1040010          ADD      r0,r4,#0x10
000096  f7fffffe          BL       xTaskRemoveFromEventList
00009a  b1e8              CBZ      r0,|L25.216|
;;;1297   						{
;;;1298   							queueYIELD_IF_USING_PREEMPTION();
00009c  f04f5080          MOV      r0,#0x10000000
0000a0  4948              LDR      r1,|L25.452|
0000a2  6008              STR      r0,[r1,#0]
0000a4  f3bf8f4f          DSB      
0000a8  f3bf8f6f          ISB      
0000ac  e014              B        |L25.216|
                  |L25.174|
;;;1299   						}
;;;1300   						else
;;;1301   						{
;;;1302   							mtCOVERAGE_TEST_MARKER();
;;;1303   						}
;;;1304   					}
;;;1305   					else
;;;1306   					{
;;;1307   						mtCOVERAGE_TEST_MARKER();
;;;1308   					}
;;;1309   				}
;;;1310   				else
;;;1311   				{
;;;1312   					traceQUEUE_PEEK( pxQueue );
;;;1313   
;;;1314   					/* The data is not being removed, so reset the read
;;;1315   					pointer. */
;;;1316   					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
0000ae  f8c4800c          STR      r8,[r4,#0xc]
;;;1317   
;;;1318   					/* The data is being left in the queue, so see if there are
;;;1319   					any other tasks waiting for the data. */
;;;1320   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0000b2  6a60              LDR      r0,[r4,#0x24]
0000b4  b908              CBNZ     r0,|L25.186|
0000b6  2001              MOVS     r0,#1
0000b8  e000              B        |L25.188|
                  |L25.186|
0000ba  2000              MOVS     r0,#0
                  |L25.188|
0000bc  b960              CBNZ     r0,|L25.216|
;;;1321   					{
;;;1322   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0000be  f1040024          ADD      r0,r4,#0x24
0000c2  f7fffffe          BL       xTaskRemoveFromEventList
0000c6  b138              CBZ      r0,|L25.216|
;;;1323   						{
;;;1324   							/* The task waiting has a higher priority than this task. */
;;;1325   							queueYIELD_IF_USING_PREEMPTION();
0000c8  f04f5080          MOV      r0,#0x10000000
0000cc  493d              LDR      r1,|L25.452|
0000ce  6008              STR      r0,[r1,#0]
0000d0  f3bf8f4f          DSB      
0000d4  f3bf8f6f          ISB      
                  |L25.216|
;;;1326   						}
;;;1327   						else
;;;1328   						{
;;;1329   							mtCOVERAGE_TEST_MARKER();
;;;1330   						}
;;;1331   					}
;;;1332   					else
;;;1333   					{
;;;1334   						mtCOVERAGE_TEST_MARKER();
;;;1335   					}
;;;1336   				}
;;;1337   
;;;1338   				taskEXIT_CRITICAL();
0000d8  f7fffffe          BL       vPortExitCritical
;;;1339   				return pdPASS;
0000dc  2001              MOVS     r0,#1
                  |L25.222|
;;;1340   			}
;;;1341   			else
;;;1342   			{
;;;1343   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1344   				{
;;;1345   					/* The queue was empty and no block time is specified (or
;;;1346   					the block time has expired) so leave now. */
;;;1347   					taskEXIT_CRITICAL();
;;;1348   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1349   					return errQUEUE_EMPTY;
;;;1350   				}
;;;1351   				else if( xEntryTimeSet == pdFALSE )
;;;1352   				{
;;;1353   					/* The queue was empty and a block time was specified so
;;;1354   					configure the timeout structure. */
;;;1355   					vTaskSetTimeOutState( &xTimeOut );
;;;1356   					xEntryTimeSet = pdTRUE;
;;;1357   				}
;;;1358   				else
;;;1359   				{
;;;1360   					/* Entry time was already set. */
;;;1361   					mtCOVERAGE_TEST_MARKER();
;;;1362   				}
;;;1363   			}
;;;1364   		}
;;;1365   		taskEXIT_CRITICAL();
;;;1366   
;;;1367   		/* Interrupts and other tasks can send to and receive from the queue
;;;1368   		now the critical section has been exited. */
;;;1369   
;;;1370   		vTaskSuspendAll();
;;;1371   		prvLockQueue( pxQueue );
;;;1372   
;;;1373   		/* Update the timeout state to see if it has expired yet. */
;;;1374   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1375   		{
;;;1376   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1377   			{
;;;1378   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1379   
;;;1380   				#if ( configUSE_MUTEXES == 1 )
;;;1381   				{
;;;1382   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1383   					{
;;;1384   						taskENTER_CRITICAL();
;;;1385   						{
;;;1386   							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
;;;1387   						}
;;;1388   						taskEXIT_CRITICAL();
;;;1389   					}
;;;1390   					else
;;;1391   					{
;;;1392   						mtCOVERAGE_TEST_MARKER();
;;;1393   					}
;;;1394   				}
;;;1395   				#endif
;;;1396   
;;;1397   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1398   				prvUnlockQueue( pxQueue );
;;;1399   				if( xTaskResumeAll() == pdFALSE )
;;;1400   				{
;;;1401   					portYIELD_WITHIN_API();
;;;1402   				}
;;;1403   				else
;;;1404   				{
;;;1405   					mtCOVERAGE_TEST_MARKER();
;;;1406   				}
;;;1407   			}
;;;1408   			else
;;;1409   			{
;;;1410   				/* Try again. */
;;;1411   				prvUnlockQueue( pxQueue );
;;;1412   				( void ) xTaskResumeAll();
;;;1413   			}
;;;1414   		}
;;;1415   		else
;;;1416   		{
;;;1417   			prvUnlockQueue( pxQueue );
;;;1418   			( void ) xTaskResumeAll();
;;;1419   
;;;1420   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1421   			{
;;;1422   				traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1423   				return errQUEUE_EMPTY;
;;;1424   			}
;;;1425   			else
;;;1426   			{
;;;1427   				mtCOVERAGE_TEST_MARKER();
;;;1428   			}
;;;1429   		}
;;;1430   	}
;;;1431   }
0000de  b006              ADD      sp,sp,#0x18
0000e0  e8bd87f0          POP      {r4-r10,pc}
                  |L25.228|
0000e4  9804              LDR      r0,[sp,#0x10]         ;1343
0000e6  b918              CBNZ     r0,|L25.240|
0000e8  f7fffffe          BL       vPortExitCritical
0000ec  2000              MOVS     r0,#0                 ;1349
0000ee  e7f6              B        |L25.222|
                  |L25.240|
0000f0  f1ba0f00          CMP      r10,#0                ;1351
0000f4  d104              BNE      |L25.256|
0000f6  4668              MOV      r0,sp                 ;1355
0000f8  f7fffffe          BL       vTaskSetTimeOutState
0000fc  f04f0a01          MOV      r10,#1                ;1356
                  |L25.256|
000100  f7fffffe          BL       vPortExitCritical
000104  f7fffffe          BL       vTaskSuspendAll
000108  f7fffffe          BL       vPortEnterCritical
00010c  f9940044          LDRSB    r0,[r4,#0x44]         ;1371
000110  1c40              ADDS     r0,r0,#1              ;1371
000112  b910              CBNZ     r0,|L25.282|
000114  2000              MOVS     r0,#0                 ;1371
000116  f8840044          STRB     r0,[r4,#0x44]         ;1371
                  |L25.282|
00011a  f9940045          LDRSB    r0,[r4,#0x45]         ;1371
00011e  1c40              ADDS     r0,r0,#1              ;1371
000120  b910              CBNZ     r0,|L25.296|
000122  2000              MOVS     r0,#0                 ;1371
000124  f8840045          STRB     r0,[r4,#0x45]         ;1371
                  |L25.296|
000128  f7fffffe          BL       vPortExitCritical
00012c  a904              ADD      r1,sp,#0x10           ;1374
00012e  4668              MOV      r0,sp                 ;1374
000130  f7fffffe          BL       xTaskCheckForTimeOut
000134  bb40              CBNZ     r0,|L25.392|
000136  4620              MOV      r0,r4                 ;1376
000138  f7fffffe          BL       prvIsQueueEmpty
00013c  b1f0              CBZ      r0,|L25.380|
00013e  6820              LDR      r0,[r4,#0]            ;1382
000140  b930              CBNZ     r0,|L25.336|
000142  f7fffffe          BL       vPortEnterCritical
000146  6860              LDR      r0,[r4,#4]            ;1386
000148  f7fffffe          BL       vTaskPriorityInherit
00014c  f7fffffe          BL       vPortExitCritical
                  |L25.336|
000150  f1040024          ADD      r0,r4,#0x24           ;1397
000154  9904              LDR      r1,[sp,#0x10]         ;1397
000156  f7fffffe          BL       vTaskPlaceOnEventList
00015a  4620              MOV      r0,r4                 ;1398
00015c  f7fffffe          BL       prvUnlockQueue
000160  f7fffffe          BL       xTaskResumeAll
000164  2800              CMP      r0,#0                 ;1399
000166  f47faf78          BNE      |L25.90|
00016a  f04f5080          MOV      r0,#0x10000000        ;1401
00016e  4915              LDR      r1,|L25.452|
000170  6008              STR      r0,[r1,#0]            ;1401
000172  f3bf8f4f          DSB                            ;1401
000176  f3bf8f6f          ISB                            ;1401
                  |L25.378|
00017a  e76e              B        |L25.90|
                  |L25.380|
00017c  4620              MOV      r0,r4                 ;1411
00017e  f7fffffe          BL       prvUnlockQueue
000182  f7fffffe          BL       xTaskResumeAll
000186  e768              B        |L25.90|
                  |L25.392|
000188  4620              MOV      r0,r4                 ;1417
00018a  f7fffffe          BL       prvUnlockQueue
00018e  f7fffffe          BL       xTaskResumeAll
000192  4620              MOV      r0,r4                 ;1420
000194  f7fffffe          BL       prvIsQueueEmpty
000198  2800              CMP      r0,#0                 ;1420
00019a  d0ee              BEQ      |L25.378|
00019c  2000              MOVS     r0,#0                 ;1423
00019e  e79e              B        |L25.222|
;;;1432   /*-----------------------------------------------------------*/
                          ENDP

                  |L25.416|
0001a0  2e2e5c46          DCB      "..\\FreeRTOS\\queue.c",0
0001a4  72656552
0001a8  544f535c
0001ac  71756575
0001b0  652e6300
                  |L25.436|
0001b4  4572726f          DCB      "Error:%s,%d\r\n",0
0001b8  723a2573
0001bc  2c25640d
0001c0  0a00    
0001c2  00                DCB      0
0001c3  00                DCB      0
                  |L25.452|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericReset||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  xQueueGenericReset PROC
;;;278    
;;;279    BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;280    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;281    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000006  462c              MOV      r4,r5
;;;282    
;;;283    	configASSERT( pxQueue );
000008  b92c              CBNZ     r4,|L26.22|
00000a  f240121b          MOV      r2,#0x11b
00000e  a11e              ADR      r1,|L26.136|
000010  a022              ADR      r0,|L26.156|
000012  f7fffffe          BL       __2printf
                  |L26.22|
;;;284    
;;;285    	taskENTER_CRITICAL();
000016  f7fffffe          BL       vPortEnterCritical
;;;286    	{
;;;287    		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
00001a  e9d4120f          LDRD     r1,r2,[r4,#0x3c]
00001e  6820              LDR      r0,[r4,#0]
000020  fb010002          MLA      r0,r1,r2,r0
000024  6060              STR      r0,[r4,#4]
;;;288    		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
000026  2000              MOVS     r0,#0
000028  63a0              STR      r0,[r4,#0x38]
;;;289    		pxQueue->pcWriteTo = pxQueue->pcHead;
00002a  6820              LDR      r0,[r4,#0]
00002c  60a0              STR      r0,[r4,#8]
;;;290    		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
00002e  6be0              LDR      r0,[r4,#0x3c]
000030  1e40              SUBS     r0,r0,#1
000032  6c22              LDR      r2,[r4,#0x40]
000034  6821              LDR      r1,[r4,#0]
000036  fb001002          MLA      r0,r0,r2,r1
00003a  60e0              STR      r0,[r4,#0xc]
;;;291    		pxQueue->cRxLock = queueUNLOCKED;
00003c  20ff              MOVS     r0,#0xff
00003e  f8840044          STRB     r0,[r4,#0x44]
;;;292    		pxQueue->cTxLock = queueUNLOCKED;
000042  f8840045          STRB     r0,[r4,#0x45]
;;;293    
;;;294    		if( xNewQueue == pdFALSE )
000046  b99e              CBNZ     r6,|L26.112|
;;;295    		{
;;;296    			/* If there are tasks blocked waiting to read from the queue, then
;;;297    			the tasks will remain blocked as after this function exits the queue
;;;298    			will still be empty.  If there are tasks blocked waiting to write to
;;;299    			the queue, then one should be unblocked as after this function exits
;;;300    			it will be possible to write to it. */
;;;301    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000048  6920              LDR      r0,[r4,#0x10]
00004a  b908              CBNZ     r0,|L26.80|
00004c  2001              MOVS     r0,#1
00004e  e000              B        |L26.82|
                  |L26.80|
000050  2000              MOVS     r0,#0
                  |L26.82|
000052  b9a8              CBNZ     r0,|L26.128|
;;;302    			{
;;;303    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000054  f1040010          ADD      r0,r4,#0x10
000058  f7fffffe          BL       xTaskRemoveFromEventList
00005c  b180              CBZ      r0,|L26.128|
;;;304    				{
;;;305    					queueYIELD_IF_USING_PREEMPTION();
00005e  f04f5080          MOV      r0,#0x10000000
000062  4912              LDR      r1,|L26.172|
000064  6008              STR      r0,[r1,#0]
000066  f3bf8f4f          DSB      
00006a  f3bf8f6f          ISB      
00006e  e007              B        |L26.128|
                  |L26.112|
;;;306    				}
;;;307    				else
;;;308    				{
;;;309    					mtCOVERAGE_TEST_MARKER();
;;;310    				}
;;;311    			}
;;;312    			else
;;;313    			{
;;;314    				mtCOVERAGE_TEST_MARKER();
;;;315    			}
;;;316    		}
;;;317    		else
;;;318    		{
;;;319    			/* Ensure the event queues start in the correct state. */
;;;320    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
000070  f1040010          ADD      r0,r4,#0x10
000074  f7fffffe          BL       vListInitialise
;;;321    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
000078  f1040024          ADD      r0,r4,#0x24
00007c  f7fffffe          BL       vListInitialise
                  |L26.128|
;;;322    		}
;;;323    	}
;;;324    	taskEXIT_CRITICAL();
000080  f7fffffe          BL       vPortExitCritical
;;;325    
;;;326    	/* A value is returned for calling semantic consistency with previous
;;;327    	versions. */
;;;328    	return pdPASS;
000084  2001              MOVS     r0,#1
;;;329    }
000086  bd70              POP      {r4-r6,pc}
;;;330    /*-----------------------------------------------------------*/
                          ENDP

                  |L26.136|
000088  2e2e5c46          DCB      "..\\FreeRTOS\\queue.c",0
00008c  72656552
000090  544f535c
000094  71756575
000098  652e6300
                  |L26.156|
00009c  4572726f          DCB      "Error:%s,%d\r\n",0
0000a0  723a2573
0000a4  2c25640d
0000a8  0a00    
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L26.172|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericSend||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  xQueueGenericSend PROC
;;;722    
;;;723    BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
000000  e92d43ff          PUSH     {r0-r9,lr}
;;;724    {
000004  b083              SUB      sp,sp,#0xc
000006  4606              MOV      r6,r0
000008  4688              MOV      r8,r1
00000a  461d              MOV      r5,r3
;;;725    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
00000c  f04f0900          MOV      r9,#0
;;;726    TimeOut_t xTimeOut;
;;;727    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000010  4634              MOV      r4,r6
;;;728    
;;;729    	configASSERT( pxQueue );
000012  b92c              CBNZ     r4,|L27.32|
000014  f24022d9          MOV      r2,#0x2d9
000018  a160              ADR      r1,|L27.412|
00001a  a065              ADR      r0,|L27.432|
00001c  f7fffffe          BL       __2printf
                  |L27.32|
;;;730    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000020  f1b80f00          CMP      r8,#0
000024  d101              BNE      |L27.42|
000026  6c20              LDR      r0,[r4,#0x40]
000028  b908              CBNZ     r0,|L27.46|
                  |L27.42|
00002a  2001              MOVS     r0,#1
00002c  e000              B        |L27.48|
                  |L27.46|
00002e  2000              MOVS     r0,#0
                  |L27.48|
000030  b928              CBNZ     r0,|L27.62|
000032  f24022da          MOV      r2,#0x2da
000036  a159              ADR      r1,|L27.412|
000038  a05d              ADR      r0,|L27.432|
00003a  f7fffffe          BL       __2printf
                  |L27.62|
;;;731    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
00003e  2d02              CMP      r5,#2
000040  d102              BNE      |L27.72|
000042  6be0              LDR      r0,[r4,#0x3c]
000044  2801              CMP      r0,#1
000046  d101              BNE      |L27.76|
                  |L27.72|
000048  2001              MOVS     r0,#1
00004a  e000              B        |L27.78|
                  |L27.76|
00004c  2000              MOVS     r0,#0
                  |L27.78|
00004e  b928              CBNZ     r0,|L27.92|
000050  f24022db          MOV      r2,#0x2db
000054  a151              ADR      r1,|L27.412|
000056  a056              ADR      r0,|L27.432|
000058  f7fffffe          BL       __2printf
                  |L27.92|
;;;732    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;733    	{
;;;734    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
00005c  f7fffffe          BL       xTaskGetSchedulerState
000060  b908              CBNZ     r0,|L27.102|
000062  9805              LDR      r0,[sp,#0x14]
000064  b908              CBNZ     r0,|L27.106|
                  |L27.102|
000066  2001              MOVS     r0,#1
000068  e000              B        |L27.108|
                  |L27.106|
00006a  2000              MOVS     r0,#0
                  |L27.108|
00006c  b928              CBNZ     r0,|L27.122|
00006e  f24022de          MOV      r2,#0x2de
000072  a14a              ADR      r1,|L27.412|
000074  a04e              ADR      r0,|L27.432|
000076  f7fffffe          BL       __2printf
                  |L27.122|
;;;735    	}
;;;736    	#endif
;;;737    
;;;738    
;;;739    	/* This function relaxes the coding standard somewhat to allow return
;;;740    	statements within the function itself.  This is done in the interest
;;;741    	of execution time efficiency. */
;;;742    	for( ;; )
00007a  bf00              NOP      
                  |L27.124|
;;;743    	{
;;;744    		taskENTER_CRITICAL();
00007c  f7fffffe          BL       vPortEnterCritical
;;;745    		{
;;;746    			/* Is there room on the queue now?  The running task must be the
;;;747    			highest priority task wanting to access the queue.  If the head item
;;;748    			in the queue is to be overwritten then it does not matter if the
;;;749    			queue is full. */
;;;750    			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000080  6ba0              LDR      r0,[r4,#0x38]
000082  6be1              LDR      r1,[r4,#0x3c]
000084  4288              CMP      r0,r1
000086  d301              BCC      |L27.140|
000088  2d02              CMP      r5,#2
00008a  d138              BNE      |L27.254|
                  |L27.140|
;;;751    			{
;;;752    				traceQUEUE_SEND( pxQueue );
;;;753    				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
00008c  462a              MOV      r2,r5
00008e  4641              MOV      r1,r8
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       prvCopyDataToQueue
000096  4607              MOV      r7,r0
;;;754    
;;;755    				#if ( configUSE_QUEUE_SETS == 1 )
;;;756    				{
;;;757    					if( pxQueue->pxQueueSetContainer != NULL )
000098  6ca0              LDR      r0,[r4,#0x48]
00009a  b168              CBZ      r0,|L27.184|
;;;758    					{
;;;759    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
00009c  4629              MOV      r1,r5
00009e  4620              MOV      r0,r4
0000a0  f7fffffe          BL       prvNotifyQueueSetContainer
0000a4  b328              CBZ      r0,|L27.242|
;;;760    						{
;;;761    							/* The queue is a member of a queue set, and posting
;;;762    							to the queue set caused a higher priority task to
;;;763    							unblock. A context switch is required. */
;;;764    							queueYIELD_IF_USING_PREEMPTION();
0000a6  f04f5080          MOV      r0,#0x10000000
0000aa  4945              LDR      r1,|L27.448|
0000ac  6008              STR      r0,[r1,#0]
0000ae  f3bf8f4f          DSB      
0000b2  f3bf8f6f          ISB      
0000b6  e01c              B        |L27.242|
                  |L27.184|
;;;765    						}
;;;766    						else
;;;767    						{
;;;768    							mtCOVERAGE_TEST_MARKER();
;;;769    						}
;;;770    					}
;;;771    					else
;;;772    					{
;;;773    						/* If there was a task waiting for data to arrive on the
;;;774    						queue then unblock it now. */
;;;775    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0000b8  6a60              LDR      r0,[r4,#0x24]
0000ba  b908              CBNZ     r0,|L27.192|
0000bc  2001              MOVS     r0,#1
0000be  e000              B        |L27.194|
                  |L27.192|
0000c0  2000              MOVS     r0,#0
                  |L27.194|
0000c2  b968              CBNZ     r0,|L27.224|
;;;776    						{
;;;777    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0000c4  f1040024          ADD      r0,r4,#0x24
0000c8  f7fffffe          BL       xTaskRemoveFromEventList
0000cc  b188              CBZ      r0,|L27.242|
;;;778    							{
;;;779    								/* The unblocked task has a priority higher than
;;;780    								our own so yield immediately.  Yes it is ok to
;;;781    								do this from within the critical section - the
;;;782    								kernel takes care of that. */
;;;783    								queueYIELD_IF_USING_PREEMPTION();
0000ce  f04f5080          MOV      r0,#0x10000000
0000d2  493b              LDR      r1,|L27.448|
0000d4  6008              STR      r0,[r1,#0]
0000d6  f3bf8f4f          DSB      
0000da  f3bf8f6f          ISB      
0000de  e008              B        |L27.242|
                  |L27.224|
;;;784    							}
;;;785    							else
;;;786    							{
;;;787    								mtCOVERAGE_TEST_MARKER();
;;;788    							}
;;;789    						}
;;;790    						else if( xYieldRequired != pdFALSE )
0000e0  b13f              CBZ      r7,|L27.242|
;;;791    						{
;;;792    							/* This path is a special case that will only get
;;;793    							executed if the task was holding multiple mutexes
;;;794    							and the mutexes were given back in an order that is
;;;795    							different to that in which they were taken. */
;;;796    							queueYIELD_IF_USING_PREEMPTION();
0000e2  f04f5080          MOV      r0,#0x10000000
0000e6  4936              LDR      r1,|L27.448|
0000e8  6008              STR      r0,[r1,#0]
0000ea  f3bf8f4f          DSB      
0000ee  f3bf8f6f          ISB      
                  |L27.242|
;;;797    						}
;;;798    						else
;;;799    						{
;;;800    							mtCOVERAGE_TEST_MARKER();
;;;801    						}
;;;802    					}
;;;803    				}
;;;804    				#else /* configUSE_QUEUE_SETS */
;;;805    				{
;;;806    					/* If there was a task waiting for data to arrive on the
;;;807    					queue then unblock it now. */
;;;808    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;809    					{
;;;810    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;811    						{
;;;812    							/* The unblocked task has a priority higher than
;;;813    							our own so yield immediately.  Yes it is ok to do
;;;814    							this from within the critical section - the kernel
;;;815    							takes care of that. */
;;;816    							queueYIELD_IF_USING_PREEMPTION();
;;;817    						}
;;;818    						else
;;;819    						{
;;;820    							mtCOVERAGE_TEST_MARKER();
;;;821    						}
;;;822    					}
;;;823    					else if( xYieldRequired != pdFALSE )
;;;824    					{
;;;825    						/* This path is a special case that will only get
;;;826    						executed if the task was holding multiple mutexes and
;;;827    						the mutexes were given back in an order that is
;;;828    						different to that in which they were taken. */
;;;829    						queueYIELD_IF_USING_PREEMPTION();
;;;830    					}
;;;831    					else
;;;832    					{
;;;833    						mtCOVERAGE_TEST_MARKER();
;;;834    					}
;;;835    				}
;;;836    				#endif /* configUSE_QUEUE_SETS */
;;;837    
;;;838    				taskEXIT_CRITICAL();
0000f2  f7fffffe          BL       vPortExitCritical
;;;839    				return pdPASS;
0000f6  2001              MOVS     r0,#1
                  |L27.248|
;;;840    			}
;;;841    			else
;;;842    			{
;;;843    				if( xTicksToWait == ( TickType_t ) 0 )
;;;844    				{
;;;845    					/* The queue was full and no block time is specified (or
;;;846    					the block time has expired) so leave now. */
;;;847    					taskEXIT_CRITICAL();
;;;848    
;;;849    					/* Return to the original privilege level before exiting
;;;850    					the function. */
;;;851    					traceQUEUE_SEND_FAILED( pxQueue );
;;;852    					return errQUEUE_FULL;
;;;853    				}
;;;854    				else if( xEntryTimeSet == pdFALSE )
;;;855    				{
;;;856    					/* The queue was full and a block time was specified so
;;;857    					configure the timeout structure. */
;;;858    					vTaskSetTimeOutState( &xTimeOut );
;;;859    					xEntryTimeSet = pdTRUE;
;;;860    				}
;;;861    				else
;;;862    				{
;;;863    					/* Entry time was already set. */
;;;864    					mtCOVERAGE_TEST_MARKER();
;;;865    				}
;;;866    			}
;;;867    		}
;;;868    		taskEXIT_CRITICAL();
;;;869    
;;;870    		/* Interrupts and other tasks can send to and receive from the queue
;;;871    		now the critical section has been exited. */
;;;872    
;;;873    		vTaskSuspendAll();
;;;874    		prvLockQueue( pxQueue );
;;;875    
;;;876    		/* Update the timeout state to see if it has expired yet. */
;;;877    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;878    		{
;;;879    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;880    			{
;;;881    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;882    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;883    
;;;884    				/* Unlocking the queue means queue events can effect the
;;;885    				event list.  It is possible	that interrupts occurring now
;;;886    				remove this task from the event	list again - but as the
;;;887    				scheduler is suspended the task will go onto the pending
;;;888    				ready last instead of the actual ready list. */
;;;889    				prvUnlockQueue( pxQueue );
;;;890    
;;;891    				/* Resuming the scheduler will move tasks from the pending
;;;892    				ready list into the ready list - so it is feasible that this
;;;893    				task is already in a ready list before it yields - in which
;;;894    				case the yield will not cause a context switch unless there
;;;895    				is also a higher priority task in the pending ready list. */
;;;896    				if( xTaskResumeAll() == pdFALSE )
;;;897    				{
;;;898    					portYIELD_WITHIN_API();
;;;899    				}
;;;900    			}
;;;901    			else
;;;902    			{
;;;903    				/* Try again. */
;;;904    				prvUnlockQueue( pxQueue );
;;;905    				( void ) xTaskResumeAll();
;;;906    			}
;;;907    		}
;;;908    		else
;;;909    		{
;;;910    			/* The timeout has expired. */
;;;911    			prvUnlockQueue( pxQueue );
;;;912    			( void ) xTaskResumeAll();
;;;913    
;;;914    			traceQUEUE_SEND_FAILED( pxQueue );
;;;915    			return errQUEUE_FULL;
;;;916    		}
;;;917    	}
;;;918    }
0000f8  b007              ADD      sp,sp,#0x1c
0000fa  e8bd83f0          POP      {r4-r9,pc}
                  |L27.254|
0000fe  9805              LDR      r0,[sp,#0x14]         ;843
000100  b918              CBNZ     r0,|L27.266|
000102  f7fffffe          BL       vPortExitCritical
000106  2000              MOVS     r0,#0                 ;852
000108  e7f6              B        |L27.248|
                  |L27.266|
00010a  f1b90f00          CMP      r9,#0                 ;854
00010e  d104              BNE      |L27.282|
000110  a801              ADD      r0,sp,#4              ;858
000112  f7fffffe          BL       vTaskSetTimeOutState
000116  f04f0901          MOV      r9,#1                 ;859
                  |L27.282|
00011a  f7fffffe          BL       vPortExitCritical
00011e  f7fffffe          BL       vTaskSuspendAll
000122  f7fffffe          BL       vPortEnterCritical
000126  f9940044          LDRSB    r0,[r4,#0x44]         ;874
00012a  1c40              ADDS     r0,r0,#1              ;874
00012c  b910              CBNZ     r0,|L27.308|
00012e  2000              MOVS     r0,#0                 ;874
000130  f8840044          STRB     r0,[r4,#0x44]         ;874
                  |L27.308|
000134  f9940045          LDRSB    r0,[r4,#0x45]         ;874
000138  1c40              ADDS     r0,r0,#1              ;874
00013a  b910              CBNZ     r0,|L27.322|
00013c  2000              MOVS     r0,#0                 ;874
00013e  f8840045          STRB     r0,[r4,#0x45]         ;874
                  |L27.322|
000142  f7fffffe          BL       vPortExitCritical
000146  a905              ADD      r1,sp,#0x14           ;877
000148  a801              ADD      r0,sp,#4              ;877
00014a  f7fffffe          BL       xTaskCheckForTimeOut
00014e  b9f0              CBNZ     r0,|L27.398|
000150  4620              MOV      r0,r4                 ;879
000152  f7fffffe          BL       prvIsQueueFull
000156  b1a0              CBZ      r0,|L27.386|
000158  f1040010          ADD      r0,r4,#0x10           ;882
00015c  9905              LDR      r1,[sp,#0x14]         ;882
00015e  f7fffffe          BL       vTaskPlaceOnEventList
000162  4620              MOV      r0,r4                 ;889
000164  f7fffffe          BL       prvUnlockQueue
000168  f7fffffe          BL       xTaskResumeAll
00016c  2800              CMP      r0,#0                 ;896
00016e  d185              BNE      |L27.124|
000170  f04f5080          MOV      r0,#0x10000000        ;898
000174  4912              LDR      r1,|L27.448|
000176  6008              STR      r0,[r1,#0]            ;898
000178  f3bf8f4f          DSB                            ;898
00017c  f3bf8f6f          ISB                            ;898
000180  e77c              B        |L27.124|
                  |L27.386|
000182  4620              MOV      r0,r4                 ;904
000184  f7fffffe          BL       prvUnlockQueue
000188  f7fffffe          BL       xTaskResumeAll
00018c  e776              B        |L27.124|
                  |L27.398|
00018e  4620              MOV      r0,r4                 ;911
000190  f7fffffe          BL       prvUnlockQueue
000194  f7fffffe          BL       xTaskResumeAll
000198  2000              MOVS     r0,#0                 ;915
00019a  e7ad              B        |L27.248|
;;;919    /*-----------------------------------------------------------*/
                          ENDP

                  |L27.412|
00019c  2e2e5c46          DCB      "..\\FreeRTOS\\queue.c",0
0001a0  72656552
0001a4  544f535c
0001a8  71756575
0001ac  652e6300
                  |L27.432|
0001b0  4572726f          DCB      "Error:%s,%d\r\n",0
0001b4  723a2573
0001b8  2c25640d
0001bc  0a00    
0001be  00                DCB      0
0001bf  00                DCB      0
                  |L27.448|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericSendFromISR||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  xQueueGenericSendFromISR PROC
;;;920    
;;;921    BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;922    {
000004  4680              MOV      r8,r0
000006  468a              MOV      r10,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;923    BaseType_t xReturn;
;;;924    UBaseType_t uxSavedInterruptStatus;
;;;925    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
00000c  4644              MOV      r4,r8
;;;926    
;;;927    	configASSERT( pxQueue );
00000e  b92c              CBNZ     r4,|L28.28|
000010  f240329f          MOV      r2,#0x39f
000014  a135              ADR      r1,|L28.236|
000016  a03a              ADR      r0,|L28.256|
000018  f7fffffe          BL       __2printf
                  |L28.28|
;;;928    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
00001c  f1ba0f00          CMP      r10,#0
000020  d101              BNE      |L28.38|
000022  6c20              LDR      r0,[r4,#0x40]
000024  b908              CBNZ     r0,|L28.42|
                  |L28.38|
000026  2001              MOVS     r0,#1
000028  e000              B        |L28.44|
                  |L28.42|
00002a  2000              MOVS     r0,#0
                  |L28.44|
00002c  b928              CBNZ     r0,|L28.58|
00002e  f44f7268          MOV      r2,#0x3a0
000032  a12e              ADR      r1,|L28.236|
000034  a032              ADR      r0,|L28.256|
000036  f7fffffe          BL       __2printf
                  |L28.58|
;;;929    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
00003a  2e02              CMP      r6,#2
00003c  d102              BNE      |L28.68|
00003e  6be0              LDR      r0,[r4,#0x3c]
000040  2801              CMP      r0,#1
000042  d101              BNE      |L28.72|
                  |L28.68|
000044  2001              MOVS     r0,#1
000046  e000              B        |L28.74|
                  |L28.72|
000048  2000              MOVS     r0,#0
                  |L28.74|
00004a  b928              CBNZ     r0,|L28.88|
00004c  f24032a1          MOV      r2,#0x3a1
000050  a126              ADR      r1,|L28.236|
000052  a02b              ADR      r0,|L28.256|
000054  f7fffffe          BL       __2printf
                  |L28.88|
;;;930    
;;;931    	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;932    	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;933    	above the maximum system call priority are kept permanently enabled, even
;;;934    	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;935    	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;936    	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;937    	failure if a FreeRTOS API function is called from an interrupt that has been
;;;938    	assigned a priority above the configured maximum system call priority.
;;;939    	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;940    	that have been assigned a priority at or (logically) below the maximum
;;;941    	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;942    	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;943    	More information (albeit Cortex-M specific) is provided on the following
;;;944    	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;945    	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000058  f7fffffe          BL       vPortValidateInterruptPriority
;;;946    
;;;947    	/* Similar to xQueueGenericSend, except without blocking if there is no room
;;;948    	in the queue.  Also don't directly wake a task that was blocked on a queue
;;;949    	read, instead return a flag to say whether a context switch is required or
;;;950    	not (i.e. has a task with a higher priority than us been woken by this
;;;951    	post). */
;;;952    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00005c  bf00              NOP      
00005e  2160              MOVS     r1,#0x60
000060  f3ef8011          MRS      r0,BASEPRI
000064  f3818811          MSR      BASEPRI,r1
000068  f3bf8f4f          DSB      
00006c  f3bf8f6f          ISB      
000070  bf00              NOP      
000072  4607              MOV      r7,r0
;;;953    	{
;;;954    		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000074  6ba0              LDR      r0,[r4,#0x38]
000076  6be1              LDR      r1,[r4,#0x3c]
000078  4288              CMP      r0,r1
00007a  d301              BCC      |L28.128|
00007c  2e02              CMP      r6,#2
00007e  d12b              BNE      |L28.216|
                  |L28.128|
;;;955    		{
;;;956    			const int8_t cTxLock = pxQueue->cTxLock;
000080  f994b045          LDRSB    r11,[r4,#0x45]
;;;957    
;;;958    			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;959    
;;;960    			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
;;;961    			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
;;;962    			in a task disinheriting a priority and prvCopyDataToQueue() can be
;;;963    			called here even though the disinherit function does not check if
;;;964    			the scheduler is suspended before accessing the ready lists. */
;;;965    			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
000084  4632              MOV      r2,r6
000086  4651              MOV      r1,r10
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       prvCopyDataToQueue
;;;966    
;;;967    			/* The event list is not altered if the queue is locked.  This will
;;;968    			be done when the queue is unlocked later. */
;;;969    			if( cTxLock == queueUNLOCKED )
00008e  f10b0001          ADD      r0,r11,#1
000092  b9c8              CBNZ     r0,|L28.200|
;;;970    			{
;;;971    				#if ( configUSE_QUEUE_SETS == 1 )
;;;972    				{
;;;973    					if( pxQueue->pxQueueSetContainer != NULL )
000094  6ca0              LDR      r0,[r4,#0x48]
000096  b140              CBZ      r0,|L28.170|
;;;974    					{
;;;975    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
000098  4631              MOV      r1,r6
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       prvNotifyQueueSetContainer
0000a0  b1b8              CBZ      r0,|L28.210|
;;;976    						{
;;;977    							/* The queue is a member of a queue set, and posting
;;;978    							to the queue set caused a higher priority task to
;;;979    							unblock.  A context switch is required. */
;;;980    							if( pxHigherPriorityTaskWoken != NULL )
0000a2  b1b5              CBZ      r5,|L28.210|
;;;981    							{
;;;982    								*pxHigherPriorityTaskWoken = pdTRUE;
0000a4  2001              MOVS     r0,#1
0000a6  6028              STR      r0,[r5,#0]
0000a8  e013              B        |L28.210|
                  |L28.170|
;;;983    							}
;;;984    							else
;;;985    							{
;;;986    								mtCOVERAGE_TEST_MARKER();
;;;987    							}
;;;988    						}
;;;989    						else
;;;990    						{
;;;991    							mtCOVERAGE_TEST_MARKER();
;;;992    						}
;;;993    					}
;;;994    					else
;;;995    					{
;;;996    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0000aa  6a60              LDR      r0,[r4,#0x24]
0000ac  b908              CBNZ     r0,|L28.178|
0000ae  2001              MOVS     r0,#1
0000b0  e000              B        |L28.180|
                  |L28.178|
0000b2  2000              MOVS     r0,#0
                  |L28.180|
0000b4  b968              CBNZ     r0,|L28.210|
;;;997    						{
;;;998    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0000b6  f1040024          ADD      r0,r4,#0x24
0000ba  f7fffffe          BL       xTaskRemoveFromEventList
0000be  b140              CBZ      r0,|L28.210|
;;;999    							{
;;;1000   								/* The task waiting has a higher priority so
;;;1001   								record that a context switch is required. */
;;;1002   								if( pxHigherPriorityTaskWoken != NULL )
0000c0  b13d              CBZ      r5,|L28.210|
;;;1003   								{
;;;1004   									*pxHigherPriorityTaskWoken = pdTRUE;
0000c2  2001              MOVS     r0,#1
0000c4  6028              STR      r0,[r5,#0]
0000c6  e004              B        |L28.210|
                  |L28.200|
;;;1005   								}
;;;1006   								else
;;;1007   								{
;;;1008   									mtCOVERAGE_TEST_MARKER();
;;;1009   								}
;;;1010   							}
;;;1011   							else
;;;1012   							{
;;;1013   								mtCOVERAGE_TEST_MARKER();
;;;1014   							}
;;;1015   						}
;;;1016   						else
;;;1017   						{
;;;1018   							mtCOVERAGE_TEST_MARKER();
;;;1019   						}
;;;1020   					}
;;;1021   				}
;;;1022   				#else /* configUSE_QUEUE_SETS */
;;;1023   				{
;;;1024   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1025   					{
;;;1026   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1027   						{
;;;1028   							/* The task waiting has a higher priority so record that a
;;;1029   							context	switch is required. */
;;;1030   							if( pxHigherPriorityTaskWoken != NULL )
;;;1031   							{
;;;1032   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1033   							}
;;;1034   							else
;;;1035   							{
;;;1036   								mtCOVERAGE_TEST_MARKER();
;;;1037   							}
;;;1038   						}
;;;1039   						else
;;;1040   						{
;;;1041   							mtCOVERAGE_TEST_MARKER();
;;;1042   						}
;;;1043   					}
;;;1044   					else
;;;1045   					{
;;;1046   						mtCOVERAGE_TEST_MARKER();
;;;1047   					}
;;;1048   				}
;;;1049   				#endif /* configUSE_QUEUE_SETS */
;;;1050   			}
;;;1051   			else
;;;1052   			{
;;;1053   				/* Increment the lock count so the task that unlocks the queue
;;;1054   				knows that data was posted while it was locked. */
;;;1055   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
0000c8  f10b0001          ADD      r0,r11,#1
0000cc  b240              SXTB     r0,r0
0000ce  f8840045          STRB     r0,[r4,#0x45]
                  |L28.210|
;;;1056   			}
;;;1057   
;;;1058   			xReturn = pdPASS;
0000d2  f04f0901          MOV      r9,#1
;;;1059   		}
0000d6  e001              B        |L28.220|
                  |L28.216|
;;;1060   		else
;;;1061   		{
;;;1062   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1063   			xReturn = errQUEUE_FULL;
0000d8  f04f0900          MOV      r9,#0
                  |L28.220|
;;;1064   		}
;;;1065   	}
;;;1066   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000dc  bf00              NOP      
0000de  f3878811          MSR      BASEPRI,r7
0000e2  bf00              NOP      
;;;1067   
;;;1068   	return xReturn;
0000e4  4648              MOV      r0,r9
;;;1069   }
0000e6  e8bd9ff0          POP      {r4-r12,pc}
;;;1070   /*-----------------------------------------------------------*/
                          ENDP

0000ea  0000              DCW      0x0000
                  |L28.236|
0000ec  2e2e5c46          DCB      "..\\FreeRTOS\\queue.c",0
0000f0  72656552
0000f4  544f535c
0000f8  71756575
0000fc  652e6300
                  |L28.256|
000100  4572726f          DCB      "Error:%s,%d\r\n",0
000104  723a2573
000108  2c25640d
00010c  0a00    
00010e  00                DCB      0
00010f  00                DCB      0

                          AREA ||i.xQueueGiveFromISR||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  xQueueGiveFromISR PROC
;;;1071   
;;;1072   BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1073   {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
;;;1074   BaseType_t xReturn;
;;;1075   UBaseType_t uxSavedInterruptStatus;
;;;1076   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000008  463c              MOV      r4,r7
;;;1077   
;;;1078   	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
;;;1079   	item size is 0.  Don't directly wake a task that was blocked on a queue
;;;1080   	read, instead return a flag to say whether a context switch is required or
;;;1081   	not (i.e. has a task with a higher priority than us been woken by this
;;;1082   	post). */
;;;1083   
;;;1084   	configASSERT( pxQueue );
00000a  b92c              CBNZ     r4,|L29.24|
00000c  f240423c          MOV      r2,#0x43c
000010  a131              ADR      r1,|L29.216|
000012  a036              ADR      r0,|L29.236|
000014  f7fffffe          BL       __2printf
                  |L29.24|
;;;1085   
;;;1086   	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
;;;1087   	if the item size is not 0. */
;;;1088   	configASSERT( pxQueue->uxItemSize == 0 );
000018  6c20              LDR      r0,[r4,#0x40]
00001a  b908              CBNZ     r0,|L29.32|
00001c  2001              MOVS     r0,#1
00001e  e000              B        |L29.34|
                  |L29.32|
000020  2000              MOVS     r0,#0
                  |L29.34|
000022  b928              CBNZ     r0,|L29.48|
000024  f44f6288          MOV      r2,#0x440
000028  a12b              ADR      r1,|L29.216|
00002a  a030              ADR      r0,|L29.236|
00002c  f7fffffe          BL       __2printf
                  |L29.48|
;;;1089   
;;;1090   	/* Normally a mutex would not be given from an interrupt, especially if
;;;1091   	there is a mutex holder, as priority inheritance makes no sense for an
;;;1092   	interrupts, only tasks. */
;;;1093   	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
000030  6820              LDR      r0,[r4,#0]
000032  b908              CBNZ     r0,|L29.56|
000034  6860              LDR      r0,[r4,#4]
000036  b908              CBNZ     r0,|L29.60|
                  |L29.56|
000038  2001              MOVS     r0,#1
00003a  e000              B        |L29.62|
                  |L29.60|
00003c  2000              MOVS     r0,#0
                  |L29.62|
00003e  b928              CBNZ     r0,|L29.76|
000040  f2404245          MOV      r2,#0x445
000044  a124              ADR      r1,|L29.216|
000046  a029              ADR      r0,|L29.236|
000048  f7fffffe          BL       __2printf
                  |L29.76|
;;;1094   
;;;1095   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1096   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1097   	above the maximum system call priority are kept permanently enabled, even
;;;1098   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1099   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1100   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1101   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1102   	assigned a priority above the configured maximum system call priority.
;;;1103   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1104   	that have been assigned a priority at or (logically) below the maximum
;;;1105   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1106   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1107   	More information (albeit Cortex-M specific) is provided on the following
;;;1108   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1109   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00004c  f7fffffe          BL       vPortValidateInterruptPriority
;;;1110   
;;;1111   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000050  bf00              NOP      
000052  2160              MOVS     r1,#0x60
000054  f3ef8011          MRS      r0,BASEPRI
000058  f3818811          MSR      BASEPRI,r1
00005c  f3bf8f4f          DSB      
000060  f3bf8f6f          ISB      
000064  bf00              NOP      
000066  4606              MOV      r6,r0
;;;1112   	{
;;;1113   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000068  f8d49038          LDR      r9,[r4,#0x38]
;;;1114   
;;;1115   		/* When the queue is used to implement a semaphore no data is ever
;;;1116   		moved through the queue but it is still valid to see if the queue 'has
;;;1117   		space'. */
;;;1118   		if( uxMessagesWaiting < pxQueue->uxLength )
00006c  6be0              LDR      r0,[r4,#0x3c]
00006e  4548              CMP      r0,r9
000070  d929              BLS      |L29.198|
;;;1119   		{
;;;1120   			const int8_t cTxLock = pxQueue->cTxLock;
000072  f994a045          LDRSB    r10,[r4,#0x45]
;;;1121   
;;;1122   			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;1123   
;;;1124   			/* A task can only have an inherited priority if it is a mutex
;;;1125   			holder - and if there is a mutex holder then the mutex cannot be
;;;1126   			given from an ISR.  As this is the ISR version of the function it
;;;1127   			can be assumed there is no mutex holder and no need to determine if
;;;1128   			priority disinheritance is needed.  Simply increase the count of
;;;1129   			messages (semaphores) available. */
;;;1130   			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
000076  f1090001          ADD      r0,r9,#1
00007a  63a0              STR      r0,[r4,#0x38]
;;;1131   
;;;1132   			/* The event list is not altered if the queue is locked.  This will
;;;1133   			be done when the queue is unlocked later. */
;;;1134   			if( cTxLock == queueUNLOCKED )
00007c  f10a0001          ADD      r0,r10,#1
000080  b9c8              CBNZ     r0,|L29.182|
;;;1135   			{
;;;1136   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1137   				{
;;;1138   					if( pxQueue->pxQueueSetContainer != NULL )
000082  6ca0              LDR      r0,[r4,#0x48]
000084  b140              CBZ      r0,|L29.152|
;;;1139   					{
;;;1140   						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
000086  2100              MOVS     r1,#0
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       prvNotifyQueueSetContainer
00008e  b1b8              CBZ      r0,|L29.192|
;;;1141   						{
;;;1142   							/* The semaphore is a member of a queue set, and
;;;1143   							posting	to the queue set caused a higher priority
;;;1144   							task to	unblock.  A context switch is required. */
;;;1145   							if( pxHigherPriorityTaskWoken != NULL )
000090  b1b5              CBZ      r5,|L29.192|
;;;1146   							{
;;;1147   								*pxHigherPriorityTaskWoken = pdTRUE;
000092  2001              MOVS     r0,#1
000094  6028              STR      r0,[r5,#0]
000096  e013              B        |L29.192|
                  |L29.152|
;;;1148   							}
;;;1149   							else
;;;1150   							{
;;;1151   								mtCOVERAGE_TEST_MARKER();
;;;1152   							}
;;;1153   						}
;;;1154   						else
;;;1155   						{
;;;1156   							mtCOVERAGE_TEST_MARKER();
;;;1157   						}
;;;1158   					}
;;;1159   					else
;;;1160   					{
;;;1161   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000098  6a60              LDR      r0,[r4,#0x24]
00009a  b908              CBNZ     r0,|L29.160|
00009c  2001              MOVS     r0,#1
00009e  e000              B        |L29.162|
                  |L29.160|
0000a0  2000              MOVS     r0,#0
                  |L29.162|
0000a2  b968              CBNZ     r0,|L29.192|
;;;1162   						{
;;;1163   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0000a4  f1040024          ADD      r0,r4,#0x24
0000a8  f7fffffe          BL       xTaskRemoveFromEventList
0000ac  b140              CBZ      r0,|L29.192|
;;;1164   							{
;;;1165   								/* The task waiting has a higher priority so
;;;1166   								record that a context switch is required. */
;;;1167   								if( pxHigherPriorityTaskWoken != NULL )
0000ae  b13d              CBZ      r5,|L29.192|
;;;1168   								{
;;;1169   									*pxHigherPriorityTaskWoken = pdTRUE;
0000b0  2001              MOVS     r0,#1
0000b2  6028              STR      r0,[r5,#0]
0000b4  e004              B        |L29.192|
                  |L29.182|
;;;1170   								}
;;;1171   								else
;;;1172   								{
;;;1173   									mtCOVERAGE_TEST_MARKER();
;;;1174   								}
;;;1175   							}
;;;1176   							else
;;;1177   							{
;;;1178   								mtCOVERAGE_TEST_MARKER();
;;;1179   							}
;;;1180   						}
;;;1181   						else
;;;1182   						{
;;;1183   							mtCOVERAGE_TEST_MARKER();
;;;1184   						}
;;;1185   					}
;;;1186   				}
;;;1187   				#else /* configUSE_QUEUE_SETS */
;;;1188   				{
;;;1189   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1190   					{
;;;1191   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1192   						{
;;;1193   							/* The task waiting has a higher priority so record that a
;;;1194   							context	switch is required. */
;;;1195   							if( pxHigherPriorityTaskWoken != NULL )
;;;1196   							{
;;;1197   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1198   							}
;;;1199   							else
;;;1200   							{
;;;1201   								mtCOVERAGE_TEST_MARKER();
;;;1202   							}
;;;1203   						}
;;;1204   						else
;;;1205   						{
;;;1206   							mtCOVERAGE_TEST_MARKER();
;;;1207   						}
;;;1208   					}
;;;1209   					else
;;;1210   					{
;;;1211   						mtCOVERAGE_TEST_MARKER();
;;;1212   					}
;;;1213   				}
;;;1214   				#endif /* configUSE_QUEUE_SETS */
;;;1215   			}
;;;1216   			else
;;;1217   			{
;;;1218   				/* Increment the lock count so the task that unlocks the queue
;;;1219   				knows that data was posted while it was locked. */
;;;1220   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
0000b6  f10a0001          ADD      r0,r10,#1
0000ba  b240              SXTB     r0,r0
0000bc  f8840045          STRB     r0,[r4,#0x45]
                  |L29.192|
;;;1221   			}
;;;1222   
;;;1223   			xReturn = pdPASS;
0000c0  f04f0801          MOV      r8,#1
;;;1224   		}
0000c4  e001              B        |L29.202|
                  |L29.198|
;;;1225   		else
;;;1226   		{
;;;1227   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1228   			xReturn = errQUEUE_FULL;
0000c6  f04f0800          MOV      r8,#0
                  |L29.202|
;;;1229   		}
;;;1230   	}
;;;1231   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000ca  bf00              NOP      
0000cc  f3868811          MSR      BASEPRI,r6
0000d0  bf00              NOP      
;;;1232   
;;;1233   	return xReturn;
0000d2  4640              MOV      r0,r8
;;;1234   }
0000d4  e8bd87f0          POP      {r4-r10,pc}
;;;1235   /*-----------------------------------------------------------*/
                          ENDP

                  |L29.216|
0000d8  2e2e5c46          DCB      "..\\FreeRTOS\\queue.c",0
0000dc  72656552
0000e0  544f535c
0000e4  71756575
0000e8  652e6300
                  |L29.236|
0000ec  4572726f          DCB      "Error:%s,%d\r\n",0
0000f0  723a2573
0000f4  2c25640d
0000f8  0a00    
0000fa  00                DCB      0
0000fb  00                DCB      0

                          AREA ||i.xQueueGiveMutexRecursive||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  xQueueGiveMutexRecursive PROC
;;;571    
;;;572    	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
000000  b570              PUSH     {r4-r6,lr}
;;;573    	{
000002  4606              MOV      r6,r0
;;;574    	BaseType_t xReturn;
;;;575    	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
000004  4634              MOV      r4,r6
;;;576    
;;;577    		configASSERT( pxMutex );
000006  b92c              CBNZ     r4,|L30.20|
000008  f2402241          MOV      r2,#0x241
00000c  a10c              ADR      r1,|L30.64|
00000e  a011              ADR      r0,|L30.84|
000010  f7fffffe          BL       __2printf
                  |L30.20|
;;;578    
;;;579    		/* If this is the task that holds the mutex then pxMutexHolder will not
;;;580    		change outside of this task.  If this task does not hold the mutex then
;;;581    		pxMutexHolder can never coincidentally equal the tasks handle, and as
;;;582    		this is the only condition we are interested in it does not matter if
;;;583    		pxMutexHolder is accessed simultaneously by another task.  Therefore no
;;;584    		mutual exclusion is required to test the pxMutexHolder variable. */
;;;585    		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
000014  f7fffffe          BL       xTaskGetCurrentTaskHandle
000018  6861              LDR      r1,[r4,#4]
00001a  4288              CMP      r0,r1
00001c  d10c              BNE      |L30.56|
;;;586    		{
;;;587    			traceGIVE_MUTEX_RECURSIVE( pxMutex );
;;;588    
;;;589    			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
;;;590    			the task handle, therefore no underflow check is required.  Also,
;;;591    			uxRecursiveCallCount is only modified by the mutex holder, and as
;;;592    			there can only be one, no mutual exclusion is required to modify the
;;;593    			uxRecursiveCallCount member. */
;;;594    			( pxMutex->u.uxRecursiveCallCount )--;
00001e  68e0              LDR      r0,[r4,#0xc]
000020  1e40              SUBS     r0,r0,#1
000022  60e0              STR      r0,[r4,#0xc]
;;;595    
;;;596    			/* Has the recursive call count unwound to 0? */
;;;597    			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
000024  68e0              LDR      r0,[r4,#0xc]
000026  b928              CBNZ     r0,|L30.52|
;;;598    			{
;;;599    				/* Return the mutex.  This will automatically unblock any other
;;;600    				task that might be waiting to access the mutex. */
;;;601    				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
000028  2300              MOVS     r3,#0
00002a  461a              MOV      r2,r3
00002c  4619              MOV      r1,r3
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       xQueueGenericSend
                  |L30.52|
;;;602    			}
;;;603    			else
;;;604    			{
;;;605    				mtCOVERAGE_TEST_MARKER();
;;;606    			}
;;;607    
;;;608    			xReturn = pdPASS;
000034  2501              MOVS     r5,#1
000036  e000              B        |L30.58|
                  |L30.56|
;;;609    		}
;;;610    		else
;;;611    		{
;;;612    			/* The mutex cannot be given because the calling task is not the
;;;613    			holder. */
;;;614    			xReturn = pdFAIL;
000038  2500              MOVS     r5,#0
                  |L30.58|
;;;615    
;;;616    			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
;;;617    		}
;;;618    
;;;619    		return xReturn;
00003a  4628              MOV      r0,r5
;;;620    	}
00003c  bd70              POP      {r4-r6,pc}
;;;621    
                          ENDP

00003e  0000              DCW      0x0000
                  |L30.64|
000040  2e2e5c46          DCB      "..\\FreeRTOS\\queue.c",0
000044  72656552
000048  544f535c
00004c  71756575
000050  652e6300
                  |L30.84|
000054  4572726f          DCB      "Error:%s,%d\r\n",0
000058  723a2573
00005c  2c25640d
000060  0a00    
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.xQueueIsQueueEmptyFromISR||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  xQueueIsQueueEmptyFromISR PROC
;;;1934   
;;;1935   BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1936   {
000002  4605              MOV      r5,r0
;;;1937   BaseType_t xReturn;
;;;1938   
;;;1939   	configASSERT( xQueue );
000004  b92d              CBNZ     r5,|L31.18|
000006  f2407293          MOV      r2,#0x793
00000a  a105              ADR      r1,|L31.32|
00000c  a009              ADR      r0,|L31.52|
00000e  f7fffffe          BL       __2printf
                  |L31.18|
;;;1940   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
000012  6ba8              LDR      r0,[r5,#0x38]
000014  b908              CBNZ     r0,|L31.26|
;;;1941   	{
;;;1942   		xReturn = pdTRUE;
000016  2401              MOVS     r4,#1
000018  e000              B        |L31.28|
                  |L31.26|
;;;1943   	}
;;;1944   	else
;;;1945   	{
;;;1946   		xReturn = pdFALSE;
00001a  2400              MOVS     r4,#0
                  |L31.28|
;;;1947   	}
;;;1948   
;;;1949   	return xReturn;
00001c  4620              MOV      r0,r4
;;;1950   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00001e  bd70              POP      {r4-r6,pc}
;;;1951   /*-----------------------------------------------------------*/
                          ENDP

                  |L31.32|
000020  2e2e5c46          DCB      "..\\FreeRTOS\\queue.c",0
000024  72656552
000028  544f535c
00002c  71756575
000030  652e6300
                  |L31.52|
000034  4572726f          DCB      "Error:%s,%d\r\n",0
000038  723a2573
00003c  2c25640d
000040  0a00    
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.xQueueIsQueueFullFromISR||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  xQueueIsQueueFullFromISR PROC
;;;1973   
;;;1974   BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1975   {
000002  4604              MOV      r4,r0
;;;1976   BaseType_t xReturn;
;;;1977   
;;;1978   	configASSERT( xQueue );
000004  b92c              CBNZ     r4,|L32.18|
000006  f24072ba          MOV      r2,#0x7ba
00000a  a106              ADR      r1,|L32.36|
00000c  a00a              ADR      r0,|L32.56|
00000e  f7fffffe          BL       __2printf
                  |L32.18|
;;;1979   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
000012  6ba0              LDR      r0,[r4,#0x38]
000014  6be1              LDR      r1,[r4,#0x3c]
000016  4288              CMP      r0,r1
000018  d101              BNE      |L32.30|
;;;1980   	{
;;;1981   		xReturn = pdTRUE;
00001a  2501              MOVS     r5,#1
00001c  e000              B        |L32.32|
                  |L32.30|
;;;1982   	}
;;;1983   	else
;;;1984   	{
;;;1985   		xReturn = pdFALSE;
00001e  2500              MOVS     r5,#0
                  |L32.32|
;;;1986   	}
;;;1987   
;;;1988   	return xReturn;
000020  4628              MOV      r0,r5
;;;1989   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000022  bd70              POP      {r4-r6,pc}
;;;1990   /*-----------------------------------------------------------*/
                          ENDP

                  |L32.36|
000024  2e2e5c46          DCB      "..\\FreeRTOS\\queue.c",0
000028  72656552
00002c  544f535c
000030  71756575
000034  652e6300
                  |L32.56|
000038  4572726f          DCB      "Error:%s,%d\r\n",0
00003c  723a2573
000040  2c25640d
000044  0a00    
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.xQueuePeekFromISR||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  xQueuePeekFromISR PROC
;;;1524   
;;;1525   BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1526   {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
;;;1527   BaseType_t xReturn;
;;;1528   UBaseType_t uxSavedInterruptStatus;
;;;1529   int8_t *pcOriginalReadPosition;
;;;1530   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
000008  4634              MOV      r4,r6
;;;1531   
;;;1532   	configASSERT( pxQueue );
00000a  b92c              CBNZ     r4,|L33.24|
00000c  f24052fc          MOV      r2,#0x5fc
000010  a120              ADR      r1,|L33.148|
000012  a025              ADR      r0,|L33.168|
000014  f7fffffe          BL       __2printf
                  |L33.24|
;;;1533   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000018  f1b80f00          CMP      r8,#0
00001c  d101              BNE      |L33.34|
00001e  6c20              LDR      r0,[r4,#0x40]
000020  b908              CBNZ     r0,|L33.38|
                  |L33.34|
000022  2001              MOVS     r0,#1
000024  e000              B        |L33.40|
                  |L33.38|
000026  2000              MOVS     r0,#0
                  |L33.40|
000028  b928              CBNZ     r0,|L33.54|
00002a  f24052fd          MOV      r2,#0x5fd
00002e  a119              ADR      r1,|L33.148|
000030  a01d              ADR      r0,|L33.168|
000032  f7fffffe          BL       __2printf
                  |L33.54|
;;;1534   	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
000036  6c20              LDR      r0,[r4,#0x40]
000038  b108              CBZ      r0,|L33.62|
00003a  2001              MOVS     r0,#1
00003c  e000              B        |L33.64|
                  |L33.62|
00003e  2000              MOVS     r0,#0
                  |L33.64|
000040  b928              CBNZ     r0,|L33.78|
000042  f24052fe          MOV      r2,#0x5fe
000046  a113              ADR      r1,|L33.148|
000048  a017              ADR      r0,|L33.168|
00004a  f7fffffe          BL       __2printf
                  |L33.78|
;;;1535   
;;;1536   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1537   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1538   	above the maximum system call priority are kept permanently enabled, even
;;;1539   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1540   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1541   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1542   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1543   	assigned a priority above the configured maximum system call priority.
;;;1544   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1545   	that have been assigned a priority at or (logically) below the maximum
;;;1546   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1547   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1548   	More information (albeit Cortex-M specific) is provided on the following
;;;1549   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1550   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00004e  f7fffffe          BL       vPortValidateInterruptPriority
;;;1551   
;;;1552   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000052  bf00              NOP      
000054  2160              MOVS     r1,#0x60
000056  f3ef8011          MRS      r0,BASEPRI
00005a  f3818811          MSR      BASEPRI,r1
00005e  f3bf8f4f          DSB      
000062  f3bf8f6f          ISB      
000066  bf00              NOP      
000068  4605              MOV      r5,r0
;;;1553   	{
;;;1554   		/* Cannot block in an ISR, so check there is data available. */
;;;1555   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
00006a  6ba0              LDR      r0,[r4,#0x38]
00006c  b148              CBZ      r0,|L33.130|
;;;1556   		{
;;;1557   			traceQUEUE_PEEK_FROM_ISR( pxQueue );
;;;1558   
;;;1559   			/* Remember the read position so it can be reset as nothing is
;;;1560   			actually being removed from the queue. */
;;;1561   			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
00006e  f8d4900c          LDR      r9,[r4,#0xc]
;;;1562   			prvCopyDataFromQueue( pxQueue, pvBuffer );
000072  4641              MOV      r1,r8
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       prvCopyDataFromQueue
;;;1563   			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
00007a  f8c4900c          STR      r9,[r4,#0xc]
;;;1564   
;;;1565   			xReturn = pdPASS;
00007e  2701              MOVS     r7,#1
000080  e000              B        |L33.132|
                  |L33.130|
;;;1566   		}
;;;1567   		else
;;;1568   		{
;;;1569   			xReturn = pdFAIL;
000082  2700              MOVS     r7,#0
                  |L33.132|
;;;1570   			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
;;;1571   		}
;;;1572   	}
;;;1573   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000084  bf00              NOP      
000086  f3858811          MSR      BASEPRI,r5
00008a  bf00              NOP      
;;;1574   
;;;1575   	return xReturn;
00008c  4638              MOV      r0,r7
;;;1576   }
00008e  e8bd87f0          POP      {r4-r10,pc}
;;;1577   /*-----------------------------------------------------------*/
                          ENDP

000092  0000              DCW      0x0000
                  |L33.148|
000094  2e2e5c46          DCB      "..\\FreeRTOS\\queue.c",0
000098  72656552
00009c  544f535c
0000a0  71756575
0000a4  652e6300
                  |L33.168|
0000a8  4572726f          DCB      "Error:%s,%d\r\n",0
0000ac  723a2573
0000b0  2c25640d
0000b4  0a00    
0000b6  00                DCB      0
0000b7  00                DCB      0

                          AREA ||i.xQueueReceiveFromISR||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  xQueueReceiveFromISR PROC
;;;1433   
;;;1434   BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1435   {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
;;;1436   BaseType_t xReturn;
;;;1437   UBaseType_t uxSavedInterruptStatus;
;;;1438   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
00000a  4634              MOV      r4,r6
;;;1439   
;;;1440   	configASSERT( pxQueue );
00000c  b92c              CBNZ     r4,|L34.26|
00000e  f44f62b4          MOV      r2,#0x5a0
000012  a129              ADR      r1,|L34.184|
000014  a02d              ADR      r0,|L34.204|
000016  f7fffffe          BL       __2printf
                  |L34.26|
;;;1441   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
00001a  f1b90f00          CMP      r9,#0
00001e  d101              BNE      |L34.36|
000020  6c20              LDR      r0,[r4,#0x40]
000022  b908              CBNZ     r0,|L34.40|
                  |L34.36|
000024  2001              MOVS     r0,#1
000026  e000              B        |L34.42|
                  |L34.40|
000028  2000              MOVS     r0,#0
                  |L34.42|
00002a  b928              CBNZ     r0,|L34.56|
00002c  f24052a1          MOV      r2,#0x5a1
000030  a121              ADR      r1,|L34.184|
000032  a026              ADR      r0,|L34.204|
000034  f7fffffe          BL       __2printf
                  |L34.56|
;;;1442   
;;;1443   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1444   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1445   	above the maximum system call priority are kept permanently enabled, even
;;;1446   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1447   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1448   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1449   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1450   	assigned a priority above the configured maximum system call priority.
;;;1451   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1452   	that have been assigned a priority at or (logically) below the maximum
;;;1453   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1454   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1455   	More information (albeit Cortex-M specific) is provided on the following
;;;1456   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1457   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000038  f7fffffe          BL       vPortValidateInterruptPriority
;;;1458   
;;;1459   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00003c  bf00              NOP      
00003e  2160              MOVS     r1,#0x60
000040  f3ef8011          MRS      r0,BASEPRI
000044  f3818811          MSR      BASEPRI,r1
000048  f3bf8f4f          DSB      
00004c  f3bf8f6f          ISB      
000050  bf00              NOP      
000052  4605              MOV      r5,r0
;;;1460   	{
;;;1461   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000054  f8d4a038          LDR      r10,[r4,#0x38]
;;;1462   
;;;1463   		/* Cannot block in an ISR, so check there is data available. */
;;;1464   		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
000058  f1ba0f00          CMP      r10,#0
00005c  d022              BEQ      |L34.164|
;;;1465   		{
;;;1466   			const int8_t cRxLock = pxQueue->cRxLock;
00005e  f994b044          LDRSB    r11,[r4,#0x44]
;;;1467   
;;;1468   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1469   
;;;1470   			prvCopyDataFromQueue( pxQueue, pvBuffer );
000062  4649              MOV      r1,r9
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       prvCopyDataFromQueue
;;;1471   			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
00006a  f1aa0001          SUB      r0,r10,#1
00006e  63a0              STR      r0,[r4,#0x38]
;;;1472   
;;;1473   			/* If the queue is locked the event list will not be modified.
;;;1474   			Instead update the lock count so the task that unlocks the queue
;;;1475   			will know that an ISR has removed data while the queue was
;;;1476   			locked. */
;;;1477   			if( cRxLock == queueUNLOCKED )
000070  f10b0001          ADD      r0,r11,#1
000074  b970              CBNZ     r0,|L34.148|
;;;1478   			{
;;;1479   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000076  6920              LDR      r0,[r4,#0x10]
000078  b908              CBNZ     r0,|L34.126|
00007a  2001              MOVS     r0,#1
00007c  e000              B        |L34.128|
                  |L34.126|
00007e  2000              MOVS     r0,#0
                  |L34.128|
000080  b968              CBNZ     r0,|L34.158|
;;;1480   				{
;;;1481   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000082  f1040010          ADD      r0,r4,#0x10
000086  f7fffffe          BL       xTaskRemoveFromEventList
00008a  b140              CBZ      r0,|L34.158|
;;;1482   					{
;;;1483   						/* The task waiting has a higher priority than us so
;;;1484   						force a context switch. */
;;;1485   						if( pxHigherPriorityTaskWoken != NULL )
00008c  b13f              CBZ      r7,|L34.158|
;;;1486   						{
;;;1487   							*pxHigherPriorityTaskWoken = pdTRUE;
00008e  2001              MOVS     r0,#1
000090  6038              STR      r0,[r7,#0]
000092  e004              B        |L34.158|
                  |L34.148|
;;;1488   						}
;;;1489   						else
;;;1490   						{
;;;1491   							mtCOVERAGE_TEST_MARKER();
;;;1492   						}
;;;1493   					}
;;;1494   					else
;;;1495   					{
;;;1496   						mtCOVERAGE_TEST_MARKER();
;;;1497   					}
;;;1498   				}
;;;1499   				else
;;;1500   				{
;;;1501   					mtCOVERAGE_TEST_MARKER();
;;;1502   				}
;;;1503   			}
;;;1504   			else
;;;1505   			{
;;;1506   				/* Increment the lock count so the task that unlocks the queue
;;;1507   				knows that data was removed while it was locked. */
;;;1508   				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
000094  f10b0001          ADD      r0,r11,#1
000098  b240              SXTB     r0,r0
00009a  f8840044          STRB     r0,[r4,#0x44]
                  |L34.158|
;;;1509   			}
;;;1510   
;;;1511   			xReturn = pdPASS;
00009e  f04f0801          MOV      r8,#1
;;;1512   		}
0000a2  e001              B        |L34.168|
                  |L34.164|
;;;1513   		else
;;;1514   		{
;;;1515   			xReturn = pdFAIL;
0000a4  f04f0800          MOV      r8,#0
                  |L34.168|
;;;1516   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1517   		}
;;;1518   	}
;;;1519   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000a8  bf00              NOP      
0000aa  f3858811          MSR      BASEPRI,r5
0000ae  bf00              NOP      
;;;1520   
;;;1521   	return xReturn;
0000b0  4640              MOV      r0,r8
;;;1522   }
0000b2  e8bd9ff0          POP      {r4-r12,pc}
;;;1523   /*-----------------------------------------------------------*/
                          ENDP

0000b6  0000              DCW      0x0000
                  |L34.184|
0000b8  2e2e5c46          DCB      "..\\FreeRTOS\\queue.c",0
0000bc  72656552
0000c0  544f535c
0000c4  71756575
0000c8  652e6300
                  |L34.204|
0000cc  4572726f          DCB      "Error:%s,%d\r\n",0
0000d0  723a2573
0000d4  2c25640d
0000d8  0a00    
0000da  00                DCB      0
0000db  00                DCB      0

                          AREA ||i.xQueueRemoveFromSet||, CODE, READONLY, ALIGN=1

                  xQueueRemoveFromSet PROC
;;;2440   
;;;2441   	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2442   	{
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;2443   	BaseType_t xReturn;
;;;2444   	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
000008  462e              MOV      r6,r5
;;;2445   
;;;2446   		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
00000a  6cb0              LDR      r0,[r6,#0x48]
00000c  42b8              CMP      r0,r7
00000e  d001              BEQ      |L35.20|
;;;2447   		{
;;;2448   			/* The queue was not a member of the set. */
;;;2449   			xReturn = pdFAIL;
000010  2400              MOVS     r4,#0
000012  e00a              B        |L35.42|
                  |L35.20|
;;;2450   		}
;;;2451   		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
000014  6bb0              LDR      r0,[r6,#0x38]
000016  b108              CBZ      r0,|L35.28|
;;;2452   		{
;;;2453   			/* It is dangerous to remove a queue from a set when the queue is
;;;2454   			not empty because the queue set will still hold pending events for
;;;2455   			the queue. */
;;;2456   			xReturn = pdFAIL;
000018  2400              MOVS     r4,#0
00001a  e006              B        |L35.42|
                  |L35.28|
;;;2457   		}
;;;2458   		else
;;;2459   		{
;;;2460   			taskENTER_CRITICAL();
00001c  f7fffffe          BL       vPortEnterCritical
;;;2461   			{
;;;2462   				/* The queue is no longer contained in the set. */
;;;2463   				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
000020  2000              MOVS     r0,#0
000022  64b0              STR      r0,[r6,#0x48]
;;;2464   			}
;;;2465   			taskEXIT_CRITICAL();
000024  f7fffffe          BL       vPortExitCritical
;;;2466   			xReturn = pdPASS;
000028  2401              MOVS     r4,#1
                  |L35.42|
;;;2467   		}
;;;2468   
;;;2469   		return xReturn;
00002a  4620              MOV      r0,r4
;;;2470   	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
00002c  e8bd81f0          POP      {r4-r8,pc}
;;;2471   
                          ENDP


                          AREA ||i.xQueueSelectFromSet||, CODE, READONLY, ALIGN=1

                  xQueueSelectFromSet PROC
;;;2476   
;;;2477   	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )
000000  b538              PUSH     {r3-r5,lr}
;;;2478   	{
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;2479   	QueueSetMemberHandle_t xReturn = NULL;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;2480   
;;;2481   		( void ) xQueueGenericReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait, pdFALSE ); /*lint !e961 Casting from one typedef to another is not redundant. */
00000a  2300              MOVS     r3,#0
00000c  4622              MOV      r2,r4
00000e  4669              MOV      r1,sp
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       xQueueGenericReceive
;;;2482   		return xReturn;
000016  9800              LDR      r0,[sp,#0]
;;;2483   	}
000018  bd38              POP      {r3-r5,pc}
;;;2484   
                          ENDP


                          AREA ||i.xQueueSelectFromSetFromISR||, CODE, READONLY, ALIGN=1

                  xQueueSelectFromSetFromISR PROC
;;;2489   
;;;2490   	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
000000  b538              PUSH     {r3-r5,lr}
;;;2491   	{
000002  4604              MOV      r4,r0
;;;2492   	QueueSetMemberHandle_t xReturn = NULL;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;2493   
;;;2494   		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
000008  2200              MOVS     r2,#0
00000a  4669              MOV      r1,sp
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       xQueueReceiveFromISR
;;;2495   		return xReturn;
000012  9800              LDR      r0,[sp,#0]
;;;2496   	}
000014  bd38              POP      {r3-r5,pc}
;;;2497   
                          ENDP


                          AREA ||i.xQueueTakeMutexRecursive||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  xQueueTakeMutexRecursive PROC
;;;626    
;;;627    	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;628    	{
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;629    	BaseType_t xReturn;
;;;630    	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
000008  4634              MOV      r4,r6
;;;631    
;;;632    		configASSERT( pxMutex );
00000a  b92c              CBNZ     r4,|L38.24|
00000c  f44f721e          MOV      r2,#0x278
000010  a10d              ADR      r1,|L38.72|
000012  a012              ADR      r0,|L38.92|
000014  f7fffffe          BL       __2printf
                  |L38.24|
;;;633    
;;;634    		/* Comments regarding mutual exclusion as per those within
;;;635    		xQueueGiveMutexRecursive(). */
;;;636    
;;;637    		traceTAKE_MUTEX_RECURSIVE( pxMutex );
;;;638    
;;;639    		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
000018  f7fffffe          BL       xTaskGetCurrentTaskHandle
00001c  6861              LDR      r1,[r4,#4]
00001e  4288              CMP      r0,r1
000020  d104              BNE      |L38.44|
;;;640    		{
;;;641    			( pxMutex->u.uxRecursiveCallCount )++;
000022  68e0              LDR      r0,[r4,#0xc]
000024  1c40              ADDS     r0,r0,#1
000026  60e0              STR      r0,[r4,#0xc]
;;;642    			xReturn = pdPASS;
000028  2501              MOVS     r5,#1
00002a  e00a              B        |L38.66|
                  |L38.44|
;;;643    		}
;;;644    		else
;;;645    		{
;;;646    			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
00002c  2300              MOVS     r3,#0
00002e  463a              MOV      r2,r7
000030  4619              MOV      r1,r3
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       xQueueGenericReceive
000038  4605              MOV      r5,r0
;;;647    
;;;648    			/* pdPASS will only be returned if the mutex was successfully
;;;649    			obtained.  The calling task may have entered the Blocked state
;;;650    			before reaching here. */
;;;651    			if( xReturn != pdFAIL )
00003a  b115              CBZ      r5,|L38.66|
;;;652    			{
;;;653    				( pxMutex->u.uxRecursiveCallCount )++;
00003c  68e0              LDR      r0,[r4,#0xc]
00003e  1c40              ADDS     r0,r0,#1
000040  60e0              STR      r0,[r4,#0xc]
                  |L38.66|
;;;654    			}
;;;655    			else
;;;656    			{
;;;657    				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
;;;658    			}
;;;659    		}
;;;660    
;;;661    		return xReturn;
000042  4628              MOV      r0,r5
;;;662    	}
000044  e8bd81f0          POP      {r4-r8,pc}
;;;663    
                          ENDP

                  |L38.72|
000048  2e2e5c46          DCB      "..\\FreeRTOS\\queue.c",0
00004c  72656552
000050  544f535c
000054  71756575
000058  652e6300
                  |L38.92|
00005c  4572726f          DCB      "Error:%s,%d\r\n",0
000060  723a2573
000064  2c25640d
000068  0a00    
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  xQueueRegistry
                          %        64
