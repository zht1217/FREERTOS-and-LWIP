; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\ip_frag.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\ip_frag.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\ip_frag.crf ..\LWIP\lwip-1.4.1\src\core\ipv4\ip_frag.c]
                          THUMB

                          AREA ||i.ip_frag||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  ip_frag PROC
;;;666    err_t 
;;;667    ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;668    {
000004  b08c              SUB      sp,sp,#0x30
000006  4604              MOV      r4,r0
000008  4689              MOV      r9,r1
;;;669      struct pbuf *rambuf;
;;;670    #if IP_FRAG_USES_STATIC_BUF
;;;671      struct pbuf *header;
;;;672    #else
;;;673    #if !LWIP_NETIF_TX_SINGLE_PBUF
;;;674      struct pbuf *newpbuf;
;;;675    #endif
;;;676      struct ip_hdr *original_iphdr;
;;;677    #endif
;;;678      struct ip_hdr *iphdr;
;;;679      u16_t nfb;
;;;680      u16_t left, cop;
;;;681      u16_t mtu = netif->mtu;
00000a  f8b90024          LDRH     r0,[r9,#0x24]
00000e  9008              STR      r0,[sp,#0x20]
;;;682      u16_t ofo, omf;
;;;683      u16_t last;
;;;684      u16_t poff = IP_HLEN;
000010  2014              MOVS     r0,#0x14
000012  9004              STR      r0,[sp,#0x10]
;;;685      u16_t tmp;
;;;686    #if !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF
;;;687      u16_t newpbuflen = 0;
000014  f04f0800          MOV      r8,#0
;;;688      u16_t left_to_copy;
;;;689    #endif
;;;690    
;;;691      /* Get a RAM based MTU sized pbuf */
;;;692    #if IP_FRAG_USES_STATIC_BUF
;;;693      /* When using a static buffer, we use a PBUF_REF, which we will
;;;694       * use to reference the packet (without link header).
;;;695       * Layer and length is irrelevant.
;;;696       */
;;;697      rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
;;;698      if (rambuf == NULL) {
;;;699        LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
;;;700        return ERR_MEM;
;;;701      }
;;;702      rambuf->tot_len = rambuf->len = mtu;
;;;703      rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
;;;704    
;;;705      /* Copy the IP header in it */
;;;706      iphdr = (struct ip_hdr *)rambuf->payload;
;;;707      SMEMCPY(iphdr, p->payload, IP_HLEN);
;;;708    #else /* IP_FRAG_USES_STATIC_BUF */
;;;709      original_iphdr = (struct ip_hdr *)p->payload;
000018  6860              LDR      r0,[r4,#4]
00001a  900b              STR      r0,[sp,#0x2c]
;;;710      iphdr = original_iphdr;
00001c  9e0b              LDR      r6,[sp,#0x2c]
;;;711    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;712    
;;;713      /* Save original offset */
;;;714      tmp = ntohs(IPH_OFFSET(iphdr));
00001e  88f0              LDRH     r0,[r6,#6]
000020  f7fffffe          BL       lwip_ntohs
000024  9003              STR      r0,[sp,#0xc]
;;;715      ofo = tmp & IP_OFFMASK;
000026  9803              LDR      r0,[sp,#0xc]
000028  f3c0000c          UBFX     r0,r0,#0,#13
00002c  9007              STR      r0,[sp,#0x1c]
;;;716      omf = tmp & IP_MF;
00002e  9803              LDR      r0,[sp,#0xc]
000030  f4005000          AND      r0,r0,#0x2000
000034  9006              STR      r0,[sp,#0x18]
;;;717    
;;;718      left = p->tot_len - IP_HLEN;
000036  8920              LDRH     r0,[r4,#8]
000038  3814              SUBS     r0,r0,#0x14
00003a  b280              UXTH     r0,r0
00003c  9009              STR      r0,[sp,#0x24]
;;;719    
;;;720      nfb = (mtu - IP_HLEN) / 8;
00003e  9908              LDR      r1,[sp,#0x20]
000040  f1a10014          SUB      r0,r1,#0x14
000044  17c1              ASRS     r1,r0,#31
000046  eb007151          ADD      r1,r0,r1,LSR #29
00004a  f3c101cf          UBFX     r1,r1,#3,#16
00004e  910a              STR      r1,[sp,#0x28]
;;;721    
;;;722      while (left) {
000050  e0b0              B        |L1.436|
                  |L1.82|
;;;723        last = (left <= mtu - IP_HLEN);
000052  9808              LDR      r0,[sp,#0x20]
000054  3814              SUBS     r0,r0,#0x14
000056  9909              LDR      r1,[sp,#0x24]
000058  4288              CMP      r0,r1
00005a  db01              BLT      |L1.96|
00005c  2001              MOVS     r0,#1
00005e  e000              B        |L1.98|
                  |L1.96|
000060  2000              MOVS     r0,#0
                  |L1.98|
000062  9005              STR      r0,[sp,#0x14]
;;;724    
;;;725        /* Set new offset and MF flag */
;;;726        tmp = omf | (IP_OFFMASK & (ofo));
000064  9807              LDR      r0,[sp,#0x1c]
000066  f3c0000c          UBFX     r0,r0,#0,#13
00006a  9906              LDR      r1,[sp,#0x18]
00006c  4308              ORRS     r0,r0,r1
00006e  9003              STR      r0,[sp,#0xc]
;;;727        if (!last) {
000070  9805              LDR      r0,[sp,#0x14]
000072  b918              CBNZ     r0,|L1.124|
;;;728          tmp = tmp | IP_MF;
000074  9803              LDR      r0,[sp,#0xc]
000076  f4405000          ORR      r0,r0,#0x2000
00007a  9003              STR      r0,[sp,#0xc]
                  |L1.124|
;;;729        }
;;;730    
;;;731        /* Fill this fragment */
;;;732        cop = last ? left : nfb * 8;
00007c  9805              LDR      r0,[sp,#0x14]
00007e  b108              CBZ      r0,|L1.132|
000080  9809              LDR      r0,[sp,#0x24]
000082  e001              B        |L1.136|
                  |L1.132|
000084  980a              LDR      r0,[sp,#0x28]
000086  00c0              LSLS     r0,r0,#3
                  |L1.136|
000088  fa1ffb80          UXTH     r11,r0
;;;733    
;;;734    #if IP_FRAG_USES_STATIC_BUF
;;;735        poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
;;;736    #else /* IP_FRAG_USES_STATIC_BUF */
;;;737    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;738        rambuf = pbuf_alloc(PBUF_IP, cop, PBUF_RAM);
;;;739        if (rambuf == NULL) {
;;;740          return ERR_MEM;
;;;741        }
;;;742        LWIP_ASSERT("this needs a pbuf in one piece!",
;;;743          (rambuf->len == rambuf->tot_len) && (rambuf->next == NULL));
;;;744        poff += pbuf_copy_partial(p, rambuf->payload, cop, poff);
;;;745        /* make room for the IP header */
;;;746        if(pbuf_header(rambuf, IP_HLEN)) {
;;;747          pbuf_free(rambuf);
;;;748          return ERR_MEM;
;;;749        }
;;;750        /* fill in the IP header */
;;;751        SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
;;;752        iphdr = rambuf->payload;
;;;753    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;754        /* When not using a static buffer, create a chain of pbufs.
;;;755         * The first will be a PBUF_RAM holding the link and IP header.
;;;756         * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
;;;757         * but limited to the size of an mtu.
;;;758         */
;;;759        rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
00008c  2200              MOVS     r2,#0
00008e  2114              MOVS     r1,#0x14
000090  2002              MOVS     r0,#2
000092  f7fffffe          BL       pbuf_alloc
000096  4605              MOV      r5,r0
;;;760        if (rambuf == NULL) {
000098  b925              CBNZ     r5,|L1.164|
;;;761          return ERR_MEM;
00009a  f04f30ff          MOV      r0,#0xffffffff
                  |L1.158|
;;;762        }
;;;763        LWIP_ASSERT("this needs a pbuf in one piece!",
;;;764                    (p->len >= (IP_HLEN)));
;;;765        SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
;;;766        iphdr = (struct ip_hdr *)rambuf->payload;
;;;767    
;;;768        /* Can just adjust p directly for needed offset. */
;;;769        p->payload = (u8_t *)p->payload + poff;
;;;770        p->len -= poff;
;;;771    
;;;772        left_to_copy = cop;
;;;773        while (left_to_copy) {
;;;774          struct pbuf_custom_ref *pcr;
;;;775          newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
;;;776          /* Is this pbuf already empty? */
;;;777          if (!newpbuflen) {
;;;778            p = p->next;
;;;779            continue;
;;;780          }
;;;781          pcr = ip_frag_alloc_pbuf_custom_ref();
;;;782          if (pcr == NULL) {
;;;783            pbuf_free(rambuf);
;;;784            return ERR_MEM;
;;;785          }
;;;786          /* Mirror this pbuf, although we might not need all of it. */
;;;787          newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
;;;788          if (newpbuf == NULL) {
;;;789            ip_frag_free_pbuf_custom_ref(pcr);
;;;790            pbuf_free(rambuf);
;;;791            return ERR_MEM;
;;;792          }
;;;793          pbuf_ref(p);
;;;794          pcr->original = p;
;;;795          pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
;;;796    
;;;797          /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
;;;798           * so that it is removed when pbuf_dechain is later called on rambuf.
;;;799           */
;;;800          pbuf_cat(rambuf, newpbuf);
;;;801          left_to_copy -= newpbuflen;
;;;802          if (left_to_copy) {
;;;803            p = p->next;
;;;804          }
;;;805        }
;;;806        poff = newpbuflen;
;;;807    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;808    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;809    
;;;810        /* Correct header */
;;;811        IPH_OFFSET_SET(iphdr, htons(tmp));
;;;812        IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
;;;813        IPH_CHKSUM_SET(iphdr, 0);
;;;814        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
;;;815    
;;;816    #if IP_FRAG_USES_STATIC_BUF
;;;817        if (last) {
;;;818          pbuf_realloc(rambuf, left + IP_HLEN);
;;;819        }
;;;820    
;;;821        /* This part is ugly: we alloc a RAM based pbuf for 
;;;822         * the link level header for each chunk and then 
;;;823         * free it.A PBUF_ROM style pbuf for which pbuf_header
;;;824         * worked would make things simpler.
;;;825         */
;;;826        header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
;;;827        if (header != NULL) {
;;;828          pbuf_chain(header, rambuf);
;;;829          netif->output(netif, header, dest);
;;;830          IPFRAG_STATS_INC(ip_frag.xmit);
;;;831          snmp_inc_ipfragcreates();
;;;832          pbuf_free(header);
;;;833        } else {
;;;834          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
;;;835          pbuf_free(rambuf);
;;;836          return ERR_MEM;
;;;837        }
;;;838    #else /* IP_FRAG_USES_STATIC_BUF */
;;;839        /* No need for separate header pbuf - we allowed room for it in rambuf
;;;840         * when allocated.
;;;841         */
;;;842        netif->output(netif, rambuf, dest);
;;;843        IPFRAG_STATS_INC(ip_frag.xmit);
;;;844    
;;;845        /* Unfortunately we can't reuse rambuf - the hardware may still be
;;;846         * using the buffer. Instead we free it (and the ensuing chain) and
;;;847         * recreate it next time round the loop. If we're lucky the hardware
;;;848         * will have already sent the packet, the free will really free, and
;;;849         * there will be zero memory penalty.
;;;850         */
;;;851        
;;;852        pbuf_free(rambuf);
;;;853    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;854        left -= cop;
;;;855        ofo += nfb;
;;;856      }
;;;857    #if IP_FRAG_USES_STATIC_BUF
;;;858      pbuf_free(rambuf);
;;;859    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;860      snmp_inc_ipfragoks();
;;;861      return ERR_OK;
;;;862    }
00009e  b00f              ADD      sp,sp,#0x3c
0000a0  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.164|
0000a4  bf00              NOP                            ;763
0000a6  8960              LDRH     r0,[r4,#0xa]          ;763
0000a8  2814              CMP      r0,#0x14              ;763
0000aa  da08              BGE      |L1.190|
0000ac  bf00              NOP                            ;763
0000ae  a344              ADR      r3,|L1.448|
0000b0  f24022fb          MOV      r2,#0x2fb             ;763
0000b4  a14d              ADR      r1,|L1.492|
0000b6  a055              ADR      r0,|L1.524|
0000b8  f7fffffe          BL       __2printf
0000bc  bf00              NOP                            ;763
                  |L1.190|
0000be  bf00              NOP                            ;763
0000c0  2214              MOVS     r2,#0x14              ;765
0000c2  6868              LDR      r0,[r5,#4]            ;765
0000c4  990b              LDR      r1,[sp,#0x2c]         ;765
0000c6  f7fffffe          BL       __aeabi_memcpy
0000ca  686e              LDR      r6,[r5,#4]            ;766
0000cc  6861              LDR      r1,[r4,#4]            ;769
0000ce  9804              LDR      r0,[sp,#0x10]         ;769
0000d0  4408              ADD      r0,r0,r1              ;769
0000d2  6060              STR      r0,[r4,#4]            ;769
0000d4  8961              LDRH     r1,[r4,#0xa]          ;770
0000d6  9804              LDR      r0,[sp,#0x10]         ;770
0000d8  1a08              SUBS     r0,r1,r0              ;770
0000da  8160              STRH     r0,[r4,#0xa]          ;770
0000dc  f8cdb008          STR      r11,[sp,#8]           ;772
0000e0  e03f              B        |L1.354|
                  |L1.226|
0000e2  8961              LDRH     r1,[r4,#0xa]          ;775
0000e4  9802              LDR      r0,[sp,#8]            ;775
0000e6  4281              CMP      r1,r0                 ;775
0000e8  dd01              BLE      |L1.238|
0000ea  9802              LDR      r0,[sp,#8]            ;775
0000ec  e000              B        |L1.240|
                  |L1.238|
0000ee  8960              LDRH     r0,[r4,#0xa]          ;775
                  |L1.240|
0000f0  4680              MOV      r8,r0                 ;775
0000f2  f1b80f00          CMP      r8,#0                 ;777
0000f6  d101              BNE      |L1.252|
0000f8  6824              LDR      r4,[r4,#0]            ;778
0000fa  e032              B        |L1.354|
                  |L1.252|
0000fc  f7fffffe          BL       ip_frag_alloc_pbuf_custom_ref
000100  4607              MOV      r7,r0                 ;781
000102  b92f              CBNZ     r7,|L1.272|
000104  4628              MOV      r0,r5                 ;783
000106  f7fffffe          BL       pbuf_free
00010a  f04f30ff          MOV      r0,#0xffffffff        ;784
00010e  e7c6              B        |L1.158|
                  |L1.272|
000110  6860              LDR      r0,[r4,#4]            ;787
000112  463b              MOV      r3,r7                 ;787
000114  2202              MOVS     r2,#2                 ;787
000116  4641              MOV      r1,r8                 ;787
000118  e9cd0800          STRD     r0,r8,[sp,#0]         ;787
00011c  2003              MOVS     r0,#3                 ;787
00011e  f7fffffe          BL       pbuf_alloced_custom
000122  4682              MOV      r10,r0                ;787
000124  f1ba0f00          CMP      r10,#0                ;788
000128  d108              BNE      |L1.316|
00012a  4638              MOV      r0,r7                 ;789
00012c  f7fffffe          BL       ip_frag_free_pbuf_custom_ref
000130  4628              MOV      r0,r5                 ;790
000132  f7fffffe          BL       pbuf_free
000136  f04f30ff          MOV      r0,#0xffffffff        ;791
00013a  e7b0              B        |L1.158|
                  |L1.316|
00013c  4620              MOV      r0,r4                 ;793
00013e  f7fffffe          BL       pbuf_ref
000142  617c              STR      r4,[r7,#0x14]         ;794
000144  483c              LDR      r0,|L1.568|
000146  6138              STR      r0,[r7,#0x10]         ;795
000148  4651              MOV      r1,r10                ;800
00014a  4628              MOV      r0,r5                 ;800
00014c  f7fffffe          BL       pbuf_cat
000150  9802              LDR      r0,[sp,#8]            ;801
000152  eba00008          SUB      r0,r0,r8              ;801
000156  b280              UXTH     r0,r0                 ;801
000158  9002              STR      r0,[sp,#8]            ;801
00015a  9802              LDR      r0,[sp,#8]            ;802
00015c  b100              CBZ      r0,|L1.352|
00015e  6824              LDR      r4,[r4,#0]            ;803
                  |L1.352|
000160  bf00              NOP                            ;779
                  |L1.354|
000162  9802              LDR      r0,[sp,#8]            ;773
000164  2800              CMP      r0,#0                 ;773
000166  d1bc              BNE      |L1.226|
000168  f8cd8010          STR      r8,[sp,#0x10]         ;806
00016c  9803              LDR      r0,[sp,#0xc]          ;811
00016e  f7fffffe          BL       lwip_htons
000172  80f0              STRH     r0,[r6,#6]            ;811
000174  f10b0114          ADD      r1,r11,#0x14          ;812
000178  b288              UXTH     r0,r1                 ;812
00017a  f7fffffe          BL       lwip_htons
00017e  8070              STRH     r0,[r6,#2]            ;812
000180  2000              MOVS     r0,#0                 ;813
000182  8170              STRH     r0,[r6,#0xa]          ;813
000184  2114              MOVS     r1,#0x14              ;814
000186  4630              MOV      r0,r6                 ;814
000188  f7fffffe          BL       inet_chksum
00018c  8170              STRH     r0,[r6,#0xa]          ;814
00018e  f8d93014          LDR      r3,[r9,#0x14]         ;842
000192  4629              MOV      r1,r5                 ;842
000194  4648              MOV      r0,r9                 ;842
000196  9a0e              LDR      r2,[sp,#0x38]         ;842
000198  4798              BLX      r3                    ;842
00019a  4628              MOV      r0,r5                 ;852
00019c  f7fffffe          BL       pbuf_free
0001a0  9809              LDR      r0,[sp,#0x24]         ;854
0001a2  eba0000b          SUB      r0,r0,r11             ;854
0001a6  b280              UXTH     r0,r0                 ;854
0001a8  9009              STR      r0,[sp,#0x24]         ;854
0001aa  990a              LDR      r1,[sp,#0x28]         ;855
0001ac  9807              LDR      r0,[sp,#0x1c]         ;855
0001ae  4408              ADD      r0,r0,r1              ;855
0001b0  b280              UXTH     r0,r0                 ;855
0001b2  9007              STR      r0,[sp,#0x1c]         ;855
                  |L1.436|
0001b4  9809              LDR      r0,[sp,#0x24]         ;722
0001b6  2800              CMP      r0,#0                 ;722
0001b8  f47faf4b          BNE      |L1.82|
0001bc  bf00              NOP                            ;861
0001be  e76e              B        |L1.158|
;;;863    #endif /* IP_FRAG */
                          ENDP

                  |L1.448|
0001c0  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\ipv4\\ip_frag.c",0
0001c4  5749505c
0001c8  6c776970
0001cc  2d312e34
0001d0  2e315c73
0001d4  72635c63
0001d8  6f72655c
0001dc  69707634
0001e0  5c69705f
0001e4  66726167
0001e8  2e6300  
0001eb  00                DCB      0
                  |L1.492|
0001ec  74686973          DCB      "this needs a pbuf in one piece!",0
0001f0  206e6565
0001f4  64732061
0001f8  20706275
0001fc  6620696e
000200  206f6e65
000204  20706965
000208  63652100
                  |L1.524|
00020c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000210  7274696f
000214  6e202225
000218  73222066
00021c  61696c65
000220  64206174
000224  206c696e
000228  65202564
00022c  20696e20
000230  25730d0a
000234  00      
000235  00                DCB      0
000236  00                DCB      0
000237  00                DCB      0
                  |L1.568|
                          DCD      ipfrag_free_pbuf_custom

                          AREA ||i.ip_frag_alloc_pbuf_custom_ref||, CODE, READONLY, ALIGN=1

                  ip_frag_alloc_pbuf_custom_ref PROC
;;;623    static struct pbuf_custom_ref*
;;;624    ip_frag_alloc_pbuf_custom_ref(void)
000000  b510              PUSH     {r4,lr}
;;;625    {
;;;626      return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
000002  2006              MOVS     r0,#6
000004  f7fffffe          BL       memp_malloc
;;;627    }
000008  bd10              POP      {r4,pc}
;;;628    
                          ENDP


                          AREA ||i.ip_frag_free_pbuf_custom_ref||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  ip_frag_free_pbuf_custom_ref PROC
;;;630    static void
;;;631    ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
000000  b510              PUSH     {r4,lr}
;;;632    {
000002  4604              MOV      r4,r0
;;;633      LWIP_ASSERT("p != NULL", p != NULL);
000004  bf00              NOP      
000006  b944              CBNZ     r4,|L3.26|
000008  bf00              NOP      
00000a  a307              ADR      r3,|L3.40|
00000c  f2402279          MOV      r2,#0x279
000010  a110              ADR      r1,|L3.84|
000012  a013              ADR      r0,|L3.96|
000014  f7fffffe          BL       __2printf
000018  bf00              NOP      
                  |L3.26|
00001a  bf00              NOP      
;;;634      memp_free(MEMP_FRAG_PBUF, p);
00001c  4621              MOV      r1,r4
00001e  2006              MOVS     r0,#6
000020  f7fffffe          BL       memp_free
;;;635    }
000024  bd10              POP      {r4,pc}
;;;636    
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
000028  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\ipv4\\ip_frag.c",0
00002c  5749505c
000030  6c776970
000034  2d312e34
000038  2e315c73
00003c  72635c63
000040  6f72655c
000044  69707634
000048  5c69705f
00004c  66726167
000050  2e6300  
000053  00                DCB      0
                  |L3.84|
000054  7020213d          DCB      "p != NULL",0
000058  204e554c
00005c  4c00    
00005e  00                DCB      0
00005f  00                DCB      0
                  |L3.96|
000060  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000064  7274696f
000068  6e202225
00006c  73222066
000070  61696c65
000074  64206174
000078  206c696e
00007c  65202564
000080  20696e20
000084  25730d0a
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.ip_reass||, CODE, READONLY, ALIGN=2

                  ip_reass PROC
;;;475    struct pbuf *
;;;476    ip_reass(struct pbuf *p)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;477    {
000004  4680              MOV      r8,r0
;;;478      struct pbuf *r;
;;;479      struct ip_hdr *fraghdr;
;;;480      struct ip_reassdata *ipr;
;;;481      struct ip_reass_helper *iprh;
;;;482      u16_t offset, len;
;;;483      u8_t clen;
;;;484      struct ip_reassdata *ipr_prev = NULL;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;485    
;;;486      IPFRAG_STATS_INC(ip_frag.recv);
;;;487      snmp_inc_ipreasmreqds();
;;;488    
;;;489      fraghdr = (struct ip_hdr*)p->payload;
00000a  f8d85004          LDR      r5,[r8,#4]
;;;490    
;;;491      if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
00000e  7828              LDRB     r0,[r5,#0]
000010  f000000f          AND      r0,r0,#0xf
000014  2114              MOVS     r1,#0x14
000016  ebb10f80          CMP      r1,r0,LSL #2
00001a  d002              BEQ      |L4.34|
;;;492        LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
00001c  bf00              NOP      
00001e  bf00              NOP      
;;;493        IPFRAG_STATS_INC(ip_frag.err);
;;;494        goto nullreturn;
000020  e0b4              B        |L4.396|
                  |L4.34|
;;;495      }
;;;496    
;;;497      offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
000022  88e8              LDRH     r0,[r5,#6]
000024  f7fffffe          BL       lwip_ntohs
000028  f3c0000c          UBFX     r0,r0,#0,#13
00002c  f64f71ff          MOV      r1,#0xffff
000030  ea010ac0          AND      r10,r1,r0,LSL #3
;;;498      len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
000034  8868              LDRH     r0,[r5,#2]
000036  f7fffffe          BL       lwip_ntohs
00003a  7829              LDRB     r1,[r5,#0]
00003c  f001010f          AND      r1,r1,#0xf
000040  eba00081          SUB      r0,r0,r1,LSL #2
000044  fa1ffb80          UXTH     r11,r0
;;;499    
;;;500      /* Check if we are allowed to enqueue more datagrams. */
;;;501      clen = pbuf_clen(p);
000048  4640              MOV      r0,r8
00004a  f7fffffe          BL       pbuf_clen
00004e  4606              MOV      r6,r0
;;;502      if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
000050  4852              LDR      r0,|L4.412|
000052  8801              LDRH     r1,[r0,#0]  ; ip_reass_pbufcount
000054  1988              ADDS     r0,r1,r6
000056  280a              CMP      r0,#0xa
000058  dd0c              BLE      |L4.116|
;;;503    #if IP_REASS_FREE_OLDEST
;;;504        if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
00005a  4631              MOV      r1,r6
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       ip_reass_remove_oldest_datagram
000062  b120              CBZ      r0,|L4.110|
;;;505            ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
000064  484d              LDR      r0,|L4.412|
000066  8800              LDRH     r0,[r0,#0]  ; ip_reass_pbufcount
000068  4430              ADD      r0,r0,r6
00006a  280a              CMP      r0,#0xa
00006c  dd02              BLE      |L4.116|
                  |L4.110|
;;;506    #endif /* IP_REASS_FREE_OLDEST */
;;;507        {
;;;508          /* No datagram could be freed and still too many pbufs enqueued */
;;;509          LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
00006e  bf00              NOP      
000070  bf00              NOP      
;;;510            ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
;;;511          IPFRAG_STATS_INC(ip_frag.memerr);
;;;512          /* @todo: send ICMP time exceeded here? */
;;;513          /* drop this pbuf */
;;;514          goto nullreturn;
000072  e08b              B        |L4.396|
                  |L4.116|
;;;515        }
;;;516      }
;;;517    
;;;518      /* Look for the datagram the fragment belongs to in the current datagram queue,
;;;519       * remembering the previous in the queue for later dequeueing. */
;;;520      for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
000074  484a              LDR      r0,|L4.416|
000076  6804              LDR      r4,[r0,#0]  ; reassdatagrams
000078  e014              B        |L4.164|
                  |L4.122|
;;;521        /* Check if the incoming fragment matches the one currently present
;;;522           in the reassembly buffer. If so, we proceed with copying the
;;;523           fragment into the buffer. */
;;;524        if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
00007a  6960              LDR      r0,[r4,#0x14]
00007c  68e9              LDR      r1,[r5,#0xc]
00007e  4288              CMP      r0,r1
000080  d109              BNE      |L4.150|
000082  69a0              LDR      r0,[r4,#0x18]
000084  6929              LDR      r1,[r5,#0x10]
000086  4288              CMP      r0,r1
000088  d105              BNE      |L4.150|
00008a  89a0              LDRH     r0,[r4,#0xc]
00008c  88a9              LDRH     r1,[r5,#4]
00008e  4288              CMP      r0,r1
000090  d101              BNE      |L4.150|
000092  2001              MOVS     r0,#1
000094  e000              B        |L4.152|
                  |L4.150|
000096  2000              MOVS     r0,#0
                  |L4.152|
000098  b110              CBZ      r0,|L4.160|
;;;525          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
00009a  bf00              NOP      
00009c  bf00              NOP      
;;;526            ntohs(IPH_ID(fraghdr))));
;;;527          IPFRAG_STATS_INC(ip_frag.cachehit);
;;;528          break;
00009e  e003              B        |L4.168|
                  |L4.160|
;;;529        }
;;;530        ipr_prev = ipr;
0000a0  9400              STR      r4,[sp,#0]
0000a2  6824              LDR      r4,[r4,#0]            ;520
                  |L4.164|
0000a4  2c00              CMP      r4,#0                 ;520
0000a6  d1e8              BNE      |L4.122|
                  |L4.168|
0000a8  bf00              NOP                            ;528
;;;531      }
;;;532    
;;;533      if (ipr == NULL) {
0000aa  b934              CBNZ     r4,|L4.186|
;;;534      /* Enqueue a new datagram into the datagram queue */
;;;535        ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
0000ac  4631              MOV      r1,r6
0000ae  4628              MOV      r0,r5
0000b0  f7fffffe          BL       ip_reass_enqueue_new_datagram
0000b4  4604              MOV      r4,r0
;;;536        /* Bail if unable to enqueue */
;;;537        if(ipr == NULL) {
0000b6  b994              CBNZ     r4,|L4.222|
;;;538          goto nullreturn;
0000b8  e068              B        |L4.396|
                  |L4.186|
;;;539        }
;;;540      } else {
;;;541        if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
0000ba  88e8              LDRH     r0,[r5,#6]
0000bc  f7fffffe          BL       lwip_ntohs
0000c0  f3c0000c          UBFX     r0,r0,#0,#13
0000c4  b958              CBNZ     r0,|L4.222|
;;;542          ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
0000c6  89e0              LDRH     r0,[r4,#0xe]
0000c8  f7fffffe          BL       lwip_ntohs
0000cc  f3c0000c          UBFX     r0,r0,#0,#13
0000d0  b128              CBZ      r0,|L4.222|
;;;543          /* ipr->iphdr is not the header from the first fragment, but fraghdr is
;;;544           * -> copy fraghdr into ipr->iphdr since we want to have the header
;;;545           * of the first fragment (for ICMP time exceeded and later, for copying
;;;546           * all options, if supported)*/
;;;547          SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
0000d2  2214              MOVS     r2,#0x14
0000d4  4629              MOV      r1,r5
0000d6  f1040008          ADD      r0,r4,#8
0000da  f7fffffe          BL       __aeabi_memcpy
                  |L4.222|
;;;548        }
;;;549      }
;;;550      /* Track the current number of pbufs current 'in-flight', in order to limit 
;;;551      the number of fragments that may be enqueued at any one time */
;;;552      ip_reass_pbufcount += clen;
0000de  482f              LDR      r0,|L4.412|
0000e0  8800              LDRH     r0,[r0,#0]  ; ip_reass_pbufcount
0000e2  4430              ADD      r0,r0,r6
0000e4  492d              LDR      r1,|L4.412|
0000e6  8008              STRH     r0,[r1,#0]
;;;553    
;;;554      /* At this point, we have either created a new entry or pointing 
;;;555       * to an existing one */
;;;556    
;;;557      /* check for 'no more fragments', and update queue entry*/
;;;558      if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
0000e8  79a8              LDRB     r0,[r5,#6]
0000ea  f0000020          AND      r0,r0,#0x20
0000ee  b940              CBNZ     r0,|L4.258|
;;;559        ipr->flags |= IP_REASS_FLAG_LASTFRAG;
0000f0  7fa0              LDRB     r0,[r4,#0x1e]
0000f2  f0400001          ORR      r0,r0,#1
0000f6  77a0              STRB     r0,[r4,#0x1e]
;;;560        ipr->datagram_len = offset + len;
0000f8  eb0a000b          ADD      r0,r10,r11
0000fc  83a0              STRH     r0,[r4,#0x1c]
;;;561        LWIP_DEBUGF(IP_REASS_DEBUG,
0000fe  bf00              NOP      
000100  bf00              NOP      
                  |L4.258|
;;;562         ("ip_reass: last fragment seen, total len %"S16_F"\n",
;;;563          ipr->datagram_len));
;;;564      }
;;;565      /* find the right place to insert this pbuf */
;;;566      /* @todo: trim pbufs if fragments are overlapping */
;;;567      if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
000102  4641              MOV      r1,r8
000104  4620              MOV      r0,r4
000106  f7fffffe          BL       ip_reass_chain_frag_into_datagram_and_validate
00010a  b3d0              CBZ      r0,|L4.386|
;;;568        /* the totally last fragment (flag more fragments = 0) was received at least
;;;569         * once AND all fragments are received */
;;;570        ipr->datagram_len += IP_HLEN;
00010c  8ba0              LDRH     r0,[r4,#0x1c]
00010e  3014              ADDS     r0,r0,#0x14
000110  83a0              STRH     r0,[r4,#0x1c]
;;;571    
;;;572        /* save the second pbuf before copying the header over the pointer */
;;;573        r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
000112  6860              LDR      r0,[r4,#4]
000114  6840              LDR      r0,[r0,#4]
000116  6807              LDR      r7,[r0,#0]
;;;574    
;;;575        /* copy the original ip header back to the first pbuf */
;;;576        fraghdr = (struct ip_hdr*)(ipr->p->payload);
000118  6860              LDR      r0,[r4,#4]
00011a  6845              LDR      r5,[r0,#4]
;;;577        SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
00011c  2214              MOVS     r2,#0x14
00011e  f1040108          ADD      r1,r4,#8
000122  4628              MOV      r0,r5
000124  f7fffffe          BL       __aeabi_memcpy
;;;578        IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
000128  8ba0              LDRH     r0,[r4,#0x1c]
00012a  f7fffffe          BL       lwip_htons
00012e  8068              STRH     r0,[r5,#2]
;;;579        IPH_OFFSET_SET(fraghdr, 0);
000130  2000              MOVS     r0,#0
000132  80e8              STRH     r0,[r5,#6]
;;;580        IPH_CHKSUM_SET(fraghdr, 0);
000134  8168              STRH     r0,[r5,#0xa]
;;;581        /* @todo: do we need to set calculate the correct checksum? */
;;;582        IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
000136  2114              MOVS     r1,#0x14
000138  4628              MOV      r0,r5
00013a  f7fffffe          BL       inet_chksum
00013e  8168              STRH     r0,[r5,#0xa]
;;;583    
;;;584        p = ipr->p;
000140  f8d48004          LDR      r8,[r4,#4]
;;;585    
;;;586        /* chain together the pbufs contained within the reass_data list. */
;;;587        while(r != NULL) {
000144  e00c              B        |L4.352|
                  |L4.326|
;;;588          iprh = (struct ip_reass_helper*)r->payload;
000146  f8d79004          LDR      r9,[r7,#4]
;;;589    
;;;590          /* hide the ip header for every succeding fragment */
;;;591          pbuf_header(r, -IP_HLEN);
00014a  f06f0113          MVN      r1,#0x13
00014e  4638              MOV      r0,r7
000150  f7fffffe          BL       pbuf_header
;;;592          pbuf_cat(p, r);
000154  4639              MOV      r1,r7
000156  4640              MOV      r0,r8
000158  f7fffffe          BL       pbuf_cat
;;;593          r = iprh->next_pbuf;
00015c  f8d97000          LDR      r7,[r9,#0]
                  |L4.352|
000160  2f00              CMP      r7,#0                 ;587
000162  d1f0              BNE      |L4.326|
;;;594        }
;;;595        /* release the sources allocate for the fragment queue entry */
;;;596        ip_reass_dequeue_datagram(ipr, ipr_prev);
000164  4620              MOV      r0,r4
000166  9900              LDR      r1,[sp,#0]
000168  f7fffffe          BL       ip_reass_dequeue_datagram
;;;597    
;;;598        /* and adjust the number of pbufs currently queued for reassembly. */
;;;599        ip_reass_pbufcount -= pbuf_clen(p);
00016c  4640              MOV      r0,r8
00016e  f7fffffe          BL       pbuf_clen
000172  490a              LDR      r1,|L4.412|
000174  8809              LDRH     r1,[r1,#0]  ; ip_reass_pbufcount
000176  1a08              SUBS     r0,r1,r0
000178  4908              LDR      r1,|L4.412|
00017a  8008              STRH     r0,[r1,#0]
;;;600    
;;;601        /* Return the pbuf chain */
;;;602        return p;
00017c  4640              MOV      r0,r8
                  |L4.382|
;;;603      }
;;;604      /* the datagram is not (yet?) reassembled completely */
;;;605      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
;;;606      return NULL;
;;;607    
;;;608    nullreturn:
;;;609      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
;;;610      IPFRAG_STATS_INC(ip_frag.drop);
;;;611      pbuf_free(p);
;;;612      return NULL;
;;;613    }
00017e  e8bd8ff8          POP      {r3-r11,pc}
                  |L4.386|
000182  e7ff              B        |L4.388|
                  |L4.388|
000184  bf00              NOP                            ;605
000186  bf00              NOP                            ;605
000188  2000              MOVS     r0,#0                 ;606
00018a  e7f8              B        |L4.382|
                  |L4.396|
00018c  bf00              NOP                            ;609
00018e  bf00              NOP                            ;609
000190  4640              MOV      r0,r8                 ;611
000192  f7fffffe          BL       pbuf_free
000196  2000              MOVS     r0,#0                 ;612
000198  e7f1              B        |L4.382|
;;;614    #endif /* IP_REASSEMBLY */
                          ENDP

00019a  0000              DCW      0x0000
                  |L4.412|
                          DCD      ip_reass_pbufcount
                  |L4.416|
                          DCD      reassdatagrams

                          AREA ||i.ip_reass_chain_frag_into_datagram_and_validate||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  ip_reass_chain_frag_into_datagram_and_validate PROC
;;;330    static int
;;;331    ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;332    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;333      struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
000008  2500              MOVS     r5,#0
;;;334      struct pbuf *q;
;;;335      u16_t offset,len;
;;;336      struct ip_hdr *fraghdr;
;;;337      int valid = 1;
00000a  f04f0b01          MOV      r11,#1
;;;338    
;;;339      /* Extract length and fragment offset from current fragment */
;;;340      fraghdr = (struct ip_hdr*)new_p->payload; 
00000e  f8d7a004          LDR      r10,[r7,#4]
;;;341      len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
000012  f8ba0002          LDRH     r0,[r10,#2]
000016  f7fffffe          BL       lwip_ntohs
00001a  f89a1000          LDRB     r1,[r10,#0]
00001e  f001010f          AND      r1,r1,#0xf
000022  eba00081          SUB      r0,r0,r1,LSL #2
000026  b280              UXTH     r0,r0
000028  9000              STR      r0,[sp,#0]
;;;342      offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
00002a  f8ba0006          LDRH     r0,[r10,#6]
00002e  f7fffffe          BL       lwip_ntohs
000032  f3c0000c          UBFX     r0,r0,#0,#13
000036  f64f71ff          MOV      r1,#0xffff
00003a  ea0100c0          AND      r0,r1,r0,LSL #3
00003e  9001              STR      r0,[sp,#4]
;;;343    
;;;344      /* overwrite the fragment's ip header from the pbuf with our helper struct,
;;;345       * and setup the embedded helper structure. */
;;;346      /* make sure the struct ip_reass_helper fits into the IP header */
;;;347      LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
000040  bf00              NOP      
000042  bf00              NOP      
;;;348                  sizeof(struct ip_reass_helper) <= IP_HLEN);
;;;349      iprh = (struct ip_reass_helper*)new_p->payload;
000044  687c              LDR      r4,[r7,#4]
;;;350      iprh->next_pbuf = NULL;
000046  2000              MOVS     r0,#0
000048  6020              STR      r0,[r4,#0]
;;;351      iprh->start = offset;
00004a  9801              LDR      r0,[sp,#4]
00004c  80a0              STRH     r0,[r4,#4]
;;;352      iprh->end = offset + len;
00004e  e9dd1000          LDRD     r1,r0,[sp,#0]
000052  4408              ADD      r0,r0,r1
000054  80e0              STRH     r0,[r4,#6]
;;;353    
;;;354      /* Iterate through until we either get to the end of the list (append),
;;;355       * or we find on with a larger offset (insert). */
;;;356      for (q = ipr->p; q != NULL;) {
000056  f8d69004          LDR      r9,[r6,#4]
00005a  e02e              B        |L5.186|
                  |L5.92|
;;;357        iprh_tmp = (struct ip_reass_helper*)q->payload;
00005c  f8d98004          LDR      r8,[r9,#4]
;;;358        if (iprh->start < iprh_tmp->start) {
000060  88a0              LDRH     r0,[r4,#4]
000062  f8b81004          LDRH     r1,[r8,#4]
000066  4288              CMP      r0,r1
000068  da10              BGE      |L5.140|
;;;359          /* the new pbuf should be inserted before this */
;;;360          iprh->next_pbuf = q;
00006a  f8c49000          STR      r9,[r4,#0]
;;;361          if (iprh_prev != NULL) {
00006e  b15d              CBZ      r5,|L5.136|
;;;362            /* not the fragment with the lowest offset */
;;;363    #if IP_REASS_CHECK_OVERLAP
;;;364            if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
000070  88a0              LDRH     r0,[r4,#4]
000072  88e9              LDRH     r1,[r5,#6]
000074  4288              CMP      r0,r1
000076  db04              BLT      |L5.130|
000078  88e0              LDRH     r0,[r4,#6]
00007a  f8b81004          LDRH     r1,[r8,#4]
00007e  4288              CMP      r0,r1
000080  dd00              BLE      |L5.132|
                  |L5.130|
;;;365              /* fragment overlaps with previous or following, throw away */
;;;366              goto freepbuf;
000082  e0ab              B        |L5.476|
                  |L5.132|
;;;367            }
;;;368    #endif /* IP_REASS_CHECK_OVERLAP */
;;;369            iprh_prev->next_pbuf = new_p;
000084  602f              STR      r7,[r5,#0]
000086  e000              B        |L5.138|
                  |L5.136|
;;;370          } else {
;;;371            /* fragment with the lowest offset */
;;;372            ipr->p = new_p;
000088  6077              STR      r7,[r6,#4]
                  |L5.138|
;;;373          }
;;;374          break;
00008a  e019              B        |L5.192|
                  |L5.140|
;;;375        } else if(iprh->start == iprh_tmp->start) {
00008c  88a0              LDRH     r0,[r4,#4]
00008e  f8b81004          LDRH     r1,[r8,#4]
000092  4288              CMP      r0,r1
000094  d100              BNE      |L5.152|
;;;376          /* received the same datagram twice: no need to keep the datagram */
;;;377          goto freepbuf;
000096  e0a1              B        |L5.476|
                  |L5.152|
;;;378    #if IP_REASS_CHECK_OVERLAP
;;;379        } else if(iprh->start < iprh_tmp->end) {
000098  88a0              LDRH     r0,[r4,#4]
00009a  f8b81006          LDRH     r1,[r8,#6]
00009e  4288              CMP      r0,r1
0000a0  da00              BGE      |L5.164|
;;;380          /* overlap: no need to keep the new datagram */
;;;381          goto freepbuf;
0000a2  e09b              B        |L5.476|
                  |L5.164|
;;;382    #endif /* IP_REASS_CHECK_OVERLAP */
;;;383        } else {
;;;384          /* Check if the fragments received so far have no wholes. */
;;;385          if (iprh_prev != NULL) {
0000a4  b135              CBZ      r5,|L5.180|
;;;386            if (iprh_prev->end != iprh_tmp->start) {
0000a6  88e8              LDRH     r0,[r5,#6]
0000a8  f8b81004          LDRH     r1,[r8,#4]
0000ac  4288              CMP      r0,r1
0000ae  d001              BEQ      |L5.180|
;;;387              /* There is a fragment missing between the current
;;;388               * and the previous fragment */
;;;389              valid = 0;
0000b0  f04f0b00          MOV      r11,#0
                  |L5.180|
;;;390            }
;;;391          }
;;;392        }
;;;393        q = iprh_tmp->next_pbuf;
0000b4  f8d89000          LDR      r9,[r8,#0]
;;;394        iprh_prev = iprh_tmp;
0000b8  4645              MOV      r5,r8
                  |L5.186|
0000ba  f1b90f00          CMP      r9,#0                 ;356
0000be  d1cd              BNE      |L5.92|
                  |L5.192|
0000c0  bf00              NOP                            ;374
;;;395      }
;;;396    
;;;397      /* If q is NULL, then we made it to the end of the list. Determine what to do now */
;;;398      if (q == NULL) {
0000c2  f1b90f00          CMP      r9,#0
0000c6  d126              BNE      |L5.278|
;;;399        if (iprh_prev != NULL) {
0000c8  2d00              CMP      r5,#0
0000ca  d016              BEQ      |L5.250|
;;;400          /* this is (for now), the fragment with the highest offset:
;;;401           * chain it to the last fragment */
;;;402    #if IP_REASS_CHECK_OVERLAP
;;;403          LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
0000cc  bf00              NOP      
0000ce  88e8              LDRH     r0,[r5,#6]
0000d0  88a1              LDRH     r1,[r4,#4]
0000d2  4288              CMP      r0,r1
0000d4  dd08              BLE      |L5.232|
0000d6  bf00              NOP      
0000d8  a347              ADR      r3,|L5.504|
0000da  f2401293          MOV      r2,#0x193
0000de  a151              ADR      r1,|L5.548|
0000e0  a058              ADR      r0,|L5.580|
0000e2  f7fffffe          BL       __2printf
0000e6  bf00              NOP      
                  |L5.232|
0000e8  bf00              NOP      
;;;404    #endif /* IP_REASS_CHECK_OVERLAP */
;;;405          iprh_prev->next_pbuf = new_p;
0000ea  602f              STR      r7,[r5,#0]
;;;406          if (iprh_prev->end != iprh->start) {
0000ec  88e8              LDRH     r0,[r5,#6]
0000ee  88a1              LDRH     r1,[r4,#4]
0000f0  4288              CMP      r0,r1
0000f2  d010              BEQ      |L5.278|
;;;407            valid = 0;
0000f4  f04f0b00          MOV      r11,#0
0000f8  e00d              B        |L5.278|
                  |L5.250|
;;;408          }
;;;409        } else {
;;;410    #if IP_REASS_CHECK_OVERLAP
;;;411          LWIP_ASSERT("no previous fragment, this must be the first fragment!",
0000fa  bf00              NOP      
0000fc  6870              LDR      r0,[r6,#4]
0000fe  b140              CBZ      r0,|L5.274|
000100  bf00              NOP      
000102  a33d              ADR      r3,|L5.504|
000104  f240129b          MOV      r2,#0x19b
000108  a159              ADR      r1,|L5.624|
00010a  a04e              ADR      r0,|L5.580|
00010c  f7fffffe          BL       __2printf
000110  bf00              NOP      
                  |L5.274|
000112  bf00              NOP      
;;;412            ipr->p == NULL);
;;;413    #endif /* IP_REASS_CHECK_OVERLAP */
;;;414          /* this is the first fragment we ever received for this ip datagram */
;;;415          ipr->p = new_p;
000114  6077              STR      r7,[r6,#4]
                  |L5.278|
;;;416        }
;;;417      }
;;;418    
;;;419      /* At this point, the validation part begins: */
;;;420      /* If we already received the last fragment */
;;;421      if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
000116  7fb0              LDRB     r0,[r6,#0x1e]
000118  f0000001          AND      r0,r0,#1
00011c  2800              CMP      r0,#0
00011e  d05b              BEQ      |L5.472|
;;;422        /* and had no wholes so far */
;;;423        if (valid) {
000120  f1bb0f00          CMP      r11,#0
000124  d055              BEQ      |L5.466|
;;;424          /* then check if the rest of the fragments is here */
;;;425          /* Check if the queue starts with the first datagram */
;;;426          if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
000126  6870              LDR      r0,[r6,#4]
000128  6840              LDR      r0,[r0,#4]
00012a  8880              LDRH     r0,[r0,#4]
00012c  b110              CBZ      r0,|L5.308|
;;;427            valid = 0;
00012e  f04f0b00          MOV      r11,#0
000132  e04e              B        |L5.466|
                  |L5.308|
;;;428          } else {
;;;429            /* and check that there are no wholes after this datagram */
;;;430            iprh_prev = iprh;
000134  4625              MOV      r5,r4
;;;431            q = iprh->next_pbuf;
000136  f8d49000          LDR      r9,[r4,#0]
;;;432            while (q != NULL) {
00013a  e00b              B        |L5.340|
                  |L5.316|
;;;433              iprh = (struct ip_reass_helper*)q->payload;
00013c  f8d94004          LDR      r4,[r9,#4]
;;;434              if (iprh_prev->end != iprh->start) {
000140  88e8              LDRH     r0,[r5,#6]
000142  88a1              LDRH     r1,[r4,#4]
000144  4288              CMP      r0,r1
000146  d002              BEQ      |L5.334|
;;;435                valid = 0;
000148  f04f0b00          MOV      r11,#0
;;;436                break;
00014c  e005              B        |L5.346|
                  |L5.334|
;;;437              }
;;;438              iprh_prev = iprh;
00014e  4625              MOV      r5,r4
;;;439              q = iprh->next_pbuf;
000150  f8d49000          LDR      r9,[r4,#0]
                  |L5.340|
000154  f1b90f00          CMP      r9,#0                 ;432
000158  d1f0              BNE      |L5.316|
                  |L5.346|
00015a  bf00              NOP                            ;436
;;;440            }
;;;441            /* if still valid, all fragments are received
;;;442             * (because to the MF==0 already arrived */
;;;443            if (valid) {
00015c  f1bb0f00          CMP      r11,#0
000160  d037              BEQ      |L5.466|
;;;444              LWIP_ASSERT("sanity check", ipr->p != NULL);
000162  bf00              NOP      
000164  6870              LDR      r0,[r6,#4]
000166  b940              CBNZ     r0,|L5.378|
000168  bf00              NOP      
00016a  a323              ADR      r3,|L5.504|
00016c  f44f72de          MOV      r2,#0x1bc
000170  a14d              ADR      r1,|L5.680|
000172  a034              ADR      r0,|L5.580|
000174  f7fffffe          BL       __2printf
000178  bf00              NOP      
                  |L5.378|
00017a  bf00              NOP      
;;;445              LWIP_ASSERT("sanity check",
00017c  bf00              NOP      
00017e  6870              LDR      r0,[r6,#4]
000180  6840              LDR      r0,[r0,#4]
000182  42a0              CMP      r0,r4
000184  d108              BNE      |L5.408|
000186  bf00              NOP      
000188  a31b              ADR      r3,|L5.504|
00018a  f24012bd          MOV      r2,#0x1bd
00018e  a146              ADR      r1,|L5.680|
000190  a02c              ADR      r0,|L5.580|
000192  f7fffffe          BL       __2printf
000196  bf00              NOP      
                  |L5.408|
000198  bf00              NOP      
;;;446                ((struct ip_reass_helper*)ipr->p->payload) != iprh);
;;;447              LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
00019a  bf00              NOP      
00019c  6820              LDR      r0,[r4,#0]
00019e  b140              CBZ      r0,|L5.434|
0001a0  bf00              NOP      
0001a2  a315              ADR      r3,|L5.504|
0001a4  f24012bf          MOV      r2,#0x1bf
0001a8  a143              ADR      r1,|L5.696|
0001aa  a026              ADR      r0,|L5.580|
0001ac  f7fffffe          BL       __2printf
0001b0  bf00              NOP      
                  |L5.434|
0001b2  bf00              NOP      
;;;448                iprh->next_pbuf == NULL);
;;;449              LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
0001b4  bf00              NOP      
0001b6  88e0              LDRH     r0,[r4,#6]
0001b8  8bb1              LDRH     r1,[r6,#0x1c]
0001ba  4288              CMP      r0,r1
0001bc  d008              BEQ      |L5.464|
0001be  bf00              NOP      
0001c0  a30d              ADR      r3,|L5.504|
0001c2  f24012c1          MOV      r2,#0x1c1
0001c6  a145              ADR      r1,|L5.732|
0001c8  a01e              ADR      r0,|L5.580|
0001ca  f7fffffe          BL       __2printf
0001ce  bf00              NOP      
                  |L5.464|
0001d0  bf00              NOP      
                  |L5.466|
;;;450                iprh->end == ipr->datagram_len);
;;;451            }
;;;452          }
;;;453        }
;;;454        /* If valid is 0 here, there are some fragments missing in the middle
;;;455         * (since MF == 0 has already arrived). Such datagrams simply time out if
;;;456         * no more fragments are received... */
;;;457        return valid;
0001d2  4658              MOV      r0,r11
                  |L5.468|
;;;458      }
;;;459      /* If we come here, not all fragments were received, yet! */
;;;460      return 0; /* not yet valid! */
;;;461    #if IP_REASS_CHECK_OVERLAP
;;;462    freepbuf:
;;;463      ip_reass_pbufcount -= pbuf_clen(new_p);
;;;464      pbuf_free(new_p);
;;;465      return 0;
;;;466    #endif /* IP_REASS_CHECK_OVERLAP */
;;;467    }
0001d4  e8bd9ffc          POP      {r2-r12,pc}
                  |L5.472|
0001d8  2000              MOVS     r0,#0                 ;460
0001da  e7fb              B        |L5.468|
                  |L5.476|
0001dc  4638              MOV      r0,r7                 ;463
0001de  f7fffffe          BL       pbuf_clen
0001e2  494a              LDR      r1,|L5.780|
0001e4  8809              LDRH     r1,[r1,#0]            ;463  ; ip_reass_pbufcount
0001e6  1a08              SUBS     r0,r1,r0              ;463
0001e8  4948              LDR      r1,|L5.780|
0001ea  8008              STRH     r0,[r1,#0]            ;463
0001ec  4638              MOV      r0,r7                 ;464
0001ee  f7fffffe          BL       pbuf_free
0001f2  2000              MOVS     r0,#0                 ;465
0001f4  e7ee              B        |L5.468|
;;;468    
                          ENDP

0001f6  0000              DCW      0x0000
                  |L5.504|
0001f8  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\ipv4\\ip_frag.c",0
0001fc  5749505c
000200  6c776970
000204  2d312e34
000208  2e315c73
00020c  72635c63
000210  6f72655c
000214  69707634
000218  5c69705f
00021c  66726167
000220  2e6300  
000223  00                DCB      0
                  |L5.548|
000224  63686563          DCB      "check fragments don't overlap",0
000228  6b206672
00022c  61676d65
000230  6e747320
000234  646f6e27
000238  74206f76
00023c  65726c61
000240  7000    
000242  00                DCB      0
000243  00                DCB      0
                  |L5.580|
000244  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000248  7274696f
00024c  6e202225
000250  73222066
000254  61696c65
000258  64206174
00025c  206c696e
000260  65202564
000264  20696e20
000268  25730d0a
00026c  00      
00026d  00                DCB      0
00026e  00                DCB      0
00026f  00                DCB      0
                  |L5.624|
000270  6e6f2070          DCB      "no previous fragment, this must be the first fragment!",0
000274  72657669
000278  6f757320
00027c  66726167
000280  6d656e74
000284  2c207468
000288  6973206d
00028c  75737420
000290  62652074
000294  68652066
000298  69727374
00029c  20667261
0002a0  676d656e
0002a4  742100  
0002a7  00                DCB      0
                  |L5.680|
0002a8  73616e69          DCB      "sanity check",0
0002ac  74792063
0002b0  6865636b
0002b4  00      
0002b5  00                DCB      0
0002b6  00                DCB      0
0002b7  00                DCB      0
                  |L5.696|
0002b8  76616c69          DCB      "validate_datagram:next_pbuf!=NULL",0
0002bc  64617465
0002c0  5f646174
0002c4  61677261
0002c8  6d3a6e65
0002cc  78745f70
0002d0  62756621
0002d4  3d4e554c
0002d8  4c00    
0002da  00                DCB      0
0002db  00                DCB      0
                  |L5.732|
0002dc  76616c69          DCB      "validate_datagram:datagram end!=datagram len",0
0002e0  64617465
0002e4  5f646174
0002e8  61677261
0002ec  6d3a6461
0002f0  74616772
0002f4  616d2065
0002f8  6e64213d
0002fc  64617461
000300  6772616d
000304  206c656e
000308  00      
000309  00                DCB      0
00030a  00                DCB      0
00030b  00                DCB      0
                  |L5.780|
                          DCD      ip_reass_pbufcount

                          AREA ||i.ip_reass_dequeue_datagram||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  ip_reass_dequeue_datagram PROC
;;;303    static void
;;;304    ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
000000  b570              PUSH     {r4-r6,lr}
;;;305    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;306      
;;;307      /* dequeue the reass struct  */
;;;308      if (reassdatagrams == ipr) {
000006  480e              LDR      r0,|L6.64|
000008  6800              LDR      r0,[r0,#0]  ; reassdatagrams
00000a  42a0              CMP      r0,r4
00000c  d103              BNE      |L6.22|
;;;309        /* it was the first in the list */
;;;310        reassdatagrams = ipr->next;
00000e  490c              LDR      r1,|L6.64|
000010  6820              LDR      r0,[r4,#0]
000012  6008              STR      r0,[r1,#0]  ; reassdatagrams
000014  e00e              B        |L6.52|
                  |L6.22|
;;;311      } else {
;;;312        /* it wasn't the first, so it must have a valid 'prev' */
;;;313        LWIP_ASSERT("sanity check linked list", prev != NULL);
000016  bf00              NOP      
000018  2d00              CMP      r5,#0
00001a  d108              BNE      |L6.46|
00001c  bf00              NOP      
00001e  a309              ADR      r3,|L6.68|
000020  f2401239          MOV      r2,#0x139
000024  a112              ADR      r1,|L6.112|
000026  a019              ADR      r0,|L6.140|
000028  f7fffffe          BL       __2printf
00002c  bf00              NOP      
                  |L6.46|
00002e  bf00              NOP      
;;;314        prev->next = ipr->next;
000030  6820              LDR      r0,[r4,#0]
000032  6028              STR      r0,[r5,#0]
                  |L6.52|
;;;315      }
;;;316    
;;;317      /* now we can free the ip_reass struct */
;;;318      memp_free(MEMP_REASSDATA, ipr);
000034  4621              MOV      r1,r4
000036  2005              MOVS     r0,#5
000038  f7fffffe          BL       memp_free
;;;319    }
00003c  bd70              POP      {r4-r6,pc}
;;;320    
                          ENDP

00003e  0000              DCW      0x0000
                  |L6.64|
                          DCD      reassdatagrams
                  |L6.68|
000044  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\ipv4\\ip_frag.c",0
000048  5749505c
00004c  6c776970
000050  2d312e34
000054  2e315c73
000058  72635c63
00005c  6f72655c
000060  69707634
000064  5c69705f
000068  66726167
00006c  2e6300  
00006f  00                DCB      0
                  |L6.112|
000070  73616e69          DCB      "sanity check linked list",0
000074  74792063
000078  6865636b
00007c  206c696e
000080  6b656420
000084  6c697374
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0
                  |L6.140|
00008c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000090  7274696f
000094  6e202225
000098  73222066
00009c  61696c65
0000a0  64206174
0000a4  206c696e
0000a8  65202564
0000ac  20696e20
0000b0  25730d0a
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0

                          AREA ||i.ip_reass_enqueue_new_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_enqueue_new_datagram PROC
;;;268    static struct ip_reassdata*
;;;269    ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
000000  b570              PUSH     {r4-r6,lr}
;;;270    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;271      struct ip_reassdata* ipr;
;;;272      /* No matching previous fragment found, allocate a new reassdata struct */
;;;273      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       memp_malloc
00000c  4604              MOV      r4,r0
;;;274      if (ipr == NULL) {
00000e  b974              CBNZ     r4,|L7.46|
;;;275    #if IP_REASS_FREE_OLDEST
;;;276        if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
000010  4631              MOV      r1,r6
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       ip_reass_remove_oldest_datagram
000018  42b0              CMP      r0,r6
00001a  db03              BLT      |L7.36|
;;;277          ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       memp_malloc
000022  4604              MOV      r4,r0
                  |L7.36|
;;;278        }
;;;279        if (ipr == NULL)
000024  b91c              CBNZ     r4,|L7.46|
;;;280    #endif /* IP_REASS_FREE_OLDEST */
;;;281        {
;;;282          IPFRAG_STATS_INC(ip_frag.memerr);
;;;283          LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
000026  bf00              NOP      
000028  bf00              NOP      
;;;284          return NULL;
00002a  2000              MOVS     r0,#0
                  |L7.44|
;;;285        }
;;;286      }
;;;287      memset(ipr, 0, sizeof(struct ip_reassdata));
;;;288      ipr->timer = IP_REASS_MAXAGE;
;;;289    
;;;290      /* enqueue the new structure to the front of the list */
;;;291      ipr->next = reassdatagrams;
;;;292      reassdatagrams = ipr;
;;;293      /* copy the ip header for later tests and input */
;;;294      /* @todo: no ip options supported? */
;;;295      SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
;;;296      return ipr;
;;;297    }
00002c  bd70              POP      {r4-r6,pc}
                  |L7.46|
00002e  2120              MOVS     r1,#0x20              ;287
000030  4620              MOV      r0,r4                 ;287
000032  f7fffffe          BL       __aeabi_memclr4
000036  2003              MOVS     r0,#3                 ;288
000038  77e0              STRB     r0,[r4,#0x1f]         ;288
00003a  4806              LDR      r0,|L7.84|
00003c  6800              LDR      r0,[r0,#0]            ;291  ; reassdatagrams
00003e  6020              STR      r0,[r4,#0]            ;291
000040  4804              LDR      r0,|L7.84|
000042  6004              STR      r4,[r0,#0]            ;292  ; reassdatagrams
000044  2214              MOVS     r2,#0x14              ;295
000046  4629              MOV      r1,r5                 ;295
000048  f1040008          ADD      r0,r4,#8              ;295
00004c  f7fffffe          BL       __aeabi_memcpy
000050  4620              MOV      r0,r4                 ;296
000052  e7eb              B        |L7.44|
;;;298    
                          ENDP

                  |L7.84|
                          DCD      reassdatagrams

                          AREA ||i.ip_reass_free_complete_datagram||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  ip_reass_free_complete_datagram PROC
;;;157    static int
;;;158    ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;159    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;160      u16_t pbufs_freed = 0;
000008  2500              MOVS     r5,#0
;;;161      u8_t clen;
;;;162      struct pbuf *p;
;;;163      struct ip_reass_helper *iprh;
;;;164    
;;;165      LWIP_ASSERT("prev != ipr", prev != ipr);
00000a  bf00              NOP      
00000c  45a0              CMP      r8,r4
00000e  d107              BNE      |L8.32|
000010  bf00              NOP      
000012  a340              ADR      r3,|L8.276|
000014  22a5              MOVS     r2,#0xa5
000016  a14a              ADR      r1,|L8.320|
000018  a04c              ADR      r0,|L8.332|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
                  |L8.32|
000020  bf00              NOP      
;;;166      if (prev != NULL) {
000022  f1b80f00          CMP      r8,#0
000026  d00d              BEQ      |L8.68|
;;;167        LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
000028  bf00              NOP      
00002a  f8d80000          LDR      r0,[r8,#0]
00002e  42a0              CMP      r0,r4
000030  d007              BEQ      |L8.66|
000032  bf00              NOP      
000034  a337              ADR      r3,|L8.276|
000036  22a7              MOVS     r2,#0xa7
000038  a14f              ADR      r1,|L8.376|
00003a  a044              ADR      r0,|L8.332|
00003c  f7fffffe          BL       __2printf
000040  bf00              NOP      
                  |L8.66|
000042  bf00              NOP      
                  |L8.68|
;;;168      }
;;;169    
;;;170      snmp_inc_ipreasmfails();
;;;171    #if LWIP_ICMP
;;;172      iprh = (struct ip_reass_helper *)ipr->p->payload;
000044  6860              LDR      r0,[r4,#4]
000046  f8d09004          LDR      r9,[r0,#4]
;;;173      if (iprh->start == 0) {
00004a  f8b90004          LDRH     r0,[r9,#4]
00004e  2800              CMP      r0,#0
000050  d124              BNE      |L8.156|
;;;174        /* The first fragment was received, send ICMP time exceeded. */
;;;175        /* First, de-queue the first pbuf from r->p. */
;;;176        p = ipr->p;
000052  6867              LDR      r7,[r4,#4]
;;;177        ipr->p = iprh->next_pbuf;
000054  f8d90000          LDR      r0,[r9,#0]
000058  6060              STR      r0,[r4,#4]
;;;178        /* Then, copy the original header into it. */
;;;179        SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
00005a  2214              MOVS     r2,#0x14
00005c  f1040108          ADD      r1,r4,#8
000060  6878              LDR      r0,[r7,#4]
000062  f7fffffe          BL       __aeabi_memcpy
;;;180        icmp_time_exceeded(p, ICMP_TE_FRAG);
000066  2101              MOVS     r1,#1
000068  4638              MOV      r0,r7
00006a  f7fffffe          BL       icmp_time_exceeded
;;;181        clen = pbuf_clen(p);
00006e  4638              MOV      r0,r7
000070  f7fffffe          BL       pbuf_clen
000074  4606              MOV      r6,r0
;;;182        LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
000076  bf00              NOP      
000078  19a8              ADDS     r0,r5,r6
00007a  f5b03f80          CMP      r0,#0x10000
00007e  db07              BLT      |L8.144|
000080  bf00              NOP      
000082  a324              ADR      r3,|L8.276|
000084  22b6              MOVS     r2,#0xb6
000086  a141              ADR      r1,|L8.396|
000088  a030              ADR      r0,|L8.332|
00008a  f7fffffe          BL       __2printf
00008e  bf00              NOP      
                  |L8.144|
000090  bf00              NOP      
;;;183        pbufs_freed += clen;
000092  19a8              ADDS     r0,r5,r6
000094  b285              UXTH     r5,r0
;;;184        pbuf_free(p);
000096  4638              MOV      r0,r7
000098  f7fffffe          BL       pbuf_free
                  |L8.156|
;;;185      }
;;;186    #endif /* LWIP_ICMP */
;;;187    
;;;188      /* First, free all received pbufs.  The individual pbufs need to be released 
;;;189         separately as they have not yet been chained */
;;;190      p = ipr->p;
00009c  6867              LDR      r7,[r4,#4]
;;;191      while (p != NULL) {
00009e  e01c              B        |L8.218|
                  |L8.160|
;;;192        struct pbuf *pcur;
;;;193        iprh = (struct ip_reass_helper *)p->payload;
0000a0  f8d79004          LDR      r9,[r7,#4]
;;;194        pcur = p;
0000a4  46ba              MOV      r10,r7
;;;195        /* get the next pointer before freeing */
;;;196        p = iprh->next_pbuf;
0000a6  f8d97000          LDR      r7,[r9,#0]
;;;197        clen = pbuf_clen(pcur);
0000aa  4650              MOV      r0,r10
0000ac  f7fffffe          BL       pbuf_clen
0000b0  4606              MOV      r6,r0
;;;198        LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
0000b2  bf00              NOP      
0000b4  19a8              ADDS     r0,r5,r6
0000b6  f5b03f80          CMP      r0,#0x10000
0000ba  db07              BLT      |L8.204|
0000bc  bf00              NOP      
0000be  a315              ADR      r3,|L8.276|
0000c0  22c6              MOVS     r2,#0xc6
0000c2  a132              ADR      r1,|L8.396|
0000c4  a021              ADR      r0,|L8.332|
0000c6  f7fffffe          BL       __2printf
0000ca  bf00              NOP      
                  |L8.204|
0000cc  bf00              NOP      
;;;199        pbufs_freed += clen;
0000ce  19a8              ADDS     r0,r5,r6
0000d0  b285              UXTH     r5,r0
;;;200        pbuf_free(pcur);
0000d2  4650              MOV      r0,r10
0000d4  f7fffffe          BL       pbuf_free
;;;201      }
0000d8  bf00              NOP      
                  |L8.218|
0000da  2f00              CMP      r7,#0                 ;191
0000dc  d1e0              BNE      |L8.160|
;;;202      /* Then, unchain the struct ip_reassdata from the list and free it. */
;;;203      ip_reass_dequeue_datagram(ipr, prev);
0000de  4641              MOV      r1,r8
0000e0  4620              MOV      r0,r4
0000e2  f7fffffe          BL       ip_reass_dequeue_datagram
;;;204      LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
0000e6  bf00              NOP      
0000e8  4830              LDR      r0,|L8.428|
0000ea  8800              LDRH     r0,[r0,#0]  ; ip_reass_pbufcount
0000ec  42a8              CMP      r0,r5
0000ee  da07              BGE      |L8.256|
0000f0  bf00              NOP      
0000f2  a308              ADR      r3,|L8.276|
0000f4  22cc              MOVS     r2,#0xcc
0000f6  a12e              ADR      r1,|L8.432|
0000f8  a014              ADR      r0,|L8.332|
0000fa  f7fffffe          BL       __2printf
0000fe  bf00              NOP      
                  |L8.256|
000100  bf00              NOP      
;;;205      ip_reass_pbufcount -= pbufs_freed;
000102  482a              LDR      r0,|L8.428|
000104  8800              LDRH     r0,[r0,#0]  ; ip_reass_pbufcount
000106  1b40              SUBS     r0,r0,r5
000108  4928              LDR      r1,|L8.428|
00010a  8008              STRH     r0,[r1,#0]
;;;206    
;;;207      return pbufs_freed;
00010c  4628              MOV      r0,r5
;;;208    }
00010e  e8bd87f0          POP      {r4-r10,pc}
;;;209    
                          ENDP

000112  0000              DCW      0x0000
                  |L8.276|
000114  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\ipv4\\ip_frag.c",0
000118  5749505c
00011c  6c776970
000120  2d312e34
000124  2e315c73
000128  72635c63
00012c  6f72655c
000130  69707634
000134  5c69705f
000138  66726167
00013c  2e6300  
00013f  00                DCB      0
                  |L8.320|
000140  70726576          DCB      "prev != ipr",0
000144  20213d20
000148  69707200
                  |L8.332|
00014c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000150  7274696f
000154  6e202225
000158  73222066
00015c  61696c65
000160  64206174
000164  206c696e
000168  65202564
00016c  20696e20
000170  25730d0a
000174  00      
000175  00                DCB      0
000176  00                DCB      0
000177  00                DCB      0
                  |L8.376|
000178  70726576          DCB      "prev->next == ipr",0
00017c  2d3e6e65
000180  7874203d
000184  3d206970
000188  7200    
00018a  00                DCB      0
00018b  00                DCB      0
                  |L8.396|
00018c  70627566          DCB      "pbufs_freed + clen <= 0xffff",0
000190  735f6672
000194  65656420
000198  2b20636c
00019c  656e203c
0001a0  3d203078
0001a4  66666666
0001a8  00      
0001a9  00                DCB      0
0001aa  00                DCB      0
0001ab  00                DCB      0
                  |L8.428|
                          DCD      ip_reass_pbufcount
                  |L8.432|
0001b0  69705f72          DCB      "ip_reass_pbufcount >= clen",0
0001b4  65617373
0001b8  5f706275
0001bc  66636f75
0001c0  6e74203e
0001c4  3d20636c
0001c8  656e00  
0001cb  00                DCB      0

                          AREA ||i.ip_reass_remove_oldest_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_remove_oldest_datagram PROC
;;;220    static int
;;;221    ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;222    {
000004  4605              MOV      r5,r0
000006  4689              MOV      r9,r1
;;;223      /* @todo Can't we simply remove the last datagram in the
;;;224       *       linked list behind reassdatagrams?
;;;225       */
;;;226      struct ip_reassdata *r, *oldest, *prev;
;;;227      int pbufs_freed = 0, pbufs_freed_current;
000008  2700              MOVS     r7,#0
;;;228      int other_datagrams;
;;;229    
;;;230      /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
;;;231       * but don't free the datagram that 'fraghdr' belongs to! */
;;;232      do {
00000a  bf00              NOP      
                  |L9.12|
;;;233        oldest = NULL;
00000c  2600              MOVS     r6,#0
;;;234        prev = NULL;
00000e  46b3              MOV      r11,r6
;;;235        other_datagrams = 0;
000010  46b2              MOV      r10,r6
;;;236        r = reassdatagrams;
000012  4819              LDR      r0,|L9.120|
000014  6804              LDR      r4,[r0,#0]  ; reassdatagrams
;;;237        while (r != NULL) {
000016  e01d              B        |L9.84|
                  |L9.24|
;;;238          if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
000018  6960              LDR      r0,[r4,#0x14]
00001a  68e9              LDR      r1,[r5,#0xc]
00001c  4288              CMP      r0,r1
00001e  d107              BNE      |L9.48|
000020  69a0              LDR      r0,[r4,#0x18]
000022  6929              LDR      r1,[r5,#0x10]
000024  4288              CMP      r0,r1
000026  d103              BNE      |L9.48|
000028  89a0              LDRH     r0,[r4,#0xc]
00002a  88a9              LDRH     r1,[r5,#4]
00002c  4288              CMP      r0,r1
00002e  d001              BEQ      |L9.52|
                  |L9.48|
000030  2001              MOVS     r0,#1
000032  e000              B        |L9.54|
                  |L9.52|
000034  2000              MOVS     r0,#0
                  |L9.54|
000036  b148              CBZ      r0,|L9.76|
;;;239            /* Not the same datagram as fraghdr */
;;;240            other_datagrams++;
000038  f10a0a01          ADD      r10,r10,#1
;;;241            if (oldest == NULL) {
00003c  b90e              CBNZ     r6,|L9.66|
;;;242              oldest = r;
00003e  4626              MOV      r6,r4
000040  e004              B        |L9.76|
                  |L9.66|
;;;243            } else if (r->timer <= oldest->timer) {
000042  7fe0              LDRB     r0,[r4,#0x1f]
000044  7ff1              LDRB     r1,[r6,#0x1f]
000046  4288              CMP      r0,r1
000048  dc00              BGT      |L9.76|
;;;244              /* older than the previous oldest */
;;;245              oldest = r;
00004a  4626              MOV      r6,r4
                  |L9.76|
;;;246            }
;;;247          }
;;;248          if (r->next != NULL) {
00004c  6820              LDR      r0,[r4,#0]
00004e  b100              CBZ      r0,|L9.82|
;;;249            prev = r;
000050  46a3              MOV      r11,r4
                  |L9.82|
;;;250          }
;;;251          r = r->next;
000052  6824              LDR      r4,[r4,#0]
                  |L9.84|
000054  2c00              CMP      r4,#0                 ;237
000056  d1df              BNE      |L9.24|
;;;252        }
;;;253        if (oldest != NULL) {
000058  b12e              CBZ      r6,|L9.102|
;;;254          pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
00005a  4659              MOV      r1,r11
00005c  4630              MOV      r0,r6
00005e  f7fffffe          BL       ip_reass_free_complete_datagram
000062  4680              MOV      r8,r0
;;;255          pbufs_freed += pbufs_freed_current;
000064  4447              ADD      r7,r7,r8
                  |L9.102|
;;;256        }
;;;257      } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
000066  454f              CMP      r7,r9
000068  da02              BGE      |L9.112|
00006a  f1ba0f01          CMP      r10,#1
00006e  dccd              BGT      |L9.12|
                  |L9.112|
;;;258      return pbufs_freed;
000070  4638              MOV      r0,r7
;;;259    }
000072  e8bd9ff0          POP      {r4-r12,pc}
;;;260    #endif /* IP_REASS_FREE_OLDEST */
                          ENDP

000076  0000              DCW      0x0000
                  |L9.120|
                          DCD      reassdatagrams

                          AREA ||i.ip_reass_tmr||, CODE, READONLY, ALIGN=2

                  ip_reass_tmr PROC
;;;121    void
;;;122    ip_reass_tmr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;123    {
;;;124      struct ip_reassdata *r, *prev = NULL;
000002  2600              MOVS     r6,#0
;;;125    
;;;126      r = reassdatagrams;
000004  480c              LDR      r0,|L10.56|
000006  6804              LDR      r4,[r0,#0]  ; reassdatagrams
;;;127      while (r != NULL) {
000008  e013              B        |L10.50|
                  |L10.10|
;;;128        /* Decrement the timer. Once it reaches 0,
;;;129         * clean up the incomplete fragment assembly */
;;;130        if (r->timer > 0) {
00000a  7fe0              LDRB     r0,[r4,#0x1f]
00000c  2800              CMP      r0,#0
00000e  dd07              BLE      |L10.32|
;;;131          r->timer--;
000010  7fe0              LDRB     r0,[r4,#0x1f]
000012  1e40              SUBS     r0,r0,#1
000014  77e0              STRB     r0,[r4,#0x1f]
;;;132          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
000016  bf00              NOP      
000018  bf00              NOP      
;;;133          prev = r;
00001a  4626              MOV      r6,r4
;;;134          r = r->next;
00001c  6824              LDR      r4,[r4,#0]
00001e  e008              B        |L10.50|
                  |L10.32|
;;;135        } else {
;;;136          /* reassembly timed out */
;;;137          struct ip_reassdata *tmp;
;;;138          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
000020  bf00              NOP      
000022  bf00              NOP      
;;;139          tmp = r;
000024  4625              MOV      r5,r4
;;;140          /* get the next pointer before freeing */
;;;141          r = r->next;
000026  6824              LDR      r4,[r4,#0]
;;;142          /* free the helper struct and all enqueued pbufs */
;;;143          ip_reass_free_complete_datagram(tmp, prev);
000028  4631              MOV      r1,r6
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       ip_reass_free_complete_datagram
;;;144         }
000030  bf00              NOP      
                  |L10.50|
000032  2c00              CMP      r4,#0                 ;127
000034  d1e9              BNE      |L10.10|
;;;145       }
;;;146    }
000036  bd70              POP      {r4-r6,pc}
;;;147    
                          ENDP

                  |L10.56|
                          DCD      reassdatagrams

                          AREA ||i.ipfrag_free_pbuf_custom||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  ipfrag_free_pbuf_custom PROC
;;;639    static void
;;;640    ipfrag_free_pbuf_custom(struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;641    {
000002  4605              MOV      r5,r0
;;;642      struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
000004  462c              MOV      r4,r5
;;;643      LWIP_ASSERT("pcr != NULL", pcr != NULL);
000006  bf00              NOP      
000008  b944              CBNZ     r4,|L11.28|
00000a  bf00              NOP      
00000c  a30f              ADR      r3,|L11.76|
00000e  f2402283          MOV      r2,#0x283
000012  a119              ADR      r1,|L11.120|
000014  a01b              ADR      r0,|L11.132|
000016  f7fffffe          BL       __2printf
00001a  bf00              NOP      
                  |L11.28|
00001c  bf00              NOP      
;;;644      LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
00001e  bf00              NOP      
000020  42ac              CMP      r4,r5
000022  d008              BEQ      |L11.54|
000024  bf00              NOP      
000026  a309              ADR      r3,|L11.76|
000028  f44f7221          MOV      r2,#0x284
00002c  a120              ADR      r1,|L11.176|
00002e  a015              ADR      r0,|L11.132|
000030  f7fffffe          BL       __2printf
000034  bf00              NOP      
                  |L11.54|
000036  bf00              NOP      
;;;645      if (pcr->original != NULL) {
000038  6960              LDR      r0,[r4,#0x14]
00003a  b110              CBZ      r0,|L11.66|
;;;646        pbuf_free(pcr->original);
00003c  6960              LDR      r0,[r4,#0x14]
00003e  f7fffffe          BL       pbuf_free
                  |L11.66|
;;;647      }
;;;648      ip_frag_free_pbuf_custom_ref(pcr);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       ip_frag_free_pbuf_custom_ref
;;;649    }
000048  bd70              POP      {r4-r6,pc}
;;;650    #endif /* !LWIP_NETIF_TX_SINGLE_PBUF */
                          ENDP

00004a  0000              DCW      0x0000
                  |L11.76|
00004c  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\ipv4\\ip_frag.c",0
000050  5749505c
000054  6c776970
000058  2d312e34
00005c  2e315c73
000060  72635c63
000064  6f72655c
000068  69707634
00006c  5c69705f
000070  66726167
000074  2e6300  
000077  00                DCB      0
                  |L11.120|
000078  70637220          DCB      "pcr != NULL",0
00007c  213d204e
000080  554c4c00
                  |L11.132|
000084  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000088  7274696f
00008c  6e202225
000090  73222066
000094  61696c65
000098  64206174
00009c  206c696e
0000a0  65202564
0000a4  20696e20
0000a8  25730d0a
0000ac  00      
0000ad  00                DCB      0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L11.176|
0000b0  70637220          DCB      "pcr == p",0
0000b4  3d3d2070
0000b8  00      
0000b9  00                DCB      0
0000ba  00                DCB      0
0000bb  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  reassdatagrams
                          DCD      0x00000000
                  ip_reass_pbufcount
000004  0000              DCB      0x00,0x00
