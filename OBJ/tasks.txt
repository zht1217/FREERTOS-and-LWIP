; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\tasks.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\tasks.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\tasks.crf ..\FreeRTOS\tasks.c]
                          THUMB

                          AREA ||i.eTaskGetState||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  eTaskGetState PROC
;;;1268   
;;;1269   	eTaskState eTaskGetState( TaskHandle_t xTask )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1270   	{
000004  4607              MOV      r7,r0
;;;1271   	eTaskState eReturn;
;;;1272   	List_t *pxStateList;
;;;1273   	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
000006  463e              MOV      r6,r7
;;;1274   
;;;1275   		configASSERT( pxTCB );
000008  b92e              CBNZ     r6,|L1.22|
00000a  f24042fb          MOV      r2,#0x4fb
00000e  a116              ADR      r1,|L1.104|
000010  a01a              ADR      r0,|L1.124|
000012  f7fffffe          BL       __2printf
                  |L1.22|
;;;1276   
;;;1277   		if( pxTCB == pxCurrentTCB )
000016  481d              LDR      r0,|L1.140|
000018  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00001a  4286              CMP      r6,r0
00001c  d101              BNE      |L1.34|
;;;1278   		{
;;;1279   			/* The task calling this function is querying its own state. */
;;;1280   			eReturn = eRunning;
00001e  2400              MOVS     r4,#0
000020  e01e              B        |L1.96|
                  |L1.34|
;;;1281   		}
;;;1282   		else
;;;1283   		{
;;;1284   			taskENTER_CRITICAL();
000022  f7fffffe          BL       vPortEnterCritical
;;;1285   			{
;;;1286   				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
000026  6975              LDR      r5,[r6,#0x14]
;;;1287   			}
;;;1288   			taskEXIT_CRITICAL();
000028  f7fffffe          BL       vPortExitCritical
;;;1289   
;;;1290   			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
00002c  4818              LDR      r0,|L1.144|
00002e  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000030  4285              CMP      r5,r0
000032  d003              BEQ      |L1.60|
000034  4817              LDR      r0,|L1.148|
000036  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000038  4285              CMP      r5,r0
00003a  d101              BNE      |L1.64|
                  |L1.60|
;;;1291   			{
;;;1292   				/* The task being queried is referenced from one of the Blocked
;;;1293   				lists. */
;;;1294   				eReturn = eBlocked;
00003c  2402              MOVS     r4,#2
00003e  e00f              B        |L1.96|
                  |L1.64|
;;;1295   			}
;;;1296   
;;;1297   			#if ( INCLUDE_vTaskSuspend == 1 )
;;;1298   				else if( pxStateList == &xSuspendedTaskList )
000040  4815              LDR      r0,|L1.152|
000042  4285              CMP      r5,r0
000044  d105              BNE      |L1.82|
;;;1299   				{
;;;1300   					/* The task being queried is referenced from the suspended
;;;1301   					list.  Is it genuinely suspended or is it block
;;;1302   					indefinitely? */
;;;1303   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
000046  6ab0              LDR      r0,[r6,#0x28]
000048  b908              CBNZ     r0,|L1.78|
;;;1304   					{
;;;1305   						eReturn = eSuspended;
00004a  2403              MOVS     r4,#3
00004c  e008              B        |L1.96|
                  |L1.78|
;;;1306   					}
;;;1307   					else
;;;1308   					{
;;;1309   						eReturn = eBlocked;
00004e  2402              MOVS     r4,#2
000050  e006              B        |L1.96|
                  |L1.82|
;;;1310   					}
;;;1311   				}
;;;1312   			#endif
;;;1313   
;;;1314   			#if ( INCLUDE_vTaskDelete == 1 )
;;;1315   				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
000052  4812              LDR      r0,|L1.156|
000054  4285              CMP      r5,r0
000056  d000              BEQ      |L1.90|
000058  b90d              CBNZ     r5,|L1.94|
                  |L1.90|
;;;1316   				{
;;;1317   					/* The task being queried is referenced from the deleted
;;;1318   					tasks list, or it is not referenced from any lists at
;;;1319   					all. */
;;;1320   					eReturn = eDeleted;
00005a  2404              MOVS     r4,#4
00005c  e000              B        |L1.96|
                  |L1.94|
;;;1321   				}
;;;1322   			#endif
;;;1323   
;;;1324   			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
;;;1325   			{
;;;1326   				/* If the task is not in any other state, it must be in the
;;;1327   				Ready (including pending ready) state. */
;;;1328   				eReturn = eReady;
00005e  2401              MOVS     r4,#1
                  |L1.96|
;;;1329   			}
;;;1330   		}
;;;1331   
;;;1332   		return eReturn;
000060  4620              MOV      r0,r4
;;;1333   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
000062  e8bd81f0          POP      {r4-r8,pc}
;;;1334   
                          ENDP

000066  0000              DCW      0x0000
                  |L1.104|
000068  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
00006c  72656552
000070  544f535c
000074  7461736b
000078  732e6300
                  |L1.124|
00007c  4572726f          DCB      "Error:%s,%d\r\n",0
000080  723a2573
000084  2c25640d
000088  0a00    
00008a  00                DCB      0
00008b  00                DCB      0
                  |L1.140|
                          DCD      pxCurrentTCB
                  |L1.144|
                          DCD      pxDelayedTaskList
                  |L1.148|
                          DCD      pxOverflowDelayedTaskList
                  |L1.152|
                          DCD      xSuspendedTaskList
                  |L1.156|
                          DCD      xTasksWaitingTermination

                          AREA ||i.pcTaskGetName||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  pcTaskGetName PROC
;;;2180   
;;;2181   char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  b570              PUSH     {r4-r6,lr}
;;;2182   {
000002  4604              MOV      r4,r0
;;;2183   TCB_t *pxTCB;
;;;2184   
;;;2185   	/* If null is passed in here then the name of the calling task is being
;;;2186   	queried. */
;;;2187   	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
000004  b914              CBNZ     r4,|L2.12|
000006  4807              LDR      r0,|L2.36|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000a  e000              B        |L2.14|
                  |L2.12|
00000c  4620              MOV      r0,r4
                  |L2.14|
00000e  4605              MOV      r5,r0
;;;2188   	configASSERT( pxTCB );
000010  b92d              CBNZ     r5,|L2.30|
000012  f640028c          MOV      r2,#0x88c
000016  a104              ADR      r1,|L2.40|
000018  a008              ADR      r0,|L2.60|
00001a  f7fffffe          BL       __2printf
                  |L2.30|
;;;2189   	return &( pxTCB->pcTaskName[ 0 ] );
00001e  f1050034          ADD      r0,r5,#0x34
;;;2190   }
000022  bd70              POP      {r4-r6,pc}
;;;2191   /*-----------------------------------------------------------*/
                          ENDP

                  |L2.36|
                          DCD      pxCurrentTCB
                  |L2.40|
000028  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
00002c  72656552
000030  544f535c
000034  7461736b
000038  732e6300
                  |L2.60|
00003c  4572726f          DCB      "Error:%s,%d\r\n",0
000040  723a2573
000044  2c25640d
000048  0a00    
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.prvAddCurrentTaskToDelayedList||, CODE, READONLY, ALIGN=2

                  prvAddCurrentTaskToDelayedList PROC
;;;4691   
;;;4692   static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4693   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;4694   TickType_t xTimeToWake;
;;;4695   const TickType_t xConstTickCount = xTickCount;
000008  481c              LDR      r0,|L3.124|
00000a  6807              LDR      r7,[r0,#0]  ; xTickCount
;;;4696   
;;;4697   	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;4698   	{
;;;4699   		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
;;;4700   		reset to pdFALSE so it can be detected as having been set to pdTRUE
;;;4701   		when the task leaves the Blocked state. */
;;;4702   		pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;4703   	}
;;;4704   	#endif
;;;4705   
;;;4706   	/* Remove the task from the ready list before adding it to the blocked list
;;;4707   	as the same list item is used for both lists. */
;;;4708   	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00000c  481c              LDR      r0,|L3.128|
00000e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000010  1d00              ADDS     r0,r0,#4
000012  f7fffffe          BL       uxListRemove
000016  b950              CBNZ     r0,|L3.46|
;;;4709   	{
;;;4710   		/* The current task must be in a ready list, so there is no need to
;;;4711   		check, and the port reset macro can be called directly. */
;;;4712   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000018  4819              LDR      r0,|L3.128|
00001a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00001c  f890102c          LDRB     r1,[r0,#0x2c]
000020  2001              MOVS     r0,#1
000022  4088              LSLS     r0,r0,r1
000024  4917              LDR      r1,|L3.132|
000026  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000028  4381              BICS     r1,r1,r0
00002a  4816              LDR      r0,|L3.132|
00002c  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L3.46|
;;;4713   	}
;;;4714   	else
;;;4715   	{
;;;4716   		mtCOVERAGE_TEST_MARKER();
;;;4717   	}
;;;4718   
;;;4719   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;4720   	{
;;;4721   		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
00002e  1c68              ADDS     r0,r5,#1
000030  b938              CBNZ     r0,|L3.66|
000032  b136              CBZ      r6,|L3.66|
;;;4722   		{
;;;4723   			/* Add the task to the suspended task list instead of a delayed task
;;;4724   			list to ensure it is not woken by a timing event.  It will block
;;;4725   			indefinitely. */
;;;4726   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
000034  4812              LDR      r0,|L3.128|
000036  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000038  1d09              ADDS     r1,r1,#4
00003a  4813              LDR      r0,|L3.136|
00003c  f7fffffe          BL       vListInsertEnd
000040  e01a              B        |L3.120|
                  |L3.66|
;;;4727   		}
;;;4728   		else
;;;4729   		{
;;;4730   			/* Calculate the time at which the task should be woken if the event
;;;4731   			does not occur.  This may overflow but this doesn't matter, the
;;;4732   			kernel will manage it correctly. */
;;;4733   			xTimeToWake = xConstTickCount + xTicksToWait;
000042  197c              ADDS     r4,r7,r5
;;;4734   
;;;4735   			/* The list item will be inserted in wake time order. */
;;;4736   			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
000044  480e              LDR      r0,|L3.128|
000046  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000048  6044              STR      r4,[r0,#4]
;;;4737   
;;;4738   			if( xTimeToWake < xConstTickCount )
00004a  42bc              CMP      r4,r7
00004c  d207              BCS      |L3.94|
;;;4739   			{
;;;4740   				/* Wake time has overflowed.  Place this item in the overflow
;;;4741   				list. */
;;;4742   				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
00004e  480c              LDR      r0,|L3.128|
000050  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000052  1d09              ADDS     r1,r1,#4
000054  480d              LDR      r0,|L3.140|
000056  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000058  f7fffffe          BL       vListInsert
00005c  e00c              B        |L3.120|
                  |L3.94|
;;;4743   			}
;;;4744   			else
;;;4745   			{
;;;4746   				/* The wake time has not overflowed, so the current block list
;;;4747   				is used. */
;;;4748   				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
00005e  4808              LDR      r0,|L3.128|
000060  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000062  1d09              ADDS     r1,r1,#4
000064  480a              LDR      r0,|L3.144|
000066  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000068  f7fffffe          BL       vListInsert
;;;4749   
;;;4750   				/* If the task entering the blocked state was placed at the
;;;4751   				head of the list of blocked tasks then xNextTaskUnblockTime
;;;4752   				needs to be updated too. */
;;;4753   				if( xTimeToWake < xNextTaskUnblockTime )
00006c  4809              LDR      r0,|L3.148|
00006e  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
000070  4284              CMP      r4,r0
000072  d201              BCS      |L3.120|
;;;4754   				{
;;;4755   					xNextTaskUnblockTime = xTimeToWake;
000074  4807              LDR      r0,|L3.148|
000076  6004              STR      r4,[r0,#0]  ; xNextTaskUnblockTime
                  |L3.120|
;;;4756   				}
;;;4757   				else
;;;4758   				{
;;;4759   					mtCOVERAGE_TEST_MARKER();
;;;4760   				}
;;;4761   			}
;;;4762   		}
;;;4763   	}
;;;4764   	#else /* INCLUDE_vTaskSuspend */
;;;4765   	{
;;;4766   		/* Calculate the time at which the task should be woken if the event
;;;4767   		does not occur.  This may overflow but this doesn't matter, the kernel
;;;4768   		will manage it correctly. */
;;;4769   		xTimeToWake = xConstTickCount + xTicksToWait;
;;;4770   
;;;4771   		/* The list item will be inserted in wake time order. */
;;;4772   		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
;;;4773   
;;;4774   		if( xTimeToWake < xConstTickCount )
;;;4775   		{
;;;4776   			/* Wake time has overflowed.  Place this item in the overflow list. */
;;;4777   			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;4778   		}
;;;4779   		else
;;;4780   		{
;;;4781   			/* The wake time has not overflowed, so the current block list is used. */
;;;4782   			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;4783   
;;;4784   			/* If the task entering the blocked state was placed at the head of the
;;;4785   			list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;4786   			too. */
;;;4787   			if( xTimeToWake < xNextTaskUnblockTime )
;;;4788   			{
;;;4789   				xNextTaskUnblockTime = xTimeToWake;
;;;4790   			}
;;;4791   			else
;;;4792   			{
;;;4793   				mtCOVERAGE_TEST_MARKER();
;;;4794   			}
;;;4795   		}
;;;4796   
;;;4797   		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
;;;4798   		( void ) xCanBlockIndefinitely;
;;;4799   	}
;;;4800   	#endif /* INCLUDE_vTaskSuspend */
;;;4801   }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;4802   
                          ENDP

                  |L3.124|
                          DCD      xTickCount
                  |L3.128|
                          DCD      pxCurrentTCB
                  |L3.132|
                          DCD      uxTopReadyPriority
                  |L3.136|
                          DCD      xSuspendedTaskList
                  |L3.140|
                          DCD      pxOverflowDelayedTaskList
                  |L3.144|
                          DCD      pxDelayedTaskList
                  |L3.148|
                          DCD      xNextTaskUnblockTime

                          AREA ||i.prvAddNewTaskToReadyList||, CODE, READONLY, ALIGN=2

                  prvAddNewTaskToReadyList PROC
;;;962    
;;;963    static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
000000  b510              PUSH     {r4,lr}
;;;964    {
000002  4604              MOV      r4,r0
;;;965    	/* Ensure interrupts don't access the task lists while the lists are being
;;;966    	updated. */
;;;967    	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;968    	{
;;;969    		uxCurrentNumberOfTasks++;
000008  4824              LDR      r0,|L4.156|
00000a  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
00000c  1c40              ADDS     r0,r0,#1
00000e  4923              LDR      r1,|L4.156|
000010  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;970    		if( pxCurrentTCB == NULL )
000012  4823              LDR      r0,|L4.160|
000014  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000016  b940              CBNZ     r0,|L4.42|
;;;971    		{
;;;972    			/* There are no other tasks, or all the other tasks are in
;;;973    			the suspended state - make this the current task. */
;;;974    			pxCurrentTCB = pxNewTCB;
000018  4821              LDR      r0,|L4.160|
00001a  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
;;;975    
;;;976    			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
00001c  4608              MOV      r0,r1
00001e  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000020  2801              CMP      r0,#1
000022  d10d              BNE      |L4.64|
;;;977    			{
;;;978    				/* This is the first task to be created so do the preliminary
;;;979    				initialisation required.  We will not recover if this call
;;;980    				fails, but we will report the failure. */
;;;981    				prvInitialiseTaskLists();
000024  f7fffffe          BL       prvInitialiseTaskLists
000028  e00a              B        |L4.64|
                  |L4.42|
;;;982    			}
;;;983    			else
;;;984    			{
;;;985    				mtCOVERAGE_TEST_MARKER();
;;;986    			}
;;;987    		}
;;;988    		else
;;;989    		{
;;;990    			/* If the scheduler is not already running, make this task the
;;;991    			current task if it is the highest priority task to be created
;;;992    			so far. */
;;;993    			if( xSchedulerRunning == pdFALSE )
00002a  481e              LDR      r0,|L4.164|
00002c  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00002e  b938              CBNZ     r0,|L4.64|
;;;994    			{
;;;995    				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
000030  481b              LDR      r0,|L4.160|
000032  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000034  6ac0              LDR      r0,[r0,#0x2c]
000036  6ae1              LDR      r1,[r4,#0x2c]
000038  4288              CMP      r0,r1
00003a  d801              BHI      |L4.64|
;;;996    				{
;;;997    					pxCurrentTCB = pxNewTCB;
00003c  4818              LDR      r0,|L4.160|
00003e  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
                  |L4.64|
;;;998    				}
;;;999    				else
;;;1000   				{
;;;1001   					mtCOVERAGE_TEST_MARKER();
;;;1002   				}
;;;1003   			}
;;;1004   			else
;;;1005   			{
;;;1006   				mtCOVERAGE_TEST_MARKER();
;;;1007   			}
;;;1008   		}
;;;1009   
;;;1010   		uxTaskNumber++;
000040  4819              LDR      r0,|L4.168|
000042  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
000044  1c40              ADDS     r0,r0,#1
000046  4918              LDR      r1,|L4.168|
000048  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;1011   
;;;1012   		#if ( configUSE_TRACE_FACILITY == 1 )
;;;1013   		{
;;;1014   			/* Add a counter into the TCB for tracing only. */
;;;1015   			pxNewTCB->uxTCBNumber = uxTaskNumber;
00004a  4608              MOV      r0,r1
00004c  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
00004e  64a0              STR      r0,[r4,#0x48]
;;;1016   		}
;;;1017   		#endif /* configUSE_TRACE_FACILITY */
;;;1018   		traceTASK_CREATE( pxNewTCB );
;;;1019   
;;;1020   		prvAddTaskToReadyList( pxNewTCB );
000050  f894102c          LDRB     r1,[r4,#0x2c]
000054  2001              MOVS     r0,#1
000056  4088              LSLS     r0,r0,r1
000058  4914              LDR      r1,|L4.172|
00005a  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00005c  4308              ORRS     r0,r0,r1
00005e  4913              LDR      r1,|L4.172|
000060  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000062  6ae1              LDR      r1,[r4,#0x2c]
000064  eb010181          ADD      r1,r1,r1,LSL #2
000068  4a11              LDR      r2,|L4.176|
00006a  eb020081          ADD      r0,r2,r1,LSL #2
00006e  1d21              ADDS     r1,r4,#4
000070  f7fffffe          BL       vListInsertEnd
;;;1021   
;;;1022   		portSETUP_TCB( pxNewTCB );
;;;1023   	}
;;;1024   	taskEXIT_CRITICAL();
000074  f7fffffe          BL       vPortExitCritical
;;;1025   
;;;1026   	if( xSchedulerRunning != pdFALSE )
000078  480a              LDR      r0,|L4.164|
00007a  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00007c  b168              CBZ      r0,|L4.154|
;;;1027   	{
;;;1028   		/* If the created task is of a higher priority than the current task
;;;1029   		then it should run now. */
;;;1030   		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
00007e  4808              LDR      r0,|L4.160|
000080  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000082  6ac0              LDR      r0,[r0,#0x2c]
000084  6ae1              LDR      r1,[r4,#0x2c]
000086  4288              CMP      r0,r1
000088  d207              BCS      |L4.154|
;;;1031   		{
;;;1032   			taskYIELD_IF_USING_PREEMPTION();
00008a  f04f5080          MOV      r0,#0x10000000
00008e  4909              LDR      r1,|L4.180|
000090  6008              STR      r0,[r1,#0]
000092  f3bf8f4f          DSB      
000096  f3bf8f6f          ISB      
                  |L4.154|
;;;1033   		}
;;;1034   		else
;;;1035   		{
;;;1036   			mtCOVERAGE_TEST_MARKER();
;;;1037   		}
;;;1038   	}
;;;1039   	else
;;;1040   	{
;;;1041   		mtCOVERAGE_TEST_MARKER();
;;;1042   	}
;;;1043   }
00009a  bd10              POP      {r4,pc}
;;;1044   /*-----------------------------------------------------------*/
                          ENDP

                  |L4.156|
                          DCD      uxCurrentNumberOfTasks
                  |L4.160|
                          DCD      pxCurrentTCB
                  |L4.164|
                          DCD      xSchedulerRunning
                  |L4.168|
                          DCD      uxTaskNumber
                  |L4.172|
                          DCD      uxTopReadyPriority
                  |L4.176|
                          DCD      pxReadyTasksLists
                  |L4.180|
                          DCD      0xe000ed04

                          AREA ||i.prvCheckTasksWaitingTermination||, CODE, READONLY, ALIGN=2

                  prvCheckTasksWaitingTermination PROC
;;;3364   
;;;3365   static void prvCheckTasksWaitingTermination( void )
000000  b570              PUSH     {r4-r6,lr}
;;;3366   {
;;;3367   
;;;3368   	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
;;;3369   
;;;3370   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3371   	{
;;;3372   		BaseType_t xListIsEmpty;
;;;3373   
;;;3374   		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
;;;3375   		too often in the idle task. */
;;;3376   		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
000002  e023              B        |L5.76|
                  |L5.4|
;;;3377   		{
;;;3378   			vTaskSuspendAll();
000004  f7fffffe          BL       vTaskSuspendAll
;;;3379   			{
;;;3380   				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
000008  4813              LDR      r0,|L5.88|
00000a  6800              LDR      r0,[r0,#0]  ; xTasksWaitingTermination
00000c  b908              CBNZ     r0,|L5.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L5.20|
                  |L5.18|
000012  2000              MOVS     r0,#0
                  |L5.20|
000014  4605              MOV      r5,r0
;;;3381   			}
;;;3382   			( void ) xTaskResumeAll();
000016  f7fffffe          BL       xTaskResumeAll
;;;3383   
;;;3384   			if( xListIsEmpty == pdFALSE )
00001a  b9bd              CBNZ     r5,|L5.76|
;;;3385   			{
;;;3386   				TCB_t *pxTCB;
;;;3387   
;;;3388   				taskENTER_CRITICAL();
00001c  f7fffffe          BL       vPortEnterCritical
;;;3389   				{
;;;3390   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
000020  480d              LDR      r0,|L5.88|
000022  68c0              LDR      r0,[r0,#0xc]
000024  68c4              LDR      r4,[r0,#0xc]
;;;3391   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000026  1d20              ADDS     r0,r4,#4
000028  f7fffffe          BL       uxListRemove
;;;3392   					--uxCurrentNumberOfTasks;
00002c  480b              LDR      r0,|L5.92|
00002e  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000030  1e40              SUBS     r0,r0,#1
000032  490a              LDR      r1,|L5.92|
000034  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;3393   					--uxDeletedTasksWaitingCleanUp;
000036  480a              LDR      r0,|L5.96|
000038  6800              LDR      r0,[r0,#0]  ; uxDeletedTasksWaitingCleanUp
00003a  1e40              SUBS     r0,r0,#1
00003c  4908              LDR      r1,|L5.96|
00003e  6008              STR      r0,[r1,#0]  ; uxDeletedTasksWaitingCleanUp
;;;3394   				}
;;;3395   				taskEXIT_CRITICAL();
000040  f7fffffe          BL       vPortExitCritical
;;;3396   
;;;3397   				prvDeleteTCB( pxTCB );
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       prvDeleteTCB
;;;3398   			}
00004a  bf00              NOP      
                  |L5.76|
00004c  4804              LDR      r0,|L5.96|
00004e  6800              LDR      r0,[r0,#0]            ;3376  ; uxDeletedTasksWaitingCleanUp
000050  2800              CMP      r0,#0                 ;3376
000052  d1d7              BNE      |L5.4|
;;;3399   			else
;;;3400   			{
;;;3401   				mtCOVERAGE_TEST_MARKER();
;;;3402   			}
;;;3403   		}
;;;3404   	}
;;;3405   	#endif /* INCLUDE_vTaskDelete */
;;;3406   }
000054  bd70              POP      {r4-r6,pc}
;;;3407   /*-----------------------------------------------------------*/
                          ENDP

000056  0000              DCW      0x0000
                  |L5.88|
                          DCD      xTasksWaitingTermination
                  |L5.92|
                          DCD      uxCurrentNumberOfTasks
                  |L5.96|
                          DCD      uxDeletedTasksWaitingCleanUp

                          AREA ||i.prvDeleteTCB||, CODE, READONLY, ALIGN=1

                  prvDeleteTCB PROC
;;;3580   
;;;3581   	static void prvDeleteTCB( TCB_t *pxTCB )
000000  b510              PUSH     {r4,lr}
;;;3582   	{
000002  4604              MOV      r4,r0
;;;3583   		/* This call is required specifically for the TriCore port.  It must be
;;;3584   		above the vPortFree() calls.  The call is also used by ports/demos that
;;;3585   		want to allocate and clean RAM statically. */
;;;3586   		portCLEAN_UP_TCB( pxTCB );
;;;3587   
;;;3588   		/* Free up the memory allocated by the scheduler for the task.  It is up
;;;3589   		to the task to free any memory allocated at the application level. */
;;;3590   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;3591   		{
;;;3592   			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
;;;3593   		}
;;;3594   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;3595   
;;;3596   		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
;;;3597   		{
;;;3598   			/* The task can only have been allocated dynamically - free both
;;;3599   			the stack and TCB. */
;;;3600   			vPortFree( pxTCB->pxStack );
000004  6b20              LDR      r0,[r4,#0x30]
000006  f7fffffe          BL       vPortFree
;;;3601   			vPortFree( pxTCB );
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       vPortFree
;;;3602   		}
;;;3603   		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1 )
;;;3604   		{
;;;3605   			/* The task could have been allocated statically or dynamically, so
;;;3606   			check what was statically allocated before trying to free the
;;;3607   			memory. */
;;;3608   			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
;;;3609   			{
;;;3610   				/* Both the stack and TCB were allocated dynamically, so both
;;;3611   				must be freed. */
;;;3612   				vPortFree( pxTCB->pxStack );
;;;3613   				vPortFree( pxTCB );
;;;3614   			}
;;;3615   			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
;;;3616   			{
;;;3617   				/* Only the stack was statically allocated, so the TCB is the
;;;3618   				only memory that must be freed. */
;;;3619   				vPortFree( pxTCB );
;;;3620   			}
;;;3621   			else
;;;3622   			{
;;;3623   				/* Neither the stack nor the TCB were allocated dynamically, so
;;;3624   				nothing needs to be freed. */
;;;3625   				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
;;;3626   				mtCOVERAGE_TEST_MARKER();
;;;3627   			}
;;;3628   		}
;;;3629   		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;3630   	}
000010  bd10              POP      {r4,pc}
;;;3631   
                          ENDP


                          AREA ||i.prvIdleTask||, CODE, READONLY, ALIGN=2

                  prvIdleTask PROC
;;;3130    */
;;;3131   static portTASK_FUNCTION( prvIdleTask, pvParameters )
000000  bf00              NOP      
                  |L7.2|
;;;3132   {
;;;3133   	/* Stop warnings. */
;;;3134   	( void ) pvParameters;
;;;3135   
;;;3136   	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
;;;3137   	SCHEDULER IS STARTED. **/
;;;3138   
;;;3139   	for( ;; )
;;;3140   	{
;;;3141   		/* See if any tasks have deleted themselves - if so then the idle task
;;;3142   		is responsible for freeing the deleted task's TCB and stack. */
;;;3143   		prvCheckTasksWaitingTermination();
000002  f7fffffe          BL       prvCheckTasksWaitingTermination
;;;3144   
;;;3145   		#if ( configUSE_PREEMPTION == 0 )
;;;3146   		{
;;;3147   			/* If we are not using preemption we keep forcing a task switch to
;;;3148   			see if any other task has become available.  If we are using
;;;3149   			preemption we don't need to do this as any task becoming available
;;;3150   			will automatically get the processor anyway. */
;;;3151   			taskYIELD();
;;;3152   		}
;;;3153   		#endif /* configUSE_PREEMPTION */
;;;3154   
;;;3155   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;3156   		{
;;;3157   			/* When using preemption tasks of equal priority will be
;;;3158   			timesliced.  If a task that is sharing the idle priority is ready
;;;3159   			to run then the idle task should yield before the end of the
;;;3160   			timeslice.
;;;3161   
;;;3162   			A critical region is not required here as we are just reading from
;;;3163   			the list, and an occasional incorrect value will not matter.  If
;;;3164   			the ready list at the idle priority contains more than one task
;;;3165   			then a task other than the idle task is ready to execute. */
;;;3166   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
000006  4806              LDR      r0,|L7.32|
000008  6800              LDR      r0,[r0,#0]  ; pxReadyTasksLists
00000a  2801              CMP      r0,#1
00000c  d9f9              BLS      |L7.2|
;;;3167   			{
;;;3168   				taskYIELD();
00000e  f04f5080          MOV      r0,#0x10000000
000012  4904              LDR      r1,|L7.36|
000014  6008              STR      r0,[r1,#0]
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  e7f0              B        |L7.2|
;;;3169   			}
;;;3170   			else
;;;3171   			{
;;;3172   				mtCOVERAGE_TEST_MARKER();
;;;3173   			}
;;;3174   		}
;;;3175   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;3176   
;;;3177   		#if ( configUSE_IDLE_HOOK == 1 )
;;;3178   		{
;;;3179   			extern void vApplicationIdleHook( void );
;;;3180   
;;;3181   			/* Call the user defined function from within the idle task.  This
;;;3182   			allows the application designer to add background functionality
;;;3183   			without the overhead of a separate task.
;;;3184   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;3185   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;3186   			vApplicationIdleHook();
;;;3187   		}
;;;3188   		#endif /* configUSE_IDLE_HOOK */
;;;3189   
;;;3190   		/* This conditional compilation should use inequality to 0, not equality
;;;3191   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;3192   		user defined low power mode	implementations require
;;;3193   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;3194   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;3195   		{
;;;3196   		TickType_t xExpectedIdleTime;
;;;3197   
;;;3198   			/* It is not desirable to suspend then resume the scheduler on
;;;3199   			each iteration of the idle task.  Therefore, a preliminary
;;;3200   			test of the expected idle time is performed without the
;;;3201   			scheduler suspended.  The result here is not necessarily
;;;3202   			valid. */
;;;3203   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3204   
;;;3205   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3206   			{
;;;3207   				vTaskSuspendAll();
;;;3208   				{
;;;3209   					/* Now the scheduler is suspended, the expected idle
;;;3210   					time can be sampled again, and this time its value can
;;;3211   					be used. */
;;;3212   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;3213   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3214   
;;;3215   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3216   					{
;;;3217   						traceLOW_POWER_IDLE_BEGIN();
;;;3218   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;3219   						traceLOW_POWER_IDLE_END();
;;;3220   					}
;;;3221   					else
;;;3222   					{
;;;3223   						mtCOVERAGE_TEST_MARKER();
;;;3224   					}
;;;3225   				}
;;;3226   				( void ) xTaskResumeAll();
;;;3227   			}
;;;3228   			else
;;;3229   			{
;;;3230   				mtCOVERAGE_TEST_MARKER();
;;;3231   			}
;;;3232   		}
;;;3233   		#endif /* configUSE_TICKLESS_IDLE */
;;;3234   	}
;;;3235   }
;;;3236   /*-----------------------------------------------------------*/
                          ENDP

                  |L7.32|
                          DCD      pxReadyTasksLists
                  |L7.36|
                          DCD      0xe000ed04

                          AREA ||i.prvInitialiseNewTask||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  prvInitialiseNewTask PROC
;;;766    
;;;767    static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;768    									const char * const pcName,
;;;769    									const uint32_t ulStackDepth,
;;;770    									void * const pvParameters,
;;;771    									UBaseType_t uxPriority,
;;;772    									TaskHandle_t * const pxCreatedTask,
;;;773    									TCB_t *pxNewTCB,
;;;774    									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;775    {
000004  4682              MOV      r10,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  469b              MOV      r11,r3
00000c  9e0a              LDR      r6,[sp,#0x28]
00000e  9c0c              LDR      r4,[sp,#0x30]
;;;776    StackType_t *pxTopOfStack;
;;;777    UBaseType_t x;
;;;778    
;;;779    	#if( portUSING_MPU_WRAPPERS == 1 )
;;;780    		/* Should the task be created in privileged mode? */
;;;781    		BaseType_t xRunPrivileged;
;;;782    		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;783    		{
;;;784    			xRunPrivileged = pdTRUE;
;;;785    		}
;;;786    		else
;;;787    		{
;;;788    			xRunPrivileged = pdFALSE;
;;;789    		}
;;;790    		uxPriority &= ~portPRIVILEGE_BIT;
;;;791    	#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;792    
;;;793    	/* Avoid dependency on memset() if it is not required. */
;;;794    	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
;;;795    	{
;;;796    		/* Fill the stack with a known value to assist debugging. */
;;;797    		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
000010  ea4f0188          LSL      r1,r8,#2
000014  22a5              MOVS     r2,#0xa5
000016  6b20              LDR      r0,[r4,#0x30]
000018  f7fffffe          BL       __aeabi_memset
;;;798    	}
;;;799    	#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
;;;800    
;;;801    	/* Calculate the top of stack address.  This depends on whether the stack
;;;802    	grows from high memory to low (as per the 80x86) or vice versa.
;;;803    	portSTACK_GROWTH is used to make the result positive or negative as required
;;;804    	by the port. */
;;;805    	#if( portSTACK_GROWTH < 0 )
;;;806    	{
;;;807    		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
00001c  f1a80001          SUB      r0,r8,#1
000020  6b21              LDR      r1,[r4,#0x30]
000022  eb010980          ADD      r9,r1,r0,LSL #2
;;;808    		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
000026  f0290907          BIC      r9,r9,#7
;;;809    
;;;810    		/* Check the alignment of the calculated top of stack is correct. */
;;;811    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
00002a  f0090007          AND      r0,r9,#7
00002e  b908              CBNZ     r0,|L8.52|
000030  2001              MOVS     r0,#1
000032  e000              B        |L8.54|
                  |L8.52|
000034  2000              MOVS     r0,#0
                  |L8.54|
000036  b928              CBNZ     r0,|L8.68|
000038  f240322b          MOV      r2,#0x32b
00003c  a11b              ADR      r1,|L8.172|
00003e  a020              ADR      r0,|L8.192|
000040  f7fffffe          BL       __2printf
                  |L8.68|
;;;812    	}
;;;813    	#else /* portSTACK_GROWTH */
;;;814    	{
;;;815    		pxTopOfStack = pxNewTCB->pxStack;
;;;816    
;;;817    		/* Check the alignment of the stack buffer is correct. */
;;;818    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;819    
;;;820    		/* The other extreme of the stack space is required if stack checking is
;;;821    		performed. */
;;;822    		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
;;;823    	}
;;;824    	#endif /* portSTACK_GROWTH */
;;;825    
;;;826    	/* Store the task name in the TCB. */
;;;827    	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
000044  2500              MOVS     r5,#0
000046  e007              B        |L8.88|
                  |L8.72|
;;;828    	{
;;;829    		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
000048  5d79              LDRB     r1,[r7,r5]
00004a  f1040034          ADD      r0,r4,#0x34
00004e  5541              STRB     r1,[r0,r5]
;;;830    
;;;831    		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
;;;832    		configMAX_TASK_NAME_LEN characters just in case the memory after the
;;;833    		string is not accessible (extremely unlikely). */
;;;834    		if( pcName[ x ] == 0x00 )
000050  5d78              LDRB     r0,[r7,r5]
000052  b900              CBNZ     r0,|L8.86|
;;;835    		{
;;;836    			break;
000054  e002              B        |L8.92|
                  |L8.86|
000056  1c6d              ADDS     r5,r5,#1              ;827
                  |L8.88|
000058  2d14              CMP      r5,#0x14              ;827
00005a  d3f5              BCC      |L8.72|
                  |L8.92|
00005c  bf00              NOP      
;;;837    		}
;;;838    		else
;;;839    		{
;;;840    			mtCOVERAGE_TEST_MARKER();
;;;841    		}
;;;842    	}
;;;843    
;;;844    	/* Ensure the name string is terminated in the case that the string length
;;;845    	was greater or equal to configMAX_TASK_NAME_LEN. */
;;;846    	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
00005e  2100              MOVS     r1,#0
000060  2047              MOVS     r0,#0x47
000062  5501              STRB     r1,[r0,r4]
;;;847    
;;;848    	/* This is used as an array index so must ensure it's not too large.  First
;;;849    	remove the privilege bit if one is present. */
;;;850    	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
000064  2e20              CMP      r6,#0x20
000066  d300              BCC      |L8.106|
;;;851    	{
;;;852    		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
000068  261f              MOVS     r6,#0x1f
                  |L8.106|
;;;853    	}
;;;854    	else
;;;855    	{
;;;856    		mtCOVERAGE_TEST_MARKER();
;;;857    	}
;;;858    
;;;859    	pxNewTCB->uxPriority = uxPriority;
00006a  62e6              STR      r6,[r4,#0x2c]
;;;860    	#if ( configUSE_MUTEXES == 1 )
;;;861    	{
;;;862    		pxNewTCB->uxBasePriority = uxPriority;
00006c  6526              STR      r6,[r4,#0x50]
;;;863    		pxNewTCB->uxMutexesHeld = 0;
00006e  2000              MOVS     r0,#0
000070  6560              STR      r0,[r4,#0x54]
;;;864    	}
;;;865    	#endif /* configUSE_MUTEXES */
;;;866    
;;;867    	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
000072  1d20              ADDS     r0,r4,#4
000074  f7fffffe          BL       vListInitialiseItem
;;;868    	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
000078  f1040018          ADD      r0,r4,#0x18
00007c  f7fffffe          BL       vListInitialiseItem
;;;869    
;;;870    	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
;;;871    	back to	the containing TCB from a generic item in a list. */
;;;872    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
000080  6124              STR      r4,[r4,#0x10]
;;;873    
;;;874    	/* Event lists are always in priority order. */
;;;875    	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000082  f1c60020          RSB      r0,r6,#0x20
000086  61a0              STR      r0,[r4,#0x18]
;;;876    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
000088  6264              STR      r4,[r4,#0x24]
;;;877    
;;;878    	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
;;;879    	{
;;;880    		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
;;;881    	}
;;;882    	#endif /* portCRITICAL_NESTING_IN_TCB */
;;;883    
;;;884    	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
;;;885    	{
;;;886    		pxNewTCB->pxTaskTag = NULL;
;;;887    	}
;;;888    	#endif /* configUSE_APPLICATION_TASK_TAG */
;;;889    
;;;890    	#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;891    	{
;;;892    		pxNewTCB->ulRunTimeCounter = 0UL;
00008a  2000              MOVS     r0,#0
00008c  65a0              STR      r0,[r4,#0x58]
;;;893    	}
;;;894    	#endif /* configGENERATE_RUN_TIME_STATS */
;;;895    
;;;896    	#if ( portUSING_MPU_WRAPPERS == 1 )
;;;897    	{
;;;898    		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
;;;899    	}
;;;900    	#else
;;;901    	{
;;;902    		/* Avoid compiler warning about unreferenced parameter. */
;;;903    		( void ) xRegions;
;;;904    	}
;;;905    	#endif
;;;906    
;;;907    	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
;;;908    	{
;;;909    		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
;;;910    		{
;;;911    			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
;;;912    		}
;;;913    	}
;;;914    	#endif
;;;915    
;;;916    	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
;;;917    	{
;;;918    		pxNewTCB->ulNotifiedValue = 0;
00008e  65e0              STR      r0,[r4,#0x5c]
;;;919    		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000090  f8840060          STRB     r0,[r4,#0x60]
;;;920    	}
;;;921    	#endif
;;;922    
;;;923    	#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;924    	{
;;;925    		/* Initialise this task's Newlib reent structure. */
;;;926    		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
;;;927    	}
;;;928    	#endif
;;;929    
;;;930    	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;931    	{
;;;932    		pxNewTCB->ucDelayAborted = pdFALSE;
;;;933    	}
;;;934    	#endif
;;;935    
;;;936    	/* Initialize the TCB stack to look as if the task was already running,
;;;937    	but had been interrupted by the scheduler.  The return address is set
;;;938    	to the start of the task function. Once the stack has been initialised
;;;939    	the	top of stack variable is updated. */
;;;940    	#if( portUSING_MPU_WRAPPERS == 1 )
;;;941    	{
;;;942    		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;943    	}
;;;944    	#else /* portUSING_MPU_WRAPPERS */
;;;945    	{
;;;946    		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
000094  465a              MOV      r2,r11
000096  4651              MOV      r1,r10
000098  4648              MOV      r0,r9
00009a  f7fffffe          BL       pxPortInitialiseStack
00009e  6020              STR      r0,[r4,#0]
;;;947    	}
;;;948    	#endif /* portUSING_MPU_WRAPPERS */
;;;949    
;;;950    	if( ( void * ) pxCreatedTask != NULL )
0000a0  980b              LDR      r0,[sp,#0x2c]
0000a2  b108              CBZ      r0,|L8.168|
;;;951    	{
;;;952    		/* Pass the handle out in an anonymous way.  The handle can be used to
;;;953    		change the created task's priority, delete the created task, etc.*/
;;;954    		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
0000a4  980b              LDR      r0,[sp,#0x2c]
0000a6  6004              STR      r4,[r0,#0]
                  |L8.168|
;;;955    	}
;;;956    	else
;;;957    	{
;;;958    		mtCOVERAGE_TEST_MARKER();
;;;959    	}
;;;960    }
0000a8  e8bd9ff0          POP      {r4-r12,pc}
;;;961    /*-----------------------------------------------------------*/
                          ENDP

                  |L8.172|
0000ac  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
0000b0  72656552
0000b4  544f535c
0000b8  7461736b
0000bc  732e6300
                  |L8.192|
0000c0  4572726f          DCB      "Error:%s,%d\r\n",0
0000c4  723a2573
0000c8  2c25640d
0000cc  0a00    
0000ce  00                DCB      0
0000cf  00                DCB      0

                          AREA ||i.prvInitialiseTaskLists||, CODE, READONLY, ALIGN=2

                  prvInitialiseTaskLists PROC
;;;3332   
;;;3333   static void prvInitialiseTaskLists( void )
000000  b510              PUSH     {r4,lr}
;;;3334   {
;;;3335   UBaseType_t uxPriority;
;;;3336   
;;;3337   	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
000002  2400              MOVS     r4,#0
000004  e007              B        |L9.22|
                  |L9.6|
;;;3338   	{
;;;3339   		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
000006  eb040184          ADD      r1,r4,r4,LSL #2
00000a  4a0f              LDR      r2,|L9.72|
00000c  eb020081          ADD      r0,r2,r1,LSL #2
000010  f7fffffe          BL       vListInitialise
000014  1c64              ADDS     r4,r4,#1              ;3337
                  |L9.22|
000016  2c20              CMP      r4,#0x20              ;3337
000018  d3f5              BCC      |L9.6|
;;;3340   	}
;;;3341   
;;;3342   	vListInitialise( &xDelayedTaskList1 );
00001a  480c              LDR      r0,|L9.76|
00001c  f7fffffe          BL       vListInitialise
;;;3343   	vListInitialise( &xDelayedTaskList2 );
000020  480b              LDR      r0,|L9.80|
000022  f7fffffe          BL       vListInitialise
;;;3344   	vListInitialise( &xPendingReadyList );
000026  480b              LDR      r0,|L9.84|
000028  f7fffffe          BL       vListInitialise
;;;3345   
;;;3346   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3347   	{
;;;3348   		vListInitialise( &xTasksWaitingTermination );
00002c  480a              LDR      r0,|L9.88|
00002e  f7fffffe          BL       vListInitialise
;;;3349   	}
;;;3350   	#endif /* INCLUDE_vTaskDelete */
;;;3351   
;;;3352   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;3353   	{
;;;3354   		vListInitialise( &xSuspendedTaskList );
000032  480a              LDR      r0,|L9.92|
000034  f7fffffe          BL       vListInitialise
;;;3355   	}
;;;3356   	#endif /* INCLUDE_vTaskSuspend */
;;;3357   
;;;3358   	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
;;;3359   	using list2. */
;;;3360   	pxDelayedTaskList = &xDelayedTaskList1;
000038  4804              LDR      r0,|L9.76|
00003a  4909              LDR      r1,|L9.96|
00003c  6008              STR      r0,[r1,#0]  ; pxDelayedTaskList
;;;3361   	pxOverflowDelayedTaskList = &xDelayedTaskList2;
00003e  4804              LDR      r0,|L9.80|
000040  4908              LDR      r1,|L9.100|
000042  6008              STR      r0,[r1,#0]  ; pxOverflowDelayedTaskList
;;;3362   }
000044  bd10              POP      {r4,pc}
;;;3363   /*-----------------------------------------------------------*/
                          ENDP

000046  0000              DCW      0x0000
                  |L9.72|
                          DCD      pxReadyTasksLists
                  |L9.76|
                          DCD      xDelayedTaskList1
                  |L9.80|
                          DCD      xDelayedTaskList2
                  |L9.84|
                          DCD      xPendingReadyList
                  |L9.88|
                          DCD      xTasksWaitingTermination
                  |L9.92|
                          DCD      xSuspendedTaskList
                  |L9.96|
                          DCD      pxDelayedTaskList
                  |L9.100|
                          DCD      pxOverflowDelayedTaskList

                          AREA ||i.prvListTasksWithinSingleList||, CODE, READONLY, ALIGN=1

                  prvListTasksWithinSingleList PROC
;;;3499   
;;;3500   	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;3501   	{
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;3502   	volatile TCB_t *pxNextTCB, *pxFirstTCB;
;;;3503   	UBaseType_t uxTask = 0;
00000a  2600              MOVS     r6,#0
;;;3504   
;;;3505   		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
00000c  6820              LDR      r0,[r4,#0]
00000e  b348              CBZ      r0,|L10.100|
;;;3506   		{
;;;3507   			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
000010  4620              MOV      r0,r4
000012  6841              LDR      r1,[r0,#4]
000014  6849              LDR      r1,[r1,#4]
000016  6041              STR      r1,[r0,#4]
000018  f1000108          ADD      r1,r0,#8
00001c  6842              LDR      r2,[r0,#4]
00001e  428a              CMP      r2,r1
000020  d102              BNE      |L10.40|
000022  6841              LDR      r1,[r0,#4]
000024  6849              LDR      r1,[r1,#4]
000026  6041              STR      r1,[r0,#4]
                  |L10.40|
000028  6841              LDR      r1,[r0,#4]
00002a  f8d1900c          LDR      r9,[r1,#0xc]
;;;3508   
;;;3509   			/* Populate an TaskStatus_t structure within the
;;;3510   			pxTaskStatusArray array for each task that is referenced from
;;;3511   			pxList.  See the definition of TaskStatus_t in task.h for the
;;;3512   			meaning of each TaskStatus_t structure member. */
;;;3513   			do
00002e  bf00              NOP      
                  |L10.48|
;;;3514   			{
;;;3515   				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
000030  4620              MOV      r0,r4
000032  6841              LDR      r1,[r0,#4]
000034  6849              LDR      r1,[r1,#4]
000036  6041              STR      r1,[r0,#4]
000038  f1000108          ADD      r1,r0,#8
00003c  6842              LDR      r2,[r0,#4]
00003e  428a              CMP      r2,r1
000040  d102              BNE      |L10.72|
000042  6841              LDR      r1,[r0,#4]
000044  6849              LDR      r1,[r1,#4]
000046  6041              STR      r1,[r0,#4]
                  |L10.72|
000048  6841              LDR      r1,[r0,#4]
00004a  68cd              LDR      r5,[r1,#0xc]
;;;3516   				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
00004c  eb0600c6          ADD      r0,r6,r6,LSL #3
000050  eb070180          ADD      r1,r7,r0,LSL #2
000054  4643              MOV      r3,r8
000056  2201              MOVS     r2,#1
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       vTaskGetInfo
;;;3517   				uxTask++;
00005e  1c76              ADDS     r6,r6,#1
;;;3518   			} while( pxNextTCB != pxFirstTCB );
000060  454d              CMP      r5,r9
000062  d1e5              BNE      |L10.48|
                  |L10.100|
;;;3519   		}
;;;3520   		else
;;;3521   		{
;;;3522   			mtCOVERAGE_TEST_MARKER();
;;;3523   		}
;;;3524   
;;;3525   		return uxTask;
000064  4630              MOV      r0,r6
;;;3526   	}
000066  e8bd87f0          POP      {r4-r10,pc}
;;;3527   
                          ENDP


                          AREA ||i.prvResetNextTaskUnblockTime||, CODE, READONLY, ALIGN=2

                  prvResetNextTaskUnblockTime PROC
;;;3634   
;;;3635   static void prvResetNextTaskUnblockTime( void )
000000  490a              LDR      r1,|L11.44|
;;;3636   {
;;;3637   TCB_t *pxTCB;
;;;3638   
;;;3639   	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000002  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
000004  6809              LDR      r1,[r1,#0]
000006  b909              CBNZ     r1,|L11.12|
000008  2101              MOVS     r1,#1
00000a  e000              B        |L11.14|
                  |L11.12|
00000c  2100              MOVS     r1,#0
                  |L11.14|
00000e  b121              CBZ      r1,|L11.26|
;;;3640   	{
;;;3641   		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
;;;3642   		the maximum possible value so it is	extremely unlikely that the
;;;3643   		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
;;;3644   		there is an item in the delayed list. */
;;;3645   		xNextTaskUnblockTime = portMAX_DELAY;
000010  f04f31ff          MOV      r1,#0xffffffff
000014  4a06              LDR      r2,|L11.48|
000016  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
000018  e006              B        |L11.40|
                  |L11.26|
;;;3646   	}
;;;3647   	else
;;;3648   	{
;;;3649   		/* The new current delayed list is not empty, get the value of
;;;3650   		the item at the head of the delayed list.  This is the time at
;;;3651   		which the task at the head of the delayed list should be removed
;;;3652   		from the Blocked state. */
;;;3653   		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
00001a  4904              LDR      r1,|L11.44|
00001c  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
00001e  68c9              LDR      r1,[r1,#0xc]
000020  68c8              LDR      r0,[r1,#0xc]
;;;3654   		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
000022  4a03              LDR      r2,|L11.48|
000024  6841              LDR      r1,[r0,#4]
000026  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
                  |L11.40|
;;;3655   	}
;;;3656   }
000028  4770              BX       lr
;;;3657   /*-----------------------------------------------------------*/
                          ENDP

00002a  0000              DCW      0x0000
                  |L11.44|
                          DCD      pxDelayedTaskList
                  |L11.48|
                          DCD      xNextTaskUnblockTime

                          AREA ||i.prvTaskCheckFreeStackSpace||, CODE, READONLY, ALIGN=1

                  prvTaskCheckFreeStackSpace PROC
;;;3532   
;;;3533   	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
000000  4602              MOV      r2,r0
;;;3534   	{
;;;3535   	uint32_t ulCount = 0U;
000002  2100              MOVS     r1,#0
;;;3536   
;;;3537   		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
000004  e001              B        |L12.10|
                  |L12.6|
;;;3538   		{
;;;3539   			pucStackByte -= portSTACK_GROWTH;
000006  1c52              ADDS     r2,r2,#1
;;;3540   			ulCount++;
000008  1c49              ADDS     r1,r1,#1
                  |L12.10|
00000a  7810              LDRB     r0,[r2,#0]            ;3537
00000c  28a5              CMP      r0,#0xa5              ;3537
00000e  d0fa              BEQ      |L12.6|
;;;3541   		}
;;;3542   
;;;3543   		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
000010  0889              LSRS     r1,r1,#2
;;;3544   
;;;3545   		return ( uint16_t ) ulCount;
000012  b288              UXTH     r0,r1
;;;3546   	}
000014  4770              BX       lr
;;;3547   
                          ENDP


                          AREA ||i.prvTaskIsTaskSuspended||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  prvTaskIsTaskSuspended PROC
;;;1655   
;;;1656   	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;1657   	{
000002  4605              MOV      r5,r0
;;;1658   	BaseType_t xReturn = pdFALSE;
000004  2600              MOVS     r6,#0
;;;1659   	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
000006  462c              MOV      r4,r5
;;;1660   
;;;1661   		/* Accesses xPendingReadyList so must be called from a critical
;;;1662   		section. */
;;;1663   
;;;1664   		/* It does not make sense to check if the calling task is suspended. */
;;;1665   		configASSERT( xTask );
000008  b92d              CBNZ     r5,|L13.22|
00000a  f2406281          MOV      r2,#0x681
00000e  a10e              ADR      r1,|L13.72|
000010  a012              ADR      r0,|L13.92|
000012  f7fffffe          BL       __2printf
                  |L13.22|
;;;1666   
;;;1667   		/* Is the task being resumed actually in the suspended list? */
;;;1668   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
000016  4915              LDR      r1,|L13.108|
000018  6960              LDR      r0,[r4,#0x14]
00001a  4288              CMP      r0,r1
00001c  d101              BNE      |L13.34|
00001e  2001              MOVS     r0,#1
000020  e000              B        |L13.36|
                  |L13.34|
000022  2000              MOVS     r0,#0
                  |L13.36|
000024  b170              CBZ      r0,|L13.68|
;;;1669   		{
;;;1670   			/* Has the task already been resumed from within an ISR? */
;;;1671   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
000026  4912              LDR      r1,|L13.112|
000028  6aa0              LDR      r0,[r4,#0x28]
00002a  4288              CMP      r0,r1
00002c  d101              BNE      |L13.50|
00002e  2001              MOVS     r0,#1
000030  e000              B        |L13.52|
                  |L13.50|
000032  2000              MOVS     r0,#0
                  |L13.52|
000034  b930              CBNZ     r0,|L13.68|
;;;1672   			{
;;;1673   				/* Is it in the suspended list because it is in the	Suspended
;;;1674   				state, or because is is blocked with no timeout? */
;;;1675   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
000036  6aa0              LDR      r0,[r4,#0x28]
000038  b908              CBNZ     r0,|L13.62|
00003a  2001              MOVS     r0,#1
00003c  e000              B        |L13.64|
                  |L13.62|
00003e  2000              MOVS     r0,#0
                  |L13.64|
000040  b100              CBZ      r0,|L13.68|
;;;1676   				{
;;;1677   					xReturn = pdTRUE;
000042  2601              MOVS     r6,#1
                  |L13.68|
;;;1678   				}
;;;1679   				else
;;;1680   				{
;;;1681   					mtCOVERAGE_TEST_MARKER();
;;;1682   				}
;;;1683   			}
;;;1684   			else
;;;1685   			{
;;;1686   				mtCOVERAGE_TEST_MARKER();
;;;1687   			}
;;;1688   		}
;;;1689   		else
;;;1690   		{
;;;1691   			mtCOVERAGE_TEST_MARKER();
;;;1692   		}
;;;1693   
;;;1694   		return xReturn;
000044  4630              MOV      r0,r6
;;;1695   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
000046  bd70              POP      {r4-r6,pc}
;;;1696   
                          ENDP

                  |L13.72|
000048  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
00004c  72656552
000050  544f535c
000054  7461736b
000058  732e6300
                  |L13.92|
00005c  4572726f          DCB      "Error:%s,%d\r\n",0
000060  723a2573
000064  2c25640d
000068  0a00    
00006a  00                DCB      0
00006b  00                DCB      0
                  |L13.108|
                          DCD      xSuspendedTaskList
                  |L13.112|
                          DCD      xPendingReadyList

                          AREA ||i.prvWriteNameToBuffer||, CODE, READONLY, ALIGN=1

                  prvWriteNameToBuffer PROC
;;;3915   
;;;3916   	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
000000  b570              PUSH     {r4-r6,lr}
;;;3917   	{
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;3918   	size_t x;
;;;3919   
;;;3920   		/* Start by copying the entire string. */
;;;3921   		strcpy( pcBuffer, pcTaskName );
000006  4631              MOV      r1,r6
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       strcpy
;;;3922   
;;;3923   		/* Pad the end of the string with spaces to ensure columns line up when
;;;3924   		printed out. */
;;;3925   		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       strlen
000014  4604              MOV      r4,r0
000016  e002              B        |L14.30|
                  |L14.24|
;;;3926   		{
;;;3927   			pcBuffer[ x ] = ' ';
000018  2020              MOVS     r0,#0x20
00001a  5528              STRB     r0,[r5,r4]
00001c  1c64              ADDS     r4,r4,#1              ;3925
                  |L14.30|
00001e  2c13              CMP      r4,#0x13              ;3925
000020  d3fa              BCC      |L14.24|
;;;3928   		}
;;;3929   
;;;3930   		/* Terminate. */
;;;3931   		pcBuffer[ x ] = 0x00;
000022  2000              MOVS     r0,#0
000024  5528              STRB     r0,[r5,r4]
;;;3932   
;;;3933   		/* Return the new end of string. */
;;;3934   		return &( pcBuffer[ x ] );
000026  1928              ADDS     r0,r5,r4
;;;3935   	}
000028  bd70              POP      {r4-r6,pc}
;;;3936   
                          ENDP


                          AREA ||i.pvTaskIncrementMutexHeldCount||, CODE, READONLY, ALIGN=2

                  pvTaskIncrementMutexHeldCount PROC
;;;4177   
;;;4178   	void *pvTaskIncrementMutexHeldCount( void )
000000  4806              LDR      r0,|L15.28|
;;;4179   	{
;;;4180   		/* If xSemaphoreCreateMutex() is called before any tasks have been created
;;;4181   		then pxCurrentTCB will be NULL. */
;;;4182   		if( pxCurrentTCB != NULL )
000002  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000004  b130              CBZ      r0,|L15.20|
;;;4183   		{
;;;4184   			( pxCurrentTCB->uxMutexesHeld )++;
000006  4905              LDR      r1,|L15.28|
000008  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000a  f1010054          ADD      r0,r1,#0x54
00000e  6d49              LDR      r1,[r1,#0x54]
000010  1c49              ADDS     r1,r1,#1
000012  6001              STR      r1,[r0,#0]
                  |L15.20|
;;;4185   		}
;;;4186   
;;;4187   		return pxCurrentTCB;
000014  4801              LDR      r0,|L15.28|
000016  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
;;;4188   	}
000018  4770              BX       lr
;;;4189   
                          ENDP

00001a  0000              DCW      0x0000
                  |L15.28|
                          DCD      pxCurrentTCB

                          AREA ||i.ulTaskNotifyTake||, CODE, READONLY, ALIGN=2

                  ulTaskNotifyTake PROC
;;;4194   
;;;4195   	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;4196   	{
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;4197   	uint32_t ulReturn;
;;;4198   
;;;4199   		taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;4200   		{
;;;4201   			/* Only block if the notification count is not already non-zero. */
;;;4202   			if( pxCurrentTCB->ulNotifiedValue == 0UL )
00000a  4818              LDR      r0,|L16.108|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  6dc0              LDR      r0,[r0,#0x5c]
000010  b988              CBNZ     r0,|L16.54|
;;;4203   			{
;;;4204   				/* Mark this task as waiting for a notification. */
;;;4205   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
000012  2001              MOVS     r0,#1
000014  4915              LDR      r1,|L16.108|
000016  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000018  f8810060          STRB     r0,[r1,#0x60]
;;;4206   
;;;4207   				if( xTicksToWait > ( TickType_t ) 0 )
00001c  b15d              CBZ      r5,|L16.54|
;;;4208   				{
;;;4209   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00001e  2101              MOVS     r1,#1
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4210   					traceTASK_NOTIFY_TAKE_BLOCK();
;;;4211   
;;;4212   					/* All ports are written to allow a yield in a critical
;;;4213   					section (some will yield immediately, others wait until the
;;;4214   					critical section exits) - but it is not something that
;;;4215   					application code should ever do. */
;;;4216   					portYIELD_WITHIN_API();
000026  f04f5080          MOV      r0,#0x10000000
00002a  4911              LDR      r1,|L16.112|
00002c  6008              STR      r0,[r1,#0]
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
                  |L16.54|
;;;4217   				}
;;;4218   				else
;;;4219   				{
;;;4220   					mtCOVERAGE_TEST_MARKER();
;;;4221   				}
;;;4222   			}
;;;4223   			else
;;;4224   			{
;;;4225   				mtCOVERAGE_TEST_MARKER();
;;;4226   			}
;;;4227   		}
;;;4228   		taskEXIT_CRITICAL();
000036  f7fffffe          BL       vPortExitCritical
;;;4229   
;;;4230   		taskENTER_CRITICAL();
00003a  f7fffffe          BL       vPortEnterCritical
;;;4231   		{
;;;4232   			traceTASK_NOTIFY_TAKE();
;;;4233   			ulReturn = pxCurrentTCB->ulNotifiedValue;
00003e  480b              LDR      r0,|L16.108|
000040  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000042  6dc4              LDR      r4,[r0,#0x5c]
;;;4234   
;;;4235   			if( ulReturn != 0UL )
000044  b14c              CBZ      r4,|L16.90|
;;;4236   			{
;;;4237   				if( xClearCountOnExit != pdFALSE )
000046  b126              CBZ      r6,|L16.82|
;;;4238   				{
;;;4239   					pxCurrentTCB->ulNotifiedValue = 0UL;
000048  2000              MOVS     r0,#0
00004a  4908              LDR      r1,|L16.108|
00004c  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00004e  65c8              STR      r0,[r1,#0x5c]
000050  e003              B        |L16.90|
                  |L16.82|
;;;4240   				}
;;;4241   				else
;;;4242   				{
;;;4243   					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
000052  1e60              SUBS     r0,r4,#1
000054  4905              LDR      r1,|L16.108|
000056  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000058  65c8              STR      r0,[r1,#0x5c]
                  |L16.90|
;;;4244   				}
;;;4245   			}
;;;4246   			else
;;;4247   			{
;;;4248   				mtCOVERAGE_TEST_MARKER();
;;;4249   			}
;;;4250   
;;;4251   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00005a  2000              MOVS     r0,#0
00005c  4903              LDR      r1,|L16.108|
00005e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000060  f8810060          STRB     r0,[r1,#0x60]
;;;4252   		}
;;;4253   		taskEXIT_CRITICAL();
000064  f7fffffe          BL       vPortExitCritical
;;;4254   
;;;4255   		return ulReturn;
000068  4620              MOV      r0,r4
;;;4256   	}
00006a  bd70              POP      {r4-r6,pc}
;;;4257   
                          ENDP

                  |L16.108|
                          DCD      pxCurrentTCB
                  |L16.112|
                          DCD      0xe000ed04

                          AREA ||i.uxTaskGetNumberOfTasks||, CODE, READONLY, ALIGN=2

                  uxTaskGetNumberOfTasks PROC
;;;2172   
;;;2173   UBaseType_t uxTaskGetNumberOfTasks( void )
000000  4801              LDR      r0,|L17.8|
;;;2174   {
;;;2175   	/* A critical section is not required because the variables are of type
;;;2176   	BaseType_t. */
;;;2177   	return uxCurrentNumberOfTasks;
000002  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
;;;2178   }
000004  4770              BX       lr
;;;2179   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      uxCurrentNumberOfTasks

                          AREA ||i.uxTaskGetSystemState||, CODE, READONLY, ALIGN=2

                  uxTaskGetSystemState PROC
;;;2320   
;;;2321   	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2322   	{
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;2323   	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
00000a  2400              MOVS     r4,#0
00000c  2720              MOVS     r7,#0x20
;;;2324   
;;;2325   		vTaskSuspendAll();
00000e  f7fffffe          BL       vTaskSuspendAll
;;;2326   		{
;;;2327   			/* Is there a space in the array for each task in the system? */
;;;2328   			if( uxArraySize >= uxCurrentNumberOfTasks )
000012  4822              LDR      r0,|L18.156|
000014  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000016  4580              CMP      r8,r0
000018  d33b              BCC      |L18.146|
;;;2329   			{
;;;2330   				/* Fill in an TaskStatus_t structure with information on each
;;;2331   				task in the Ready state. */
;;;2332   				do
00001a  bf00              NOP      
                  |L18.28|
;;;2333   				{
;;;2334   					uxQueue--;
00001c  1e7f              SUBS     r7,r7,#1
;;;2335   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
00001e  eb070287          ADD      r2,r7,r7,LSL #2
000022  4b1f              LDR      r3,|L18.160|
000024  eb030182          ADD      r1,r3,r2,LSL #2
000028  eb0402c4          ADD      r2,r4,r4,LSL #3
00002c  eb050082          ADD      r0,r5,r2,LSL #2
000030  2201              MOVS     r2,#1
000032  f7fffffe          BL       prvListTasksWithinSingleList
000036  4404              ADD      r4,r4,r0
;;;2336   
;;;2337   				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000038  2f00              CMP      r7,#0
00003a  d1ef              BNE      |L18.28|
;;;2338   
;;;2339   				/* Fill in an TaskStatus_t structure with information on each
;;;2340   				task in the Blocked state. */
;;;2341   				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
00003c  eb0401c4          ADD      r1,r4,r4,LSL #3
000040  eb050081          ADD      r0,r5,r1,LSL #2
000044  2202              MOVS     r2,#2
000046  4917              LDR      r1,|L18.164|
000048  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
00004a  f7fffffe          BL       prvListTasksWithinSingleList
00004e  4404              ADD      r4,r4,r0
;;;2342   				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
000050  eb0401c4          ADD      r1,r4,r4,LSL #3
000054  eb050081          ADD      r0,r5,r1,LSL #2
000058  2202              MOVS     r2,#2
00005a  4913              LDR      r1,|L18.168|
00005c  6809              LDR      r1,[r1,#0]  ; pxOverflowDelayedTaskList
00005e  f7fffffe          BL       prvListTasksWithinSingleList
000062  4404              ADD      r4,r4,r0
;;;2343   
;;;2344   				#if( INCLUDE_vTaskDelete == 1 )
;;;2345   				{
;;;2346   					/* Fill in an TaskStatus_t structure with information on
;;;2347   					each task that has been deleted but not yet cleaned up. */
;;;2348   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
000064  eb0401c4          ADD      r1,r4,r4,LSL #3
000068  eb050081          ADD      r0,r5,r1,LSL #2
00006c  2204              MOVS     r2,#4
00006e  490f              LDR      r1,|L18.172|
000070  f7fffffe          BL       prvListTasksWithinSingleList
000074  4404              ADD      r4,r4,r0
;;;2349   				}
;;;2350   				#endif
;;;2351   
;;;2352   				#if ( INCLUDE_vTaskSuspend == 1 )
;;;2353   				{
;;;2354   					/* Fill in an TaskStatus_t structure with information on
;;;2355   					each task in the Suspended state. */
;;;2356   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
000076  eb0401c4          ADD      r1,r4,r4,LSL #3
00007a  eb050081          ADD      r0,r5,r1,LSL #2
00007e  2203              MOVS     r2,#3
000080  490b              LDR      r1,|L18.176|
000082  f7fffffe          BL       prvListTasksWithinSingleList
000086  4404              ADD      r4,r4,r0
;;;2357   				}
;;;2358   				#endif
;;;2359   
;;;2360   				#if ( configGENERATE_RUN_TIME_STATS == 1)
;;;2361   				{
;;;2362   					if( pulTotalRunTime != NULL )
000088  b11e              CBZ      r6,|L18.146|
;;;2363   					{
;;;2364   						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2365   							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
;;;2366   						#else
;;;2367   							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
00008a  490a              LDR      r1,|L18.180|
00008c  6808              LDR      r0,[r1,#0]  ; FreeRTOSRunTimeTicks
00008e  6849              LDR      r1,[r1,#4]  ; FreeRTOSRunTimeTicks
000090  6030              STR      r0,[r6,#0]
                  |L18.146|
;;;2368   						#endif
;;;2369   					}
;;;2370   				}
;;;2371   				#else
;;;2372   				{
;;;2373   					if( pulTotalRunTime != NULL )
;;;2374   					{
;;;2375   						*pulTotalRunTime = 0;
;;;2376   					}
;;;2377   				}
;;;2378   				#endif
;;;2379   			}
;;;2380   			else
;;;2381   			{
;;;2382   				mtCOVERAGE_TEST_MARKER();
;;;2383   			}
;;;2384   		}
;;;2385   		( void ) xTaskResumeAll();
000092  f7fffffe          BL       xTaskResumeAll
;;;2386   
;;;2387   		return uxTask;
000096  4620              MOV      r0,r4
;;;2388   	}
000098  e8bd81f0          POP      {r4-r8,pc}
;;;2389   
                          ENDP

                  |L18.156|
                          DCD      uxCurrentNumberOfTasks
                  |L18.160|
                          DCD      pxReadyTasksLists
                  |L18.164|
                          DCD      pxDelayedTaskList
                  |L18.168|
                          DCD      pxOverflowDelayedTaskList
                  |L18.172|
                          DCD      xTasksWaitingTermination
                  |L18.176|
                          DCD      xSuspendedTaskList
                  |L18.180|
                          DCD      FreeRTOSRunTimeTicks

                          AREA ||i.uxTaskGetTaskNumber||, CODE, READONLY, ALIGN=1

                  uxTaskGetTaskNumber PROC
;;;3083   
;;;3084   	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
000000  4601              MOV      r1,r0
;;;3085   	{
;;;3086   	UBaseType_t uxReturn;
;;;3087   	TCB_t *pxTCB;
;;;3088   
;;;3089   		if( xTask != NULL )
000002  b111              CBZ      r1,|L19.10|
;;;3090   		{
;;;3091   			pxTCB = ( TCB_t * ) xTask;
000004  460a              MOV      r2,r1
;;;3092   			uxReturn = pxTCB->uxTaskNumber;
000006  6cd0              LDR      r0,[r2,#0x4c]
000008  e000              B        |L19.12|
                  |L19.10|
;;;3093   		}
;;;3094   		else
;;;3095   		{
;;;3096   			uxReturn = 0U;
00000a  2000              MOVS     r0,#0
                  |L19.12|
;;;3097   		}
;;;3098   
;;;3099   		return uxReturn;
;;;3100   	}
00000c  4770              BX       lr
;;;3101   
                          ENDP


                          AREA ||i.uxTaskPriorityGet||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGet PROC
;;;1339   
;;;1340   	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;1341   	{
000002  4604              MOV      r4,r0
;;;1342   	TCB_t *pxTCB;
;;;1343   	UBaseType_t uxReturn;
;;;1344   
;;;1345   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1346   		{
;;;1347   			/* If null is passed in here then it is the priority of the that
;;;1348   			called uxTaskPriorityGet() that is being queried. */
;;;1349   			pxTCB = prvGetTCBFromHandle( xTask );
000008  b914              CBNZ     r4,|L20.16|
00000a  4805              LDR      r0,|L20.32|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L20.18|
                  |L20.16|
000010  4620              MOV      r0,r4
                  |L20.18|
000012  4606              MOV      r6,r0
;;;1350   			uxReturn = pxTCB->uxPriority;
000014  6af5              LDR      r5,[r6,#0x2c]
;;;1351   		}
;;;1352   		taskEXIT_CRITICAL();
000016  f7fffffe          BL       vPortExitCritical
;;;1353   
;;;1354   		return uxReturn;
00001a  4628              MOV      r0,r5
;;;1355   	}
00001c  bd70              POP      {r4-r6,pc}
;;;1356   
                          ENDP

00001e  0000              DCW      0x0000
                  |L20.32|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskPriorityGetFromISR||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGetFromISR PROC
;;;1361   
;;;1362   	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1363   	{
000004  4605              MOV      r5,r0
;;;1364   	TCB_t *pxTCB;
;;;1365   	UBaseType_t uxReturn, uxSavedInterruptState;
;;;1366   
;;;1367   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1368   		maximum	system call (or maximum API call) interrupt priority.
;;;1369   		Interrupts that are	above the maximum system call priority are keep
;;;1370   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1371   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1372   		is defined in FreeRTOSConfig.h then
;;;1373   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1374   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1375   		been assigned a priority above the configured maximum system call
;;;1376   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1377   		from interrupts	that have been assigned a priority at or (logically)
;;;1378   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1379   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1380   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1381   		provided on the following link:
;;;1382   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1383   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000006  f7fffffe          BL       vPortValidateInterruptPriority
;;;1384   
;;;1385   		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
00000a  bf00              NOP      
00000c  2160              MOVS     r1,#0x60
00000e  f3ef8011          MRS      r0,BASEPRI
000012  f3818811          MSR      BASEPRI,r1
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  4604              MOV      r4,r0
;;;1386   		{
;;;1387   			/* If null is passed in here then it is the priority of the calling
;;;1388   			task that is being queried. */
;;;1389   			pxTCB = prvGetTCBFromHandle( xTask );
000022  b915              CBNZ     r5,|L21.42|
000024  4806              LDR      r0,|L21.64|
000026  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000028  e000              B        |L21.44|
                  |L21.42|
00002a  4628              MOV      r0,r5
                  |L21.44|
00002c  4607              MOV      r7,r0
;;;1390   			uxReturn = pxTCB->uxPriority;
00002e  6afe              LDR      r6,[r7,#0x2c]
;;;1391   		}
;;;1392   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
000030  bf00              NOP      
000032  f3848811          MSR      BASEPRI,r4
000036  bf00              NOP      
;;;1393   
;;;1394   		return uxReturn;
000038  4630              MOV      r0,r6
;;;1395   	}
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;1396   
                          ENDP

00003e  0000              DCW      0x0000
                  |L21.64|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskResetEventItemValue||, CODE, READONLY, ALIGN=2

                  uxTaskResetEventItemValue PROC
;;;4161   
;;;4162   TickType_t uxTaskResetEventItemValue( void )
000000  4905              LDR      r1,|L22.24|
;;;4163   {
;;;4164   TickType_t uxReturn;
;;;4165   
;;;4166   	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
000002  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000004  6988              LDR      r0,[r1,#0x18]
;;;4167   
;;;4168   	/* Reset the event list item to its normal value - so it can be used with
;;;4169   	queues and semaphores. */
;;;4170   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000006  4904              LDR      r1,|L22.24|
000008  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000a  6ac9              LDR      r1,[r1,#0x2c]
00000c  f1c10120          RSB      r1,r1,#0x20
000010  4a01              LDR      r2,|L22.24|
000012  6812              LDR      r2,[r2,#0]  ; pxCurrentTCB
000014  6191              STR      r1,[r2,#0x18]
;;;4171   
;;;4172   	return uxReturn;
;;;4173   }
000016  4770              BX       lr
;;;4174   /*-----------------------------------------------------------*/
                          ENDP

                  |L22.24|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskDelay||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vTaskDelay PROC
;;;1223   
;;;1224   	void vTaskDelay( const TickType_t xTicksToDelay )
000000  b570              PUSH     {r4-r6,lr}
;;;1225   	{
000002  4604              MOV      r4,r0
;;;1226   	BaseType_t xAlreadyYielded = pdFALSE;
000004  2500              MOVS     r5,#0
;;;1227   
;;;1228   		/* A delay time of zero just forces a reschedule. */
;;;1229   		if( xTicksToDelay > ( TickType_t ) 0U )
000006  b1ac              CBZ      r4,|L23.52|
;;;1230   		{
;;;1231   			configASSERT( uxSchedulerSuspended == 0 );
000008  480f              LDR      r0,|L23.72|
00000a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000c  b908              CBNZ     r0,|L23.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L23.20|
                  |L23.18|
000012  2000              MOVS     r0,#0
                  |L23.20|
000014  b928              CBNZ     r0,|L23.34|
000016  f24042cf          MOV      r2,#0x4cf
00001a  a10c              ADR      r1,|L23.76|
00001c  a010              ADR      r0,|L23.96|
00001e  f7fffffe          BL       __2printf
                  |L23.34|
;;;1232   			vTaskSuspendAll();
000022  f7fffffe          BL       vTaskSuspendAll
;;;1233   			{
;;;1234   				traceTASK_DELAY();
;;;1235   
;;;1236   				/* A task that is removed from the event list while the
;;;1237   				scheduler is suspended will not get placed in the ready
;;;1238   				list or removed from the blocked list until the scheduler
;;;1239   				is resumed.
;;;1240   
;;;1241   				This task cannot be in an event list as it is the currently
;;;1242   				executing task. */
;;;1243   				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
000026  2100              MOVS     r1,#0
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;1244   			}
;;;1245   			xAlreadyYielded = xTaskResumeAll();
00002e  f7fffffe          BL       xTaskResumeAll
000032  4605              MOV      r5,r0
                  |L23.52|
;;;1246   		}
;;;1247   		else
;;;1248   		{
;;;1249   			mtCOVERAGE_TEST_MARKER();
;;;1250   		}
;;;1251   
;;;1252   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1253   		have put ourselves to sleep. */
;;;1254   		if( xAlreadyYielded == pdFALSE )
000034  b93d              CBNZ     r5,|L23.70|
;;;1255   		{
;;;1256   			portYIELD_WITHIN_API();
000036  f04f5080          MOV      r0,#0x10000000
00003a  490d              LDR      r1,|L23.112|
00003c  6008              STR      r0,[r1,#0]
00003e  f3bf8f4f          DSB      
000042  f3bf8f6f          ISB      
                  |L23.70|
;;;1257   		}
;;;1258   		else
;;;1259   		{
;;;1260   			mtCOVERAGE_TEST_MARKER();
;;;1261   		}
;;;1262   	}
000046  bd70              POP      {r4-r6,pc}
;;;1263   
                          ENDP

                  |L23.72|
                          DCD      uxSchedulerSuspended
                  |L23.76|
00004c  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
000050  72656552
000054  544f535c
000058  7461736b
00005c  732e6300
                  |L23.96|
000060  4572726f          DCB      "Error:%s,%d\r\n",0
000064  723a2573
000068  2c25640d
00006c  0a00    
00006e  00                DCB      0
00006f  00                DCB      0
                  |L23.112|
                          DCD      0xe000ed04

                          AREA ||i.vTaskDelayUntil||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  vTaskDelayUntil PROC
;;;1139   
;;;1140   	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1141   	{
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;1142   	TickType_t xTimeToWake;
;;;1143   	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
000008  f04f0900          MOV      r9,#0
;;;1144   
;;;1145   		configASSERT( pxPreviousWakeTime );
00000c  b92c              CBNZ     r4,|L24.26|
00000e  f2404279          MOV      r2,#0x479
000012  a126              ADR      r1,|L24.172|
000014  a02a              ADR      r0,|L24.192|
000016  f7fffffe          BL       __2printf
                  |L24.26|
;;;1146   		configASSERT( ( xTimeIncrement > 0U ) );
00001a  b10f              CBZ      r7,|L24.32|
00001c  2001              MOVS     r0,#1
00001e  e000              B        |L24.34|
                  |L24.32|
000020  2000              MOVS     r0,#0
                  |L24.34|
000022  b928              CBNZ     r0,|L24.48|
000024  f240427a          MOV      r2,#0x47a
000028  a120              ADR      r1,|L24.172|
00002a  a025              ADR      r0,|L24.192|
00002c  f7fffffe          BL       __2printf
                  |L24.48|
;;;1147   		configASSERT( uxSchedulerSuspended == 0 );
000030  4827              LDR      r0,|L24.208|
000032  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000034  b908              CBNZ     r0,|L24.58|
000036  2001              MOVS     r0,#1
000038  e000              B        |L24.60|
                  |L24.58|
00003a  2000              MOVS     r0,#0
                  |L24.60|
00003c  b928              CBNZ     r0,|L24.74|
00003e  f240427b          MOV      r2,#0x47b
000042  a11a              ADR      r1,|L24.172|
000044  a01e              ADR      r0,|L24.192|
000046  f7fffffe          BL       __2printf
                  |L24.74|
;;;1148   
;;;1149   		vTaskSuspendAll();
00004a  f7fffffe          BL       vTaskSuspendAll
;;;1150   		{
;;;1151   			/* Minor optimisation.  The tick count cannot change in this
;;;1152   			block. */
;;;1153   			const TickType_t xConstTickCount = xTickCount;
00004e  4821              LDR      r0,|L24.212|
000050  6806              LDR      r6,[r0,#0]  ; xTickCount
;;;1154   
;;;1155   			/* Generate the tick time at which the task wants to wake. */
;;;1156   			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
000052  6820              LDR      r0,[r4,#0]
000054  19c5              ADDS     r5,r0,r7
;;;1157   
;;;1158   			if( xConstTickCount < *pxPreviousWakeTime )
000056  6820              LDR      r0,[r4,#0]
000058  42b0              CMP      r0,r6
00005a  d907              BLS      |L24.108|
;;;1159   			{
;;;1160   				/* The tick count has overflowed since this function was
;;;1161   				lasted called.  In this case the only time we should ever
;;;1162   				actually delay is if the wake time has also	overflowed,
;;;1163   				and the wake time is greater than the tick time.  When this
;;;1164   				is the case it is as if neither time had overflowed. */
;;;1165   				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
00005c  6820              LDR      r0,[r4,#0]
00005e  42a8              CMP      r0,r5
000060  d90b              BLS      |L24.122|
000062  42b5              CMP      r5,r6
000064  d909              BLS      |L24.122|
;;;1166   				{
;;;1167   					xShouldDelay = pdTRUE;
000066  f04f0901          MOV      r9,#1
00006a  e006              B        |L24.122|
                  |L24.108|
;;;1168   				}
;;;1169   				else
;;;1170   				{
;;;1171   					mtCOVERAGE_TEST_MARKER();
;;;1172   				}
;;;1173   			}
;;;1174   			else
;;;1175   			{
;;;1176   				/* The tick time has not overflowed.  In this case we will
;;;1177   				delay if either the wake time has overflowed, and/or the
;;;1178   				tick time is less than the wake time. */
;;;1179   				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
00006c  6820              LDR      r0,[r4,#0]
00006e  42a8              CMP      r0,r5
000070  d801              BHI      |L24.118|
000072  42b5              CMP      r5,r6
000074  d901              BLS      |L24.122|
                  |L24.118|
;;;1180   				{
;;;1181   					xShouldDelay = pdTRUE;
000076  f04f0901          MOV      r9,#1
                  |L24.122|
;;;1182   				}
;;;1183   				else
;;;1184   				{
;;;1185   					mtCOVERAGE_TEST_MARKER();
;;;1186   				}
;;;1187   			}
;;;1188   
;;;1189   			/* Update the wake time ready for the next call. */
;;;1190   			*pxPreviousWakeTime = xTimeToWake;
00007a  6025              STR      r5,[r4,#0]
;;;1191   
;;;1192   			if( xShouldDelay != pdFALSE )
00007c  f1b90f00          CMP      r9,#0
000080  d003              BEQ      |L24.138|
;;;1193   			{
;;;1194   				traceTASK_DELAY_UNTIL( xTimeToWake );
;;;1195   
;;;1196   				/* prvAddCurrentTaskToDelayedList() needs the block time, not
;;;1197   				the time to wake, so subtract the current tick count. */
;;;1198   				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
000082  1ba8              SUBS     r0,r5,r6
000084  2100              MOVS     r1,#0
000086  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L24.138|
;;;1199   			}
;;;1200   			else
;;;1201   			{
;;;1202   				mtCOVERAGE_TEST_MARKER();
;;;1203   			}
;;;1204   		}
;;;1205   		xAlreadyYielded = xTaskResumeAll();
00008a  f7fffffe          BL       xTaskResumeAll
00008e  4680              MOV      r8,r0
;;;1206   
;;;1207   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1208   		have put ourselves to sleep. */
;;;1209   		if( xAlreadyYielded == pdFALSE )
000090  f1b80f00          CMP      r8,#0
000094  d107              BNE      |L24.166|
;;;1210   		{
;;;1211   			portYIELD_WITHIN_API();
000096  f04f5080          MOV      r0,#0x10000000
00009a  490f              LDR      r1,|L24.216|
00009c  6008              STR      r0,[r1,#0]
00009e  f3bf8f4f          DSB      
0000a2  f3bf8f6f          ISB      
                  |L24.166|
;;;1212   		}
;;;1213   		else
;;;1214   		{
;;;1215   			mtCOVERAGE_TEST_MARKER();
;;;1216   		}
;;;1217   	}
0000a6  e8bd87f0          POP      {r4-r10,pc}
;;;1218   
                          ENDP

0000aa  0000              DCW      0x0000
                  |L24.172|
0000ac  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
0000b0  72656552
0000b4  544f535c
0000b8  7461736b
0000bc  732e6300
                  |L24.192|
0000c0  4572726f          DCB      "Error:%s,%d\r\n",0
0000c4  723a2573
0000c8  2c25640d
0000cc  0a00    
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L24.208|
                          DCD      uxSchedulerSuspended
                  |L24.212|
                          DCD      xTickCount
                  |L24.216|
                          DCD      0xe000ed04

                          AREA ||i.vTaskDelete||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vTaskDelete PROC
;;;1047   
;;;1048   	void vTaskDelete( TaskHandle_t xTaskToDelete )
000000  b570              PUSH     {r4-r6,lr}
;;;1049   	{
000002  4605              MOV      r5,r0
;;;1050   	TCB_t *pxTCB;
;;;1051   
;;;1052   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1053   		{
;;;1054   			/* If null is passed in here then it is the calling task that is
;;;1055   			being deleted. */
;;;1056   			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
000008  b915              CBNZ     r5,|L25.16|
00000a  482d              LDR      r0,|L25.192|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L25.18|
                  |L25.16|
000010  4628              MOV      r0,r5
                  |L25.18|
000012  4604              MOV      r4,r0
;;;1057   
;;;1058   			/* Remove task from the ready list. */
;;;1059   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000014  1d20              ADDS     r0,r4,#4
000016  f7fffffe          BL       uxListRemove
00001a  b978              CBNZ     r0,|L25.60|
;;;1060   			{
;;;1061   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00001c  6ae0              LDR      r0,[r4,#0x2c]
00001e  eb000080          ADD      r0,r0,r0,LSL #2
000022  4928              LDR      r1,|L25.196|
000024  f8510020          LDR      r0,[r1,r0,LSL #2]
000028  b940              CBNZ     r0,|L25.60|
00002a  f894102c          LDRB     r1,[r4,#0x2c]
00002e  2001              MOVS     r0,#1
000030  4088              LSLS     r0,r0,r1
000032  4925              LDR      r1,|L25.200|
000034  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000036  4381              BICS     r1,r1,r0
000038  4823              LDR      r0,|L25.200|
00003a  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L25.60|
;;;1062   			}
;;;1063   			else
;;;1064   			{
;;;1065   				mtCOVERAGE_TEST_MARKER();
;;;1066   			}
;;;1067   
;;;1068   			/* Is the task waiting on an event also? */
;;;1069   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00003c  6aa0              LDR      r0,[r4,#0x28]
00003e  b118              CBZ      r0,|L25.72|
;;;1070   			{
;;;1071   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000040  f1040018          ADD      r0,r4,#0x18
000044  f7fffffe          BL       uxListRemove
                  |L25.72|
;;;1072   			}
;;;1073   			else
;;;1074   			{
;;;1075   				mtCOVERAGE_TEST_MARKER();
;;;1076   			}
;;;1077   
;;;1078   			/* Increment the uxTaskNumber also so kernel aware debuggers can
;;;1079   			detect that the task lists need re-generating.  This is done before
;;;1080   			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
;;;1081   			not return. */
;;;1082   			uxTaskNumber++;
000048  4820              LDR      r0,|L25.204|
00004a  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
00004c  1c40              ADDS     r0,r0,#1
00004e  491f              LDR      r1,|L25.204|
000050  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;1083   
;;;1084   			if( pxTCB == pxCurrentTCB )
000052  481b              LDR      r0,|L25.192|
000054  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000056  4284              CMP      r4,r0
000058  d109              BNE      |L25.110|
;;;1085   			{
;;;1086   				/* A task is deleting itself.  This cannot complete within the
;;;1087   				task itself, as a context switch to another task is required.
;;;1088   				Place the task in the termination list.  The idle task will
;;;1089   				check the termination list and free up any memory allocated by
;;;1090   				the scheduler for the TCB and stack of the deleted task. */
;;;1091   				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
00005a  1d21              ADDS     r1,r4,#4
00005c  481c              LDR      r0,|L25.208|
00005e  f7fffffe          BL       vListInsertEnd
;;;1092   
;;;1093   				/* Increment the ucTasksDeleted variable so the idle task knows
;;;1094   				there is a task that has been deleted and that it should therefore
;;;1095   				check the xTasksWaitingTermination list. */
;;;1096   				++uxDeletedTasksWaitingCleanUp;
000062  481c              LDR      r0,|L25.212|
000064  6800              LDR      r0,[r0,#0]  ; uxDeletedTasksWaitingCleanUp
000066  1c40              ADDS     r0,r0,#1
000068  491a              LDR      r1,|L25.212|
00006a  6008              STR      r0,[r1,#0]  ; uxDeletedTasksWaitingCleanUp
00006c  e009              B        |L25.130|
                  |L25.110|
;;;1097   
;;;1098   				/* The pre-delete hook is primarily for the Windows simulator,
;;;1099   				in which Windows specific clean up operations are performed,
;;;1100   				after which it is not possible to yield away from this task -
;;;1101   				hence xYieldPending is used to latch that a context switch is
;;;1102   				required. */
;;;1103   				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
;;;1104   			}
;;;1105   			else
;;;1106   			{
;;;1107   				--uxCurrentNumberOfTasks;
00006e  481a              LDR      r0,|L25.216|
000070  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000072  1e40              SUBS     r0,r0,#1
000074  4918              LDR      r1,|L25.216|
000076  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;1108   				prvDeleteTCB( pxTCB );
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       prvDeleteTCB
;;;1109   
;;;1110   				/* Reset the next expected unblock time in case it referred to
;;;1111   				the task that has just been deleted. */
;;;1112   				prvResetNextTaskUnblockTime();
00007e  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L25.130|
;;;1113   			}
;;;1114   
;;;1115   			traceTASK_DELETE( pxTCB );
;;;1116   		}
;;;1117   		taskEXIT_CRITICAL();
000082  f7fffffe          BL       vPortExitCritical
;;;1118   
;;;1119   		/* Force a reschedule if it is the currently running task that has just
;;;1120   		been deleted. */
;;;1121   		if( xSchedulerRunning != pdFALSE )
000086  4815              LDR      r0,|L25.220|
000088  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00008a  b1c0              CBZ      r0,|L25.190|
;;;1122   		{
;;;1123   			if( pxTCB == pxCurrentTCB )
00008c  480c              LDR      r0,|L25.192|
00008e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000090  4284              CMP      r4,r0
000092  d114              BNE      |L25.190|
;;;1124   			{
;;;1125   				configASSERT( uxSchedulerSuspended == 0 );
000094  4812              LDR      r0,|L25.224|
000096  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000098  b908              CBNZ     r0,|L25.158|
00009a  2001              MOVS     r0,#1
00009c  e000              B        |L25.160|
                  |L25.158|
00009e  2000              MOVS     r0,#0
                  |L25.160|
0000a0  b928              CBNZ     r0,|L25.174|
0000a2  f2404265          MOV      r2,#0x465
0000a6  a10f              ADR      r1,|L25.228|
0000a8  a013              ADR      r0,|L25.248|
0000aa  f7fffffe          BL       __2printf
                  |L25.174|
;;;1126   				portYIELD_WITHIN_API();
0000ae  f04f5080          MOV      r0,#0x10000000
0000b2  4915              LDR      r1,|L25.264|
0000b4  6008              STR      r0,[r1,#0]
0000b6  f3bf8f4f          DSB      
0000ba  f3bf8f6f          ISB      
                  |L25.190|
;;;1127   			}
;;;1128   			else
;;;1129   			{
;;;1130   				mtCOVERAGE_TEST_MARKER();
;;;1131   			}
;;;1132   		}
;;;1133   	}
0000be  bd70              POP      {r4-r6,pc}
;;;1134   
                          ENDP

                  |L25.192|
                          DCD      pxCurrentTCB
                  |L25.196|
                          DCD      pxReadyTasksLists
                  |L25.200|
                          DCD      uxTopReadyPriority
                  |L25.204|
                          DCD      uxTaskNumber
                  |L25.208|
                          DCD      xTasksWaitingTermination
                  |L25.212|
                          DCD      uxDeletedTasksWaitingCleanUp
                  |L25.216|
                          DCD      uxCurrentNumberOfTasks
                  |L25.220|
                          DCD      xSchedulerRunning
                  |L25.224|
                          DCD      uxSchedulerSuspended
                  |L25.228|
0000e4  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
0000e8  72656552
0000ec  544f535c
0000f0  7461736b
0000f4  732e6300
                  |L25.248|
0000f8  4572726f          DCB      "Error:%s,%d\r\n",0
0000fc  723a2573
000100  2c25640d
000104  0a00    
000106  00                DCB      0
000107  00                DCB      0
                  |L25.264|
                          DCD      0xe000ed04

                          AREA ||i.vTaskEndScheduler||, CODE, READONLY, ALIGN=2

                  vTaskEndScheduler PROC
;;;1932   
;;;1933   void vTaskEndScheduler( void )
000000  b510              PUSH     {r4,lr}
;;;1934   {
;;;1935   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;1936   	routine so the original ISRs can be restored if necessary.  The port
;;;1937   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;1938   	portDISABLE_INTERRUPTS();
000002  bf00              NOP      
000004  2060              MOVS     r0,#0x60
000006  f3808811          MSR      BASEPRI,r0
00000a  f3bf8f4f          DSB      
00000e  f3bf8f6f          ISB      
000012  bf00              NOP      
;;;1939   	xSchedulerRunning = pdFALSE;
000014  2000              MOVS     r0,#0
000016  4902              LDR      r1,|L26.32|
000018  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;1940   	vPortEndScheduler();
00001a  f7fffffe          BL       vPortEndScheduler
;;;1941   }
00001e  bd10              POP      {r4,pc}
;;;1942   /*----------------------------------------------------------*/
                          ENDP

                  |L26.32|
                          DCD      xSchedulerRunning

                          AREA ||i.vTaskGetInfo||, CODE, READONLY, ALIGN=2

                  vTaskGetInfo PROC
;;;3410   
;;;3411   	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3412   	{
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
;;;3413   	TCB_t *pxTCB;
;;;3414   
;;;3415   		/* xTask is NULL then get the state of the calling task. */
;;;3416   		pxTCB = prvGetTCBFromHandle( xTask );
00000c  b917              CBNZ     r7,|L27.20|
00000e  4819              LDR      r0,|L27.116|
000010  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000012  e000              B        |L27.22|
                  |L27.20|
000014  4638              MOV      r0,r7
                  |L27.22|
000016  4605              MOV      r5,r0
;;;3417   
;;;3418   		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
000018  6025              STR      r5,[r4,#0]
;;;3419   		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
00001a  f1050034          ADD      r0,r5,#0x34
00001e  6060              STR      r0,[r4,#4]
;;;3420   		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
000020  6ae8              LDR      r0,[r5,#0x2c]
000022  6120              STR      r0,[r4,#0x10]
;;;3421   		pxTaskStatus->pxStackBase = pxTCB->pxStack;
000024  6b28              LDR      r0,[r5,#0x30]
000026  61e0              STR      r0,[r4,#0x1c]
;;;3422   		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
000028  6ca8              LDR      r0,[r5,#0x48]
00002a  60a0              STR      r0,[r4,#8]
;;;3423   
;;;3424   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;3425   		{
;;;3426   			/* If the task is in the suspended list then there is a chance it is
;;;3427   			actually just blocked indefinitely - so really it should be reported as
;;;3428   			being in the Blocked state. */
;;;3429   			if( pxTaskStatus->eCurrentState == eSuspended )
00002c  7b20              LDRB     r0,[r4,#0xc]
00002e  2803              CMP      r0,#3
000030  d107              BNE      |L27.66|
;;;3430   			{
;;;3431   				vTaskSuspendAll();
000032  f7fffffe          BL       vTaskSuspendAll
;;;3432   				{
;;;3433   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000036  6aa8              LDR      r0,[r5,#0x28]
000038  b108              CBZ      r0,|L27.62|
;;;3434   					{
;;;3435   						pxTaskStatus->eCurrentState = eBlocked;
00003a  2002              MOVS     r0,#2
00003c  7320              STRB     r0,[r4,#0xc]
                  |L27.62|
;;;3436   					}
;;;3437   				}
;;;3438   				xTaskResumeAll();
00003e  f7fffffe          BL       xTaskResumeAll
                  |L27.66|
;;;3439   			}
;;;3440   		}
;;;3441   		#endif /* INCLUDE_vTaskSuspend */
;;;3442   
;;;3443   		#if ( configUSE_MUTEXES == 1 )
;;;3444   		{
;;;3445   			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
000042  6d28              LDR      r0,[r5,#0x50]
000044  6160              STR      r0,[r4,#0x14]
;;;3446   		}
;;;3447   		#else
;;;3448   		{
;;;3449   			pxTaskStatus->uxBasePriority = 0;
;;;3450   		}
;;;3451   		#endif
;;;3452   
;;;3453   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;3454   		{
;;;3455   			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
000046  6da8              LDR      r0,[r5,#0x58]
000048  61a0              STR      r0,[r4,#0x18]
;;;3456   		}
;;;3457   		#else
;;;3458   		{
;;;3459   			pxTaskStatus->ulRunTimeCounter = 0;
;;;3460   		}
;;;3461   		#endif
;;;3462   
;;;3463   		/* Obtaining the task state is a little fiddly, so is only done if the value
;;;3464   		of eState passed into this function is eInvalid - otherwise the state is
;;;3465   		just set to whatever is passed in. */
;;;3466   		if( eState != eInvalid )
00004a  2e05              CMP      r6,#5
00004c  d001              BEQ      |L27.82|
;;;3467   		{
;;;3468   			pxTaskStatus->eCurrentState = eState;
00004e  7326              STRB     r6,[r4,#0xc]
000050  e003              B        |L27.90|
                  |L27.82|
;;;3469   		}
;;;3470   		else
;;;3471   		{
;;;3472   			pxTaskStatus->eCurrentState = eTaskGetState( xTask );
000052  4638              MOV      r0,r7
000054  f7fffffe          BL       eTaskGetState
000058  7320              STRB     r0,[r4,#0xc]
                  |L27.90|
;;;3473   		}
;;;3474   
;;;3475   		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
;;;3476   		parameter is provided to allow it to be skipped. */
;;;3477   		if( xGetFreeStackSpace != pdFALSE )
00005a  f1b80f00          CMP      r8,#0
00005e  d004              BEQ      |L27.106|
;;;3478   		{
;;;3479   			#if ( portSTACK_GROWTH > 0 )
;;;3480   			{
;;;3481   				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
;;;3482   			}
;;;3483   			#else
;;;3484   			{
;;;3485   				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
000060  6b28              LDR      r0,[r5,#0x30]
000062  f7fffffe          BL       prvTaskCheckFreeStackSpace
000066  8420              STRH     r0,[r4,#0x20]
000068  e001              B        |L27.110|
                  |L27.106|
;;;3486   			}
;;;3487   			#endif
;;;3488   		}
;;;3489   		else
;;;3490   		{
;;;3491   			pxTaskStatus->usStackHighWaterMark = 0;
00006a  2000              MOVS     r0,#0
00006c  8420              STRH     r0,[r4,#0x20]
                  |L27.110|
;;;3492   		}
;;;3493   	}
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;3494   
                          ENDP

000072  0000              DCW      0x0000
                  |L27.116|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskGetRunTimeStats||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_u
                          REQUIRE _printf_int_dec
                  vTaskGetRunTimeStats PROC
;;;4036   
;;;4037   	void vTaskGetRunTimeStats( char *pcWriteBuffer )
000000  b5fe              PUSH     {r1-r7,lr}
;;;4038   	{
000002  4605              MOV      r5,r0
;;;4039   	TaskStatus_t *pxTaskStatusArray;
;;;4040   	volatile UBaseType_t uxArraySize, x;
;;;4041   	uint32_t ulTotalTime, ulStatsAsPercentage;
;;;4042   
;;;4043   		#if( configUSE_TRACE_FACILITY != 1 )
;;;4044   		{
;;;4045   			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
;;;4046   		}
;;;4047   		#endif
;;;4048   
;;;4049   		/*
;;;4050   		 * PLEASE NOTE:
;;;4051   		 *
;;;4052   		 * This function is provided for convenience only, and is used by many
;;;4053   		 * of the demo applications.  Do not consider it to be part of the
;;;4054   		 * scheduler.
;;;4055   		 *
;;;4056   		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
;;;4057   		 * of the uxTaskGetSystemState() output into a human readable table that
;;;4058   		 * displays the amount of time each task has spent in the Running state
;;;4059   		 * in both absolute and percentage terms.
;;;4060   		 *
;;;4061   		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
;;;4062   		 * function that might bloat the code size, use a lot of stack, and
;;;4063   		 * provide different results on different platforms.  An alternative,
;;;4064   		 * tiny, third party, and limited functionality implementation of
;;;4065   		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
;;;4066   		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
;;;4067   		 * a full snprintf() implementation!).
;;;4068   		 *
;;;4069   		 * It is recommended that production systems call uxTaskGetSystemState()
;;;4070   		 * directly to get access to raw stats data, rather than indirectly
;;;4071   		 * through a call to vTaskGetRunTimeStats().
;;;4072   		 */
;;;4073   
;;;4074   		/* Make sure the write buffer does not contain a string. */
;;;4075   		*pcWriteBuffer = 0x00;
000004  2000              MOVS     r0,#0
000006  7028              STRB     r0,[r5,#0]
;;;4076   
;;;4077   		/* Take a snapshot of the number of tasks in case it changes while this
;;;4078   		function is executing. */
;;;4079   		uxArraySize = uxCurrentNumberOfTasks;
000008  482b              LDR      r0,|L28.184|
00000a  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
00000c  9002              STR      r0,[sp,#8]
;;;4080   
;;;4081   		/* Allocate an array index for each task.  NOTE!  If
;;;4082   		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
;;;4083   		equate to NULL. */
;;;4084   		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
00000e  492a              LDR      r1,|L28.184|
000010  6809              LDR      r1,[r1,#0]  ; uxCurrentNumberOfTasks
000012  eb0101c1          ADD      r1,r1,r1,LSL #3
000016  0088              LSLS     r0,r1,#2
000018  f7fffffe          BL       pvPortMalloc
00001c  4604              MOV      r4,r0
;;;4085   
;;;4086   		if( pxTaskStatusArray != NULL )
00001e  2c00              CMP      r4,#0
000020  d048              BEQ      |L28.180|
;;;4087   		{
;;;4088   			/* Generate the (binary) data. */
;;;4089   			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
000022  466a              MOV      r2,sp
000024  4620              MOV      r0,r4
000026  9902              LDR      r1,[sp,#8]
000028  f7fffffe          BL       uxTaskGetSystemState
00002c  9002              STR      r0,[sp,#8]
;;;4090   
;;;4091   			/* For percentage calculations. */
;;;4092   			ulTotalTime /= 100UL;
00002e  2164              MOVS     r1,#0x64
000030  9800              LDR      r0,[sp,#0]
000032  fbb0f0f1          UDIV     r0,r0,r1
000036  9000              STR      r0,[sp,#0]
;;;4093   
;;;4094   			/* Avoid divide by zero errors. */
;;;4095   			if( ulTotalTime > 0 )
000038  9800              LDR      r0,[sp,#0]
00003a  2800              CMP      r0,#0
00003c  d037              BEQ      |L28.174|
;;;4096   			{
;;;4097   				/* Create a human readable table from the binary data. */
;;;4098   				for( x = 0; x < uxArraySize; x++ )
00003e  2000              MOVS     r0,#0
000040  9001              STR      r0,[sp,#4]
000042  e030              B        |L28.166|
                  |L28.68|
;;;4099   				{
;;;4100   					/* What percentage of the total run time has the task used?
;;;4101   					This will always be rounded down to the nearest integer.
;;;4102   					ulTotalRunTimeDiv100 has already been divided by 100. */
;;;4103   					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
000044  9801              LDR      r0,[sp,#4]
000046  eb0000c0          ADD      r0,r0,r0,LSL #3
00004a  eb040080          ADD      r0,r4,r0,LSL #2
00004e  6980              LDR      r0,[r0,#0x18]
000050  9900              LDR      r1,[sp,#0]
000052  fbb0f6f1          UDIV     r6,r0,r1
;;;4104   
;;;4105   					/* Write the task name to the string, padding with
;;;4106   					spaces so it can be printed in tabular form more
;;;4107   					easily. */
;;;4108   					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
000056  9801              LDR      r0,[sp,#4]
000058  eb0000c0          ADD      r0,r0,r0,LSL #3
00005c  eb040080          ADD      r0,r4,r0,LSL #2
000060  6841              LDR      r1,[r0,#4]
000062  4628              MOV      r0,r5
000064  f7fffffe          BL       prvWriteNameToBuffer
000068  4605              MOV      r5,r0
;;;4109   
;;;4110   					if( ulStatsAsPercentage > 0UL )
00006a  b15e              CBZ      r6,|L28.132|
;;;4111   					{
;;;4112   						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
;;;4113   						{
;;;4114   							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
;;;4115   						}
;;;4116   						#else
;;;4117   						{
;;;4118   							/* sizeof( int ) == sizeof( long ) so a smaller
;;;4119   							printf() library can be used. */
;;;4120   							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
00006c  9801              LDR      r0,[sp,#4]
00006e  eb0000c0          ADD      r0,r0,r0,LSL #3
000072  eb040080          ADD      r0,r4,r0,LSL #2
000076  4633              MOV      r3,r6
000078  a110              ADR      r1,|L28.188|
00007a  6982              LDR      r2,[r0,#0x18]
00007c  4628              MOV      r0,r5
00007e  f7fffffe          BL       __2sprintf
000082  e009              B        |L28.152|
                  |L28.132|
;;;4121   						}
;;;4122   						#endif
;;;4123   					}
;;;4124   					else
;;;4125   					{
;;;4126   						/* If the percentage is zero here then the task has
;;;4127   						consumed less than 1% of the total run time. */
;;;4128   						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
;;;4129   						{
;;;4130   							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
;;;4131   						}
;;;4132   						#else
;;;4133   						{
;;;4134   							/* sizeof( int ) == sizeof( long ) so a smaller
;;;4135   							printf() library can be used. */
;;;4136   							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
000084  9801              LDR      r0,[sp,#4]
000086  eb0000c0          ADD      r0,r0,r0,LSL #3
00008a  eb040080          ADD      r0,r4,r0,LSL #2
00008e  a10e              ADR      r1,|L28.200|
000090  6982              LDR      r2,[r0,#0x18]
000092  4628              MOV      r0,r5
000094  f7fffffe          BL       __2sprintf
                  |L28.152|
;;;4137   						}
;;;4138   						#endif
;;;4139   					}
;;;4140   
;;;4141   					pcWriteBuffer += strlen( pcWriteBuffer );
000098  4628              MOV      r0,r5
00009a  f7fffffe          BL       strlen
00009e  4405              ADD      r5,r5,r0
0000a0  9801              LDR      r0,[sp,#4]            ;4098
0000a2  1c40              ADDS     r0,r0,#1              ;4098
0000a4  9001              STR      r0,[sp,#4]            ;4098
                  |L28.166|
0000a6  e9dd0101          LDRD     r0,r1,[sp,#4]         ;4098
0000aa  4288              CMP      r0,r1                 ;4098
0000ac  d3ca              BCC      |L28.68|
                  |L28.174|
;;;4142   				}
;;;4143   			}
;;;4144   			else
;;;4145   			{
;;;4146   				mtCOVERAGE_TEST_MARKER();
;;;4147   			}
;;;4148   
;;;4149   			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
;;;4150   			is 0 then vPortFree() will be #defined to nothing. */
;;;4151   			vPortFree( pxTaskStatusArray );
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       vPortFree
                  |L28.180|
;;;4152   		}
;;;4153   		else
;;;4154   		{
;;;4155   			mtCOVERAGE_TEST_MARKER();
;;;4156   		}
;;;4157   	}
0000b4  bdfe              POP      {r1-r7,pc}
;;;4158   
                          ENDP

0000b6  0000              DCW      0x0000
                  |L28.184|
                          DCD      uxCurrentNumberOfTasks
                  |L28.188|
0000bc  09257509          DCB      "\t%u\t\t%u%%\r\n",0
0000c0  09257525
0000c4  250d0a00
                  |L28.200|
0000c8  09257509          DCB      "\t%u\t\t<1%%\r\n",0
0000cc  093c3125
0000d0  250d0a00

                          AREA ||i.vTaskList||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_u
                          REQUIRE _printf_c
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vTaskList PROC
;;;3941   
;;;3942   	void vTaskList( char * pcWriteBuffer )
000000  b57f              PUSH     {r0-r6,lr}
;;;3943   	{
000002  4605              MOV      r5,r0
;;;3944   	TaskStatus_t *pxTaskStatusArray;
;;;3945   	volatile UBaseType_t uxArraySize, x;
;;;3946   	char cStatus;
;;;3947   
;;;3948   		/*
;;;3949   		 * PLEASE NOTE:
;;;3950   		 *
;;;3951   		 * This function is provided for convenience only, and is used by many
;;;3952   		 * of the demo applications.  Do not consider it to be part of the
;;;3953   		 * scheduler.
;;;3954   		 *
;;;3955   		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
;;;3956   		 * uxTaskGetSystemState() output into a human readable table that
;;;3957   		 * displays task names, states and stack usage.
;;;3958   		 *
;;;3959   		 * vTaskList() has a dependency on the sprintf() C library function that
;;;3960   		 * might bloat the code size, use a lot of stack, and provide different
;;;3961   		 * results on different platforms.  An alternative, tiny, third party,
;;;3962   		 * and limited functionality implementation of sprintf() is provided in
;;;3963   		 * many of the FreeRTOS/Demo sub-directories in a file called
;;;3964   		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
;;;3965   		 * snprintf() implementation!).
;;;3966   		 *
;;;3967   		 * It is recommended that production systems call uxTaskGetSystemState()
;;;3968   		 * directly to get access to raw stats data, rather than indirectly
;;;3969   		 * through a call to vTaskList().
;;;3970   		 */
;;;3971   
;;;3972   
;;;3973   		/* Make sure the write buffer does not contain a string. */
;;;3974   		*pcWriteBuffer = 0x00;
000004  2000              MOVS     r0,#0
000006  7028              STRB     r0,[r5,#0]
;;;3975   
;;;3976   		/* Take a snapshot of the number of tasks in case it changes while this
;;;3977   		function is executing. */
;;;3978   		uxArraySize = uxCurrentNumberOfTasks;
000008  4830              LDR      r0,|L29.204|
00000a  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
00000c  9003              STR      r0,[sp,#0xc]
;;;3979   
;;;3980   		/* Allocate an array index for each task.  NOTE!  if
;;;3981   		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
;;;3982   		equate to NULL. */
;;;3983   		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
00000e  492f              LDR      r1,|L29.204|
000010  6809              LDR      r1,[r1,#0]  ; uxCurrentNumberOfTasks
000012  eb0101c1          ADD      r1,r1,r1,LSL #3
000016  0088              LSLS     r0,r1,#2
000018  f7fffffe          BL       pvPortMalloc
00001c  4604              MOV      r4,r0
;;;3984   
;;;3985   		if( pxTaskStatusArray != NULL )
00001e  2c00              CMP      r4,#0
000020  d053              BEQ      |L29.202|
;;;3986   		{
;;;3987   			/* Generate the (binary) data. */
;;;3988   			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
000022  2200              MOVS     r2,#0
000024  4620              MOV      r0,r4
000026  9903              LDR      r1,[sp,#0xc]
000028  f7fffffe          BL       uxTaskGetSystemState
00002c  9003              STR      r0,[sp,#0xc]
;;;3989   
;;;3990   			/* Create a human readable table from the binary data. */
;;;3991   			for( x = 0; x < uxArraySize; x++ )
00002e  2000              MOVS     r0,#0
000030  9002              STR      r0,[sp,#8]
000032  e043              B        |L29.188|
                  |L29.52|
;;;3992   			{
;;;3993   				switch( pxTaskStatusArray[ x ].eCurrentState )
000034  9802              LDR      r0,[sp,#8]
000036  eb0000c0          ADD      r0,r0,r0,LSL #3
00003a  eb040080          ADD      r0,r4,r0,LSL #2
00003e  7b00              LDRB     r0,[r0,#0xc]
000040  2801              CMP      r0,#1
000042  d006              BEQ      |L29.82|
000044  2802              CMP      r0,#2
000046  d006              BEQ      |L29.86|
000048  2803              CMP      r0,#3
00004a  d006              BEQ      |L29.90|
00004c  2804              CMP      r0,#4
00004e  d108              BNE      |L29.98|
000050  e005              B        |L29.94|
                  |L29.82|
;;;3994   				{
;;;3995   					case eReady:		cStatus = tskREADY_CHAR;
000052  2652              MOVS     r6,#0x52
;;;3996   										break;
000054  e007              B        |L29.102|
                  |L29.86|
;;;3997   
;;;3998   					case eBlocked:		cStatus = tskBLOCKED_CHAR;
000056  2642              MOVS     r6,#0x42
;;;3999   										break;
000058  e005              B        |L29.102|
                  |L29.90|
;;;4000   
;;;4001   					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
00005a  2653              MOVS     r6,#0x53
;;;4002   										break;
00005c  e003              B        |L29.102|
                  |L29.94|
;;;4003   
;;;4004   					case eDeleted:		cStatus = tskDELETED_CHAR;
00005e  2644              MOVS     r6,#0x44
;;;4005   										break;
000060  e001              B        |L29.102|
                  |L29.98|
;;;4006   
;;;4007   					default:			/* Should not get here, but it is included
;;;4008   										to prevent static checking errors. */
;;;4009   										cStatus = 0x00;
000062  2600              MOVS     r6,#0
;;;4010   										break;
000064  bf00              NOP      
                  |L29.102|
000066  bf00              NOP                            ;3996
;;;4011   				}
;;;4012   
;;;4013   				/* Write the task name to the string, padding with spaces so it
;;;4014   				can be printed in tabular form more easily. */
;;;4015   				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
000068  9802              LDR      r0,[sp,#8]
00006a  eb0000c0          ADD      r0,r0,r0,LSL #3
00006e  eb040080          ADD      r0,r4,r0,LSL #2
000072  6841              LDR      r1,[r0,#4]
000074  4628              MOV      r0,r5
000076  f7fffffe          BL       prvWriteNameToBuffer
00007a  4605              MOV      r5,r0
;;;4016   
;;;4017   				/* Write the rest of the string. */
;;;4018   				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
00007c  9802              LDR      r0,[sp,#8]
00007e  eb0000c0          ADD      r0,r0,r0,LSL #3
000082  eb040080          ADD      r0,r4,r0,LSL #2
000086  6880              LDR      r0,[r0,#8]
000088  9902              LDR      r1,[sp,#8]
00008a  eb0101c1          ADD      r1,r1,r1,LSL #3
00008e  eb040181          ADD      r1,r4,r1,LSL #2
000092  8c09              LDRH     r1,[r1,#0x20]
000094  e9cd1000          STRD     r1,r0,[sp,#0]
000098  9802              LDR      r0,[sp,#8]
00009a  eb0000c0          ADD      r0,r0,r0,LSL #3
00009e  eb040080          ADD      r0,r4,r0,LSL #2
0000a2  4632              MOV      r2,r6
0000a4  a10a              ADR      r1,|L29.208|
0000a6  6903              LDR      r3,[r0,#0x10]
0000a8  4628              MOV      r0,r5
0000aa  f7fffffe          BL       __2sprintf
;;;4019   				pcWriteBuffer += strlen( pcWriteBuffer );
0000ae  4628              MOV      r0,r5
0000b0  f7fffffe          BL       strlen
0000b4  4405              ADD      r5,r5,r0
0000b6  9802              LDR      r0,[sp,#8]            ;3991
0000b8  1c40              ADDS     r0,r0,#1              ;3991
0000ba  9002              STR      r0,[sp,#8]            ;3991
                  |L29.188|
0000bc  e9dd0102          LDRD     r0,r1,[sp,#8]         ;3991
0000c0  4288              CMP      r0,r1                 ;3991
0000c2  d3b7              BCC      |L29.52|
;;;4020   			}
;;;4021   
;;;4022   			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
;;;4023   			is 0 then vPortFree() will be #defined to nothing. */
;;;4024   			vPortFree( pxTaskStatusArray );
0000c4  4620              MOV      r0,r4
0000c6  f7fffffe          BL       vPortFree
                  |L29.202|
;;;4025   		}
;;;4026   		else
;;;4027   		{
;;;4028   			mtCOVERAGE_TEST_MARKER();
;;;4029   		}
;;;4030   	}
0000ca  bd7f              POP      {r0-r6,pc}
;;;4031   
                          ENDP

                  |L29.204|
                          DCD      uxCurrentNumberOfTasks
                  |L29.208|
0000d0  09256309          DCB      "\t%c\t%u\t%u\t%u\r\n",0
0000d4  25750925
0000d8  75092575
0000dc  0d0a00  
0000df  00                DCB      0

                          AREA ||i.vTaskMissedYield||, CODE, READONLY, ALIGN=2

                  vTaskMissedYield PROC
;;;3075   
;;;3076   void vTaskMissedYield( void )
000000  2001              MOVS     r0,#1
;;;3077   {
;;;3078   	xYieldPending = pdTRUE;
000002  4901              LDR      r1,|L30.8|
000004  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;3079   }
000006  4770              BX       lr
;;;3080   /*-----------------------------------------------------------*/
                          ENDP

                  |L30.8|
                          DCD      xYieldPending

                          AREA ||i.vTaskNotifyGiveFromISR||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  vTaskNotifyGiveFromISR PROC
;;;4572   
;;;4573   	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4574   	{
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;4575   	TCB_t * pxTCB;
;;;4576   	uint8_t ucOriginalNotifyState;
;;;4577   	UBaseType_t uxSavedInterruptStatus;
;;;4578   
;;;4579   		configASSERT( xTaskToNotify );
000008  b92d              CBNZ     r5,|L31.22|
00000a  f24112e3          MOV      r2,#0x11e3
00000e  a12d              ADR      r1,|L31.196|
000010  a031              ADR      r0,|L31.216|
000012  f7fffffe          BL       __2printf
                  |L31.22|
;;;4580   
;;;4581   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4582   		maximum	system call (or maximum API call) interrupt priority.
;;;4583   		Interrupts that are	above the maximum system call priority are keep
;;;4584   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4585   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4586   		is defined in FreeRTOSConfig.h then
;;;4587   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4588   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4589   		been assigned a priority above the configured maximum system call
;;;4590   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4591   		from interrupts	that have been assigned a priority at or (logically)
;;;4592   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4593   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4594   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4595   		provided on the following link:
;;;4596   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4597   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000016  f7fffffe          BL       vPortValidateInterruptPriority
;;;4598   
;;;4599   		pxTCB = ( TCB_t * ) xTaskToNotify;
00001a  462c              MOV      r4,r5
;;;4600   
;;;4601   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00001c  bf00              NOP      
00001e  2160              MOVS     r1,#0x60
000020  f3ef8011          MRS      r0,BASEPRI
000024  f3818811          MSR      BASEPRI,r1
000028  f3bf8f4f          DSB      
00002c  f3bf8f6f          ISB      
000030  bf00              NOP      
000032  4606              MOV      r6,r0
;;;4602   		{
;;;4603   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000034  f8948060          LDRB     r8,[r4,#0x60]
;;;4604   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000038  2002              MOVS     r0,#2
00003a  f8840060          STRB     r0,[r4,#0x60]
;;;4605   
;;;4606   			/* 'Giving' is equivalent to incrementing a count in a counting
;;;4607   			semaphore. */
;;;4608   			( pxTCB->ulNotifiedValue )++;
00003e  6de0              LDR      r0,[r4,#0x5c]
000040  1c40              ADDS     r0,r0,#1
000042  65e0              STR      r0,[r4,#0x5c]
;;;4609   
;;;4610   			traceTASK_NOTIFY_GIVE_FROM_ISR();
;;;4611   
;;;4612   			/* If the task is in the blocked state specifically to wait for a
;;;4613   			notification then unblock it now. */
;;;4614   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
000044  f1b80f01          CMP      r8,#1
000048  d136              BNE      |L31.184|
;;;4615   			{
;;;4616   				/* The task should not have been on an event list. */
;;;4617   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
00004a  6aa0              LDR      r0,[r4,#0x28]
00004c  b908              CBNZ     r0,|L31.82|
00004e  2001              MOVS     r0,#1
000050  e000              B        |L31.84|
                  |L31.82|
000052  2000              MOVS     r0,#0
                  |L31.84|
000054  b928              CBNZ     r0,|L31.98|
000056  f2412209          MOV      r2,#0x1209
00005a  a11a              ADR      r1,|L31.196|
00005c  a01e              ADR      r0,|L31.216|
00005e  f7fffffe          BL       __2printf
                  |L31.98|
;;;4618   
;;;4619   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000062  4821              LDR      r0,|L31.232|
000064  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000066  b9a8              CBNZ     r0,|L31.148|
;;;4620   				{
;;;4621   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000068  1d20              ADDS     r0,r4,#4
00006a  f7fffffe          BL       uxListRemove
;;;4622   					prvAddTaskToReadyList( pxTCB );
00006e  f894102c          LDRB     r1,[r4,#0x2c]
000072  2001              MOVS     r0,#1
000074  4088              LSLS     r0,r0,r1
000076  491d              LDR      r1,|L31.236|
000078  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00007a  4308              ORRS     r0,r0,r1
00007c  491b              LDR      r1,|L31.236|
00007e  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000080  6ae1              LDR      r1,[r4,#0x2c]
000082  eb010181          ADD      r1,r1,r1,LSL #2
000086  4a1a              LDR      r2,|L31.240|
000088  eb020081          ADD      r0,r2,r1,LSL #2
00008c  1d21              ADDS     r1,r4,#4
00008e  f7fffffe          BL       vListInsertEnd
000092  e004              B        |L31.158|
                  |L31.148|
;;;4623   				}
;;;4624   				else
;;;4625   				{
;;;4626   					/* The delayed and ready lists cannot be accessed, so hold
;;;4627   					this task pending until the scheduler is resumed. */
;;;4628   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000094  f1040118          ADD      r1,r4,#0x18
000098  4816              LDR      r0,|L31.244|
00009a  f7fffffe          BL       vListInsertEnd
                  |L31.158|
;;;4629   				}
;;;4630   
;;;4631   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
00009e  4916              LDR      r1,|L31.248|
0000a0  6ae0              LDR      r0,[r4,#0x2c]
0000a2  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000a4  6ac9              LDR      r1,[r1,#0x2c]
0000a6  4288              CMP      r0,r1
0000a8  d906              BLS      |L31.184|
;;;4632   				{
;;;4633   					/* The notified task has a priority above the currently
;;;4634   					executing task so a yield is required. */
;;;4635   					if( pxHigherPriorityTaskWoken != NULL )
0000aa  b117              CBZ      r7,|L31.178|
;;;4636   					{
;;;4637   						*pxHigherPriorityTaskWoken = pdTRUE;
0000ac  2001              MOVS     r0,#1
0000ae  6038              STR      r0,[r7,#0]
0000b0  e002              B        |L31.184|
                  |L31.178|
;;;4638   					}
;;;4639   					else
;;;4640   					{
;;;4641   						/* Mark that a yield is pending in case the user is not
;;;4642   						using the "xHigherPriorityTaskWoken" parameter in an ISR
;;;4643   						safe FreeRTOS function. */
;;;4644   						xYieldPending = pdTRUE;
0000b2  2001              MOVS     r0,#1
0000b4  4911              LDR      r1,|L31.252|
0000b6  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L31.184|
;;;4645   					}
;;;4646   				}
;;;4647   				else
;;;4648   				{
;;;4649   					mtCOVERAGE_TEST_MARKER();
;;;4650   				}
;;;4651   			}
;;;4652   		}
;;;4653   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000b8  bf00              NOP      
0000ba  f3868811          MSR      BASEPRI,r6
0000be  bf00              NOP      
;;;4654   	}
0000c0  e8bd81f0          POP      {r4-r8,pc}
;;;4655   
                          ENDP

                  |L31.196|
0000c4  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
0000c8  72656552
0000cc  544f535c
0000d0  7461736b
0000d4  732e6300
                  |L31.216|
0000d8  4572726f          DCB      "Error:%s,%d\r\n",0
0000dc  723a2573
0000e0  2c25640d
0000e4  0a00    
0000e6  00                DCB      0
0000e7  00                DCB      0
                  |L31.232|
                          DCD      uxSchedulerSuspended
                  |L31.236|
                          DCD      uxTopReadyPriority
                  |L31.240|
                          DCD      pxReadyTasksLists
                  |L31.244|
                          DCD      xPendingReadyList
                  |L31.248|
                          DCD      pxCurrentTCB
                  |L31.252|
                          DCD      xYieldPending

                          AREA ||i.vTaskPlaceOnEventList||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vTaskPlaceOnEventList PROC
;;;2819   
;;;2820   void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;2821   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2822   	configASSERT( pxEventList );
000006  b92c              CBNZ     r4,|L32.20|
000008  f6403206          MOV      r2,#0xb06
00000c  a107              ADR      r1,|L32.44|
00000e  a00c              ADR      r0,|L32.64|
000010  f7fffffe          BL       __2printf
                  |L32.20|
;;;2823   
;;;2824   	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
;;;2825   	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
;;;2826   
;;;2827   	/* Place the event list item of the TCB in the appropriate event list.
;;;2828   	This is placed in the list in priority order so the highest priority task
;;;2829   	is the first to be woken by the event.  The queue that contains the event
;;;2830   	list is locked, preventing simultaneous access from interrupts. */
;;;2831   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000014  480e              LDR      r0,|L32.80|
000016  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000018  3118              ADDS     r1,r1,#0x18
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       vListInsert
;;;2832   
;;;2833   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000020  2101              MOVS     r1,#1
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;2834   }
000028  bd70              POP      {r4-r6,pc}
;;;2835   /*-----------------------------------------------------------*/
                          ENDP

00002a  0000              DCW      0x0000
                  |L32.44|
00002c  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
000030  72656552
000034  544f535c
000038  7461736b
00003c  732e6300
                  |L32.64|
000040  4572726f          DCB      "Error:%s,%d\r\n",0
000044  723a2573
000048  2c25640d
00004c  0a00    
00004e  00                DCB      0
00004f  00                DCB      0
                  |L32.80|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPlaceOnEventListRestricted||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vTaskPlaceOnEventListRestricted PROC
;;;2862   
;;;2863   	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
000000  b570              PUSH     {r4-r6,lr}
;;;2864   	{
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;2865   		configASSERT( pxEventList );
000008  b92d              CBNZ     r5,|L33.22|
00000a  f6403231          MOV      r2,#0xb31
00000e  a109              ADR      r1,|L33.52|
000010  a00d              ADR      r0,|L33.72|
000012  f7fffffe          BL       __2printf
                  |L33.22|
;;;2866   
;;;2867   		/* This function should not be called by application code hence the
;;;2868   		'Restricted' in its name.  It is not part of the public API.  It is
;;;2869   		designed for use by kernel code, and has special calling requirements -
;;;2870   		it should be called with the scheduler suspended. */
;;;2871   
;;;2872   
;;;2873   		/* Place the event list item of the TCB in the appropriate event list.
;;;2874   		In this case it is assume that this is the only task that is going to
;;;2875   		be waiting on this event list, so the faster vListInsertEnd() function
;;;2876   		can be used in place of vListInsert. */
;;;2877   		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000016  4810              LDR      r0,|L33.88|
000018  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00001a  3118              ADDS     r1,r1,#0x18
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       vListInsertEnd
;;;2878   
;;;2879   		/* If the task should block indefinitely then set the block time to a
;;;2880   		value that will be recognised as an indefinite delay inside the
;;;2881   		prvAddCurrentTaskToDelayedList() function. */
;;;2882   		if( xWaitIndefinitely != pdFALSE )
000022  b10c              CBZ      r4,|L33.40|
;;;2883   		{
;;;2884   			xTicksToWait = portMAX_DELAY;
000024  f04f36ff          MOV      r6,#0xffffffff
                  |L33.40|
;;;2885   		}
;;;2886   
;;;2887   		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
;;;2888   		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
000028  4621              MOV      r1,r4
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;2889   	}
000030  bd70              POP      {r4-r6,pc}
;;;2890   
                          ENDP

000032  0000              DCW      0x0000
                  |L33.52|
000034  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
000038  72656552
00003c  544f535c
000040  7461736b
000044  732e6300
                  |L33.72|
000048  4572726f          DCB      "Error:%s,%d\r\n",0
00004c  723a2573
000050  2c25640d
000054  0a00    
000056  00                DCB      0
000057  00                DCB      0
                  |L33.88|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPlaceOnUnorderedEventList||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  vTaskPlaceOnUnorderedEventList PROC
;;;2836   
;;;2837   void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;2838   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;2839   	configASSERT( pxEventList );
000008  b92c              CBNZ     r4,|L34.22|
00000a  f6403217          MOV      r2,#0xb17
00000e  a110              ADR      r1,|L34.80|
000010  a014              ADR      r0,|L34.100|
000012  f7fffffe          BL       __2printf
                  |L34.22|
;;;2840   
;;;2841   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2842   	the event groups implementation. */
;;;2843   	configASSERT( uxSchedulerSuspended != 0 );
000016  4817              LDR      r0,|L34.116|
000018  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00001a  b108              CBZ      r0,|L34.32|
00001c  2001              MOVS     r0,#1
00001e  e000              B        |L34.34|
                  |L34.32|
000020  2000              MOVS     r0,#0
                  |L34.34|
000022  b928              CBNZ     r0,|L34.48|
000024  f640321b          MOV      r2,#0xb1b
000028  a109              ADR      r1,|L34.80|
00002a  a00e              ADR      r0,|L34.100|
00002c  f7fffffe          BL       __2printf
                  |L34.48|
;;;2844   
;;;2845   	/* Store the item value in the event list item.  It is safe to access the
;;;2846   	event list item here as interrupts won't access the event list item of a
;;;2847   	task that is not in the Blocked state. */
;;;2848   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000030  f0454000          ORR      r0,r5,#0x80000000
000034  4910              LDR      r1,|L34.120|
000036  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000038  6188              STR      r0,[r1,#0x18]
;;;2849   
;;;2850   	/* Place the event list item of the TCB at the end of the appropriate event
;;;2851   	list.  It is safe to access the event list here because it is part of an
;;;2852   	event group implementation - and interrupts don't access event groups
;;;2853   	directly (instead they access them indirectly by pending function calls to
;;;2854   	the task level). */
;;;2855   	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
00003a  480f              LDR      r0,|L34.120|
00003c  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00003e  3118              ADDS     r1,r1,#0x18
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       vListInsertEnd
;;;2856   
;;;2857   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000046  2101              MOVS     r1,#1
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;2858   }
00004e  bd70              POP      {r4-r6,pc}
;;;2859   /*-----------------------------------------------------------*/
                          ENDP

                  |L34.80|
000050  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
000054  72656552
000058  544f535c
00005c  7461736b
000060  732e6300
                  |L34.100|
000064  4572726f          DCB      "Error:%s,%d\r\n",0
000068  723a2573
00006c  2c25640d
000070  0a00    
000072  00                DCB      0
000073  00                DCB      0
                  |L34.116|
                          DCD      uxSchedulerSuspended
                  |L34.120|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPriorityInherit||, CODE, READONLY, ALIGN=2

                  vTaskPriorityInherit PROC
;;;3705   
;;;3706   	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;3707   	{
000002  4605              MOV      r5,r0
;;;3708   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
000004  462c              MOV      r4,r5
;;;3709   
;;;3710   		/* If the mutex was given back by an interrupt while the queue was
;;;3711   		locked then the mutex holder might now be NULL. */
;;;3712   		if( pxMutexHolder != NULL )
000006  2d00              CMP      r5,#0
000008  d04b              BEQ      |L35.162|
;;;3713   		{
;;;3714   			/* If the holder of the mutex has a priority below the priority of
;;;3715   			the task attempting to obtain the mutex then it will temporarily
;;;3716   			inherit the priority of the task attempting to obtain the mutex. */
;;;3717   			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
00000a  4926              LDR      r1,|L35.164|
00000c  6ae0              LDR      r0,[r4,#0x2c]
00000e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000010  6ac9              LDR      r1,[r1,#0x2c]
000012  4288              CMP      r0,r1
000014  d245              BCS      |L35.162|
;;;3718   			{
;;;3719   				/* Adjust the mutex holder state to account for its new
;;;3720   				priority.  Only reset the event list item value if the value is
;;;3721   				not	being used for anything else. */
;;;3722   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000016  69a0              LDR      r0,[r4,#0x18]
000018  f0004000          AND      r0,r0,#0x80000000
00001c  b928              CBNZ     r0,|L35.42|
;;;3723   				{
;;;3724   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00001e  4821              LDR      r0,|L35.164|
000020  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000022  6ac0              LDR      r0,[r0,#0x2c]
000024  f1c00020          RSB      r0,r0,#0x20
000028  61a0              STR      r0,[r4,#0x18]
                  |L35.42|
;;;3725   				}
;;;3726   				else
;;;3727   				{
;;;3728   					mtCOVERAGE_TEST_MARKER();
;;;3729   				}
;;;3730   
;;;3731   				/* If the task being modified is in the ready state it will need
;;;3732   				to be moved into a new list. */
;;;3733   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
00002a  6ae1              LDR      r1,[r4,#0x2c]
00002c  eb010181          ADD      r1,r1,r1,LSL #2
000030  4a1d              LDR      r2,|L35.168|
000032  eb020181          ADD      r1,r2,r1,LSL #2
000036  6960              LDR      r0,[r4,#0x14]
000038  4288              CMP      r0,r1
00003a  d101              BNE      |L35.64|
00003c  2001              MOVS     r0,#1
00003e  e000              B        |L35.66|
                  |L35.64|
000040  2000              MOVS     r0,#0
                  |L35.66|
000042  b350              CBZ      r0,|L35.154|
;;;3734   				{
;;;3735   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000044  1d20              ADDS     r0,r4,#4
000046  f7fffffe          BL       uxListRemove
00004a  b978              CBNZ     r0,|L35.108|
;;;3736   					{
;;;3737   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00004c  6ae0              LDR      r0,[r4,#0x2c]
00004e  eb000080          ADD      r0,r0,r0,LSL #2
000052  4915              LDR      r1,|L35.168|
000054  f8510020          LDR      r0,[r1,r0,LSL #2]
000058  b940              CBNZ     r0,|L35.108|
00005a  f894102c          LDRB     r1,[r4,#0x2c]
00005e  2001              MOVS     r0,#1
000060  4088              LSLS     r0,r0,r1
000062  4912              LDR      r1,|L35.172|
000064  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000066  4381              BICS     r1,r1,r0
000068  4810              LDR      r0,|L35.172|
00006a  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L35.108|
;;;3738   					}
;;;3739   					else
;;;3740   					{
;;;3741   						mtCOVERAGE_TEST_MARKER();
;;;3742   					}
;;;3743   
;;;3744   					/* Inherit the priority before being moved into the new list. */
;;;3745   					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
00006c  480d              LDR      r0,|L35.164|
00006e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000070  6ac0              LDR      r0,[r0,#0x2c]
000072  62e0              STR      r0,[r4,#0x2c]
;;;3746   					prvAddTaskToReadyList( pxTCB );
000074  f894102c          LDRB     r1,[r4,#0x2c]
000078  2001              MOVS     r0,#1
00007a  4088              LSLS     r0,r0,r1
00007c  490b              LDR      r1,|L35.172|
00007e  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000080  4308              ORRS     r0,r0,r1
000082  490a              LDR      r1,|L35.172|
000084  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000086  6ae1              LDR      r1,[r4,#0x2c]
000088  eb010181          ADD      r1,r1,r1,LSL #2
00008c  4a06              LDR      r2,|L35.168|
00008e  eb020081          ADD      r0,r2,r1,LSL #2
000092  1d21              ADDS     r1,r4,#4
000094  f7fffffe          BL       vListInsertEnd
000098  e003              B        |L35.162|
                  |L35.154|
;;;3747   				}
;;;3748   				else
;;;3749   				{
;;;3750   					/* Just inherit the priority. */
;;;3751   					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
00009a  4802              LDR      r0,|L35.164|
00009c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00009e  6ac0              LDR      r0,[r0,#0x2c]
0000a0  62e0              STR      r0,[r4,#0x2c]
                  |L35.162|
;;;3752   				}
;;;3753   
;;;3754   				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
;;;3755   			}
;;;3756   			else
;;;3757   			{
;;;3758   				mtCOVERAGE_TEST_MARKER();
;;;3759   			}
;;;3760   		}
;;;3761   		else
;;;3762   		{
;;;3763   			mtCOVERAGE_TEST_MARKER();
;;;3764   		}
;;;3765   	}
0000a2  bd70              POP      {r4-r6,pc}
;;;3766   
                          ENDP

                  |L35.164|
                          DCD      pxCurrentTCB
                  |L35.168|
                          DCD      pxReadyTasksLists
                  |L35.172|
                          DCD      uxTopReadyPriority

                          AREA ||i.vTaskPrioritySet||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vTaskPrioritySet PROC
;;;1401   
;;;1402   	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1403   	{
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
;;;1404   	TCB_t *pxTCB;
;;;1405   	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;1406   	BaseType_t xYieldRequired = pdFALSE;
000008  f04f0900          MOV      r9,#0
;;;1407   
;;;1408   		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
00000c  2d20              CMP      r5,#0x20
00000e  d201              BCS      |L36.20|
000010  2001              MOVS     r0,#1
000012  e000              B        |L36.22|
                  |L36.20|
000014  2000              MOVS     r0,#0
                  |L36.22|
000016  b928              CBNZ     r0,|L36.36|
000018  f44f62b0          MOV      r2,#0x580
00001c  a137              ADR      r1,|L36.252|
00001e  a03c              ADR      r0,|L36.272|
000020  f7fffffe          BL       __2printf
                  |L36.36|
;;;1409   
;;;1410   		/* Ensure the new priority is valid. */
;;;1411   		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
000024  2d20              CMP      r5,#0x20
000026  d300              BCC      |L36.42|
;;;1412   		{
;;;1413   			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
000028  251f              MOVS     r5,#0x1f
                  |L36.42|
;;;1414   		}
;;;1415   		else
;;;1416   		{
;;;1417   			mtCOVERAGE_TEST_MARKER();
;;;1418   		}
;;;1419   
;;;1420   		taskENTER_CRITICAL();
00002a  f7fffffe          BL       vPortEnterCritical
;;;1421   		{
;;;1422   			/* If null is passed in here then it is the priority of the calling
;;;1423   			task that is being changed. */
;;;1424   			pxTCB = prvGetTCBFromHandle( xTask );
00002e  f1b80f00          CMP      r8,#0
000032  d102              BNE      |L36.58|
000034  483a              LDR      r0,|L36.288|
000036  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000038  e000              B        |L36.60|
                  |L36.58|
00003a  4640              MOV      r0,r8
                  |L36.60|
00003c  4604              MOV      r4,r0
;;;1425   
;;;1426   			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;1427   
;;;1428   			#if ( configUSE_MUTEXES == 1 )
;;;1429   			{
;;;1430   				uxCurrentBasePriority = pxTCB->uxBasePriority;
00003e  6d26              LDR      r6,[r4,#0x50]
;;;1431   			}
;;;1432   			#else
;;;1433   			{
;;;1434   				uxCurrentBasePriority = pxTCB->uxPriority;
;;;1435   			}
;;;1436   			#endif
;;;1437   
;;;1438   			if( uxCurrentBasePriority != uxNewPriority )
000040  42ae              CMP      r6,r5
000042  d056              BEQ      |L36.242|
;;;1439   			{
;;;1440   				/* The priority change may have readied a task of higher
;;;1441   				priority than the calling task. */
;;;1442   				if( uxNewPriority > uxCurrentBasePriority )
000044  42b5              CMP      r5,r6
000046  d90b              BLS      |L36.96|
;;;1443   				{
;;;1444   					if( pxTCB != pxCurrentTCB )
000048  4835              LDR      r0,|L36.288|
00004a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00004c  4284              CMP      r4,r0
00004e  d00d              BEQ      |L36.108|
;;;1445   					{
;;;1446   						/* The priority of a task other than the currently
;;;1447   						running task is being raised.  Is the priority being
;;;1448   						raised above that of the running task? */
;;;1449   						if( uxNewPriority >= pxCurrentTCB->uxPriority )
000050  4833              LDR      r0,|L36.288|
000052  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000054  6ac0              LDR      r0,[r0,#0x2c]
000056  42a8              CMP      r0,r5
000058  d808              BHI      |L36.108|
;;;1450   						{
;;;1451   							xYieldRequired = pdTRUE;
00005a  f04f0901          MOV      r9,#1
00005e  e005              B        |L36.108|
                  |L36.96|
;;;1452   						}
;;;1453   						else
;;;1454   						{
;;;1455   							mtCOVERAGE_TEST_MARKER();
;;;1456   						}
;;;1457   					}
;;;1458   					else
;;;1459   					{
;;;1460   						/* The priority of the running task is being raised,
;;;1461   						but the running task must already be the highest
;;;1462   						priority task able to run so no yield is required. */
;;;1463   					}
;;;1464   				}
;;;1465   				else if( pxTCB == pxCurrentTCB )
000060  482f              LDR      r0,|L36.288|
000062  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000064  4284              CMP      r4,r0
000066  d101              BNE      |L36.108|
;;;1466   				{
;;;1467   					/* Setting the priority of the running task down means
;;;1468   					there may now be another task of higher priority that
;;;1469   					is ready to execute. */
;;;1470   					xYieldRequired = pdTRUE;
000068  f04f0901          MOV      r9,#1
                  |L36.108|
;;;1471   				}
;;;1472   				else
;;;1473   				{
;;;1474   					/* Setting the priority of any other task down does not
;;;1475   					require a yield as the running task must be above the
;;;1476   					new priority of the task being modified. */
;;;1477   				}
;;;1478   
;;;1479   				/* Remember the ready list the task might be referenced from
;;;1480   				before its uxPriority member is changed so the
;;;1481   				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;1482   				uxPriorityUsedOnEntry = pxTCB->uxPriority;
00006c  6ae7              LDR      r7,[r4,#0x2c]
;;;1483   
;;;1484   				#if ( configUSE_MUTEXES == 1 )
;;;1485   				{
;;;1486   					/* Only change the priority being used if the task is not
;;;1487   					currently using an inherited priority. */
;;;1488   					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
00006e  6ae1              LDR      r1,[r4,#0x2c]
000070  6d20              LDR      r0,[r4,#0x50]
000072  4288              CMP      r0,r1
000074  d100              BNE      |L36.120|
;;;1489   					{
;;;1490   						pxTCB->uxPriority = uxNewPriority;
000076  62e5              STR      r5,[r4,#0x2c]
                  |L36.120|
;;;1491   					}
;;;1492   					else
;;;1493   					{
;;;1494   						mtCOVERAGE_TEST_MARKER();
;;;1495   					}
;;;1496   
;;;1497   					/* The base priority gets set whatever. */
;;;1498   					pxTCB->uxBasePriority = uxNewPriority;
000078  6525              STR      r5,[r4,#0x50]
;;;1499   				}
;;;1500   				#else
;;;1501   				{
;;;1502   					pxTCB->uxPriority = uxNewPriority;
;;;1503   				}
;;;1504   				#endif
;;;1505   
;;;1506   				/* Only reset the event list item value if the value is not
;;;1507   				being used for anything else. */
;;;1508   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
00007a  69a0              LDR      r0,[r4,#0x18]
00007c  f0004000          AND      r0,r0,#0x80000000
000080  b910              CBNZ     r0,|L36.136|
;;;1509   				{
;;;1510   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000082  f1c50020          RSB      r0,r5,#0x20
000086  61a0              STR      r0,[r4,#0x18]
                  |L36.136|
;;;1511   				}
;;;1512   				else
;;;1513   				{
;;;1514   					mtCOVERAGE_TEST_MARKER();
;;;1515   				}
;;;1516   
;;;1517   				/* If the task is in the blocked or suspended list we need do
;;;1518   				nothing more than change it's priority variable. However, if
;;;1519   				the task is in a ready list it needs to be removed and placed
;;;1520   				in the list appropriate to its new priority. */
;;;1521   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
000088  eb070187          ADD      r1,r7,r7,LSL #2
00008c  4a25              LDR      r2,|L36.292|
00008e  eb020181          ADD      r1,r2,r1,LSL #2
000092  6960              LDR      r0,[r4,#0x14]
000094  4288              CMP      r0,r1
000096  d101              BNE      |L36.156|
000098  2001              MOVS     r0,#1
00009a  e000              B        |L36.158|
                  |L36.156|
00009c  2000              MOVS     r0,#0
                  |L36.158|
00009e  b1e0              CBZ      r0,|L36.218|
;;;1522   				{
;;;1523   					/* The task is currently in its ready list - remove before adding
;;;1524   					it to it's new ready list.  As we are in a critical section we
;;;1525   					can do this even if the scheduler is suspended. */
;;;1526   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
0000a0  1d20              ADDS     r0,r4,#4
0000a2  f7fffffe          BL       uxListRemove
0000a6  b930              CBNZ     r0,|L36.182|
;;;1527   					{
;;;1528   						/* It is known that the task is in its ready list so
;;;1529   						there is no need to check again and the port level
;;;1530   						reset macro can be called directly. */
;;;1531   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
0000a8  2001              MOVS     r0,#1
0000aa  40b8              LSLS     r0,r0,r7
0000ac  491e              LDR      r1,|L36.296|
0000ae  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000b0  4381              BICS     r1,r1,r0
0000b2  481d              LDR      r0,|L36.296|
0000b4  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L36.182|
;;;1532   					}
;;;1533   					else
;;;1534   					{
;;;1535   						mtCOVERAGE_TEST_MARKER();
;;;1536   					}
;;;1537   					prvAddTaskToReadyList( pxTCB );
0000b6  f894102c          LDRB     r1,[r4,#0x2c]
0000ba  2001              MOVS     r0,#1
0000bc  4088              LSLS     r0,r0,r1
0000be  491a              LDR      r1,|L36.296|
0000c0  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000c2  4308              ORRS     r0,r0,r1
0000c4  4918              LDR      r1,|L36.296|
0000c6  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
0000c8  6ae1              LDR      r1,[r4,#0x2c]
0000ca  eb010181          ADD      r1,r1,r1,LSL #2
0000ce  4a15              LDR      r2,|L36.292|
0000d0  eb020081          ADD      r0,r2,r1,LSL #2
0000d4  1d21              ADDS     r1,r4,#4
0000d6  f7fffffe          BL       vListInsertEnd
                  |L36.218|
;;;1538   				}
;;;1539   				else
;;;1540   				{
;;;1541   					mtCOVERAGE_TEST_MARKER();
;;;1542   				}
;;;1543   
;;;1544   				if( xYieldRequired != pdFALSE )
0000da  f1b90f00          CMP      r9,#0
0000de  d007              BEQ      |L36.240|
;;;1545   				{
;;;1546   					taskYIELD_IF_USING_PREEMPTION();
0000e0  f04f5080          MOV      r0,#0x10000000
0000e4  4911              LDR      r1,|L36.300|
0000e6  6008              STR      r0,[r1,#0]
0000e8  f3bf8f4f          DSB      
0000ec  f3bf8f6f          ISB      
                  |L36.240|
;;;1547   				}
;;;1548   				else
;;;1549   				{
;;;1550   					mtCOVERAGE_TEST_MARKER();
;;;1551   				}
;;;1552   
;;;1553   				/* Remove compiler warning about unused variables when the port
;;;1554   				optimised task selection is not being used. */
;;;1555   				( void ) uxPriorityUsedOnEntry;
0000f0  bf00              NOP      
                  |L36.242|
;;;1556   			}
;;;1557   		}
;;;1558   		taskEXIT_CRITICAL();
0000f2  f7fffffe          BL       vPortExitCritical
;;;1559   	}
0000f6  e8bd87f0          POP      {r4-r10,pc}
;;;1560   
                          ENDP

0000fa  0000              DCW      0x0000
                  |L36.252|
0000fc  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
000100  72656552
000104  544f535c
000108  7461736b
00010c  732e6300
                  |L36.272|
000110  4572726f          DCB      "Error:%s,%d\r\n",0
000114  723a2573
000118  2c25640d
00011c  0a00    
00011e  00                DCB      0
00011f  00                DCB      0
                  |L36.288|
                          DCD      pxCurrentTCB
                  |L36.292|
                          DCD      pxReadyTasksLists
                  |L36.296|
                          DCD      uxTopReadyPriority
                  |L36.300|
                          DCD      0xe000ed04

                          AREA ||i.vTaskResume||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vTaskResume PROC
;;;1701   
;;;1702   	void vTaskResume( TaskHandle_t xTaskToResume )
000000  b570              PUSH     {r4-r6,lr}
;;;1703   	{
000002  4605              MOV      r5,r0
;;;1704   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
000004  462c              MOV      r4,r5
;;;1705   
;;;1706   		/* It does not make sense to resume the calling task. */
;;;1707   		configASSERT( xTaskToResume );
000006  b92d              CBNZ     r5,|L37.20|
000008  f24062ab          MOV      r2,#0x6ab
00000c  a11a              ADR      r1,|L37.120|
00000e  a01f              ADR      r0,|L37.140|
000010  f7fffffe          BL       __2printf
                  |L37.20|
;;;1708   
;;;1709   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1710   		currently executing task. */
;;;1711   		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
000014  b374              CBZ      r4,|L37.116|
000016  4821              LDR      r0,|L37.156|
000018  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00001a  4284              CMP      r4,r0
00001c  d02a              BEQ      |L37.116|
;;;1712   		{
;;;1713   			taskENTER_CRITICAL();
00001e  f7fffffe          BL       vPortEnterCritical
;;;1714   			{
;;;1715   				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       prvTaskIsTaskSuspended
000028  b310              CBZ      r0,|L37.112|
;;;1716   				{
;;;1717   					traceTASK_RESUME( pxTCB );
;;;1718   
;;;1719   					/* As we are in a critical section we can access the ready
;;;1720   					lists even if the scheduler is suspended. */
;;;1721   					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
00002a  1d20              ADDS     r0,r4,#4
00002c  f7fffffe          BL       uxListRemove
;;;1722   					prvAddTaskToReadyList( pxTCB );
000030  f894102c          LDRB     r1,[r4,#0x2c]
000034  2001              MOVS     r0,#1
000036  4088              LSLS     r0,r0,r1
000038  4919              LDR      r1,|L37.160|
00003a  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00003c  4308              ORRS     r0,r0,r1
00003e  4918              LDR      r1,|L37.160|
000040  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000042  6ae1              LDR      r1,[r4,#0x2c]
000044  eb010181          ADD      r1,r1,r1,LSL #2
000048  4a16              LDR      r2,|L37.164|
00004a  eb020081          ADD      r0,r2,r1,LSL #2
00004e  1d21              ADDS     r1,r4,#4
000050  f7fffffe          BL       vListInsertEnd
;;;1723   
;;;1724   					/* We may have just resumed a higher priority task. */
;;;1725   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000054  4911              LDR      r1,|L37.156|
000056  6ae0              LDR      r0,[r4,#0x2c]
000058  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00005a  6ac9              LDR      r1,[r1,#0x2c]
00005c  4288              CMP      r0,r1
00005e  d307              BCC      |L37.112|
;;;1726   					{
;;;1727   						/* This yield may not cause the task just resumed to run,
;;;1728   						but will leave the lists in the correct state for the
;;;1729   						next yield. */
;;;1730   						taskYIELD_IF_USING_PREEMPTION();
000060  f04f5080          MOV      r0,#0x10000000
000064  4910              LDR      r1,|L37.168|
000066  6008              STR      r0,[r1,#0]
000068  f3bf8f4f          DSB      
00006c  f3bf8f6f          ISB      
                  |L37.112|
;;;1731   					}
;;;1732   					else
;;;1733   					{
;;;1734   						mtCOVERAGE_TEST_MARKER();
;;;1735   					}
;;;1736   				}
;;;1737   				else
;;;1738   				{
;;;1739   					mtCOVERAGE_TEST_MARKER();
;;;1740   				}
;;;1741   			}
;;;1742   			taskEXIT_CRITICAL();
000070  f7fffffe          BL       vPortExitCritical
                  |L37.116|
;;;1743   		}
;;;1744   		else
;;;1745   		{
;;;1746   			mtCOVERAGE_TEST_MARKER();
;;;1747   		}
;;;1748   	}
000074  bd70              POP      {r4-r6,pc}
;;;1749   
                          ENDP

000076  0000              DCW      0x0000
                  |L37.120|
000078  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
00007c  72656552
000080  544f535c
000084  7461736b
000088  732e6300
                  |L37.140|
00008c  4572726f          DCB      "Error:%s,%d\r\n",0
000090  723a2573
000094  2c25640d
000098  0a00    
00009a  00                DCB      0
00009b  00                DCB      0
                  |L37.156|
                          DCD      pxCurrentTCB
                  |L37.160|
                          DCD      uxTopReadyPriority
                  |L37.164|
                          DCD      pxReadyTasksLists
                  |L37.168|
                          DCD      0xe000ed04

                          AREA ||i.vTaskSetTaskNumber||, CODE, READONLY, ALIGN=1

                  vTaskSetTaskNumber PROC
;;;3106   
;;;3107   	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
000000  b108              CBZ      r0,|L38.6|
;;;3108   	{
;;;3109   	TCB_t *pxTCB;
;;;3110   
;;;3111   		if( xTask != NULL )
;;;3112   		{
;;;3113   			pxTCB = ( TCB_t * ) xTask;
000002  4602              MOV      r2,r0
;;;3114   			pxTCB->uxTaskNumber = uxHandle;
000004  64d1              STR      r1,[r2,#0x4c]
                  |L38.6|
;;;3115   		}
;;;3116   	}
000006  4770              BX       lr
;;;3117   
                          ENDP


                          AREA ||i.vTaskSetTimeOutState||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vTaskSetTimeOutState PROC
;;;3006   
;;;3007   void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
000000  b510              PUSH     {r4,lr}
;;;3008   {
000002  4604              MOV      r4,r0
;;;3009   	configASSERT( pxTimeOut );
000004  b92c              CBNZ     r4,|L39.18|
000006  f64032c1          MOV      r2,#0xbc1
00000a  a105              ADR      r1,|L39.32|
00000c  a009              ADR      r0,|L39.52|
00000e  f7fffffe          BL       __2printf
                  |L39.18|
;;;3010   	pxTimeOut->xOverflowCount = xNumOfOverflows;
000012  480c              LDR      r0,|L39.68|
000014  6800              LDR      r0,[r0,#0]  ; xNumOfOverflows
000016  6020              STR      r0,[r4,#0]
;;;3011   	pxTimeOut->xTimeOnEntering = xTickCount;
000018  480b              LDR      r0,|L39.72|
00001a  6800              LDR      r0,[r0,#0]  ; xTickCount
00001c  6060              STR      r0,[r4,#4]
;;;3012   }
00001e  bd10              POP      {r4,pc}
;;;3013   /*-----------------------------------------------------------*/
                          ENDP

                  |L39.32|
000020  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
000024  72656552
000028  544f535c
00002c  7461736b
000030  732e6300
                  |L39.52|
000034  4572726f          DCB      "Error:%s,%d\r\n",0
000038  723a2573
00003c  2c25640d
000040  0a00    
000042  00                DCB      0
000043  00                DCB      0
                  |L39.68|
                          DCD      xNumOfOverflows
                  |L39.72|
                          DCD      xTickCount

                          AREA ||i.vTaskStartScheduler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vTaskStartScheduler PROC
;;;1825   
;;;1826   void vTaskStartScheduler( void )
000000  b51c              PUSH     {r2-r4,lr}
;;;1827   {
;;;1828   BaseType_t xReturn;
;;;1829   
;;;1830   	/* Add the idle task at the lowest priority. */
;;;1831   	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;1832   	{
;;;1833   		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
;;;1834   		StackType_t *pxIdleTaskStackBuffer = NULL;
;;;1835   		uint32_t ulIdleTaskStackSize;
;;;1836   
;;;1837   		/* The Idle task is created using user provided RAM - obtain the
;;;1838   		address of the RAM then create the idle task. */
;;;1839   		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
;;;1840   		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
;;;1841   												"IDLE",
;;;1842   												ulIdleTaskStackSize,
;;;1843   												( void * ) NULL,
;;;1844   												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
;;;1845   												pxIdleTaskStackBuffer,
;;;1846   												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1847   
;;;1848   		if( xIdleTaskHandle != NULL )
;;;1849   		{
;;;1850   			xReturn = pdPASS;
;;;1851   		}
;;;1852   		else
;;;1853   		{
;;;1854   			xReturn = pdFAIL;
;;;1855   		}
;;;1856   	}
;;;1857   	#else
;;;1858   	{
;;;1859   		/* The Idle task is being created using dynamically allocated RAM. */
;;;1860   		xReturn = xTaskCreate(	prvIdleTask,
000002  481b              LDR      r0,|L40.112|
000004  2100              MOVS     r1,#0
000006  460b              MOV      r3,r1
000008  2282              MOVS     r2,#0x82
00000a  e9cd1000          STRD     r1,r0,[sp,#0]
00000e  a119              ADR      r1,|L40.116|
000010  481a              LDR      r0,|L40.124|
000012  f7fffffe          BL       xTaskCreate
000016  4604              MOV      r4,r0
;;;1861   								"IDLE", configMINIMAL_STACK_SIZE,
;;;1862   								( void * ) NULL,
;;;1863   								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
;;;1864   								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1865   	}
;;;1866   	#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;1867   
;;;1868   	#if ( configUSE_TIMERS == 1 )
;;;1869   	{
;;;1870   		if( xReturn == pdPASS )
000018  2c01              CMP      r4,#1
00001a  d102              BNE      |L40.34|
;;;1871   		{
;;;1872   			xReturn = xTimerCreateTimerTask();
00001c  f7fffffe          BL       xTimerCreateTimerTask
000020  4604              MOV      r4,r0
                  |L40.34|
;;;1873   		}
;;;1874   		else
;;;1875   		{
;;;1876   			mtCOVERAGE_TEST_MARKER();
;;;1877   		}
;;;1878   	}
;;;1879   	#endif /* configUSE_TIMERS */
;;;1880   
;;;1881   	if( xReturn == pdPASS )
000022  2c01              CMP      r4,#1
000024  d117              BNE      |L40.86|
;;;1882   	{
;;;1883   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;1884   		before or during the call to xPortStartScheduler().  The stacks of
;;;1885   		the created tasks contain a status word with interrupts switched on
;;;1886   		so interrupts will automatically get re-enabled when the first task
;;;1887   		starts to run. */
;;;1888   		portDISABLE_INTERRUPTS();
000026  bf00              NOP      
000028  2060              MOVS     r0,#0x60
00002a  f3808811          MSR      BASEPRI,r0
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
000036  bf00              NOP      
;;;1889   
;;;1890   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1891   		{
;;;1892   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;1893   			structure specific to the task that will run first. */
;;;1894   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;1895   		}
;;;1896   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;1897   
;;;1898   		xNextTaskUnblockTime = portMAX_DELAY;
000038  f04f30ff          MOV      r0,#0xffffffff
00003c  4910              LDR      r1,|L40.128|
00003e  6008              STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;1899   		xSchedulerRunning = pdTRUE;
000040  2001              MOVS     r0,#1
000042  4910              LDR      r1,|L40.132|
000044  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;1900   		xTickCount = ( TickType_t ) 0U;
000046  2000              MOVS     r0,#0
000048  490f              LDR      r1,|L40.136|
00004a  6008              STR      r0,[r1,#0]  ; xTickCount
;;;1901   
;;;1902   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;1903   		macro must be defined to configure the timer/counter used to generate
;;;1904   		the run time counter time base. */
;;;1905   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
00004c  f7fffffe          BL       ConfigureTimeForRunTimeStats
;;;1906   
;;;1907   		/* Setting up the timer tick is hardware specific and thus in the
;;;1908   		portable interface. */
;;;1909   		if( xPortStartScheduler() != pdFALSE )
000050  f7fffffe          BL       xPortStartScheduler
000054  e00b              B        |L40.110|
                  |L40.86|
;;;1910   		{
;;;1911   			/* Should not reach here as if the scheduler is running the
;;;1912   			function will not return. */
;;;1913   		}
;;;1914   		else
;;;1915   		{
;;;1916   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;1917   		}
;;;1918   	}
;;;1919   	else
;;;1920   	{
;;;1921   		/* This line will only be reached if the kernel could not be started,
;;;1922   		because there was not enough FreeRTOS heap to create the idle task
;;;1923   		or the timer task. */
;;;1924   		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
000056  1c60              ADDS     r0,r4,#1
000058  b108              CBZ      r0,|L40.94|
00005a  2001              MOVS     r0,#1
00005c  e000              B        |L40.96|
                  |L40.94|
00005e  2000              MOVS     r0,#0
                  |L40.96|
000060  b928              CBNZ     r0,|L40.110|
000062  f2407284          MOV      r2,#0x784
000066  a109              ADR      r1,|L40.140|
000068  a00d              ADR      r0,|L40.160|
00006a  f7fffffe          BL       __2printf
                  |L40.110|
;;;1925   	}
;;;1926   
;;;1927   	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
;;;1928   	meaning xIdleTaskHandle is not used anywhere else. */
;;;1929   	( void ) xIdleTaskHandle;
;;;1930   }
00006e  bd1c              POP      {r2-r4,pc}
;;;1931   /*-----------------------------------------------------------*/
                          ENDP

                  |L40.112|
                          DCD      xIdleTaskHandle
                  |L40.116|
000074  49444c45          DCB      "IDLE",0
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L40.124|
                          DCD      prvIdleTask
                  |L40.128|
                          DCD      xNextTaskUnblockTime
                  |L40.132|
                          DCD      xSchedulerRunning
                  |L40.136|
                          DCD      xTickCount
                  |L40.140|
00008c  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
000090  72656552
000094  544f535c
000098  7461736b
00009c  732e6300
                  |L40.160|
0000a0  4572726f          DCB      "Error:%s,%d\r\n",0
0000a4  723a2573
0000a8  2c25640d
0000ac  0a00    
0000ae  00                DCB      0
0000af  00                DCB      0

                          AREA ||i.vTaskSuspend||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vTaskSuspend PROC
;;;1565   
;;;1566   	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
000000  b570              PUSH     {r4-r6,lr}
;;;1567   	{
000002  4605              MOV      r5,r0
;;;1568   	TCB_t *pxTCB;
;;;1569   
;;;1570   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1571   		{
;;;1572   			/* If null is passed in here then it is the running task that is
;;;1573   			being suspended. */
;;;1574   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
000008  b915              CBNZ     r5,|L41.16|
00000a  482c              LDR      r0,|L41.188|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L41.18|
                  |L41.16|
000010  4628              MOV      r0,r5
                  |L41.18|
000012  4604              MOV      r4,r0
;;;1575   
;;;1576   			traceTASK_SUSPEND( pxTCB );
;;;1577   
;;;1578   			/* Remove task from the ready/delayed list and place in the
;;;1579   			suspended list. */
;;;1580   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000014  1d20              ADDS     r0,r4,#4
000016  f7fffffe          BL       uxListRemove
00001a  b978              CBNZ     r0,|L41.60|
;;;1581   			{
;;;1582   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00001c  6ae0              LDR      r0,[r4,#0x2c]
00001e  eb000080          ADD      r0,r0,r0,LSL #2
000022  4927              LDR      r1,|L41.192|
000024  f8510020          LDR      r0,[r1,r0,LSL #2]
000028  b940              CBNZ     r0,|L41.60|
00002a  f894102c          LDRB     r1,[r4,#0x2c]
00002e  2001              MOVS     r0,#1
000030  4088              LSLS     r0,r0,r1
000032  4924              LDR      r1,|L41.196|
000034  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000036  4381              BICS     r1,r1,r0
000038  4822              LDR      r0,|L41.196|
00003a  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L41.60|
;;;1583   			}
;;;1584   			else
;;;1585   			{
;;;1586   				mtCOVERAGE_TEST_MARKER();
;;;1587   			}
;;;1588   
;;;1589   			/* Is the task waiting on an event also? */
;;;1590   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00003c  6aa0              LDR      r0,[r4,#0x28]
00003e  b118              CBZ      r0,|L41.72|
;;;1591   			{
;;;1592   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000040  f1040018          ADD      r0,r4,#0x18
000044  f7fffffe          BL       uxListRemove
                  |L41.72|
;;;1593   			}
;;;1594   			else
;;;1595   			{
;;;1596   				mtCOVERAGE_TEST_MARKER();
;;;1597   			}
;;;1598   
;;;1599   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
000048  1d21              ADDS     r1,r4,#4
00004a  481f              LDR      r0,|L41.200|
00004c  f7fffffe          BL       vListInsertEnd
;;;1600   		}
;;;1601   		taskEXIT_CRITICAL();
000050  f7fffffe          BL       vPortExitCritical
;;;1602   
;;;1603   		if( xSchedulerRunning != pdFALSE )
000054  481d              LDR      r0,|L41.204|
000056  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000058  b128              CBZ      r0,|L41.102|
;;;1604   		{
;;;1605   			/* Reset the next expected unblock time in case it referred to the
;;;1606   			task that is now in the Suspended state. */
;;;1607   			taskENTER_CRITICAL();
00005a  f7fffffe          BL       vPortEnterCritical
;;;1608   			{
;;;1609   				prvResetNextTaskUnblockTime();
00005e  f7fffffe          BL       prvResetNextTaskUnblockTime
;;;1610   			}
;;;1611   			taskEXIT_CRITICAL();
000062  f7fffffe          BL       vPortExitCritical
                  |L41.102|
;;;1612   		}
;;;1613   		else
;;;1614   		{
;;;1615   			mtCOVERAGE_TEST_MARKER();
;;;1616   		}
;;;1617   
;;;1618   		if( pxTCB == pxCurrentTCB )
000066  4815              LDR      r0,|L41.188|
000068  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00006a  4284              CMP      r4,r0
00006c  d124              BNE      |L41.184|
;;;1619   		{
;;;1620   			if( xSchedulerRunning != pdFALSE )
00006e  4817              LDR      r0,|L41.204|
000070  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000072  b1a8              CBZ      r0,|L41.160|
;;;1621   			{
;;;1622   				/* The current task has just been suspended. */
;;;1623   				configASSERT( uxSchedulerSuspended == 0 );
000074  4816              LDR      r0,|L41.208|
000076  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000078  b908              CBNZ     r0,|L41.126|
00007a  2001              MOVS     r0,#1
00007c  e000              B        |L41.128|
                  |L41.126|
00007e  2000              MOVS     r0,#0
                  |L41.128|
000080  b928              CBNZ     r0,|L41.142|
000082  f2406257          MOV      r2,#0x657
000086  a113              ADR      r1,|L41.212|
000088  a017              ADR      r0,|L41.232|
00008a  f7fffffe          BL       __2printf
                  |L41.142|
;;;1624   				portYIELD_WITHIN_API();
00008e  f04f5080          MOV      r0,#0x10000000
000092  4919              LDR      r1,|L41.248|
000094  6008              STR      r0,[r1,#0]
000096  f3bf8f4f          DSB      
00009a  f3bf8f6f          ISB      
00009e  e00b              B        |L41.184|
                  |L41.160|
;;;1625   			}
;;;1626   			else
;;;1627   			{
;;;1628   				/* The scheduler is not running, but the task that was pointed
;;;1629   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1630   				must be adjusted to point to a different task. */
;;;1631   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
0000a0  4809              LDR      r0,|L41.200|
0000a2  6800              LDR      r0,[r0,#0]  ; xSuspendedTaskList
0000a4  4915              LDR      r1,|L41.252|
0000a6  6809              LDR      r1,[r1,#0]  ; uxCurrentNumberOfTasks
0000a8  4288              CMP      r0,r1
0000aa  d103              BNE      |L41.180|
;;;1632   				{
;;;1633   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1634   					NULL so when the next task is created pxCurrentTCB will
;;;1635   					be set to point to it no matter what its relative priority
;;;1636   					is. */
;;;1637   					pxCurrentTCB = NULL;
0000ac  2000              MOVS     r0,#0
0000ae  4903              LDR      r1,|L41.188|
0000b0  6008              STR      r0,[r1,#0]  ; pxCurrentTCB
0000b2  e001              B        |L41.184|
                  |L41.180|
;;;1638   				}
;;;1639   				else
;;;1640   				{
;;;1641   					vTaskSwitchContext();
0000b4  f7fffffe          BL       vTaskSwitchContext
                  |L41.184|
;;;1642   				}
;;;1643   			}
;;;1644   		}
;;;1645   		else
;;;1646   		{
;;;1647   			mtCOVERAGE_TEST_MARKER();
;;;1648   		}
;;;1649   	}
0000b8  bd70              POP      {r4-r6,pc}
;;;1650   
                          ENDP

0000ba  0000              DCW      0x0000
                  |L41.188|
                          DCD      pxCurrentTCB
                  |L41.192|
                          DCD      pxReadyTasksLists
                  |L41.196|
                          DCD      uxTopReadyPriority
                  |L41.200|
                          DCD      xSuspendedTaskList
                  |L41.204|
                          DCD      xSchedulerRunning
                  |L41.208|
                          DCD      uxSchedulerSuspended
                  |L41.212|
0000d4  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
0000d8  72656552
0000dc  544f535c
0000e0  7461736b
0000e4  732e6300
                  |L41.232|
0000e8  4572726f          DCB      "Error:%s,%d\r\n",0
0000ec  723a2573
0000f0  2c25640d
0000f4  0a00    
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L41.248|
                          DCD      0xe000ed04
                  |L41.252|
                          DCD      uxCurrentNumberOfTasks

                          AREA ||i.vTaskSuspendAll||, CODE, READONLY, ALIGN=2

                  vTaskSuspendAll PROC
;;;1943   
;;;1944   void vTaskSuspendAll( void )
000000  4802              LDR      r0,|L42.12|
;;;1945   {
;;;1946   	/* A critical section is not required as the variable is of type
;;;1947   	BaseType_t.  Please read Richard Barry's reply in the following link to a
;;;1948   	post in the FreeRTOS support forum before reporting this as a bug! -
;;;1949   	http://goo.gl/wu4acr */
;;;1950   	++uxSchedulerSuspended;
000002  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000004  1c40              ADDS     r0,r0,#1
000006  4901              LDR      r1,|L42.12|
000008  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;1951   }
00000a  4770              BX       lr
;;;1952   /*----------------------------------------------------------*/
                          ENDP

                  |L42.12|
                          DCD      uxSchedulerSuspended

                          AREA ||i.vTaskSwitchContext||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vTaskSwitchContext PROC
;;;2760   
;;;2761   void vTaskSwitchContext( void )
000000  b510              PUSH     {r4,lr}
;;;2762   {
;;;2763   	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
000002  4828              LDR      r0,|L43.164|
000004  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000006  b118              CBZ      r0,|L43.16|
;;;2764   	{
;;;2765   		/* The scheduler is currently suspended - do not allow a context
;;;2766   		switch. */
;;;2767   		xYieldPending = pdTRUE;
000008  2001              MOVS     r0,#1
00000a  4927              LDR      r1,|L43.168|
00000c  6008              STR      r0,[r1,#0]  ; xYieldPending
00000e  e048              B        |L43.162|
                  |L43.16|
;;;2768   	}
;;;2769   	else
;;;2770   	{
;;;2771   		xYieldPending = pdFALSE;
000010  2000              MOVS     r0,#0
000012  4925              LDR      r1,|L43.168|
000014  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;2772   		traceTASK_SWITCHED_OUT();
;;;2773   
;;;2774   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2775   		{
;;;2776   				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2777   					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;2778   				#else
;;;2779   					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
000016  4925              LDR      r1,|L43.172|
000018  6808              LDR      r0,[r1,#0]  ; FreeRTOSRunTimeTicks
00001a  6849              LDR      r1,[r1,#4]  ; FreeRTOSRunTimeTicks
00001c  4924              LDR      r1,|L43.176|
00001e  6008              STR      r0,[r1,#0]  ; ulTotalRunTime
;;;2780   				#endif
;;;2781   
;;;2782   				/* Add the amount of time the task has been running to the
;;;2783   				accumulated time so far.  The time the task started running was
;;;2784   				stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;2785   				protection here so count values are only valid until the timer
;;;2786   				overflows.  The guard against negative values is to protect
;;;2787   				against suspect run time stat counter implementations - which
;;;2788   				are provided by the application, not the kernel. */
;;;2789   				if( ulTotalRunTime > ulTaskSwitchedInTime )
000020  4608              MOV      r0,r1
000022  6800              LDR      r0,[r0,#0]  ; ulTotalRunTime
000024  4923              LDR      r1,|L43.180|
000026  6809              LDR      r1,[r1,#0]  ; ulTaskSwitchedInTime
000028  4288              CMP      r0,r1
00002a  d90b              BLS      |L43.68|
;;;2790   				{
;;;2791   					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
00002c  4922              LDR      r1,|L43.184|
00002e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000030  f1010058          ADD      r0,r1,#0x58
000034  6d89              LDR      r1,[r1,#0x58]
000036  4a1e              LDR      r2,|L43.176|
000038  6812              LDR      r2,[r2,#0]  ; ulTotalRunTime
00003a  4b1e              LDR      r3,|L43.180|
00003c  681b              LDR      r3,[r3,#0]  ; ulTaskSwitchedInTime
00003e  1ad2              SUBS     r2,r2,r3
000040  4411              ADD      r1,r1,r2
000042  6001              STR      r1,[r0,#0]
                  |L43.68|
;;;2792   				}
;;;2793   				else
;;;2794   				{
;;;2795   					mtCOVERAGE_TEST_MARKER();
;;;2796   				}
;;;2797   				ulTaskSwitchedInTime = ulTotalRunTime;
000044  481a              LDR      r0,|L43.176|
000046  6800              LDR      r0,[r0,#0]  ; ulTotalRunTime
000048  491a              LDR      r1,|L43.180|
00004a  6008              STR      r0,[r1,#0]  ; ulTaskSwitchedInTime
;;;2798   		}
;;;2799   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;2800   
;;;2801   		/* Check for stack overflow, if configured. */
;;;2802   		taskCHECK_FOR_STACK_OVERFLOW();
;;;2803   
;;;2804   		/* Select a new task to run using either the generic C or port
;;;2805   		optimised asm code. */
;;;2806   		taskSELECT_HIGHEST_PRIORITY_TASK();
00004c  481b              LDR      r0,|L43.188|
00004e  6800              LDR      r0,[r0,#0]  ; uxTopReadyPriority
000050  fab0f080          CLZ      r0,r0
000054  f1c0041f          RSB      r4,r0,#0x1f
000058  eb040084          ADD      r0,r4,r4,LSL #2
00005c  4918              LDR      r1,|L43.192|
00005e  f8510020          LDR      r0,[r1,r0,LSL #2]
000062  b108              CBZ      r0,|L43.104|
000064  2001              MOVS     r0,#1
000066  e000              B        |L43.106|
                  |L43.104|
000068  2000              MOVS     r0,#0
                  |L43.106|
00006a  b928              CBNZ     r0,|L43.120|
00006c  f64022f6          MOV      r2,#0xaf6
000070  a114              ADR      r1,|L43.196|
000072  a019              ADR      r0,|L43.216|
000074  f7fffffe          BL       __2printf
                  |L43.120|
000078  eb040184          ADD      r1,r4,r4,LSL #2
00007c  4a10              LDR      r2,|L43.192|
00007e  eb020081          ADD      r0,r2,r1,LSL #2
000082  6841              LDR      r1,[r0,#4]
000084  6849              LDR      r1,[r1,#4]
000086  6041              STR      r1,[r0,#4]
000088  f1000108          ADD      r1,r0,#8
00008c  6842              LDR      r2,[r0,#4]
00008e  428a              CMP      r2,r1
000090  d102              BNE      |L43.152|
000092  6841              LDR      r1,[r0,#4]
000094  6849              LDR      r1,[r1,#4]
000096  6041              STR      r1,[r0,#4]
                  |L43.152|
000098  6841              LDR      r1,[r0,#4]
00009a  68c9              LDR      r1,[r1,#0xc]
00009c  4a06              LDR      r2,|L43.184|
00009e  6011              STR      r1,[r2,#0]  ; pxCurrentTCB
0000a0  bf00              NOP      
                  |L43.162|
;;;2807   		traceTASK_SWITCHED_IN();
;;;2808   
;;;2809   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2810   		{
;;;2811   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;2812   			structure specific to this task. */
;;;2813   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;2814   		}
;;;2815   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;2816   	}
;;;2817   }
0000a2  bd10              POP      {r4,pc}
;;;2818   /*-----------------------------------------------------------*/
                          ENDP

                  |L43.164|
                          DCD      uxSchedulerSuspended
                  |L43.168|
                          DCD      xYieldPending
                  |L43.172|
                          DCD      FreeRTOSRunTimeTicks
                  |L43.176|
                          DCD      ulTotalRunTime
                  |L43.180|
                          DCD      ulTaskSwitchedInTime
                  |L43.184|
                          DCD      pxCurrentTCB
                  |L43.188|
                          DCD      uxTopReadyPriority
                  |L43.192|
                          DCD      pxReadyTasksLists
                  |L43.196|
0000c4  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
0000c8  72656552
0000cc  544f535c
0000d0  7461736b
0000d4  732e6300
                  |L43.216|
0000d8  4572726f          DCB      "Error:%s,%d\r\n",0
0000dc  723a2573
0000e0  2c25640d
0000e4  0a00    
0000e6  00                DCB      0
0000e7  00                DCB      0

                          AREA ||i.xTaskCheckForTimeOut||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  xTaskCheckForTimeOut PROC
;;;3014   
;;;3015   BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3016   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;3017   BaseType_t xReturn;
;;;3018   
;;;3019   	configASSERT( pxTimeOut );
000008  b92c              CBNZ     r4,|L44.22|
00000a  f64032cb          MOV      r2,#0xbcb
00000e  a119              ADR      r1,|L44.116|
000010  a01d              ADR      r0,|L44.136|
000012  f7fffffe          BL       __2printf
                  |L44.22|
;;;3020   	configASSERT( pxTicksToWait );
000016  b92d              CBNZ     r5,|L44.36|
000018  f64032cc          MOV      r2,#0xbcc
00001c  a115              ADR      r1,|L44.116|
00001e  a01a              ADR      r0,|L44.136|
000020  f7fffffe          BL       __2printf
                  |L44.36|
;;;3021   
;;;3022   	taskENTER_CRITICAL();
000024  f7fffffe          BL       vPortEnterCritical
;;;3023   	{
;;;3024   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;3025   		const TickType_t xConstTickCount = xTickCount;
000028  481b              LDR      r0,|L44.152|
00002a  6807              LDR      r7,[r0,#0]  ; xTickCount
;;;3026   
;;;3027   		#if( INCLUDE_xTaskAbortDelay == 1 )
;;;3028   			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
;;;3029   			{
;;;3030   				/* The delay was aborted, which is not the same as a time out,
;;;3031   				but has the same result. */
;;;3032   				pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;3033   				xReturn = pdTRUE;
;;;3034   			}
;;;3035   			else
;;;3036   		#endif
;;;3037   
;;;3038   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;3039   			if( *pxTicksToWait == portMAX_DELAY )
00002c  6828              LDR      r0,[r5,#0]
00002e  1c40              ADDS     r0,r0,#1
000030  b908              CBNZ     r0,|L44.54|
;;;3040   			{
;;;3041   				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
;;;3042   				specified is the maximum block time then the task should block
;;;3043   				indefinitely, and therefore never time out. */
;;;3044   				xReturn = pdFALSE;
000032  2600              MOVS     r6,#0
000034  e019              B        |L44.106|
                  |L44.54|
;;;3045   			}
;;;3046   			else
;;;3047   		#endif
;;;3048   
;;;3049   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
000036  4919              LDR      r1,|L44.156|
000038  6820              LDR      r0,[r4,#0]
00003a  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
00003c  4288              CMP      r0,r1
00003e  d004              BEQ      |L44.74|
000040  6860              LDR      r0,[r4,#4]
000042  42b8              CMP      r0,r7
000044  d801              BHI      |L44.74|
;;;3050   		{
;;;3051   			/* The tick count is greater than the time at which
;;;3052   			vTaskSetTimeout() was called, but has also overflowed since
;;;3053   			vTaskSetTimeOut() was called.  It must have wrapped all the way
;;;3054   			around and gone past again. This passed since vTaskSetTimeout()
;;;3055   			was called. */
;;;3056   			xReturn = pdTRUE;
000046  2601              MOVS     r6,#1
000048  e00f              B        |L44.106|
                  |L44.74|
;;;3057   		}
;;;3058   		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
00004a  6860              LDR      r0,[r4,#4]
00004c  1a38              SUBS     r0,r7,r0
00004e  6829              LDR      r1,[r5,#0]
000050  4288              CMP      r0,r1
000052  d209              BCS      |L44.104|
;;;3059   		{
;;;3060   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;3061   			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
000054  6828              LDR      r0,[r5,#0]
000056  6861              LDR      r1,[r4,#4]
000058  1a79              SUBS     r1,r7,r1
00005a  1a40              SUBS     r0,r0,r1
00005c  6028              STR      r0,[r5,#0]
;;;3062   			vTaskSetTimeOutState( pxTimeOut );
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       vTaskSetTimeOutState
;;;3063   			xReturn = pdFALSE;
000064  2600              MOVS     r6,#0
000066  e000              B        |L44.106|
                  |L44.104|
;;;3064   		}
;;;3065   		else
;;;3066   		{
;;;3067   			xReturn = pdTRUE;
000068  2601              MOVS     r6,#1
                  |L44.106|
;;;3068   		}
;;;3069   	}
;;;3070   	taskEXIT_CRITICAL();
00006a  f7fffffe          BL       vPortExitCritical
;;;3071   
;;;3072   	return xReturn;
00006e  4630              MOV      r0,r6
;;;3073   }
000070  e8bd81f0          POP      {r4-r8,pc}
;;;3074   /*-----------------------------------------------------------*/
                          ENDP

                  |L44.116|
000074  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
000078  72656552
00007c  544f535c
000080  7461736b
000084  732e6300
                  |L44.136|
000088  4572726f          DCB      "Error:%s,%d\r\n",0
00008c  723a2573
000090  2c25640d
000094  0a00    
000096  00                DCB      0
000097  00                DCB      0
                  |L44.152|
                          DCD      xTickCount
                  |L44.156|
                          DCD      xNumOfOverflows

                          AREA ||i.xTaskCreate||, CODE, READONLY, ALIGN=1

                  xTaskCreate PROC
;;;675    
;;;676    	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;677    							const char * const pcName,
;;;678    							const uint16_t usStackDepth,
;;;679    							void * const pvParameters,
;;;680    							UBaseType_t uxPriority,
;;;681    							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;682    	{
000004  b085              SUB      sp,sp,#0x14
000006  4680              MOV      r8,r0
000008  4689              MOV      r9,r1
00000a  4617              MOV      r7,r2
00000c  e9ddab12          LDRD     r10,r11,[sp,#0x48]
;;;683    	TCB_t *pxNewTCB;
;;;684    	BaseType_t xReturn;
;;;685    
;;;686    		/* If the stack grows down then allocate the stack then the TCB so the stack
;;;687    		does not grow into the TCB.  Likewise if the stack grows up then allocate
;;;688    		the TCB then the stack. */
;;;689    		#if( portSTACK_GROWTH > 0 )
;;;690    		{
;;;691    			/* Allocate space for the TCB.  Where the memory comes from depends on
;;;692    			the implementation of the port malloc function and whether or not static
;;;693    			allocation is being used. */
;;;694    			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
;;;695    
;;;696    			if( pxNewTCB != NULL )
;;;697    			{
;;;698    				/* Allocate space for the stack used by the task being created.
;;;699    				The base of the stack memory stored in the TCB so the task can
;;;700    				be deleted later if required. */
;;;701    				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;;;702    
;;;703    				if( pxNewTCB->pxStack == NULL )
;;;704    				{
;;;705    					/* Could not allocate the stack.  Delete the allocated TCB. */
;;;706    					vPortFree( pxNewTCB );
;;;707    					pxNewTCB = NULL;
;;;708    				}
;;;709    			}
;;;710    		}
;;;711    		#else /* portSTACK_GROWTH */
;;;712    		{
;;;713    		StackType_t *pxStack;
;;;714    
;;;715    			/* Allocate space for the stack used by the task being created. */
;;;716    			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000010  00b8              LSLS     r0,r7,#2
000012  f7fffffe          BL       pvPortMalloc
000016  4606              MOV      r6,r0
;;;717    
;;;718    			if( pxStack != NULL )
000018  b156              CBZ      r6,|L45.48|
;;;719    			{
;;;720    				/* Allocate space for the TCB. */
;;;721    				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
00001a  2064              MOVS     r0,#0x64
00001c  f7fffffe          BL       pvPortMalloc
000020  4604              MOV      r4,r0
;;;722    
;;;723    				if( pxNewTCB != NULL )
000022  b10c              CBZ      r4,|L45.40|
;;;724    				{
;;;725    					/* Store the stack location in the TCB. */
;;;726    					pxNewTCB->pxStack = pxStack;
000024  6326              STR      r6,[r4,#0x30]
000026  e004              B        |L45.50|
                  |L45.40|
;;;727    				}
;;;728    				else
;;;729    				{
;;;730    					/* The stack cannot be used as the TCB was not created.  Free
;;;731    					it again. */
;;;732    					vPortFree( pxStack );
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       vPortFree
00002e  e000              B        |L45.50|
                  |L45.48|
;;;733    				}
;;;734    			}
;;;735    			else
;;;736    			{
;;;737    				pxNewTCB = NULL;
000030  2400              MOVS     r4,#0
                  |L45.50|
;;;738    			}
;;;739    		}
;;;740    		#endif /* portSTACK_GROWTH */
;;;741    
;;;742    		if( pxNewTCB != NULL )
000032  b17c              CBZ      r4,|L45.84|
;;;743    		{
;;;744    			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
;;;745    			{
;;;746    				/* Tasks can be created statically or dynamically, so note this
;;;747    				task was created dynamically in case it is later deleted. */
;;;748    				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
;;;749    			}
;;;750    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;751    
;;;752    			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
000034  2000              MOVS     r0,#0
000036  e9cdab00          STRD     r10,r11,[sp,#0]
00003a  e9cd4002          STRD     r4,r0,[sp,#8]
00003e  463a              MOV      r2,r7
000040  4649              MOV      r1,r9
000042  4640              MOV      r0,r8
000044  9b08              LDR      r3,[sp,#0x20]
000046  f7fffffe          BL       prvInitialiseNewTask
;;;753    			prvAddNewTaskToReadyList( pxNewTCB );
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       prvAddNewTaskToReadyList
;;;754    			xReturn = pdPASS;
000050  2501              MOVS     r5,#1
000052  e001              B        |L45.88|
                  |L45.84|
;;;755    		}
;;;756    		else
;;;757    		{
;;;758    			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
000054  f04f35ff          MOV      r5,#0xffffffff
                  |L45.88|
;;;759    		}
;;;760    
;;;761    		return xReturn;
000058  4628              MOV      r0,r5
;;;762    	}
00005a  b009              ADD      sp,sp,#0x24
00005c  e8bd8ff0          POP      {r4-r11,pc}
;;;763    
                          ENDP


                          AREA ||i.xTaskGenericNotify||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  xTaskGenericNotify PROC
;;;4342   
;;;4343   	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;4344   	{
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;4345   	TCB_t * pxTCB;
;;;4346   	BaseType_t xReturn = pdPASS;
00000c  f04f0a01          MOV      r10,#1
;;;4347   	uint8_t ucOriginalNotifyState;
;;;4348   
;;;4349   		configASSERT( xTaskToNotify );
000010  b92e              CBNZ     r6,|L46.30|
000012  f24102fd          MOV      r2,#0x10fd
000016  a132              ADR      r1,|L46.224|
000018  a036              ADR      r0,|L46.244|
00001a  f7fffffe          BL       __2printf
                  |L46.30|
;;;4350   		pxTCB = ( TCB_t * ) xTaskToNotify;
00001e  4634              MOV      r4,r6
;;;4351   
;;;4352   		taskENTER_CRITICAL();
000020  f7fffffe          BL       vPortEnterCritical
;;;4353   		{
;;;4354   			if( pulPreviousNotificationValue != NULL )
000024  f1b80f00          CMP      r8,#0
000028  d002              BEQ      |L46.48|
;;;4355   			{
;;;4356   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
00002a  6de0              LDR      r0,[r4,#0x5c]
00002c  f8c80000          STR      r0,[r8,#0]
                  |L46.48|
;;;4357   			}
;;;4358   
;;;4359   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000030  f8949060          LDRB     r9,[r4,#0x60]
;;;4360   
;;;4361   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000034  2002              MOVS     r0,#2
000036  f8840060          STRB     r0,[r4,#0x60]
;;;4362   
;;;4363   			switch( eAction )
00003a  2f05              CMP      r7,#5
00003c  d217              BCS      |L46.110|
00003e  e8dff007          TBB      [pc,r7]
000042  1503              DCB      0x15,0x03
000044  070b0d00          DCB      0x07,0x0b,0x0d,0x00
;;;4364   			{
;;;4365   				case eSetBits	:
;;;4366   					pxTCB->ulNotifiedValue |= ulValue;
000048  6de0              LDR      r0,[r4,#0x5c]
00004a  4328              ORRS     r0,r0,r5
00004c  65e0              STR      r0,[r4,#0x5c]
;;;4367   					break;
00004e  e00e              B        |L46.110|
;;;4368   
;;;4369   				case eIncrement	:
;;;4370   					( pxTCB->ulNotifiedValue )++;
000050  6de0              LDR      r0,[r4,#0x5c]
000052  1c40              ADDS     r0,r0,#1
000054  65e0              STR      r0,[r4,#0x5c]
;;;4371   					break;
000056  e00a              B        |L46.110|
;;;4372   
;;;4373   				case eSetValueWithOverwrite	:
;;;4374   					pxTCB->ulNotifiedValue = ulValue;
000058  65e5              STR      r5,[r4,#0x5c]
;;;4375   					break;
00005a  e008              B        |L46.110|
;;;4376   
;;;4377   				case eSetValueWithoutOverwrite :
;;;4378   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
00005c  f1b90f02          CMP      r9,#2
000060  d001              BEQ      |L46.102|
;;;4379   					{
;;;4380   						pxTCB->ulNotifiedValue = ulValue;
000062  65e5              STR      r5,[r4,#0x5c]
000064  e001              B        |L46.106|
                  |L46.102|
;;;4381   					}
;;;4382   					else
;;;4383   					{
;;;4384   						/* The value could not be written to the task. */
;;;4385   						xReturn = pdFAIL;
000066  f04f0a00          MOV      r10,#0
                  |L46.106|
;;;4386   					}
;;;4387   					break;
00006a  e000              B        |L46.110|
;;;4388   
;;;4389   				case eNoAction:
;;;4390   					/* The task is being notified without its notify value being
;;;4391   					updated. */
;;;4392   					break;
00006c  bf00              NOP      
                  |L46.110|
00006e  bf00              NOP                            ;4367
;;;4393   			}
;;;4394   
;;;4395   			traceTASK_NOTIFY();
;;;4396   
;;;4397   			/* If the task is in the blocked state specifically to wait for a
;;;4398   			notification then unblock it now. */
;;;4399   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
000070  f1b90f01          CMP      r9,#1
000074  d12e              BNE      |L46.212|
;;;4400   			{
;;;4401   				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000076  1d20              ADDS     r0,r4,#4
000078  f7fffffe          BL       uxListRemove
;;;4402   				prvAddTaskToReadyList( pxTCB );
00007c  f894102c          LDRB     r1,[r4,#0x2c]
000080  2001              MOVS     r0,#1
000082  4088              LSLS     r0,r0,r1
000084  491f              LDR      r1,|L46.260|
000086  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000088  4308              ORRS     r0,r0,r1
00008a  491e              LDR      r1,|L46.260|
00008c  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
00008e  6ae1              LDR      r1,[r4,#0x2c]
000090  eb010181          ADD      r1,r1,r1,LSL #2
000094  4a1c              LDR      r2,|L46.264|
000096  eb020081          ADD      r0,r2,r1,LSL #2
00009a  1d21              ADDS     r1,r4,#4
00009c  f7fffffe          BL       vListInsertEnd
;;;4403   
;;;4404   				/* The task should not have been on an event list. */
;;;4405   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
0000a0  6aa0              LDR      r0,[r4,#0x28]
0000a2  b908              CBNZ     r0,|L46.168|
0000a4  2001              MOVS     r0,#1
0000a6  e000              B        |L46.170|
                  |L46.168|
0000a8  2000              MOVS     r0,#0
                  |L46.170|
0000aa  b928              CBNZ     r0,|L46.184|
0000ac  f2411235          MOV      r2,#0x1135
0000b0  a10b              ADR      r1,|L46.224|
0000b2  a010              ADR      r0,|L46.244|
0000b4  f7fffffe          BL       __2printf
                  |L46.184|
;;;4406   
;;;4407   				#if( configUSE_TICKLESS_IDLE != 0 )
;;;4408   				{
;;;4409   					/* If a task is blocked waiting for a notification then
;;;4410   					xNextTaskUnblockTime might be set to the blocked task's time
;;;4411   					out time.  If the task is unblocked for a reason other than
;;;4412   					a timeout xNextTaskUnblockTime is normally left unchanged,
;;;4413   					because it will automatically get reset to a new value when
;;;4414   					the tick count equals xNextTaskUnblockTime.  However if
;;;4415   					tickless idling is used it might be more important to enter
;;;4416   					sleep mode at the earliest possible time - so reset
;;;4417   					xNextTaskUnblockTime here to ensure it is updated at the
;;;4418   					earliest possible time. */
;;;4419   					prvResetNextTaskUnblockTime();
;;;4420   				}
;;;4421   				#endif
;;;4422   
;;;4423   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
0000b8  4914              LDR      r1,|L46.268|
0000ba  6ae0              LDR      r0,[r4,#0x2c]
0000bc  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000be  6ac9              LDR      r1,[r1,#0x2c]
0000c0  4288              CMP      r0,r1
0000c2  d907              BLS      |L46.212|
;;;4424   				{
;;;4425   					/* The notified task has a priority above the currently
;;;4426   					executing task so a yield is required. */
;;;4427   					taskYIELD_IF_USING_PREEMPTION();
0000c4  f04f5080          MOV      r0,#0x10000000
0000c8  4911              LDR      r1,|L46.272|
0000ca  6008              STR      r0,[r1,#0]
0000cc  f3bf8f4f          DSB      
0000d0  f3bf8f6f          ISB      
                  |L46.212|
;;;4428   				}
;;;4429   				else
;;;4430   				{
;;;4431   					mtCOVERAGE_TEST_MARKER();
;;;4432   				}
;;;4433   			}
;;;4434   			else
;;;4435   			{
;;;4436   				mtCOVERAGE_TEST_MARKER();
;;;4437   			}
;;;4438   		}
;;;4439   		taskEXIT_CRITICAL();
0000d4  f7fffffe          BL       vPortExitCritical
;;;4440   
;;;4441   		return xReturn;
0000d8  4650              MOV      r0,r10
;;;4442   	}
0000da  e8bd87f0          POP      {r4-r10,pc}
;;;4443   
                          ENDP

0000de  0000              DCW      0x0000
                  |L46.224|
0000e0  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
0000e4  72656552
0000e8  544f535c
0000ec  7461736b
0000f0  732e6300
                  |L46.244|
0000f4  4572726f          DCB      "Error:%s,%d\r\n",0
0000f8  723a2573
0000fc  2c25640d
000100  0a00    
000102  00                DCB      0
000103  00                DCB      0
                  |L46.260|
                          DCD      uxTopReadyPriority
                  |L46.264|
                          DCD      pxReadyTasksLists
                  |L46.268|
                          DCD      pxCurrentTCB
                  |L46.272|
                          DCD      0xe000ed04

                          AREA ||i.xTaskGenericNotifyFromISR||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  xTaskGenericNotifyFromISR PROC
;;;4448   
;;;4449   	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;4450   	{
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  f8ddb028          LDR      r11,[sp,#0x28]
;;;4451   	TCB_t * pxTCB;
;;;4452   	uint8_t ucOriginalNotifyState;
;;;4453   	BaseType_t xReturn = pdPASS;
000010  2001              MOVS     r0,#1
000012  9000              STR      r0,[sp,#0]
;;;4454   	UBaseType_t uxSavedInterruptStatus;
;;;4455   
;;;4456   		configASSERT( xTaskToNotify );
000014  b92f              CBNZ     r7,|L47.34|
000016  f2411268          MOV      r2,#0x1168
00001a  a13f              ADR      r1,|L47.280|
00001c  a043              ADR      r0,|L47.300|
00001e  f7fffffe          BL       __2printf
                  |L47.34|
;;;4457   
;;;4458   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4459   		maximum	system call (or maximum API call) interrupt priority.
;;;4460   		Interrupts that are	above the maximum system call priority are keep
;;;4461   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4462   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4463   		is defined in FreeRTOSConfig.h then
;;;4464   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4465   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4466   		been assigned a priority above the configured maximum system call
;;;4467   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4468   		from interrupts	that have been assigned a priority at or (logically)
;;;4469   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4470   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4471   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4472   		provided on the following link:
;;;4473   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4474   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000022  f7fffffe          BL       vPortValidateInterruptPriority
;;;4475   
;;;4476   		pxTCB = ( TCB_t * ) xTaskToNotify;
000026  463c              MOV      r4,r7
;;;4477   
;;;4478   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000028  bf00              NOP      
00002a  2160              MOVS     r1,#0x60
00002c  f3ef8011          MRS      r0,BASEPRI
000030  f3818811          MSR      BASEPRI,r1
000034  f3bf8f4f          DSB      
000038  f3bf8f6f          ISB      
00003c  bf00              NOP      
00003e  4605              MOV      r5,r0
;;;4479   		{
;;;4480   			if( pulPreviousNotificationValue != NULL )
000040  f1b90f00          CMP      r9,#0
000044  d002              BEQ      |L47.76|
;;;4481   			{
;;;4482   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000046  6de0              LDR      r0,[r4,#0x5c]
000048  f8c90000          STR      r0,[r9,#0]
                  |L47.76|
;;;4483   			}
;;;4484   
;;;4485   			ucOriginalNotifyState = pxTCB->ucNotifyState;
00004c  f894a060          LDRB     r10,[r4,#0x60]
;;;4486   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000050  2002              MOVS     r0,#2
000052  f8840060          STRB     r0,[r4,#0x60]
;;;4487   
;;;4488   			switch( eAction )
000056  f1b80f05          CMP      r8,#5
00005a  d217              BCS      |L47.140|
00005c  e8dff008          TBB      [pc,r8]
000060  1503070b          DCB      0x15,0x03,0x07,0x0b
000064  0d00              DCB      0x0d,0x00
;;;4489   			{
;;;4490   				case eSetBits	:
;;;4491   					pxTCB->ulNotifiedValue |= ulValue;
000066  6de0              LDR      r0,[r4,#0x5c]
000068  4330              ORRS     r0,r0,r6
00006a  65e0              STR      r0,[r4,#0x5c]
;;;4492   					break;
00006c  e00e              B        |L47.140|
;;;4493   
;;;4494   				case eIncrement	:
;;;4495   					( pxTCB->ulNotifiedValue )++;
00006e  6de0              LDR      r0,[r4,#0x5c]
000070  1c40              ADDS     r0,r0,#1
000072  65e0              STR      r0,[r4,#0x5c]
;;;4496   					break;
000074  e00a              B        |L47.140|
;;;4497   
;;;4498   				case eSetValueWithOverwrite	:
;;;4499   					pxTCB->ulNotifiedValue = ulValue;
000076  65e6              STR      r6,[r4,#0x5c]
;;;4500   					break;
000078  e008              B        |L47.140|
;;;4501   
;;;4502   				case eSetValueWithoutOverwrite :
;;;4503   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
00007a  f1ba0f02          CMP      r10,#2
00007e  d001              BEQ      |L47.132|
;;;4504   					{
;;;4505   						pxTCB->ulNotifiedValue = ulValue;
000080  65e6              STR      r6,[r4,#0x5c]
000082  e001              B        |L47.136|
                  |L47.132|
;;;4506   					}
;;;4507   					else
;;;4508   					{
;;;4509   						/* The value could not be written to the task. */
;;;4510   						xReturn = pdFAIL;
000084  2000              MOVS     r0,#0
000086  9000              STR      r0,[sp,#0]
                  |L47.136|
;;;4511   					}
;;;4512   					break;
000088  e000              B        |L47.140|
;;;4513   
;;;4514   				case eNoAction :
;;;4515   					/* The task is being notified without its notify value being
;;;4516   					updated. */
;;;4517   					break;
00008a  bf00              NOP      
                  |L47.140|
00008c  bf00              NOP                            ;4492
;;;4518   			}
;;;4519   
;;;4520   			traceTASK_NOTIFY_FROM_ISR();
;;;4521   
;;;4522   			/* If the task is in the blocked state specifically to wait for a
;;;4523   			notification then unblock it now. */
;;;4524   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
00008e  f1ba0f01          CMP      r10,#1
000092  d139              BNE      |L47.264|
;;;4525   			{
;;;4526   				/* The task should not have been on an event list. */
;;;4527   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
000094  6aa0              LDR      r0,[r4,#0x28]
000096  b908              CBNZ     r0,|L47.156|
000098  2001              MOVS     r0,#1
00009a  e000              B        |L47.158|
                  |L47.156|
00009c  2000              MOVS     r0,#0
                  |L47.158|
00009e  b928              CBNZ     r0,|L47.172|
0000a0  f24112af          MOV      r2,#0x11af
0000a4  a11c              ADR      r1,|L47.280|
0000a6  a021              ADR      r0,|L47.300|
0000a8  f7fffffe          BL       __2printf
                  |L47.172|
;;;4528   
;;;4529   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
0000ac  4823              LDR      r0,|L47.316|
0000ae  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
0000b0  b9a8              CBNZ     r0,|L47.222|
;;;4530   				{
;;;4531   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
0000b2  1d20              ADDS     r0,r4,#4
0000b4  f7fffffe          BL       uxListRemove
;;;4532   					prvAddTaskToReadyList( pxTCB );
0000b8  f894102c          LDRB     r1,[r4,#0x2c]
0000bc  2001              MOVS     r0,#1
0000be  4088              LSLS     r0,r0,r1
0000c0  491f              LDR      r1,|L47.320|
0000c2  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000c4  4308              ORRS     r0,r0,r1
0000c6  491e              LDR      r1,|L47.320|
0000c8  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
0000ca  6ae1              LDR      r1,[r4,#0x2c]
0000cc  eb010181          ADD      r1,r1,r1,LSL #2
0000d0  4a1c              LDR      r2,|L47.324|
0000d2  eb020081          ADD      r0,r2,r1,LSL #2
0000d6  1d21              ADDS     r1,r4,#4
0000d8  f7fffffe          BL       vListInsertEnd
0000dc  e004              B        |L47.232|
                  |L47.222|
;;;4533   				}
;;;4534   				else
;;;4535   				{
;;;4536   					/* The delayed and ready lists cannot be accessed, so hold
;;;4537   					this task pending until the scheduler is resumed. */
;;;4538   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
0000de  f1040118          ADD      r1,r4,#0x18
0000e2  4819              LDR      r0,|L47.328|
0000e4  f7fffffe          BL       vListInsertEnd
                  |L47.232|
;;;4539   				}
;;;4540   
;;;4541   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
0000e8  4918              LDR      r1,|L47.332|
0000ea  6ae0              LDR      r0,[r4,#0x2c]
0000ec  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000ee  6ac9              LDR      r1,[r1,#0x2c]
0000f0  4288              CMP      r0,r1
0000f2  d909              BLS      |L47.264|
;;;4542   				{
;;;4543   					/* The notified task has a priority above the currently
;;;4544   					executing task so a yield is required. */
;;;4545   					if( pxHigherPriorityTaskWoken != NULL )
0000f4  f1bb0f00          CMP      r11,#0
0000f8  d003              BEQ      |L47.258|
;;;4546   					{
;;;4547   						*pxHigherPriorityTaskWoken = pdTRUE;
0000fa  2001              MOVS     r0,#1
0000fc  f8cb0000          STR      r0,[r11,#0]
000100  e002              B        |L47.264|
                  |L47.258|
;;;4548   					}
;;;4549   					else
;;;4550   					{
;;;4551   						/* Mark that a yield is pending in case the user is not
;;;4552   						using the "xHigherPriorityTaskWoken" parameter to an ISR
;;;4553   						safe FreeRTOS function. */
;;;4554   						xYieldPending = pdTRUE;
000102  2001              MOVS     r0,#1
000104  4912              LDR      r1,|L47.336|
000106  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L47.264|
;;;4555   					}
;;;4556   				}
;;;4557   				else
;;;4558   				{
;;;4559   					mtCOVERAGE_TEST_MARKER();
;;;4560   				}
;;;4561   			}
;;;4562   		}
;;;4563   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000108  bf00              NOP      
00010a  f3858811          MSR      BASEPRI,r5
00010e  bf00              NOP      
;;;4564   
;;;4565   		return xReturn;
000110  9800              LDR      r0,[sp,#0]
;;;4566   	}
000112  e8bd8ff8          POP      {r3-r11,pc}
;;;4567   
                          ENDP

000116  0000              DCW      0x0000
                  |L47.280|
000118  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
00011c  72656552
000120  544f535c
000124  7461736b
000128  732e6300
                  |L47.300|
00012c  4572726f          DCB      "Error:%s,%d\r\n",0
000130  723a2573
000134  2c25640d
000138  0a00    
00013a  00                DCB      0
00013b  00                DCB      0
                  |L47.316|
                          DCD      uxSchedulerSuspended
                  |L47.320|
                          DCD      uxTopReadyPriority
                  |L47.324|
                          DCD      pxReadyTasksLists
                  |L47.328|
                          DCD      xPendingReadyList
                  |L47.332|
                          DCD      pxCurrentTCB
                  |L47.336|
                          DCD      xYieldPending

                          AREA ||i.xTaskGetCurrentTaskHandle||, CODE, READONLY, ALIGN=2

                  xTaskGetCurrentTaskHandle PROC
;;;3660   
;;;3661   	TaskHandle_t xTaskGetCurrentTaskHandle( void )
000000  4901              LDR      r1,|L48.8|
;;;3662   	{
;;;3663   	TaskHandle_t xReturn;
;;;3664   
;;;3665   		/* A critical section is not required as this is not called from
;;;3666   		an interrupt and the current TCB will always be the same for any
;;;3667   		individual execution thread. */
;;;3668   		xReturn = pxCurrentTCB;
000002  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;3669   
;;;3670   		return xReturn;
;;;3671   	}
000004  4770              BX       lr
;;;3672   
                          ENDP

000006  0000              DCW      0x0000
                  |L48.8|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskGetSchedulerState||, CODE, READONLY, ALIGN=2

                  xTaskGetSchedulerState PROC
;;;3677   
;;;3678   	BaseType_t xTaskGetSchedulerState( void )
000000  4905              LDR      r1,|L49.24|
;;;3679   	{
;;;3680   	BaseType_t xReturn;
;;;3681   
;;;3682   		if( xSchedulerRunning == pdFALSE )
000002  6809              LDR      r1,[r1,#0]  ; xSchedulerRunning
000004  b909              CBNZ     r1,|L49.10|
;;;3683   		{
;;;3684   			xReturn = taskSCHEDULER_NOT_STARTED;
000006  2001              MOVS     r0,#1
000008  e005              B        |L49.22|
                  |L49.10|
;;;3685   		}
;;;3686   		else
;;;3687   		{
;;;3688   			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00000a  4904              LDR      r1,|L49.28|
00000c  6809              LDR      r1,[r1,#0]  ; uxSchedulerSuspended
00000e  b909              CBNZ     r1,|L49.20|
;;;3689   			{
;;;3690   				xReturn = taskSCHEDULER_RUNNING;
000010  2002              MOVS     r0,#2
000012  e000              B        |L49.22|
                  |L49.20|
;;;3691   			}
;;;3692   			else
;;;3693   			{
;;;3694   				xReturn = taskSCHEDULER_SUSPENDED;
000014  2000              MOVS     r0,#0
                  |L49.22|
;;;3695   			}
;;;3696   		}
;;;3697   
;;;3698   		return xReturn;
;;;3699   	}
000016  4770              BX       lr
;;;3700   
                          ENDP

                  |L49.24|
                          DCD      xSchedulerRunning
                  |L49.28|
                          DCD      uxSchedulerSuspended

                          AREA ||i.xTaskGetTickCount||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCount PROC
;;;2126   
;;;2127   TickType_t xTaskGetTickCount( void )
000000  4901              LDR      r1,|L50.8|
;;;2128   {
;;;2129   TickType_t xTicks;
;;;2130   
;;;2131   	/* Critical section required if running on a 16 bit processor. */
;;;2132   	portTICK_TYPE_ENTER_CRITICAL();
;;;2133   	{
;;;2134   		xTicks = xTickCount;
000002  6808              LDR      r0,[r1,#0]  ; xTickCount
;;;2135   	}
;;;2136   	portTICK_TYPE_EXIT_CRITICAL();
;;;2137   
;;;2138   	return xTicks;
;;;2139   }
000004  4770              BX       lr
;;;2140   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L50.8|
                          DCD      xTickCount

                          AREA ||i.xTaskGetTickCountFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCountFromISR PROC
;;;2141   
;;;2142   TickType_t xTaskGetTickCountFromISR( void )
000000  b570              PUSH     {r4-r6,lr}
;;;2143   {
;;;2144   TickType_t xReturn;
;;;2145   UBaseType_t uxSavedInterruptStatus;
;;;2146   
;;;2147   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;2148   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;2149   	above the maximum system call priority are kept permanently enabled, even
;;;2150   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;2151   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;2152   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;2153   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;2154   	assigned a priority above the configured maximum system call priority.
;;;2155   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;2156   	that have been assigned a priority at or (logically) below the maximum
;;;2157   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;2158   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;2159   	More information (albeit Cortex-M specific) is provided on the following
;;;2160   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;2161   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000002  f7fffffe          BL       vPortValidateInterruptPriority
;;;2162   
;;;2163   	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
000006  2500              MOVS     r5,#0
;;;2164   	{
;;;2165   		xReturn = xTickCount;
000008  4801              LDR      r0,|L51.16|
00000a  6804              LDR      r4,[r0,#0]  ; xTickCount
;;;2166   	}
;;;2167   	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;2168   
;;;2169   	return xReturn;
00000c  4620              MOV      r0,r4
;;;2170   }
00000e  bd70              POP      {r4-r6,pc}
;;;2171   /*-----------------------------------------------------------*/
                          ENDP

                  |L51.16|
                          DCD      xTickCount

                          AREA ||i.xTaskIncrementTick||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  xTaskIncrementTick PROC
;;;2498   
;;;2499   BaseType_t xTaskIncrementTick( void )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2500   {
;;;2501   TCB_t * pxTCB;
;;;2502   TickType_t xItemValue;
;;;2503   BaseType_t xSwitchRequired = pdFALSE;
000004  f04f0800          MOV      r8,#0
;;;2504   
;;;2505   	/* Called by the portable layer each time a tick interrupt occurs.
;;;2506   	Increments the tick then checks to see if the new tick value will cause any
;;;2507   	tasks to be unblocked. */
;;;2508   	traceTASK_INCREMENT_TICK( xTickCount );
;;;2509   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000008  4841              LDR      r0,|L52.272|
00000a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000c  2800              CMP      r0,#0
00000e  d172              BNE      |L52.246|
;;;2510   	{
;;;2511   		/* Minor optimisation.  The tick count cannot change in this
;;;2512   		block. */
;;;2513   		const TickType_t xConstTickCount = xTickCount + 1;
000010  4840              LDR      r0,|L52.276|
000012  6800              LDR      r0,[r0,#0]  ; xTickCount
000014  1c45              ADDS     r5,r0,#1
;;;2514   
;;;2515   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;2516   		delayed lists if it wraps to 0. */
;;;2517   		xTickCount = xConstTickCount;
000016  483f              LDR      r0,|L52.276|
000018  6005              STR      r5,[r0,#0]  ; xTickCount
;;;2518   
;;;2519   		if( xConstTickCount == ( TickType_t ) 0U )
00001a  b9ed              CBNZ     r5,|L52.88|
;;;2520   		{
;;;2521   			taskSWITCH_DELAYED_LISTS();
00001c  483e              LDR      r0,|L52.280|
00001e  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000020  6800              LDR      r0,[r0,#0]
000022  b908              CBNZ     r0,|L52.40|
000024  2001              MOVS     r0,#1
000026  e000              B        |L52.42|
                  |L52.40|
000028  2000              MOVS     r0,#0
                  |L52.42|
00002a  b928              CBNZ     r0,|L52.56|
00002c  f64012d9          MOV      r2,#0x9d9
000030  a13a              ADR      r1,|L52.284|
000032  a03f              ADR      r0,|L52.304|
000034  f7fffffe          BL       __2printf
                  |L52.56|
000038  4837              LDR      r0,|L52.280|
00003a  6807              LDR      r7,[r0,#0]  ; pxDelayedTaskList
00003c  4840              LDR      r0,|L52.320|
00003e  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000040  4935              LDR      r1,|L52.280|
000042  6008              STR      r0,[r1,#0]  ; pxDelayedTaskList
000044  483e              LDR      r0,|L52.320|
000046  6007              STR      r7,[r0,#0]  ; pxOverflowDelayedTaskList
000048  483e              LDR      r0,|L52.324|
00004a  6800              LDR      r0,[r0,#0]  ; xNumOfOverflows
00004c  1c40              ADDS     r0,r0,#1
00004e  493d              LDR      r1,|L52.324|
000050  6008              STR      r0,[r1,#0]  ; xNumOfOverflows
000052  f7fffffe          BL       prvResetNextTaskUnblockTime
000056  bf00              NOP      
                  |L52.88|
;;;2522   		}
;;;2523   		else
;;;2524   		{
;;;2525   			mtCOVERAGE_TEST_MARKER();
;;;2526   		}
;;;2527   
;;;2528   		/* See if this tick has made a timeout expire.  Tasks are stored in
;;;2529   		the	queue in the order of their wake time - meaning once one task
;;;2530   		has been found whose block time has not expired there is no need to
;;;2531   		look any further down the list. */
;;;2532   		if( xConstTickCount >= xNextTaskUnblockTime )
000058  483b              LDR      r0,|L52.328|
00005a  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
00005c  4285              CMP      r5,r0
00005e  d33c              BCC      |L52.218|
;;;2533   		{
;;;2534   			for( ;; )
000060  bf00              NOP      
                  |L52.98|
;;;2535   			{
;;;2536   				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000062  482d              LDR      r0,|L52.280|
000064  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000066  6800              LDR      r0,[r0,#0]
000068  b908              CBNZ     r0,|L52.110|
00006a  2001              MOVS     r0,#1
00006c  e000              B        |L52.112|
                  |L52.110|
00006e  2000              MOVS     r0,#0
                  |L52.112|
000070  b120              CBZ      r0,|L52.124|
;;;2537   				{
;;;2538   					/* The delayed list is empty.  Set xNextTaskUnblockTime
;;;2539   					to the maximum possible value so it is extremely
;;;2540   					unlikely that the
;;;2541   					if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;2542   					next time through. */
;;;2543   					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000072  f04f30ff          MOV      r0,#0xffffffff
000076  4934              LDR      r1,|L52.328|
000078  6008              STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;2544   					break;
00007a  e02d              B        |L52.216|
                  |L52.124|
;;;2545   				}
;;;2546   				else
;;;2547   				{
;;;2548   					/* The delayed list is not empty, get the value of the
;;;2549   					item at the head of the delayed list.  This is the time
;;;2550   					at which the task at the head of the delayed list must
;;;2551   					be removed from the Blocked state. */
;;;2552   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
00007c  4826              LDR      r0,|L52.280|
00007e  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000080  68c0              LDR      r0,[r0,#0xc]
000082  68c4              LDR      r4,[r0,#0xc]
;;;2553   					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
000084  6866              LDR      r6,[r4,#4]
;;;2554   
;;;2555   					if( xConstTickCount < xItemValue )
000086  42b5              CMP      r5,r6
000088  d202              BCS      |L52.144|
;;;2556   					{
;;;2557   						/* It is not time to unblock this item yet, but the
;;;2558   						item value is the time at which the task at the head
;;;2559   						of the blocked list must be removed from the Blocked
;;;2560   						state -	so record the item value in
;;;2561   						xNextTaskUnblockTime. */
;;;2562   						xNextTaskUnblockTime = xItemValue;
00008a  482f              LDR      r0,|L52.328|
00008c  6006              STR      r6,[r0,#0]  ; xNextTaskUnblockTime
;;;2563   						break;
00008e  e023              B        |L52.216|
                  |L52.144|
;;;2564   					}
;;;2565   					else
;;;2566   					{
;;;2567   						mtCOVERAGE_TEST_MARKER();
;;;2568   					}
;;;2569   
;;;2570   					/* It is time to remove the item from the Blocked state. */
;;;2571   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000090  1d20              ADDS     r0,r4,#4
000092  f7fffffe          BL       uxListRemove
;;;2572   
;;;2573   					/* Is the task waiting on an event also?  If so remove
;;;2574   					it from the event list. */
;;;2575   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000096  6aa0              LDR      r0,[r4,#0x28]
000098  b118              CBZ      r0,|L52.162|
;;;2576   					{
;;;2577   						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00009a  f1040018          ADD      r0,r4,#0x18
00009e  f7fffffe          BL       uxListRemove
                  |L52.162|
;;;2578   					}
;;;2579   					else
;;;2580   					{
;;;2581   						mtCOVERAGE_TEST_MARKER();
;;;2582   					}
;;;2583   
;;;2584   					/* Place the unblocked task into the appropriate ready
;;;2585   					list. */
;;;2586   					prvAddTaskToReadyList( pxTCB );
0000a2  f894102c          LDRB     r1,[r4,#0x2c]
0000a6  2001              MOVS     r0,#1
0000a8  4088              LSLS     r0,r0,r1
0000aa  4928              LDR      r1,|L52.332|
0000ac  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000ae  4308              ORRS     r0,r0,r1
0000b0  4926              LDR      r1,|L52.332|
0000b2  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
0000b4  6ae1              LDR      r1,[r4,#0x2c]
0000b6  eb010181          ADD      r1,r1,r1,LSL #2
0000ba  4a25              LDR      r2,|L52.336|
0000bc  eb020081          ADD      r0,r2,r1,LSL #2
0000c0  1d21              ADDS     r1,r4,#4
0000c2  f7fffffe          BL       vListInsertEnd
;;;2587   
;;;2588   					/* A task being unblocked cannot cause an immediate
;;;2589   					context switch if preemption is turned off. */
;;;2590   					#if (  configUSE_PREEMPTION == 1 )
;;;2591   					{
;;;2592   						/* Preemption is on, but a context switch should
;;;2593   						only be performed if the unblocked task has a
;;;2594   						priority that is equal to or higher than the
;;;2595   						currently executing task. */
;;;2596   						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0000c6  4923              LDR      r1,|L52.340|
0000c8  6ae0              LDR      r0,[r4,#0x2c]
0000ca  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000cc  6ac9              LDR      r1,[r1,#0x2c]
0000ce  4288              CMP      r0,r1
0000d0  d3c7              BCC      |L52.98|
;;;2597   						{
;;;2598   							xSwitchRequired = pdTRUE;
0000d2  f04f0801          MOV      r8,#1
0000d6  e7c4              B        |L52.98|
                  |L52.216|
0000d8  bf00              NOP                            ;2544
                  |L52.218|
;;;2599   						}
;;;2600   						else
;;;2601   						{
;;;2602   							mtCOVERAGE_TEST_MARKER();
;;;2603   						}
;;;2604   					}
;;;2605   					#endif /* configUSE_PREEMPTION */
;;;2606   				}
;;;2607   			}
;;;2608   		}
;;;2609   
;;;2610   		/* Tasks of equal priority to the currently running task will share
;;;2611   		processing time (time slice) if preemption is on, and the application
;;;2612   		writer has not explicitly turned time slicing off. */
;;;2613   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;2614   		{
;;;2615   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
0000da  481e              LDR      r0,|L52.340|
0000dc  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0000de  6ac0              LDR      r0,[r0,#0x2c]
0000e0  eb000080          ADD      r0,r0,r0,LSL #2
0000e4  491a              LDR      r1,|L52.336|
0000e6  f8510020          LDR      r0,[r1,r0,LSL #2]
0000ea  2801              CMP      r0,#1
0000ec  d901              BLS      |L52.242|
;;;2616   			{
;;;2617   				xSwitchRequired = pdTRUE;
0000ee  f04f0801          MOV      r8,#1
                  |L52.242|
;;;2618   			}
;;;2619   			else
;;;2620   			{
;;;2621   				mtCOVERAGE_TEST_MARKER();
;;;2622   			}
;;;2623   		}
;;;2624   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;2625   
;;;2626   		#if ( configUSE_TICK_HOOK == 1 )
;;;2627   		{
;;;2628   			/* Guard against the tick hook being called when the pended tick
;;;2629   			count is being unwound (when the scheduler is being unlocked). */
;;;2630   			if( uxPendedTicks == ( UBaseType_t ) 0U )
;;;2631   			{
;;;2632   				vApplicationTickHook();
;;;2633   			}
;;;2634   			else
;;;2635   			{
;;;2636   				mtCOVERAGE_TEST_MARKER();
;;;2637   			}
;;;2638   		}
;;;2639   		#endif /* configUSE_TICK_HOOK */
;;;2640   	}
0000f2  e005              B        |L52.256|
0000f4  e7ff              B        |L52.246|
                  |L52.246|
;;;2641   	else
;;;2642   	{
;;;2643   		++uxPendedTicks;
0000f6  4818              LDR      r0,|L52.344|
0000f8  6800              LDR      r0,[r0,#0]  ; uxPendedTicks
0000fa  1c40              ADDS     r0,r0,#1
0000fc  4916              LDR      r1,|L52.344|
0000fe  6008              STR      r0,[r1,#0]  ; uxPendedTicks
                  |L52.256|
;;;2644   
;;;2645   		/* The tick hook gets called at regular intervals, even if the
;;;2646   		scheduler is locked. */
;;;2647   		#if ( configUSE_TICK_HOOK == 1 )
;;;2648   		{
;;;2649   			vApplicationTickHook();
;;;2650   		}
;;;2651   		#endif
;;;2652   	}
;;;2653   
;;;2654   	#if ( configUSE_PREEMPTION == 1 )
;;;2655   	{
;;;2656   		if( xYieldPending != pdFALSE )
000100  4816              LDR      r0,|L52.348|
000102  6800              LDR      r0,[r0,#0]  ; xYieldPending
000104  b108              CBZ      r0,|L52.266|
;;;2657   		{
;;;2658   			xSwitchRequired = pdTRUE;
000106  f04f0801          MOV      r8,#1
                  |L52.266|
;;;2659   		}
;;;2660   		else
;;;2661   		{
;;;2662   			mtCOVERAGE_TEST_MARKER();
;;;2663   		}
;;;2664   	}
;;;2665   	#endif /* configUSE_PREEMPTION */
;;;2666   
;;;2667   	return xSwitchRequired;
00010a  4640              MOV      r0,r8
;;;2668   }
00010c  e8bd81f0          POP      {r4-r8,pc}
;;;2669   /*-----------------------------------------------------------*/
                          ENDP

                  |L52.272|
                          DCD      uxSchedulerSuspended
                  |L52.276|
                          DCD      xTickCount
                  |L52.280|
                          DCD      pxDelayedTaskList
                  |L52.284|
00011c  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
000120  72656552
000124  544f535c
000128  7461736b
00012c  732e6300
                  |L52.304|
000130  4572726f          DCB      "Error:%s,%d\r\n",0
000134  723a2573
000138  2c25640d
00013c  0a00    
00013e  00                DCB      0
00013f  00                DCB      0
                  |L52.320|
                          DCD      pxOverflowDelayedTaskList
                  |L52.324|
                          DCD      xNumOfOverflows
                  |L52.328|
                          DCD      xNextTaskUnblockTime
                  |L52.332|
                          DCD      uxTopReadyPriority
                  |L52.336|
                          DCD      pxReadyTasksLists
                  |L52.340|
                          DCD      pxCurrentTCB
                  |L52.344|
                          DCD      uxPendedTicks
                  |L52.348|
                          DCD      xYieldPending

                          AREA ||i.xTaskNotifyStateClear||, CODE, READONLY, ALIGN=2

                  xTaskNotifyStateClear PROC
;;;4661   
;;;4662   	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;4663   	{
000002  4605              MOV      r5,r0
;;;4664   	TCB_t *pxTCB;
;;;4665   	BaseType_t xReturn;
;;;4666   
;;;4667   		/* If null is passed in here then it is the calling task that is having
;;;4668   		its notification state cleared. */
;;;4669   		pxTCB = prvGetTCBFromHandle( xTask );
000004  b915              CBNZ     r5,|L53.12|
000006  480a              LDR      r0,|L53.48|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000a  e000              B        |L53.14|
                  |L53.12|
00000c  4628              MOV      r0,r5
                  |L53.14|
00000e  4606              MOV      r6,r0
;;;4670   
;;;4671   		taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;4672   		{
;;;4673   			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
000014  f8960060          LDRB     r0,[r6,#0x60]
000018  2802              CMP      r0,#2
00001a  d104              BNE      |L53.38|
;;;4674   			{
;;;4675   				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00001c  2000              MOVS     r0,#0
00001e  f8860060          STRB     r0,[r6,#0x60]
;;;4676   				xReturn = pdPASS;
000022  2401              MOVS     r4,#1
000024  e000              B        |L53.40|
                  |L53.38|
;;;4677   			}
;;;4678   			else
;;;4679   			{
;;;4680   				xReturn = pdFAIL;
000026  2400              MOVS     r4,#0
                  |L53.40|
;;;4681   			}
;;;4682   		}
;;;4683   		taskEXIT_CRITICAL();
000028  f7fffffe          BL       vPortExitCritical
;;;4684   
;;;4685   		return xReturn;
00002c  4620              MOV      r0,r4
;;;4686   	}
00002e  bd70              POP      {r4-r6,pc}
;;;4687   
                          ENDP

                  |L53.48|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskNotifyWait||, CODE, READONLY, ALIGN=2

                  xTaskNotifyWait PROC
;;;4262   
;;;4263   	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4264   	{
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;4265   	BaseType_t xReturn;
;;;4266   
;;;4267   		taskENTER_CRITICAL();
00000c  f7fffffe          BL       vPortEnterCritical
;;;4268   		{
;;;4269   			/* Only block if a notification is not already pending. */
;;;4270   			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
000010  4821              LDR      r0,|L54.152|
000012  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000014  f8900060          LDRB     r0,[r0,#0x60]
000018  2802              CMP      r0,#2
00001a  d018              BEQ      |L54.78|
;;;4271   			{
;;;4272   				/* Clear bits in the task's notification value as bits may get
;;;4273   				set	by the notifying task or interrupt.  This can be used to
;;;4274   				clear the value to zero. */
;;;4275   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
00001c  491e              LDR      r1,|L54.152|
00001e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000020  f101005c          ADD      r0,r1,#0x5c
000024  6dc9              LDR      r1,[r1,#0x5c]
000026  43b9              BICS     r1,r1,r7
000028  6001              STR      r1,[r0,#0]
;;;4276   
;;;4277   				/* Mark this task as waiting for a notification. */
;;;4278   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
00002a  2001              MOVS     r0,#1
00002c  491a              LDR      r1,|L54.152|
00002e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000030  f8810060          STRB     r0,[r1,#0x60]
;;;4279   
;;;4280   				if( xTicksToWait > ( TickType_t ) 0 )
000034  b15d              CBZ      r5,|L54.78|
;;;4281   				{
;;;4282   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000036  2101              MOVS     r1,#1
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4283   					traceTASK_NOTIFY_WAIT_BLOCK();
;;;4284   
;;;4285   					/* All ports are written to allow a yield in a critical
;;;4286   					section (some will yield immediately, others wait until the
;;;4287   					critical section exits) - but it is not something that
;;;4288   					application code should ever do. */
;;;4289   					portYIELD_WITHIN_API();
00003e  f04f5080          MOV      r0,#0x10000000
000042  4916              LDR      r1,|L54.156|
000044  6008              STR      r0,[r1,#0]
000046  f3bf8f4f          DSB      
00004a  f3bf8f6f          ISB      
                  |L54.78|
;;;4290   				}
;;;4291   				else
;;;4292   				{
;;;4293   					mtCOVERAGE_TEST_MARKER();
;;;4294   				}
;;;4295   			}
;;;4296   			else
;;;4297   			{
;;;4298   				mtCOVERAGE_TEST_MARKER();
;;;4299   			}
;;;4300   		}
;;;4301   		taskEXIT_CRITICAL();
00004e  f7fffffe          BL       vPortExitCritical
;;;4302   
;;;4303   		taskENTER_CRITICAL();
000052  f7fffffe          BL       vPortEnterCritical
;;;4304   		{
;;;4305   			traceTASK_NOTIFY_WAIT();
;;;4306   
;;;4307   			if( pulNotificationValue != NULL )
000056  b11c              CBZ      r4,|L54.96|
;;;4308   			{
;;;4309   				/* Output the current notification value, which may or may not
;;;4310   				have changed. */
;;;4311   				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
000058  480f              LDR      r0,|L54.152|
00005a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00005c  6dc0              LDR      r0,[r0,#0x5c]
00005e  6020              STR      r0,[r4,#0]
                  |L54.96|
;;;4312   			}
;;;4313   
;;;4314   			/* If ucNotifyValue is set then either the task never entered the
;;;4315   			blocked state (because a notification was already pending) or the
;;;4316   			task unblocked because of a notification.  Otherwise the task
;;;4317   			unblocked because of a timeout. */
;;;4318   			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
000060  480d              LDR      r0,|L54.152|
000062  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000064  f8900060          LDRB     r0,[r0,#0x60]
000068  2801              CMP      r0,#1
00006a  d101              BNE      |L54.112|
;;;4319   			{
;;;4320   				/* A notification was not received. */
;;;4321   				xReturn = pdFALSE;
00006c  2600              MOVS     r6,#0
00006e  e008              B        |L54.130|
                  |L54.112|
;;;4322   			}
;;;4323   			else
;;;4324   			{
;;;4325   				/* A notification was already pending or a notification was
;;;4326   				received while the task was waiting. */
;;;4327   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
000070  4909              LDR      r1,|L54.152|
000072  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000074  f101005c          ADD      r0,r1,#0x5c
000078  6dc9              LDR      r1,[r1,#0x5c]
00007a  ea210108          BIC      r1,r1,r8
00007e  6001              STR      r1,[r0,#0]
;;;4328   				xReturn = pdTRUE;
000080  2601              MOVS     r6,#1
                  |L54.130|
;;;4329   			}
;;;4330   
;;;4331   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000082  2000              MOVS     r0,#0
000084  4904              LDR      r1,|L54.152|
000086  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000088  f8810060          STRB     r0,[r1,#0x60]
;;;4332   		}
;;;4333   		taskEXIT_CRITICAL();
00008c  f7fffffe          BL       vPortExitCritical
;;;4334   
;;;4335   		return xReturn;
000090  4630              MOV      r0,r6
;;;4336   	}
000092  e8bd81f0          POP      {r4-r8,pc}
;;;4337   
                          ENDP

000096  0000              DCW      0x0000
                  |L54.152|
                          DCD      pxCurrentTCB
                  |L54.156|
                          DCD      0xe000ed04

                          AREA ||i.xTaskPriorityDisinherit||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  xTaskPriorityDisinherit PROC
;;;3771   
;;;3772   	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;3773   	{
000002  4605              MOV      r5,r0
;;;3774   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
000004  462c              MOV      r4,r5
;;;3775   	BaseType_t xReturn = pdFALSE;
000006  2600              MOVS     r6,#0
;;;3776   
;;;3777   		if( pxMutexHolder != NULL )
000008  2d00              CMP      r5,#0
00000a  d04b              BEQ      |L55.164|
;;;3778   		{
;;;3779   			/* A task can only have an inherited priority if it holds the mutex.
;;;3780   			If the mutex is held by a task then it cannot be given from an
;;;3781   			interrupt, and if a mutex is given by the holding task then it must
;;;3782   			be the running state task. */
;;;3783   			configASSERT( pxTCB == pxCurrentTCB );
00000c  4826              LDR      r0,|L55.168|
00000e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000010  4284              CMP      r4,r0
000012  d101              BNE      |L55.24|
000014  2001              MOVS     r0,#1
000016  e000              B        |L55.26|
                  |L55.24|
000018  2000              MOVS     r0,#0
                  |L55.26|
00001a  b928              CBNZ     r0,|L55.40|
00001c  f64062c7          MOV      r2,#0xec7
000020  a122              ADR      r1,|L55.172|
000022  a027              ADR      r0,|L55.192|
000024  f7fffffe          BL       __2printf
                  |L55.40|
;;;3784   
;;;3785   			configASSERT( pxTCB->uxMutexesHeld );
000028  6d60              LDR      r0,[r4,#0x54]
00002a  b928              CBNZ     r0,|L55.56|
00002c  f64062c9          MOV      r2,#0xec9
000030  a11e              ADR      r1,|L55.172|
000032  a023              ADR      r0,|L55.192|
000034  f7fffffe          BL       __2printf
                  |L55.56|
;;;3786   			( pxTCB->uxMutexesHeld )--;
000038  6d60              LDR      r0,[r4,#0x54]
00003a  1e40              SUBS     r0,r0,#1
00003c  6560              STR      r0,[r4,#0x54]
;;;3787   
;;;3788   			/* Has the holder of the mutex inherited the priority of another
;;;3789   			task? */
;;;3790   			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
00003e  6d21              LDR      r1,[r4,#0x50]
000040  6ae0              LDR      r0,[r4,#0x2c]
000042  4288              CMP      r0,r1
000044  d02e              BEQ      |L55.164|
;;;3791   			{
;;;3792   				/* Only disinherit if no other mutexes are held. */
;;;3793   				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
000046  6d60              LDR      r0,[r4,#0x54]
000048  bb60              CBNZ     r0,|L55.164|
;;;3794   				{
;;;3795   					/* A task can only have an inherited priority if it holds
;;;3796   					the mutex.  If the mutex is held by a task then it cannot be
;;;3797   					given from an interrupt, and if a mutex is given by the
;;;3798   					holding	task then it must be the running state task.  Remove
;;;3799   					the	holding task from the ready	list. */
;;;3800   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00004a  1d20              ADDS     r0,r4,#4
00004c  f7fffffe          BL       uxListRemove
000050  b978              CBNZ     r0,|L55.114|
;;;3801   					{
;;;3802   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000052  6ae0              LDR      r0,[r4,#0x2c]
000054  eb000080          ADD      r0,r0,r0,LSL #2
000058  491d              LDR      r1,|L55.208|
00005a  f8510020          LDR      r0,[r1,r0,LSL #2]
00005e  b940              CBNZ     r0,|L55.114|
000060  f894102c          LDRB     r1,[r4,#0x2c]
000064  2001              MOVS     r0,#1
000066  4088              LSLS     r0,r0,r1
000068  491a              LDR      r1,|L55.212|
00006a  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00006c  4381              BICS     r1,r1,r0
00006e  4819              LDR      r0,|L55.212|
000070  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L55.114|
;;;3803   					}
;;;3804   					else
;;;3805   					{
;;;3806   						mtCOVERAGE_TEST_MARKER();
;;;3807   					}
;;;3808   
;;;3809   					/* Disinherit the priority before adding the task into the
;;;3810   					new	ready list. */
;;;3811   					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;3812   					pxTCB->uxPriority = pxTCB->uxBasePriority;
000072  6d20              LDR      r0,[r4,#0x50]
000074  62e0              STR      r0,[r4,#0x2c]
;;;3813   
;;;3814   					/* Reset the event list item value.  It cannot be in use for
;;;3815   					any other purpose if this task is running, and it must be
;;;3816   					running to give back the mutex. */
;;;3817   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000076  6ae0              LDR      r0,[r4,#0x2c]
000078  f1c00020          RSB      r0,r0,#0x20
00007c  61a0              STR      r0,[r4,#0x18]
;;;3818   					prvAddTaskToReadyList( pxTCB );
00007e  f894102c          LDRB     r1,[r4,#0x2c]
000082  2001              MOVS     r0,#1
000084  4088              LSLS     r0,r0,r1
000086  4913              LDR      r1,|L55.212|
000088  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00008a  4308              ORRS     r0,r0,r1
00008c  4911              LDR      r1,|L55.212|
00008e  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000090  6ae1              LDR      r1,[r4,#0x2c]
000092  eb010181          ADD      r1,r1,r1,LSL #2
000096  4a0e              LDR      r2,|L55.208|
000098  eb020081          ADD      r0,r2,r1,LSL #2
00009c  1d21              ADDS     r1,r4,#4
00009e  f7fffffe          BL       vListInsertEnd
;;;3819   
;;;3820   					/* Return true to indicate that a context switch is required.
;;;3821   					This is only actually required in the corner case whereby
;;;3822   					multiple mutexes were held and the mutexes were given back
;;;3823   					in an order different to that in which they were taken.
;;;3824   					If a context switch did not occur when the first mutex was
;;;3825   					returned, even if a task was waiting on it, then a context
;;;3826   					switch should occur when the last mutex is returned whether
;;;3827   					a task is waiting on it or not. */
;;;3828   					xReturn = pdTRUE;
0000a2  2601              MOVS     r6,#1
                  |L55.164|
;;;3829   				}
;;;3830   				else
;;;3831   				{
;;;3832   					mtCOVERAGE_TEST_MARKER();
;;;3833   				}
;;;3834   			}
;;;3835   			else
;;;3836   			{
;;;3837   				mtCOVERAGE_TEST_MARKER();
;;;3838   			}
;;;3839   		}
;;;3840   		else
;;;3841   		{
;;;3842   			mtCOVERAGE_TEST_MARKER();
;;;3843   		}
;;;3844   
;;;3845   		return xReturn;
0000a4  4630              MOV      r0,r6
;;;3846   	}
0000a6  bd70              POP      {r4-r6,pc}
;;;3847   
                          ENDP

                  |L55.168|
                          DCD      pxCurrentTCB
                  |L55.172|
0000ac  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
0000b0  72656552
0000b4  544f535c
0000b8  7461736b
0000bc  732e6300
                  |L55.192|
0000c0  4572726f          DCB      "Error:%s,%d\r\n",0
0000c4  723a2573
0000c8  2c25640d
0000cc  0a00    
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L55.208|
                          DCD      pxReadyTasksLists
                  |L55.212|
                          DCD      uxTopReadyPriority

                          AREA ||i.xTaskRemoveFromEventList||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  xTaskRemoveFromEventList PROC
;;;2893   
;;;2894   BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
000000  b570              PUSH     {r4-r6,lr}
;;;2895   {
000002  4606              MOV      r6,r0
;;;2896   TCB_t *pxUnblockedTCB;
;;;2897   BaseType_t xReturn;
;;;2898   
;;;2899   	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
;;;2900   	called from a critical section within an ISR. */
;;;2901   
;;;2902   	/* The event list is sorted in priority order, so the first in the list can
;;;2903   	be removed as it is known to be the highest priority.  Remove the TCB from
;;;2904   	the delayed list, and add it to the ready list.
;;;2905   
;;;2906   	If an event is for a queue that is locked then this function will never
;;;2907   	get called - the lock count on the queue will get modified instead.  This
;;;2908   	means exclusive access to the event list is guaranteed here.
;;;2909   
;;;2910   	This function assumes that a check has already been made to ensure that
;;;2911   	pxEventList is not empty. */
;;;2912   	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
000004  68f0              LDR      r0,[r6,#0xc]
000006  68c4              LDR      r4,[r0,#0xc]
;;;2913   	configASSERT( pxUnblockedTCB );
000008  b92c              CBNZ     r4,|L56.22|
00000a  f6403261          MOV      r2,#0xb61
00000e  a11a              ADR      r1,|L56.120|
000010  a01e              ADR      r0,|L56.140|
000012  f7fffffe          BL       __2printf
                  |L56.22|
;;;2914   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
000016  f1040018          ADD      r0,r4,#0x18
00001a  f7fffffe          BL       uxListRemove
;;;2915   
;;;2916   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00001e  481f              LDR      r0,|L56.156|
000020  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000022  b9a8              CBNZ     r0,|L56.80|
;;;2917   	{
;;;2918   		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
000024  1d20              ADDS     r0,r4,#4
000026  f7fffffe          BL       uxListRemove
;;;2919   		prvAddTaskToReadyList( pxUnblockedTCB );
00002a  f894102c          LDRB     r1,[r4,#0x2c]
00002e  2001              MOVS     r0,#1
000030  4088              LSLS     r0,r0,r1
000032  491b              LDR      r1,|L56.160|
000034  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000036  4308              ORRS     r0,r0,r1
000038  4919              LDR      r1,|L56.160|
00003a  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
00003c  6ae1              LDR      r1,[r4,#0x2c]
00003e  eb010181          ADD      r1,r1,r1,LSL #2
000042  4a18              LDR      r2,|L56.164|
000044  eb020081          ADD      r0,r2,r1,LSL #2
000048  1d21              ADDS     r1,r4,#4
00004a  f7fffffe          BL       vListInsertEnd
00004e  e004              B        |L56.90|
                  |L56.80|
;;;2920   	}
;;;2921   	else
;;;2922   	{
;;;2923   		/* The delayed and ready lists cannot be accessed, so hold this task
;;;2924   		pending until the scheduler is resumed. */
;;;2925   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
000050  f1040118          ADD      r1,r4,#0x18
000054  4814              LDR      r0,|L56.168|
000056  f7fffffe          BL       vListInsertEnd
                  |L56.90|
;;;2926   	}
;;;2927   
;;;2928   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
00005a  4914              LDR      r1,|L56.172|
00005c  6ae0              LDR      r0,[r4,#0x2c]
00005e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000060  6ac9              LDR      r1,[r1,#0x2c]
000062  4288              CMP      r0,r1
000064  d904              BLS      |L56.112|
;;;2929   	{
;;;2930   		/* Return true if the task removed from the event list has a higher
;;;2931   		priority than the calling task.  This allows the calling task to know if
;;;2932   		it should force a context switch now. */
;;;2933   		xReturn = pdTRUE;
000066  2501              MOVS     r5,#1
;;;2934   
;;;2935   		/* Mark that a yield is pending in case the user is not using the
;;;2936   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2937   		xYieldPending = pdTRUE;
000068  2001              MOVS     r0,#1
00006a  4911              LDR      r1,|L56.176|
00006c  6008              STR      r0,[r1,#0]  ; xYieldPending
00006e  e000              B        |L56.114|
                  |L56.112|
;;;2938   	}
;;;2939   	else
;;;2940   	{
;;;2941   		xReturn = pdFALSE;
000070  2500              MOVS     r5,#0
                  |L56.114|
;;;2942   	}
;;;2943   
;;;2944   	#if( configUSE_TICKLESS_IDLE != 0 )
;;;2945   	{
;;;2946   		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
;;;2947   		might be set to the blocked task's time out time.  If the task is
;;;2948   		unblocked for a reason other than a timeout xNextTaskUnblockTime is
;;;2949   		normally left unchanged, because it is automatically reset to a new
;;;2950   		value when the tick count equals xNextTaskUnblockTime.  However if
;;;2951   		tickless idling is used it might be more important to enter sleep mode
;;;2952   		at the earliest possible time - so reset xNextTaskUnblockTime here to
;;;2953   		ensure it is updated at the earliest possible time. */
;;;2954   		prvResetNextTaskUnblockTime();
;;;2955   	}
;;;2956   	#endif
;;;2957   
;;;2958   	return xReturn;
000072  4628              MOV      r0,r5
;;;2959   }
000074  bd70              POP      {r4-r6,pc}
;;;2960   /*-----------------------------------------------------------*/
                          ENDP

000076  0000              DCW      0x0000
                  |L56.120|
000078  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
00007c  72656552
000080  544f535c
000084  7461736b
000088  732e6300
                  |L56.140|
00008c  4572726f          DCB      "Error:%s,%d\r\n",0
000090  723a2573
000094  2c25640d
000098  0a00    
00009a  00                DCB      0
00009b  00                DCB      0
                  |L56.156|
                          DCD      uxSchedulerSuspended
                  |L56.160|
                          DCD      uxTopReadyPriority
                  |L56.164|
                          DCD      pxReadyTasksLists
                  |L56.168|
                          DCD      xPendingReadyList
                  |L56.172|
                          DCD      pxCurrentTCB
                  |L56.176|
                          DCD      xYieldPending

                          AREA ||i.xTaskRemoveFromUnorderedEventList||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  xTaskRemoveFromUnorderedEventList PROC
;;;2961   
;;;2962   BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2963   {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;2964   TCB_t *pxUnblockedTCB;
;;;2965   BaseType_t xReturn;
;;;2966   
;;;2967   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2968   	the event flags implementation. */
;;;2969   	configASSERT( uxSchedulerSuspended != pdFALSE );
000008  481f              LDR      r0,|L57.136|
00000a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000c  b108              CBZ      r0,|L57.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L57.20|
                  |L57.18|
000012  2000              MOVS     r0,#0
                  |L57.20|
000014  b928              CBNZ     r0,|L57.34|
000016  f6403299          MOV      r2,#0xb99
00001a  a11c              ADR      r1,|L57.140|
00001c  a020              ADR      r0,|L57.160|
00001e  f7fffffe          BL       __2printf
                  |L57.34|
;;;2970   
;;;2971   	/* Store the new item value in the event list. */
;;;2972   	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000022  f0474000          ORR      r0,r7,#0x80000000
000026  6028              STR      r0,[r5,#0]
;;;2973   
;;;2974   	/* Remove the event list form the event flag.  Interrupts do not access
;;;2975   	event flags. */
;;;2976   	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
000028  68ec              LDR      r4,[r5,#0xc]
;;;2977   	configASSERT( pxUnblockedTCB );
00002a  b92c              CBNZ     r4,|L57.56|
00002c  f64032a1          MOV      r2,#0xba1
000030  a116              ADR      r1,|L57.140|
000032  a01b              ADR      r0,|L57.160|
000034  f7fffffe          BL       __2printf
                  |L57.56|
;;;2978   	( void ) uxListRemove( pxEventListItem );
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       uxListRemove
;;;2979   
;;;2980   	/* Remove the task from the delayed list and add it to the ready list.  The
;;;2981   	scheduler is suspended so interrupts will not be accessing the ready
;;;2982   	lists. */
;;;2983   	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
00003e  1d20              ADDS     r0,r4,#4
000040  f7fffffe          BL       uxListRemove
;;;2984   	prvAddTaskToReadyList( pxUnblockedTCB );
000044  f894102c          LDRB     r1,[r4,#0x2c]
000048  2001              MOVS     r0,#1
00004a  4088              LSLS     r0,r0,r1
00004c  4918              LDR      r1,|L57.176|
00004e  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000050  4308              ORRS     r0,r0,r1
000052  4917              LDR      r1,|L57.176|
000054  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000056  6ae1              LDR      r1,[r4,#0x2c]
000058  eb010181          ADD      r1,r1,r1,LSL #2
00005c  4a15              LDR      r2,|L57.180|
00005e  eb020081          ADD      r0,r2,r1,LSL #2
000062  1d21              ADDS     r1,r4,#4
000064  f7fffffe          BL       vListInsertEnd
;;;2985   
;;;2986   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000068  4913              LDR      r1,|L57.184|
00006a  6ae0              LDR      r0,[r4,#0x2c]
00006c  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00006e  6ac9              LDR      r1,[r1,#0x2c]
000070  4288              CMP      r0,r1
000072  d904              BLS      |L57.126|
;;;2987   	{
;;;2988   		/* Return true if the task removed from the event list has
;;;2989   		a higher priority than the calling task.  This allows
;;;2990   		the calling task to know if it should force a context
;;;2991   		switch now. */
;;;2992   		xReturn = pdTRUE;
000074  2601              MOVS     r6,#1
;;;2993   
;;;2994   		/* Mark that a yield is pending in case the user is not using the
;;;2995   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2996   		xYieldPending = pdTRUE;
000076  2001              MOVS     r0,#1
000078  4910              LDR      r1,|L57.188|
00007a  6008              STR      r0,[r1,#0]  ; xYieldPending
00007c  e000              B        |L57.128|
                  |L57.126|
;;;2997   	}
;;;2998   	else
;;;2999   	{
;;;3000   		xReturn = pdFALSE;
00007e  2600              MOVS     r6,#0
                  |L57.128|
;;;3001   	}
;;;3002   
;;;3003   	return xReturn;
000080  4630              MOV      r0,r6
;;;3004   }
000082  e8bd81f0          POP      {r4-r8,pc}
;;;3005   /*-----------------------------------------------------------*/
                          ENDP

000086  0000              DCW      0x0000
                  |L57.136|
                          DCD      uxSchedulerSuspended
                  |L57.140|
00008c  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
000090  72656552
000094  544f535c
000098  7461736b
00009c  732e6300
                  |L57.160|
0000a0  4572726f          DCB      "Error:%s,%d\r\n",0
0000a4  723a2573
0000a8  2c25640d
0000ac  0a00    
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L57.176|
                          DCD      uxTopReadyPriority
                  |L57.180|
                          DCD      pxReadyTasksLists
                  |L57.184|
                          DCD      pxCurrentTCB
                  |L57.188|
                          DCD      xYieldPending

                          AREA ||i.xTaskResumeAll||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  xTaskResumeAll PROC
;;;2016   
;;;2017   BaseType_t xTaskResumeAll( void )
000000  b570              PUSH     {r4-r6,lr}
;;;2018   {
;;;2019   TCB_t *pxTCB = NULL;
000002  2400              MOVS     r4,#0
;;;2020   BaseType_t xAlreadyYielded = pdFALSE;
000004  2600              MOVS     r6,#0
;;;2021   
;;;2022   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;2023   	previous call to vTaskSuspendAll(). */
;;;2024   	configASSERT( uxSchedulerSuspended );
000006  4834              LDR      r0,|L58.216|
000008  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000a  b928              CBNZ     r0,|L58.24|
00000c  f44f62fd          MOV      r2,#0x7e8
000010  a132              ADR      r1,|L58.220|
000012  a037              ADR      r0,|L58.240|
000014  f7fffffe          BL       __2printf
                  |L58.24|
;;;2025   
;;;2026   	/* It is possible that an ISR caused a task to be removed from an event
;;;2027   	list while the scheduler was suspended.  If this was the case then the
;;;2028   	removed task will have been added to the xPendingReadyList.  Once the
;;;2029   	scheduler has been resumed it is safe to move all the pending ready
;;;2030   	tasks from this list into their appropriate ready list. */
;;;2031   	taskENTER_CRITICAL();
000018  f7fffffe          BL       vPortEnterCritical
;;;2032   	{
;;;2033   		--uxSchedulerSuspended;
00001c  482e              LDR      r0,|L58.216|
00001e  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000020  1e40              SUBS     r0,r0,#1
000022  492d              LDR      r1,|L58.216|
000024  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;2034   
;;;2035   		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000026  4608              MOV      r0,r1
000028  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00002a  2800              CMP      r0,#0
00002c  d14f              BNE      |L58.206|
;;;2036   		{
;;;2037   			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
00002e  4834              LDR      r0,|L58.256|
000030  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000032  2800              CMP      r0,#0
000034  d04b              BEQ      |L58.206|
;;;2038   			{
;;;2039   				/* Move any readied tasks from the pending list into the
;;;2040   				appropriate ready list. */
;;;2041   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
000036  e024              B        |L58.130|
                  |L58.56|
;;;2042   				{
;;;2043   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
000038  4832              LDR      r0,|L58.260|
00003a  68c0              LDR      r0,[r0,#0xc]
00003c  68c4              LDR      r4,[r0,#0xc]
;;;2044   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00003e  f1040018          ADD      r0,r4,#0x18
000042  f7fffffe          BL       uxListRemove
;;;2045   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000046  1d20              ADDS     r0,r4,#4
000048  f7fffffe          BL       uxListRemove
;;;2046   					prvAddTaskToReadyList( pxTCB );
00004c  f894102c          LDRB     r1,[r4,#0x2c]
000050  2001              MOVS     r0,#1
000052  4088              LSLS     r0,r0,r1
000054  492c              LDR      r1,|L58.264|
000056  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000058  4308              ORRS     r0,r0,r1
00005a  492b              LDR      r1,|L58.264|
00005c  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
00005e  6ae1              LDR      r1,[r4,#0x2c]
000060  eb010181          ADD      r1,r1,r1,LSL #2
000064  4a29              LDR      r2,|L58.268|
000066  eb020081          ADD      r0,r2,r1,LSL #2
00006a  1d21              ADDS     r1,r4,#4
00006c  f7fffffe          BL       vListInsertEnd
;;;2047   
;;;2048   					/* If the moved task has a priority higher than the current
;;;2049   					task then a yield must be performed. */
;;;2050   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000070  4927              LDR      r1,|L58.272|
000072  6ae0              LDR      r0,[r4,#0x2c]
000074  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000076  6ac9              LDR      r1,[r1,#0x2c]
000078  4288              CMP      r0,r1
00007a  d302              BCC      |L58.130|
;;;2051   					{
;;;2052   						xYieldPending = pdTRUE;
00007c  2001              MOVS     r0,#1
00007e  4925              LDR      r1,|L58.276|
000080  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L58.130|
000082  4820              LDR      r0,|L58.260|
000084  6800              LDR      r0,[r0,#0]            ;2041  ; xPendingReadyList
000086  b908              CBNZ     r0,|L58.140|
000088  2001              MOVS     r0,#1                 ;2041
00008a  e000              B        |L58.142|
                  |L58.140|
00008c  2000              MOVS     r0,#0                 ;2041
                  |L58.142|
00008e  2800              CMP      r0,#0                 ;2041
000090  d0d2              BEQ      |L58.56|
;;;2053   					}
;;;2054   					else
;;;2055   					{
;;;2056   						mtCOVERAGE_TEST_MARKER();
;;;2057   					}
;;;2058   				}
;;;2059   
;;;2060   				if( pxTCB != NULL )
000092  b10c              CBZ      r4,|L58.152|
;;;2061   				{
;;;2062   					/* A task was unblocked while the scheduler was suspended,
;;;2063   					which may have prevented the next unblock time from being
;;;2064   					re-calculated, in which case re-calculate it now.  Mainly
;;;2065   					important for low power tickless implementations, where
;;;2066   					this can prevent an unnecessary exit from low power
;;;2067   					state. */
;;;2068   					prvResetNextTaskUnblockTime();
000094  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L58.152|
;;;2069   				}
;;;2070   
;;;2071   				/* If any ticks occurred while the scheduler was suspended then
;;;2072   				they should be processed now.  This ensures the tick count does
;;;2073   				not	slip, and that any delayed tasks are resumed at the correct
;;;2074   				time. */
;;;2075   				{
;;;2076   					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
000098  481f              LDR      r0,|L58.280|
00009a  6805              LDR      r5,[r0,#0]  ; uxPendedTicks
;;;2077   
;;;2078   					if( uxPendedCounts > ( UBaseType_t ) 0U )
00009c  b165              CBZ      r5,|L58.184|
;;;2079   					{
;;;2080   						do
00009e  bf00              NOP      
                  |L58.160|
;;;2081   						{
;;;2082   							if( xTaskIncrementTick() != pdFALSE )
0000a0  f7fffffe          BL       xTaskIncrementTick
0000a4  b110              CBZ      r0,|L58.172|
;;;2083   							{
;;;2084   								xYieldPending = pdTRUE;
0000a6  2001              MOVS     r0,#1
0000a8  491a              LDR      r1,|L58.276|
0000aa  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L58.172|
;;;2085   							}
;;;2086   							else
;;;2087   							{
;;;2088   								mtCOVERAGE_TEST_MARKER();
;;;2089   							}
;;;2090   							--uxPendedCounts;
0000ac  1e6d              SUBS     r5,r5,#1
;;;2091   						} while( uxPendedCounts > ( UBaseType_t ) 0U );
0000ae  2d00              CMP      r5,#0
0000b0  d1f6              BNE      |L58.160|
;;;2092   
;;;2093   						uxPendedTicks = 0;
0000b2  2000              MOVS     r0,#0
0000b4  4918              LDR      r1,|L58.280|
0000b6  6008              STR      r0,[r1,#0]  ; uxPendedTicks
                  |L58.184|
;;;2094   					}
;;;2095   					else
;;;2096   					{
;;;2097   						mtCOVERAGE_TEST_MARKER();
;;;2098   					}
;;;2099   				}
;;;2100   
;;;2101   				if( xYieldPending != pdFALSE )
0000b8  4816              LDR      r0,|L58.276|
0000ba  6800              LDR      r0,[r0,#0]  ; xYieldPending
0000bc  b138              CBZ      r0,|L58.206|
;;;2102   				{
;;;2103   					#if( configUSE_PREEMPTION != 0 )
;;;2104   					{
;;;2105   						xAlreadyYielded = pdTRUE;
0000be  2601              MOVS     r6,#1
;;;2106   					}
;;;2107   					#endif
;;;2108   					taskYIELD_IF_USING_PREEMPTION();
0000c0  0730              LSLS     r0,r6,#28
0000c2  4916              LDR      r1,|L58.284|
0000c4  6008              STR      r0,[r1,#0]
0000c6  f3bf8f4f          DSB      
0000ca  f3bf8f6f          ISB      
                  |L58.206|
;;;2109   				}
;;;2110   				else
;;;2111   				{
;;;2112   					mtCOVERAGE_TEST_MARKER();
;;;2113   				}
;;;2114   			}
;;;2115   		}
;;;2116   		else
;;;2117   		{
;;;2118   			mtCOVERAGE_TEST_MARKER();
;;;2119   		}
;;;2120   	}
;;;2121   	taskEXIT_CRITICAL();
0000ce  f7fffffe          BL       vPortExitCritical
;;;2122   
;;;2123   	return xAlreadyYielded;
0000d2  4630              MOV      r0,r6
;;;2124   }
0000d4  bd70              POP      {r4-r6,pc}
;;;2125   /*-----------------------------------------------------------*/
                          ENDP

0000d6  0000              DCW      0x0000
                  |L58.216|
                          DCD      uxSchedulerSuspended
                  |L58.220|
0000dc  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
0000e0  72656552
0000e4  544f535c
0000e8  7461736b
0000ec  732e6300
                  |L58.240|
0000f0  4572726f          DCB      "Error:%s,%d\r\n",0
0000f4  723a2573
0000f8  2c25640d
0000fc  0a00    
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L58.256|
                          DCD      uxCurrentNumberOfTasks
                  |L58.260|
                          DCD      xPendingReadyList
                  |L58.264|
                          DCD      uxTopReadyPriority
                  |L58.268|
                          DCD      pxReadyTasksLists
                  |L58.272|
                          DCD      pxCurrentTCB
                  |L58.276|
                          DCD      xYieldPending
                  |L58.280|
                          DCD      uxPendedTicks
                  |L58.284|
                          DCD      0xe000ed04

                          AREA ||i.xTaskResumeFromISR||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  xTaskResumeFromISR PROC
;;;1755   
;;;1756   	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1757   	{
000004  4606              MOV      r6,r0
;;;1758   	BaseType_t xYieldRequired = pdFALSE;
000006  2700              MOVS     r7,#0
;;;1759   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
000008  4634              MOV      r4,r6
;;;1760   	UBaseType_t uxSavedInterruptStatus;
;;;1761   
;;;1762   		configASSERT( xTaskToResume );
00000a  b92e              CBNZ     r6,|L59.24|
00000c  f24062e2          MOV      r2,#0x6e2
000010  a120              ADR      r1,|L59.148|
000012  a025              ADR      r0,|L59.168|
000014  f7fffffe          BL       __2printf
                  |L59.24|
;;;1763   
;;;1764   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1765   		maximum	system call (or maximum API call) interrupt priority.
;;;1766   		Interrupts that are	above the maximum system call priority are keep
;;;1767   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1768   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1769   		is defined in FreeRTOSConfig.h then
;;;1770   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1771   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1772   		been assigned a priority above the configured maximum system call
;;;1773   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1774   		from interrupts	that have been assigned a priority at or (logically)
;;;1775   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1776   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1777   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1778   		provided on the following link:
;;;1779   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1780   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000018  f7fffffe          BL       vPortValidateInterruptPriority
;;;1781   
;;;1782   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00001c  bf00              NOP      
00001e  2160              MOVS     r1,#0x60
000020  f3ef8011          MRS      r0,BASEPRI
000024  f3818811          MSR      BASEPRI,r1
000028  f3bf8f4f          DSB      
00002c  f3bf8f6f          ISB      
000030  bf00              NOP      
000032  4605              MOV      r5,r0
;;;1783   		{
;;;1784   			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       prvTaskIsTaskSuspended
00003a  b320              CBZ      r0,|L59.134|
;;;1785   			{
;;;1786   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1787   
;;;1788   				/* Check the ready lists can be accessed. */
;;;1789   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00003c  481e              LDR      r0,|L59.184|
00003e  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000040  b9e0              CBNZ     r0,|L59.124|
;;;1790   				{
;;;1791   					/* Ready lists can be accessed so move the task from the
;;;1792   					suspended list to the ready list directly. */
;;;1793   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000042  491e              LDR      r1,|L59.188|
000044  6ae0              LDR      r0,[r4,#0x2c]
000046  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000048  6ac9              LDR      r1,[r1,#0x2c]
00004a  4288              CMP      r0,r1
00004c  d300              BCC      |L59.80|
;;;1794   					{
;;;1795   						xYieldRequired = pdTRUE;
00004e  2701              MOVS     r7,#1
                  |L59.80|
;;;1796   					}
;;;1797   					else
;;;1798   					{
;;;1799   						mtCOVERAGE_TEST_MARKER();
;;;1800   					}
;;;1801   
;;;1802   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000050  1d20              ADDS     r0,r4,#4
000052  f7fffffe          BL       uxListRemove
;;;1803   					prvAddTaskToReadyList( pxTCB );
000056  f894102c          LDRB     r1,[r4,#0x2c]
00005a  2001              MOVS     r0,#1
00005c  4088              LSLS     r0,r0,r1
00005e  4918              LDR      r1,|L59.192|
000060  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000062  4308              ORRS     r0,r0,r1
000064  4916              LDR      r1,|L59.192|
000066  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000068  6ae1              LDR      r1,[r4,#0x2c]
00006a  eb010181          ADD      r1,r1,r1,LSL #2
00006e  4a15              LDR      r2,|L59.196|
000070  eb020081          ADD      r0,r2,r1,LSL #2
000074  1d21              ADDS     r1,r4,#4
000076  f7fffffe          BL       vListInsertEnd
00007a  e004              B        |L59.134|
                  |L59.124|
;;;1804   				}
;;;1805   				else
;;;1806   				{
;;;1807   					/* The delayed or ready lists cannot be accessed so the task
;;;1808   					is held in the pending ready list until the scheduler is
;;;1809   					unsuspended. */
;;;1810   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
00007c  f1040118          ADD      r1,r4,#0x18
000080  4811              LDR      r0,|L59.200|
000082  f7fffffe          BL       vListInsertEnd
                  |L59.134|
;;;1811   				}
;;;1812   			}
;;;1813   			else
;;;1814   			{
;;;1815   				mtCOVERAGE_TEST_MARKER();
;;;1816   			}
;;;1817   		}
;;;1818   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000086  bf00              NOP      
000088  f3858811          MSR      BASEPRI,r5
00008c  bf00              NOP      
;;;1819   
;;;1820   		return xYieldRequired;
00008e  4638              MOV      r0,r7
;;;1821   	}
000090  e8bd81f0          POP      {r4-r8,pc}
;;;1822   
                          ENDP

                  |L59.148|
000094  2e2e5c46          DCB      "..\\FreeRTOS\\tasks.c",0
000098  72656552
00009c  544f535c
0000a0  7461736b
0000a4  732e6300
                  |L59.168|
0000a8  4572726f          DCB      "Error:%s,%d\r\n",0
0000ac  723a2573
0000b0  2c25640d
0000b4  0a00    
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L59.184|
                          DCD      uxSchedulerSuspended
                  |L59.188|
                          DCD      pxCurrentTCB
                  |L59.192|
                          DCD      uxTopReadyPriority
                  |L59.196|
                          DCD      pxReadyTasksLists
                  |L59.200|
                          DCD      xPendingReadyList

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        640
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000
                  uxDeletedTasksWaitingCleanUp
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0x00000000
                  xIdleTaskHandle
                          DCD      0x00000000
                  uxSchedulerSuspended
                          DCD      0x00000000
                  ulTaskSwitchedInTime
                          DCD      0x00000000
                  ulTotalRunTime
                          DCD      0x00000000
