; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\dm9000.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\dm9000.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\dm9000.crf ..\HARDWARE\DM9000\dm9000.c]
                          THUMB

                          AREA ||i.DM9000_Get_DeiviceID||, CODE, READONLY, ALIGN=1

                  DM9000_Get_DeiviceID PROC
;;;226    //返回值：DM9000的芯片ID值
;;;227    u32 DM9000_Get_DeiviceID(void)
000000  b500              PUSH     {lr}
;;;228    {
;;;229    	u32 value;
;;;230    	value =DM9000_ReadReg(DM9000_VIDL);
000002  2028              MOVS     r0,#0x28
000004  f7fffffe          BL       DM9000_ReadReg
000008  4602              MOV      r2,r0
;;;231    	value|=DM9000_ReadReg(DM9000_VIDH) << 8;
00000a  2029              MOVS     r0,#0x29
00000c  f7fffffe          BL       DM9000_ReadReg
000010  ea422200          ORR      r2,r2,r0,LSL #8
;;;232    	value|=DM9000_ReadReg(DM9000_PIDL) << 16;
000014  202a              MOVS     r0,#0x2a
000016  f7fffffe          BL       DM9000_ReadReg
00001a  ea424200          ORR      r2,r2,r0,LSL #16
;;;233    	value|=DM9000_ReadReg(DM9000_PIDH) << 24;
00001e  202b              MOVS     r0,#0x2b
000020  f7fffffe          BL       DM9000_ReadReg
000024  ea426200          ORR      r2,r2,r0,LSL #24
;;;234    	return value;
000028  4610              MOV      r0,r2
;;;235    }
00002a  bd00              POP      {pc}
;;;236    //获取DM9000的连接速度和双工模式
                          ENDP


                          AREA ||i.DM9000_Get_SpeedAndDuplex||, CODE, READONLY, ALIGN=2

                  DM9000_Get_SpeedAndDuplex PROC
;;;241    //			0XFF,连接失败！
;;;242    u8 DM9000_Get_SpeedAndDuplex(void)
000000  b570              PUSH     {r4-r6,lr}
;;;243    {
;;;244    	u8 temp;
;;;245    	u8 i=0;	
000002  2400              MOVS     r4,#0
;;;246    	if(dm9000cfg.mode==DM9000_AUTO)					//如果开启了自动协商模式一定要等待协商完成
000004  481a              LDR      r0,|L2.112|
000006  7800              LDRB     r0,[r0,#0]  ; dm9000cfg
000008  2808              CMP      r0,#8
00000a  d111              BNE      |L2.48|
;;;247    	{
;;;248    		while(!(DM9000_PHY_ReadReg(0X01)&0X0020))	//等待自动协商完成
00000c  e008              B        |L2.32|
                  |L2.14|
;;;249    		{
;;;250    			delay_ms(100);					
00000e  2064              MOVS     r0,#0x64
000010  f7fffffe          BL       delay_ms
;;;251    			i++;
000014  1c60              ADDS     r0,r4,#1
000016  b2c4              UXTB     r4,r0
;;;252    			if(i>100)return 0XFF;					//自动协商失败
000018  2c64              CMP      r4,#0x64
00001a  dd01              BLE      |L2.32|
00001c  20ff              MOVS     r0,#0xff
                  |L2.30|
;;;253    		}	
;;;254    	}else											//自定义模式,一定要等待连接成功
;;;255    	{
;;;256    		while(!(DM9000_ReadReg(DM9000_NSR)&0X40))	//等待连接成功
;;;257    		{
;;;258    			delay_ms(100);					
;;;259    			i++;
;;;260    			if(i>100)return 0XFF;					//连接失败			
;;;261    		}
;;;262    	}
;;;263    	temp =((DM9000_ReadReg(DM9000_NSR)>>6)&0X02);	//获取DM9000的连接速度
;;;264    	temp|=((DM9000_ReadReg(DM9000_NCR)>>3)&0X01);	//获取DM9000的双工状态
;;;265    	return temp;
;;;266    }
00001e  bd70              POP      {r4-r6,pc}
                  |L2.32|
000020  2001              MOVS     r0,#1                 ;248
000022  f7fffffe          BL       DM9000_PHY_ReadReg
000026  f0000020          AND      r0,r0,#0x20           ;248
00002a  2800              CMP      r0,#0                 ;248
00002c  d0ef              BEQ      |L2.14|
00002e  e010              B        |L2.82|
                  |L2.48|
000030  e008              B        |L2.68|
                  |L2.50|
000032  2064              MOVS     r0,#0x64              ;258
000034  f7fffffe          BL       delay_ms
000038  1c60              ADDS     r0,r4,#1              ;259
00003a  b2c4              UXTB     r4,r0                 ;259
00003c  2c64              CMP      r4,#0x64              ;260
00003e  dd01              BLE      |L2.68|
000040  20ff              MOVS     r0,#0xff              ;260
000042  e7ec              B        |L2.30|
                  |L2.68|
000044  2001              MOVS     r0,#1                 ;256
000046  f7fffffe          BL       DM9000_ReadReg
00004a  f0000040          AND      r0,r0,#0x40           ;256
00004e  2800              CMP      r0,#0                 ;256
000050  d0ef              BEQ      |L2.50|
                  |L2.82|
000052  2001              MOVS     r0,#1                 ;263
000054  f7fffffe          BL       DM9000_ReadReg
000058  2102              MOVS     r1,#2                 ;263
00005a  ea0115a0          AND      r5,r1,r0,ASR #6       ;263
00005e  2000              MOVS     r0,#0                 ;264
000060  f7fffffe          BL       DM9000_ReadReg
000064  f3c000c0          UBFX     r0,r0,#3,#1           ;264
000068  4305              ORRS     r5,r5,r0              ;264
00006a  4628              MOV      r0,r5                 ;265
00006c  e7d7              B        |L2.30|
;;;267    
                          ENDP

00006e  0000              DCW      0x0000
                  |L2.112|
                          DCD      dm9000cfg

                          AREA ||i.DM9000_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  DM9000_Init PROC
;;;30     //1，DM9000A ID读取错误
;;;31     u8 DM9000_Init(void)
000000  b510              PUSH     {r4,lr}
;;;32     {
000002  b09a              SUB      sp,sp,#0x68
;;;33     	u32 temp; 
;;;34     	GPIO_InitTypeDef GPIO_InitStructure;
;;;35     	EXTI_InitTypeDef EXTI_InitStructure;
;;;36     	NVIC_InitTypeDef NVIC_InitStructure;
;;;37     	
;;;38     	FSMC_NORSRAMInitTypeDef FSMC_NORSRAMInitStructure;
;;;39     	FSMC_NORSRAMTimingInitTypeDef ReadWriteTiming; 	//DM9000的读写时序
;;;40     	
;;;41     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD|RCC_APB2Periph_GPIOE|\
000004  2101              MOVS     r1,#1
000006  f44f70f0          MOV      r0,#0x1e0
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;42     						   RCC_APB2Periph_GPIOF|RCC_APB2Periph_GPIOG,ENABLE);	//使能GPIOD E F G时钟
;;;43     	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC,ENABLE);	//使能FSMC时钟
00000e  2101              MOVS     r1,#1
000010  0208              LSLS     r0,r1,#8
000012  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;44     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);	//使能复用功能时钟
000016  2101              MOVS     r1,#1
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;45     
;;;46     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7; 		//PD7 推挽输出 
00001e  2080              MOVS     r0,#0x80
000020  f8ad0064          STRH     r0,[sp,#0x64]
;;;47     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000024  2003              MOVS     r0,#3
000026  f88d0066          STRB     r0,[sp,#0x66]
;;;48     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;//推挽输出
00002a  2010              MOVS     r0,#0x10
00002c  f88d0067          STRB     r0,[sp,#0x67]
;;;49     	GPIO_Init(GPIOD,&GPIO_InitStructure);
000030  a919              ADD      r1,sp,#0x64
000032  488e              LDR      r0,|L3.620|
000034  f7fffffe          BL       GPIO_Init
;;;50     
;;;51     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; 		//PG6 推挽输出 
000038  2040              MOVS     r0,#0x40
00003a  f8ad0064          STRH     r0,[sp,#0x64]
;;;52     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;	//上拉输入
00003e  2048              MOVS     r0,#0x48
000040  f88d0067          STRB     r0,[sp,#0x67]
;;;53     	GPIO_Init(GPIOG,&GPIO_InitStructure);
000044  a919              ADD      r1,sp,#0x64
000046  488a              LDR      r0,|L3.624|
000048  f7fffffe          BL       GPIO_Init
;;;54     	
;;;55     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_4|GPIO_Pin_5|\
00004c  f24c7033          MOV      r0,#0xc733
000050  f8ad0064          STRH     r0,[sp,#0x64]
;;;56     								  GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_10|GPIO_Pin_14|GPIO_Pin_15; //PD0 1 4 5 8 9 10 14 15复用
;;;57     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000054  2003              MOVS     r0,#3
000056  f88d0066          STRB     r0,[sp,#0x66]
;;;58     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;//复用推挽输出
00005a  2018              MOVS     r0,#0x18
00005c  f88d0067          STRB     r0,[sp,#0x67]
;;;59     	GPIO_Init(GPIOD,&GPIO_InitStructure);
000060  a919              ADD      r1,sp,#0x64
000062  4882              LDR      r0,|L3.620|
000064  f7fffffe          BL       GPIO_Init
;;;60     	
;;;61     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7|GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_10|GPIO_Pin_11|\
000068  f64f7080          MOV      r0,#0xff80
00006c  f8ad0064          STRH     r0,[sp,#0x64]
;;;62     								  GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15; 			//PG7 8 9 10 11 12 13 14 15复用
;;;63     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000070  2003              MOVS     r0,#3
000072  f88d0066          STRB     r0,[sp,#0x66]
;;;64     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;//复用推挽输出
000076  2018              MOVS     r0,#0x18
000078  f88d0067          STRB     r0,[sp,#0x67]
;;;65     	GPIO_Init(GPIOE,&GPIO_InitStructure);
00007c  a919              ADD      r1,sp,#0x64
00007e  487d              LDR      r0,|L3.628|
000080  f7fffffe          BL       GPIO_Init
;;;66     	
;;;67     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;		//PF13复用
000084  f44f5000          MOV      r0,#0x2000
000088  f8ad0064          STRH     r0,[sp,#0x64]
;;;68     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00008c  2003              MOVS     r0,#3
00008e  f88d0066          STRB     r0,[sp,#0x66]
;;;69     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;//复用推挽输出
000092  2018              MOVS     r0,#0x18
000094  f88d0067          STRB     r0,[sp,#0x67]
;;;70     	GPIO_Init(GPIOF,&GPIO_InitStructure);
000098  a919              ADD      r1,sp,#0x64
00009a  4877              LDR      r0,|L3.632|
00009c  f7fffffe          BL       GPIO_Init
;;;71     	
;;;72     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;		//PG9复用
0000a0  f44f7000          MOV      r0,#0x200
0000a4  f8ad0064          STRH     r0,[sp,#0x64]
;;;73     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000a8  2003              MOVS     r0,#3
0000aa  f88d0066          STRB     r0,[sp,#0x66]
;;;74     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;//复用推挽输出
0000ae  2018              MOVS     r0,#0x18
0000b0  f88d0067          STRB     r0,[sp,#0x67]
;;;75     	GPIO_Init(GPIOG,&GPIO_InitStructure);
0000b4  a919              ADD      r1,sp,#0x64
0000b6  486e              LDR      r0,|L3.624|
0000b8  f7fffffe          BL       GPIO_Init
;;;76     	
;;;77     
;;;78     	//PG6外部中断，中断线6
;;;79     	GPIO_EXTILineConfig(GPIO_PortSourceGPIOG,GPIO_PinSource6);
0000bc  2106              MOVS     r1,#6
0000be  4608              MOV      r0,r1
0000c0  f7fffffe          BL       GPIO_EXTILineConfig
;;;80     	
;;;81     	EXTI_InitStructure.EXTI_Line = EXTI_Line6;
0000c4  2040              MOVS     r0,#0x40
0000c6  9017              STR      r0,[sp,#0x5c]
;;;82     	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
0000c8  2000              MOVS     r0,#0
0000ca  f88d0060          STRB     r0,[sp,#0x60]
;;;83     	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
0000ce  200c              MOVS     r0,#0xc
0000d0  f88d0061          STRB     r0,[sp,#0x61]
;;;84     	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
0000d4  2001              MOVS     r0,#1
0000d6  f88d0062          STRB     r0,[sp,#0x62]
;;;85     	EXTI_Init(&EXTI_InitStructure);
0000da  a817              ADD      r0,sp,#0x5c
0000dc  f7fffffe          BL       EXTI_Init
;;;86     	
;;;87     	EXTI_ClearITPendingBit(EXTI_Line6); //清除中断线6挂起标志位
0000e0  2040              MOVS     r0,#0x40
0000e2  f7fffffe          BL       EXTI_ClearITPendingBit
;;;88     	
;;;89     	NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQn;			//外部中断线6
0000e6  2017              MOVS     r0,#0x17
0000e8  f88d0058          STRB     r0,[sp,#0x58]
;;;90     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority =6;	//抢占优先级
0000ec  2006              MOVS     r0,#6
0000ee  f88d0059          STRB     r0,[sp,#0x59]
;;;91     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;			//子优先级
0000f2  2000              MOVS     r0,#0
0000f4  f88d005a          STRB     r0,[sp,#0x5a]
;;;92     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0000f8  2001              MOVS     r0,#1
0000fa  f88d005b          STRB     r0,[sp,#0x5b]
;;;93     	NVIC_Init(&NVIC_InitStructure);
0000fe  a816              ADD      r0,sp,#0x58
000100  f7fffffe          BL       NVIC_Init
;;;94     	
;;;95     	ReadWriteTiming.FSMC_AddressSetupTime = 0;		//地址建立时间
000104  2000              MOVS     r0,#0
000106  9000              STR      r0,[sp,#0]
;;;96     	ReadWriteTiming.FSMC_AddressHoldTime = 0;
000108  9001              STR      r0,[sp,#4]
;;;97     	ReadWriteTiming.FSMC_DataSetupTime = 3;		//数据建立时间
00010a  2003              MOVS     r0,#3
00010c  9002              STR      r0,[sp,#8]
;;;98     	ReadWriteTiming.FSMC_BusTurnAroundDuration = 0x00;
00010e  2000              MOVS     r0,#0
000110  9003              STR      r0,[sp,#0xc]
;;;99     	ReadWriteTiming.FSMC_CLKDivision = 0x00;
000112  9004              STR      r0,[sp,#0x10]
;;;100    	ReadWriteTiming.FSMC_DataLatency = 0x00;
000114  9005              STR      r0,[sp,#0x14]
;;;101    	ReadWriteTiming.FSMC_AccessMode = FSMC_AccessMode_A;//使用模式A
000116  9006              STR      r0,[sp,#0x18]
;;;102    	
;;;103    	FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM2;	//NE2
000118  2002              MOVS     r0,#2
00011a  9007              STR      r0,[sp,#0x1c]
;;;104    	FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
00011c  2000              MOVS     r0,#0
00011e  9008              STR      r0,[sp,#0x20]
;;;105    	FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_SRAM;
000120  9009              STR      r0,[sp,#0x24]
;;;106    	FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
000122  2010              MOVS     r0,#0x10
000124  900a              STR      r0,[sp,#0x28]
;;;107    	FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
000126  2000              MOVS     r0,#0
000128  900b              STR      r0,[sp,#0x2c]
;;;108    	FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
00012a  900c              STR      r0,[sp,#0x30]
;;;109    	FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
00012c  900d              STR      r0,[sp,#0x34]
;;;110    	FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;
00012e  900e              STR      r0,[sp,#0x38]
;;;111    	FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
000130  900f              STR      r0,[sp,#0x3c]
;;;112    	FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000132  f44f5080          MOV      r0,#0x1000
000136  9010              STR      r0,[sp,#0x40]
;;;113    	FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
000138  2000              MOVS     r0,#0
00013a  9011              STR      r0,[sp,#0x44]
;;;114    	FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
00013c  9012              STR      r0,[sp,#0x48]
;;;115    	FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
00013e  9013              STR      r0,[sp,#0x4c]
;;;116    	FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &ReadWriteTiming;
000140  f8cdd050          STR      sp,[sp,#0x50]
;;;117    	FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &ReadWriteTiming;
000144  f8cdd054          STR      sp,[sp,#0x54]
;;;118    	FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure);
000148  a807              ADD      r0,sp,#0x1c
00014a  f7fffffe          BL       FSMC_NORSRAMInit
;;;119    	FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM2,ENABLE); //使能FSMC的Bank1_Bank1_NORSRAM2
00014e  2101              MOVS     r1,#1
000150  2002              MOVS     r0,#2
000152  f7fffffe          BL       FSMC_NORSRAMCmd
;;;120    	
;;;121    	temp=*(vu32*)(0x1FFFF7E8);				//获取STM32的唯一ID的前24位作为MAC地址后三字节
000156  4849              LDR      r0,|L3.636|
000158  6804              LDR      r4,[r0,#0]
;;;122    	dm9000cfg.mode=DM9000_AUTO;	
00015a  2008              MOVS     r0,#8
00015c  4948              LDR      r1,|L3.640|
00015e  7008              STRB     r0,[r1,#0]
;;;123     	dm9000cfg.queue_packet_len=0;
000160  2000              MOVS     r0,#0
000162  8048              STRH     r0,[r1,#2]
;;;124    	//DM9000的SRAM的发送和接收指针自动返回到开始地址，并且开启接收中断
;;;125    	dm9000cfg.imr_all = IMR_PAR|IMR_PRI; 
000164  2081              MOVS     r0,#0x81
000166  7048              STRB     r0,[r1,#1]
;;;126    	//初始化MAC地址
;;;127    	dm9000cfg.mac_addr[0]=2;
000168  2002              MOVS     r0,#2
00016a  7108              STRB     r0,[r1,#4]
;;;128    	dm9000cfg.mac_addr[1]=0;
00016c  2100              MOVS     r1,#0
00016e  4844              LDR      r0,|L3.640|
000170  7141              STRB     r1,[r0,#5]
;;;129    	dm9000cfg.mac_addr[2]=0;
000172  7181              STRB     r1,[r0,#6]
;;;130    	dm9000cfg.mac_addr[3]=(temp>>16)&0XFF;	//低三字节用STM32的唯一ID
000174  0c21              LSRS     r1,r4,#16
000176  71c1              STRB     r1,[r0,#7]
;;;131    	dm9000cfg.mac_addr[4]=(temp>>8)&0XFFF;
000178  0a21              LSRS     r1,r4,#8
00017a  7201              STRB     r1,[r0,#8]
;;;132    	dm9000cfg.mac_addr[5]=temp&0XFF;
00017c  7244              STRB     r4,[r0,#9]
;;;133    	//初始化组播地址
;;;134    	dm9000cfg.multicase_addr[0]=0Xff;
00017e  20ff              MOVS     r0,#0xff
000180  493f              LDR      r1,|L3.640|
000182  7288              STRB     r0,[r1,#0xa]
;;;135    	dm9000cfg.multicase_addr[1]=0Xff;
000184  21ff              MOVS     r1,#0xff
000186  483e              LDR      r0,|L3.640|
000188  72c1              STRB     r1,[r0,#0xb]
;;;136    	dm9000cfg.multicase_addr[2]=0Xff;
00018a  7301              STRB     r1,[r0,#0xc]
;;;137    	dm9000cfg.multicase_addr[3]=0Xff;
00018c  7341              STRB     r1,[r0,#0xd]
;;;138    	dm9000cfg.multicase_addr[4]=0Xff;
00018e  7381              STRB     r1,[r0,#0xe]
;;;139    	dm9000cfg.multicase_addr[5]=0Xff;
000190  73c1              STRB     r1,[r0,#0xf]
;;;140    	dm9000cfg.multicase_addr[6]=0Xff;
000192  7401              STRB     r1,[r0,#0x10]
;;;141    	dm9000cfg.multicase_addr[7]=0Xff; 
000194  7441              STRB     r1,[r0,#0x11]
;;;142    	
;;;143    	DM9000_Reset();							//复位DM9000
000196  f7fffffe          BL       DM9000_Reset
;;;144    	delay_ms(100);
00019a  2064              MOVS     r0,#0x64
00019c  f7fffffe          BL       delay_ms
;;;145    	temp=DM9000_Get_DeiviceID();			//获取DM9000ID
0001a0  f7fffffe          BL       DM9000_Get_DeiviceID
0001a4  4604              MOV      r4,r0
;;;146    	printf("DM9000 ID:%#x\r\n",temp);
0001a6  4621              MOV      r1,r4
0001a8  a036              ADR      r0,|L3.644|
0001aa  f7fffffe          BL       __2printf
;;;147    	if(temp!=DM9000_ID) return 1; 			//读取ID错误
0001ae  4839              LDR      r0,|L3.660|
0001b0  4284              CMP      r4,r0
0001b2  d002              BEQ      |L3.442|
0001b4  2001              MOVS     r0,#1
                  |L3.438|
;;;148    	DM9000_Set_PHYMode(dm9000cfg.mode);		//设置PHY工作模式
;;;149    	
;;;150    	DM9000_WriteReg(DM9000_NCR,0X00);
;;;151    	DM9000_WriteReg(DM9000_TCR,0X00);		//发送控制寄存器清零
;;;152    	DM9000_WriteReg(DM9000_BPTR,0X3F);	
;;;153    	DM9000_WriteReg(DM9000_FCTR,0X38);
;;;154    	DM9000_WriteReg(DM9000_FCR,0X00);
;;;155    	DM9000_WriteReg(DM9000_SMCR,0X00);		//特殊模式
;;;156    	DM9000_WriteReg(DM9000_NSR,NSR_WAKEST|NSR_TX2END|NSR_TX1END);//清除发送状态
;;;157    	DM9000_WriteReg(DM9000_ISR,0X0F);		//清除中断状态
;;;158    	DM9000_WriteReg(DM9000_TCR2,0X80);		//切换LED到mode1 	
;;;159    	//设置MAC地址和组播地址
;;;160    	DM9000_Set_MACAddress(dm9000cfg.mac_addr);		//设置MAC地址
;;;161    	DM9000_Set_Multicast(dm9000cfg.multicase_addr);	//设置组播地址
;;;162    	DM9000_WriteReg(DM9000_RCR,RCR_DIS_LONG|RCR_DIS_CRC|RCR_RXEN);
;;;163    	DM9000_WriteReg(DM9000_IMR,IMR_PAR); 
;;;164    	temp=DM9000_Get_SpeedAndDuplex();		//获取DM9000的连接速度和双工状态
;;;165    	if(temp!=0XFF)							//连接成功，通过串口显示连接速度和双工状态
;;;166    	{
;;;167    		printf("DM9000 Speed:%dMbps,Duplex:%s duplex mode\r\n",(temp&0x02)?10:100,(temp&0x01)?"Full":"Half");
;;;168    	}else printf("DM9000 Establish Link Failed!\r\n");
;;;169    	DM9000_WriteReg(DM9000_IMR,dm9000cfg.imr_all);	//设置中断
;;;170    	return 0;		
;;;171    } 
0001b6  b01a              ADD      sp,sp,#0x68
0001b8  bd10              POP      {r4,pc}
                  |L3.442|
0001ba  4931              LDR      r1,|L3.640|
0001bc  7808              LDRB     r0,[r1,#0]            ;148  ; dm9000cfg
0001be  f7fffffe          BL       DM9000_Set_PHYMode
0001c2  2100              MOVS     r1,#0                 ;150
0001c4  4608              MOV      r0,r1                 ;150
0001c6  f7fffffe          BL       DM9000_WriteReg
0001ca  2100              MOVS     r1,#0                 ;151
0001cc  2002              MOVS     r0,#2                 ;151
0001ce  f7fffffe          BL       DM9000_WriteReg
0001d2  213f              MOVS     r1,#0x3f              ;152
0001d4  2008              MOVS     r0,#8                 ;152
0001d6  f7fffffe          BL       DM9000_WriteReg
0001da  2138              MOVS     r1,#0x38              ;153
0001dc  2009              MOVS     r0,#9                 ;153
0001de  f7fffffe          BL       DM9000_WriteReg
0001e2  2100              MOVS     r1,#0                 ;154
0001e4  200a              MOVS     r0,#0xa               ;154
0001e6  f7fffffe          BL       DM9000_WriteReg
0001ea  2100              MOVS     r1,#0                 ;155
0001ec  202f              MOVS     r0,#0x2f              ;155
0001ee  f7fffffe          BL       DM9000_WriteReg
0001f2  212c              MOVS     r1,#0x2c              ;156
0001f4  2001              MOVS     r0,#1                 ;156
0001f6  f7fffffe          BL       DM9000_WriteReg
0001fa  210f              MOVS     r1,#0xf               ;157
0001fc  20fe              MOVS     r0,#0xfe              ;157
0001fe  f7fffffe          BL       DM9000_WriteReg
000202  2180              MOVS     r1,#0x80              ;158
000204  202d              MOVS     r0,#0x2d              ;158
000206  f7fffffe          BL       DM9000_WriteReg
00020a  481d              LDR      r0,|L3.640|
00020c  1d00              ADDS     r0,r0,#4              ;160
00020e  f7fffffe          BL       DM9000_Set_MACAddress
000212  481b              LDR      r0,|L3.640|
000214  300a              ADDS     r0,r0,#0xa            ;161
000216  f7fffffe          BL       DM9000_Set_Multicast
00021a  2131              MOVS     r1,#0x31              ;162
00021c  2005              MOVS     r0,#5                 ;162
00021e  f7fffffe          BL       DM9000_WriteReg
000222  2180              MOVS     r1,#0x80              ;163
000224  20ff              MOVS     r0,#0xff              ;163
000226  f7fffffe          BL       DM9000_WriteReg
00022a  f7fffffe          BL       DM9000_Get_SpeedAndDuplex
00022e  4604              MOV      r4,r0                 ;164
000230  2cff              CMP      r4,#0xff              ;165
000232  d011              BEQ      |L3.600|
000234  f0040001          AND      r0,r4,#1              ;167
000238  b108              CBZ      r0,|L3.574|
00023a  a017              ADR      r0,|L3.664|
00023c  e000              B        |L3.576|
                  |L3.574|
00023e  a018              ADR      r0,|L3.672|
                  |L3.576|
000240  4602              MOV      r2,r0                 ;167
000242  f0040002          AND      r0,r4,#2              ;167
000246  b108              CBZ      r0,|L3.588|
000248  200a              MOVS     r0,#0xa               ;167
00024a  e000              B        |L3.590|
                  |L3.588|
00024c  2064              MOVS     r0,#0x64              ;167
                  |L3.590|
00024e  4601              MOV      r1,r0                 ;167
000250  a015              ADR      r0,|L3.680|
000252  f7fffffe          BL       __2printf
000256  e002              B        |L3.606|
                  |L3.600|
000258  a01e              ADR      r0,|L3.724|
00025a  f7fffffe          BL       __2printf
                  |L3.606|
00025e  4808              LDR      r0,|L3.640|
000260  7841              LDRB     r1,[r0,#1]            ;169  ; dm9000cfg
000262  20ff              MOVS     r0,#0xff              ;169
000264  f7fffffe          BL       DM9000_WriteReg
000268  2000              MOVS     r0,#0                 ;170
00026a  e7a4              B        |L3.438|
;;;172    //外部中断线6的中断服务函数(放exti.c)
                          ENDP

                  |L3.620|
                          DCD      0x40011400
                  |L3.624|
                          DCD      0x40012000
                  |L3.628|
                          DCD      0x40011800
                  |L3.632|
                          DCD      0x40011c00
                  |L3.636|
                          DCD      0x1ffff7e8
                  |L3.640|
                          DCD      dm9000cfg
                  |L3.644|
000284  444d3930          DCB      "DM9000 ID:%#x\r\n",0
000288  30302049
00028c  443a2523
000290  780d0a00
                  |L3.660|
                          DCD      0x90000a46
                  |L3.664|
000298  46756c6c          DCB      "Full",0
00029c  00      
00029d  00                DCB      0
00029e  00                DCB      0
00029f  00                DCB      0
                  |L3.672|
0002a0  48616c66          DCB      "Half",0
0002a4  00      
0002a5  00                DCB      0
0002a6  00                DCB      0
0002a7  00                DCB      0
                  |L3.680|
0002a8  444d3930          DCB      "DM9000 Speed:%dMbps,Duplex:%s duplex mode\r\n",0
0002ac  30302053
0002b0  70656564
0002b4  3a25644d
0002b8  6270732c
0002bc  4475706c
0002c0  65783a25
0002c4  73206475
0002c8  706c6578
0002cc  206d6f64
0002d0  650d0a00
                  |L3.724|
0002d4  444d3930          DCB      "DM9000 Establish Link Failed!\r\n",0
0002d8  30302045
0002dc  73746162
0002e0  6c697368
0002e4  204c696e
0002e8  6b204661
0002ec  696c6564
0002f0  210d0a00

                          AREA ||i.DM9000_PHY_ReadReg||, CODE, READONLY, ALIGN=1

                  DM9000_PHY_ReadReg PROC
;;;202    //返回值:读取到的PHY寄存器值
;;;203    u16 DM9000_PHY_ReadReg(u16 reg)
000000  b570              PUSH     {r4-r6,lr}
;;;204    {
000002  4604              MOV      r4,r0
;;;205    	u16 temp;
;;;206    	DM9000_WriteReg(DM9000_EPAR,DM9000_PHY|reg);
000004  f0440140          ORR      r1,r4,#0x40
000008  200c              MOVS     r0,#0xc
00000a  f7fffffe          BL       DM9000_WriteReg
;;;207    	DM9000_WriteReg(DM9000_EPCR,0X0C);				//选中PHY，发送读命令
00000e  210c              MOVS     r1,#0xc
000010  200b              MOVS     r0,#0xb
000012  f7fffffe          BL       DM9000_WriteReg
;;;208    	delay_ms(10);
000016  200a              MOVS     r0,#0xa
000018  f7fffffe          BL       delay_ms
;;;209    	DM9000_WriteReg(DM9000_EPCR,0X00);				//清除读命令
00001c  2100              MOVS     r1,#0
00001e  200b              MOVS     r0,#0xb
000020  f7fffffe          BL       DM9000_WriteReg
;;;210    	temp=(DM9000_ReadReg(DM9000_EPDRH)<<8)|(DM9000_ReadReg(DM9000_EPDRL));
000024  200d              MOVS     r0,#0xd
000026  f7fffffe          BL       DM9000_ReadReg
00002a  4602              MOV      r2,r0
00002c  200e              MOVS     r0,#0xe
00002e  f7fffffe          BL       DM9000_ReadReg
000032  ea422000          ORR      r0,r2,r0,LSL #8
000036  b285              UXTH     r5,r0
;;;211    	return temp;
000038  4628              MOV      r0,r5
;;;212    }
00003a  bd70              POP      {r4-r6,pc}
;;;213    //向DM9000的PHY寄存器写入指定值
                          ENDP


                          AREA ||i.DM9000_PHY_WriteReg||, CODE, READONLY, ALIGN=1

                  DM9000_PHY_WriteReg PROC
;;;215    //data:要写入的值
;;;216    void DM9000_PHY_WriteReg(u16 reg,u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;217    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;218    	DM9000_WriteReg(DM9000_EPAR,DM9000_PHY|reg);
000006  f0450140          ORR      r1,r5,#0x40
00000a  200c              MOVS     r0,#0xc
00000c  f7fffffe          BL       DM9000_WriteReg
;;;219    	DM9000_WriteReg(DM9000_EPDRL,(data&0xff));		//写入低字节
000010  b2e1              UXTB     r1,r4
000012  200d              MOVS     r0,#0xd
000014  f7fffffe          BL       DM9000_WriteReg
;;;220    	DM9000_WriteReg(DM9000_EPDRH,((data>>8)&0xff));	//写入高字节
000018  0a21              LSRS     r1,r4,#8
00001a  200e              MOVS     r0,#0xe
00001c  f7fffffe          BL       DM9000_WriteReg
;;;221    	DM9000_WriteReg(DM9000_EPCR,0X0A);				//选中PHY,发送写命令
000020  210a              MOVS     r1,#0xa
000022  200b              MOVS     r0,#0xb
000024  f7fffffe          BL       DM9000_WriteReg
;;;222    	delay_ms(50);
000028  2032              MOVS     r0,#0x32
00002a  f7fffffe          BL       delay_ms
;;;223    	DM9000_WriteReg(DM9000_EPCR,0X00);				//清除写命令	
00002e  2100              MOVS     r1,#0
000030  200b              MOVS     r0,#0xb
000032  f7fffffe          BL       DM9000_WriteReg
;;;224    } 
000036  bd70              POP      {r4-r6,pc}
;;;225    //获取DM9000的芯片ID
                          ENDP


                          AREA ||i.DM9000_ReadReg||, CODE, READONLY, ALIGN=2

                  DM9000_ReadReg PROC
;;;186    //返回值：DM9000指定寄存器的值
;;;187    u16 DM9000_ReadReg(u16 reg)
000000  4601              MOV      r1,r0
;;;188    {
;;;189    	DM9000->REG=reg;
000002  4803              LDR      r0,|L6.16|
000004  8001              STRH     r1,[r0,#0]
;;;190    	return DM9000->DATA; 
000006  f04f40c8          MOV      r0,#0x64000000
00000a  f8b00100          LDRH     r0,[r0,#0x100]
;;;191    }
00000e  4770              BX       lr
;;;192    //向DM9000指定寄存器中写入指定值
                          ENDP

                  |L6.16|
                          DCD      0x640000fe

                          AREA ||i.DM9000_Receive_Packet||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_flags
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  DM9000_Receive_Packet PROC
;;;395    //返回值：pbuf格式的接收到的数据包
;;;396    struct pbuf *DM9000_Receive_Packet(void)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;397    {
;;;398    	struct pbuf* p;
;;;399    	struct pbuf* q;
;;;400        u32 rxbyte;
;;;401    	vu16 rx_status, rx_length;
;;;402        u16* data;
;;;403    	u16 dummy; 
;;;404    	int len;
;;;405    	u8 err;
;;;406    
;;;407    	p=NULL; 
000004  2400              MOVS     r4,#0
;;;408    //	OSMutexPend(dm9000lock,0,&err); 				//请求互斥信号量,锁定DM9000
;;;409        xSemaphoreTake(dm9000lock,portMAX_DELAY);
000006  2300              MOVS     r3,#0
000008  1e5a              SUBS     r2,r3,#1
00000a  4619              MOV      r1,r3
00000c  4857              LDR      r0,|L7.364|
00000e  6800              LDR      r0,[r0,#0]  ; dm9000lock
000010  f7fffffe          BL       xQueueGenericReceive
;;;410    __error_retry:	
000014  bf00              NOP      
                  |L7.22|
;;;411    	DM9000_ReadReg(DM9000_MRCMDX);					//假读
000016  20f0              MOVS     r0,#0xf0
000018  f7fffffe          BL       DM9000_ReadReg
;;;412    	rxbyte=(u8)DM9000->DATA;						//进行第二次读取 
00001c  4854              LDR      r0,|L7.368|
00001e  8800              LDRH     r0,[r0,#0]
000020  b2c7              UXTB     r7,r0
;;;413    	if(rxbyte)										//接收到数据
000022  2f00              CMP      r7,#0
000024  d07e              BEQ      |L7.292|
;;;414    	{
;;;415    		if(rxbyte>1)								//rxbyte大于1，接收到的数据错误,挂了		
000026  2f01              CMP      r7,#1
000028  d90d              BLS      |L7.70|
;;;416    		{
;;;417                printf("dm9000 rx: rx error, stop device\r\n");
00002a  a052              ADR      r0,|L7.372|
00002c  f7fffffe          BL       __2printf
;;;418    			DM9000_WriteReg(DM9000_RCR,0x00);
000030  2100              MOVS     r1,#0
000032  2005              MOVS     r0,#5
000034  f7fffffe          BL       DM9000_WriteReg
;;;419    			DM9000_WriteReg(DM9000_ISR,0x80);		 
000038  2180              MOVS     r1,#0x80
00003a  20fe              MOVS     r0,#0xfe
00003c  f7fffffe          BL       DM9000_WriteReg
;;;420    			return (struct pbuf*)p;
000040  4620              MOV      r0,r4
                  |L7.66|
;;;421    		}
;;;422    		DM9000->REG=DM9000_MRCMD;
;;;423    		rx_status=DM9000->DATA;
;;;424            rx_length=DM9000->DATA;  
;;;425    		//if(rx_length>512)printf("rxlen:%d\r\n",rx_length);
;;;426            p=pbuf_alloc(PBUF_RAW,rx_length,PBUF_POOL);	//pbufs内存池分配pbuf
;;;427    		if(p!=NULL)									//内存申请成功
;;;428            {
;;;429                for(q=p;q!=NULL;q=q->next)
;;;430                {
;;;431                    data=(u16*)q->payload;
;;;432                    len=q->len;
;;;433                    while(len>0)
;;;434                    {
;;;435    					*data=DM9000->DATA;
;;;436                        data++;
;;;437                        len-= 2;
;;;438                    }
;;;439                }
;;;440            }else										//内存申请失败
;;;441    		{
;;;442    			printf("pbuf内存申请失败:%d\r\n",rx_length);
;;;443                data=&dummy;
;;;444    			len=rx_length;
;;;445    			while(len)
;;;446    			{
;;;447    				*data=DM9000->DATA;
;;;448    				len-=2;
;;;449    			}
;;;450            }	
;;;451    		//根据rx_status判断接收数据是否出现如下错误：FIFO溢出、CRC错误
;;;452    		//对齐错误、物理层错误，如果有任何一个出现的话丢弃该数据帧，
;;;453    		//当rx_length小于64或者大于最大数据长度的时候也丢弃该数据帧
;;;454    		if((rx_status&0XBF00) || (rx_length < 0X40) || (rx_length > DM9000_PKT_MAX))
;;;455    		{
;;;456    			printf("rx_status:%#x\r\n",rx_status);
;;;457    			if (rx_status & 0x100)printf("rx fifo error\r\n");
;;;458                if (rx_status & 0x200)printf("rx crc error\r\n");
;;;459                if (rx_status & 0x8000)printf("rx length error\r\n");
;;;460                if (rx_length>DM9000_PKT_MAX)
;;;461    			{
;;;462    				printf("rx length too big\r\n");
;;;463    				DM9000_WriteReg(DM9000_NCR, NCR_RST); 	//复位DM9000
;;;464    				delay_ms(5);
;;;465    			}
;;;466    			if(p!=NULL)pbuf_free((struct pbuf*)p);		//释放内存
;;;467    			p=NULL;
;;;468    			goto __error_retry;
;;;469    		}
;;;470    	}else
;;;471        {
;;;472            DM9000_WriteReg(DM9000_ISR,ISR_PTS);			//清除所有中断标志位
;;;473            dm9000cfg.imr_all=IMR_PAR|IMR_PRI;				//重新接收中断 
;;;474            DM9000_WriteReg(DM9000_IMR, dm9000cfg.imr_all);
;;;475        } 
;;;476    //	OSMutexPost(dm9000lock);							//发送互斥信号量,解锁DM9000
;;;477        xSemaphoreGive(dm9000lock);		//释放互斥信号量
;;;478    	return (struct pbuf*)p; 
;;;479    }
000042  e8bd83fe          POP      {r1-r9,pc}
                  |L7.70|
000046  20f2              MOVS     r0,#0xf2              ;422
000048  4949              LDR      r1,|L7.368|
00004a  1e89              SUBS     r1,r1,#2              ;422
00004c  8008              STRH     r0,[r1,#0]            ;422
00004e  f04f40c8          MOV      r0,#0x64000000        ;423
000052  f8b00100          LDRH     r0,[r0,#0x100]        ;423
000056  9002              STR      r0,[sp,#8]            ;423
000058  1c88              ADDS     r0,r1,#2              ;424
00005a  8800              LDRH     r0,[r0,#0]            ;424
00005c  9001              STR      r0,[sp,#4]            ;424
00005e  2203              MOVS     r2,#3                 ;426
000060  f8bd1004          LDRH     r1,[sp,#4]            ;426
000064  4610              MOV      r0,r2                 ;426
000066  f7fffffe          BL       pbuf_alloc
00006a  4604              MOV      r4,r0                 ;426
00006c  b1a4              CBZ      r4,|L7.152|
00006e  4625              MOV      r5,r4                 ;429
000070  e00f              B        |L7.146|
                  |L7.114|
000072  f8d58004          LDR      r8,[r5,#4]            ;431
000076  896e              LDRH     r6,[r5,#0xa]          ;432
000078  e008              B        |L7.140|
                  |L7.122|
00007a  f04f40c8          MOV      r0,#0x64000000        ;435
00007e  f8b00100          LDRH     r0,[r0,#0x100]        ;435
000082  f8a80000          STRH     r0,[r8,#0]            ;435
000086  f1080802          ADD      r8,r8,#2              ;436
00008a  1eb6              SUBS     r6,r6,#2              ;437
                  |L7.140|
00008c  2e00              CMP      r6,#0                 ;433
00008e  dcf4              BGT      |L7.122|
000090  682d              LDR      r5,[r5,#0]            ;429
                  |L7.146|
000092  2d00              CMP      r5,#0                 ;429
000094  d1ed              BNE      |L7.114|
000096  e011              B        |L7.188|
                  |L7.152|
000098  f8bd1004          LDRH     r1,[sp,#4]            ;442
00009c  a03e              ADR      r0,|L7.408|
00009e  f7fffffe          BL       __2printf
0000a2  46e8              MOV      r8,sp                 ;443
0000a4  f8bd6004          LDRH     r6,[sp,#4]            ;444
0000a8  e006              B        |L7.184|
                  |L7.170|
0000aa  f04f40c8          MOV      r0,#0x64000000        ;447
0000ae  f8b00100          LDRH     r0,[r0,#0x100]        ;447
0000b2  f8a80000          STRH     r0,[r8,#0]            ;447
0000b6  1eb6              SUBS     r6,r6,#2              ;448
                  |L7.184|
0000b8  2e00              CMP      r6,#0                 ;445
0000ba  d1f6              BNE      |L7.170|
                  |L7.188|
0000bc  f8bd0008          LDRH     r0,[sp,#8]            ;454
0000c0  f400403f          AND      r0,r0,#0xbf00         ;454
0000c4  b940              CBNZ     r0,|L7.216|
0000c6  f8bd0004          LDRH     r0,[sp,#4]            ;454
0000ca  2840              CMP      r0,#0x40              ;454
0000cc  db04              BLT      |L7.216|
0000ce  f8bd0004          LDRH     r0,[sp,#4]            ;454
0000d2  f5b06fc0          CMP      r0,#0x600             ;454
0000d6  dd3f              BLE      |L7.344|
                  |L7.216|
0000d8  f8bd1008          LDRH     r1,[sp,#8]            ;456
0000dc  a034              ADR      r0,|L7.432|
0000de  f7fffffe          BL       __2printf
0000e2  f8bd0008          LDRH     r0,[sp,#8]            ;457
0000e6  f4007080          AND      r0,r0,#0x100          ;457
0000ea  b110              CBZ      r0,|L7.242|
0000ec  a034              ADR      r0,|L7.448|
0000ee  f7fffffe          BL       __2printf
                  |L7.242|
0000f2  f8bd0008          LDRH     r0,[sp,#8]            ;458
0000f6  f4007000          AND      r0,r0,#0x200          ;458
0000fa  b110              CBZ      r0,|L7.258|
0000fc  a034              ADR      r0,|L7.464|
0000fe  f7fffffe          BL       __2printf
                  |L7.258|
000102  f8bd0008          LDRH     r0,[sp,#8]            ;459
000106  f4004000          AND      r0,r0,#0x8000         ;459
00010a  b110              CBZ      r0,|L7.274|
00010c  a034              ADR      r0,|L7.480|
00010e  f7fffffe          BL       __2printf
                  |L7.274|
000112  f8bd0004          LDRH     r0,[sp,#4]            ;460
000116  f5b06fc0          CMP      r0,#0x600             ;460
00011a  dd0b              BLE      |L7.308|
00011c  a035              ADR      r0,|L7.500|
00011e  f7fffffe          BL       __2printf
000122  e000              B        |L7.294|
                  |L7.292|
000124  e00c              B        |L7.320|
                  |L7.294|
000126  2101              MOVS     r1,#1                 ;463
000128  2000              MOVS     r0,#0                 ;463
00012a  f7fffffe          BL       DM9000_WriteReg
00012e  2005              MOVS     r0,#5                 ;464
000130  f7fffffe          BL       delay_ms
                  |L7.308|
000134  b114              CBZ      r4,|L7.316|
000136  4620              MOV      r0,r4                 ;466
000138  f7fffffe          BL       pbuf_free
                  |L7.316|
00013c  2400              MOVS     r4,#0                 ;467
00013e  e76a              B        |L7.22|
                  |L7.320|
000140  2102              MOVS     r1,#2                 ;472
000142  20fe              MOVS     r0,#0xfe              ;472
000144  f7fffffe          BL       DM9000_WriteReg
000148  2081              MOVS     r0,#0x81              ;473
00014a  492f              LDR      r1,|L7.520|
00014c  7048              STRB     r0,[r1,#1]            ;473
00014e  4608              MOV      r0,r1                 ;474
000150  7841              LDRB     r1,[r0,#1]            ;474  ; dm9000cfg
000152  20ff              MOVS     r0,#0xff              ;474
000154  f7fffffe          BL       DM9000_WriteReg
                  |L7.344|
000158  2300              MOVS     r3,#0                 ;477
00015a  461a              MOV      r2,r3                 ;477
00015c  4619              MOV      r1,r3                 ;477
00015e  4803              LDR      r0,|L7.364|
000160  6800              LDR      r0,[r0,#0]            ;477  ; dm9000lock
000162  f7fffffe          BL       xQueueGenericSend
000166  4620              MOV      r0,r4                 ;478
000168  e76b              B        |L7.66|
;;;480    //中断处理函数
                          ENDP

00016a  0000              DCW      0x0000
                  |L7.364|
                          DCD      dm9000lock
                  |L7.368|
                          DCD      0x64000100
                  |L7.372|
000174  646d3930          DCB      "dm9000 rx: rx error, stop device\r\n",0
000178  30302072
00017c  783a2072
000180  78206572
000184  726f722c
000188  2073746f
00018c  70206465
000190  76696365
000194  0d0a00  
000197  00                DCB      0
                  |L7.408|
000198  70627566          DCB      "pbuf",196,218,180,230,201,234,199,235,202,167,176,220,":"
00019c  c4dab4e6
0001a0  c9eac7eb
0001a4  caa7b0dc
0001a8  3a      
0001a9  25640d0a          DCB      "%d\r\n",0
0001ad  00      
0001ae  00                DCB      0
0001af  00                DCB      0
                  |L7.432|
0001b0  72785f73          DCB      "rx_status:%#x\r\n",0
0001b4  74617475
0001b8  733a2523
0001bc  780d0a00
                  |L7.448|
0001c0  72782066          DCB      "rx fifo error\r\n",0
0001c4  69666f20
0001c8  6572726f
0001cc  720d0a00
                  |L7.464|
0001d0  72782063          DCB      "rx crc error\r\n",0
0001d4  72632065
0001d8  72726f72
0001dc  0d0a00  
0001df  00                DCB      0
                  |L7.480|
0001e0  7278206c          DCB      "rx length error\r\n",0
0001e4  656e6774
0001e8  68206572
0001ec  726f720d
0001f0  0a00    
0001f2  00                DCB      0
0001f3  00                DCB      0
                  |L7.500|
0001f4  7278206c          DCB      "rx length too big\r\n",0
0001f8  656e6774
0001fc  6820746f
000200  6f206269
000204  670d0a00
                  |L7.520|
                          DCD      dm9000cfg

                          AREA ||i.DM9000_Reset||, CODE, READONLY, ALIGN=2

                  DM9000_Reset PROC
;;;320    //复位DM9000
;;;321    void DM9000_Reset(void)
000000  b510              PUSH     {r4,lr}
;;;322    {
;;;323    	//复位DM9000,复位步骤参考<DM9000 Application Notes V1.22>手册29页
;;;324    	DM9000_RST = 0;								//DM9000硬件复位
000002  2000              MOVS     r0,#0
000004  491b              LDR      r1,|L8.116|
000006  6008              STR      r0,[r1,#0]
;;;325    	delay_ms(10);
000008  200a              MOVS     r0,#0xa
00000a  f7fffffe          BL       delay_ms
;;;326    	DM9000_RST = 1; 							//DM9000硬件复位结束
00000e  2001              MOVS     r0,#1
000010  4919              LDR      r1,|L8.120|
000012  f8c1019c          STR      r0,[r1,#0x19c]
;;;327    	delay_ms(100);								//一定要有这个延时，让DM9000准备就绪！
000016  2064              MOVS     r0,#0x64
000018  f7fffffe          BL       delay_ms
;;;328     	DM9000_WriteReg(DM9000_GPCR,0x01);			//第一步:设置GPCR寄存器(0X1E)的bit0为1 
00001c  2101              MOVS     r1,#1
00001e  201e              MOVS     r0,#0x1e
000020  f7fffffe          BL       DM9000_WriteReg
;;;329    	DM9000_WriteReg(DM9000_GPR,0);				//第二步:设置GPR寄存器(0X1F)的bit1为0，DM9000内部的PHY上电
000024  2100              MOVS     r1,#0
000026  201f              MOVS     r0,#0x1f
000028  f7fffffe          BL       DM9000_WriteReg
;;;330     	DM9000_WriteReg(DM9000_NCR,(0x02|NCR_RST));	//第三步:软件复位DM9000 
00002c  2103              MOVS     r1,#3
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       DM9000_WriteReg
;;;331    	do 
000034  bf00              NOP      
                  |L8.54|
;;;332    	{
;;;333    		delay_ms(25); 	
000036  2019              MOVS     r0,#0x19
000038  f7fffffe          BL       delay_ms
;;;334    	}while(DM9000_ReadReg(DM9000_NCR)&1);		//等待DM9000软复位完成
00003c  2000              MOVS     r0,#0
00003e  f7fffffe          BL       DM9000_ReadReg
000042  f0000001          AND      r0,r0,#1
000046  2800              CMP      r0,#0
000048  d1f5              BNE      |L8.54|
;;;335    	DM9000_WriteReg(DM9000_NCR,0);
00004a  2100              MOVS     r1,#0
00004c  4608              MOV      r0,r1
00004e  f7fffffe          BL       DM9000_WriteReg
;;;336    	DM9000_WriteReg(DM9000_NCR,(0x02|NCR_RST));	//DM9000第二次软复位
000052  2103              MOVS     r1,#3
000054  2000              MOVS     r0,#0
000056  f7fffffe          BL       DM9000_WriteReg
;;;337    	do 
00005a  bf00              NOP      
                  |L8.92|
;;;338    	{
;;;339    		delay_ms(25);	
00005c  2019              MOVS     r0,#0x19
00005e  f7fffffe          BL       delay_ms
;;;340    	}while (DM9000_ReadReg(DM9000_NCR)&1);
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       DM9000_ReadReg
000068  f0000001          AND      r0,r0,#1
00006c  2800              CMP      r0,#0
00006e  d1f5              BNE      |L8.92|
;;;341    }  
000070  bd10              POP      {r4,pc}
;;;342    
                          ENDP

000072  0000              DCW      0x0000
                  |L8.116|
                          DCD      0x4222819c
                  |L8.120|
                          DCD      0x42228000

                          AREA ||i.DM9000_SendPacket||, CODE, READONLY, ALIGN=2

                  DM9000_SendPacket PROC
;;;344    //p:pbuf结构体指针
;;;345    void DM9000_SendPacket(struct pbuf *p)
000000  b5f8              PUSH     {r3-r7,lr}
;;;346    {
000002  4604              MOV      r4,r0
;;;347    	struct pbuf *q;
;;;348    	u16 pbuf_index = 0;
000004  2700              MOVS     r7,#0
;;;349    	u8 word[2], word_index = 0;
000006  2600              MOVS     r6,#0
;;;350    	u8 err;	
;;;351     	//printf("send len:%d\r\n",p->tot_len);
;;;352    	
;;;353      xSemaphoreTake(dm9000lock,portMAX_DELAY);//获取互斥信号量 
000008  2300              MOVS     r3,#0
00000a  1e5a              SUBS     r2,r3,#1
00000c  4619              MOV      r1,r3
00000e  482c              LDR      r0,|L9.192|
000010  6800              LDR      r0,[r0,#0]  ; dm9000lock
000012  f7fffffe          BL       xQueueGenericReceive
;;;354    	DM9000_WriteReg(DM9000_IMR,IMR_PAR);		//关闭网卡中断 
000016  2180              MOVS     r1,#0x80
000018  20ff              MOVS     r0,#0xff
00001a  f7fffffe          BL       DM9000_WriteReg
;;;355    	DM9000->REG=DM9000_MWCMD;					//发送此命令后就可以将要发送的数据搬到DM9000 TX SRAM中	
00001e  20f8              MOVS     r0,#0xf8
000020  4928              LDR      r1,|L9.196|
000022  8008              STRH     r0,[r1,#0]
;;;356    	q=p;
000024  4625              MOV      r5,r4
;;;357    	//向DM9000的TX SRAM中写入数据，一次写入两个字节数据
;;;358    	//当要发送的数据长度为奇数的时候，我们需要将最后一个字节单独写入DM9000的TX SRAM中
;;;359     	while(q)
000026  e01b              B        |L9.96|
                  |L9.40|
;;;360    	{
;;;361    		if (pbuf_index < q->len)
000028  8968              LDRH     r0,[r5,#0xa]
00002a  42b8              CMP      r0,r7
00002c  dd16              BLE      |L9.92|
;;;362    		{
;;;363    			word[word_index++] = ((u8_t*)q->payload)[pbuf_index++];
00002e  4638              MOV      r0,r7
000030  1c79              ADDS     r1,r7,#1
000032  b28f              UXTH     r7,r1
000034  686a              LDR      r2,[r5,#4]
000036  5c12              LDRB     r2,[r2,r0]
000038  4630              MOV      r0,r6
00003a  1c71              ADDS     r1,r6,#1
00003c  b2ce              UXTB     r6,r1
00003e  f80d2000          STRB     r2,[sp,r0]
;;;364    			if (word_index == 2)
000042  2e02              CMP      r6,#2
000044  d10c              BNE      |L9.96|
;;;365    			{
;;;366    				DM9000->DATA=((u16)word[1]<<8)|word[0];
000046  f89d0000          LDRB     r0,[sp,#0]
00004a  f89d1001          LDRB     r1,[sp,#1]
00004e  ea402001          ORR      r0,r0,r1,LSL #8
000052  491c              LDR      r1,|L9.196|
000054  1c89              ADDS     r1,r1,#2
000056  8008              STRH     r0,[r1,#0]
;;;367    				word_index = 0;
000058  2600              MOVS     r6,#0
00005a  e001              B        |L9.96|
                  |L9.92|
;;;368    			}
;;;369    		}else
;;;370    		{
;;;371    			q=q->next;
00005c  682d              LDR      r5,[r5,#0]
;;;372    			pbuf_index = 0;
00005e  2700              MOVS     r7,#0
                  |L9.96|
000060  2d00              CMP      r5,#0                 ;359
000062  d1e1              BNE      |L9.40|
;;;373    		}
;;;374    	}
;;;375    	//还有一个字节未写入TX SRAM
;;;376    	if(word_index==1)DM9000->DATA=word[0];
000064  2e01              CMP      r6,#1
000066  d104              BNE      |L9.114|
000068  f89d0000          LDRB     r0,[sp,#0]
00006c  4915              LDR      r1,|L9.196|
00006e  1c89              ADDS     r1,r1,#2
000070  8008              STRH     r0,[r1,#0]
                  |L9.114|
;;;377    	//向DM9000写入发送长度
;;;378    	DM9000_WriteReg(DM9000_TXPLL,p->tot_len&0XFF);
000072  7a21              LDRB     r1,[r4,#8]
000074  20fc              MOVS     r0,#0xfc
000076  f7fffffe          BL       DM9000_WriteReg
;;;379    	DM9000_WriteReg(DM9000_TXPLH,(p->tot_len>>8)&0XFF);		//设置要发送数据的数据长度
00007a  8920              LDRH     r0,[r4,#8]
00007c  0a01              LSRS     r1,r0,#8
00007e  20fd              MOVS     r0,#0xfd
000080  f7fffffe          BL       DM9000_WriteReg
;;;380    	DM9000_WriteReg(DM9000_TCR,0X01);						//启动发送 
000084  2101              MOVS     r1,#1
000086  2002              MOVS     r0,#2
000088  f7fffffe          BL       DM9000_WriteReg
;;;381    	while((DM9000_ReadReg(DM9000_ISR)&0X02)==0);			//等待发送完成 
00008c  bf00              NOP      
                  |L9.142|
00008e  20fe              MOVS     r0,#0xfe
000090  f7fffffe          BL       DM9000_ReadReg
000094  f0000002          AND      r0,r0,#2
000098  2800              CMP      r0,#0
00009a  d0f8              BEQ      |L9.142|
;;;382    	DM9000_WriteReg(DM9000_ISR,0X02);						//清除发送完成中断 
00009c  2102              MOVS     r1,#2
00009e  20fe              MOVS     r0,#0xfe
0000a0  f7fffffe          BL       DM9000_WriteReg
;;;383     	DM9000_WriteReg(DM9000_IMR,dm9000cfg.imr_all);			//DM9000网卡接收中断使能
0000a4  4808              LDR      r0,|L9.200|
0000a6  7841              LDRB     r1,[r0,#1]  ; dm9000cfg
0000a8  20ff              MOVS     r0,#0xff
0000aa  f7fffffe          BL       DM9000_WriteReg
;;;384    	xSemaphoreGive(dm9000lock);		//释放互斥信号量
0000ae  2300              MOVS     r3,#0
0000b0  461a              MOV      r2,r3
0000b2  4619              MOV      r1,r3
0000b4  4802              LDR      r0,|L9.192|
0000b6  6800              LDR      r0,[r0,#0]  ; dm9000lock
0000b8  f7fffffe          BL       xQueueGenericSend
;;;385    }
0000bc  bdf8              POP      {r3-r7,pc}
;;;386    //DM9000接收数据包
                          ENDP

0000be  0000              DCW      0x0000
                  |L9.192|
                          DCD      dm9000lock
                  |L9.196|
                          DCD      0x640000fe
                  |L9.200|
                          DCD      dm9000cfg

                          AREA ||i.DM9000_Set_MACAddress||, CODE, READONLY, ALIGN=1

                  DM9000_Set_MACAddress PROC
;;;301    //macaddr:指向MAC地址
;;;302    void DM9000_Set_MACAddress(u8 *macaddr)
000000  b510              PUSH     {r4,lr}
;;;303    {
000002  4604              MOV      r4,r0
;;;304    	u8 i;
;;;305    	for(i=0;i<6;i++)
000004  2300              MOVS     r3,#0
000006  e006              B        |L10.22|
                  |L10.8|
;;;306    	{
;;;307    		DM9000_WriteReg(DM9000_PAR+i,macaddr[i]);
000008  5ce1              LDRB     r1,[r4,r3]
00000a  f1030010          ADD      r0,r3,#0x10
00000e  f7fffffe          BL       DM9000_WriteReg
000012  1c58              ADDS     r0,r3,#1              ;305
000014  b2c3              UXTB     r3,r0                 ;305
                  |L10.22|
000016  2b06              CMP      r3,#6                 ;305
000018  dbf6              BLT      |L10.8|
;;;308    	}
;;;309    }
00001a  bd10              POP      {r4,pc}
;;;310    //设置DM9000的组播地址
                          ENDP


                          AREA ||i.DM9000_Set_Multicast||, CODE, READONLY, ALIGN=1

                  DM9000_Set_Multicast PROC
;;;311    //multicastaddr:指向多播地址
;;;312    void DM9000_Set_Multicast(u8 *multicastaddr)
000000  b510              PUSH     {r4,lr}
;;;313    {
000002  4604              MOV      r4,r0
;;;314    	u8 i;
;;;315    	for(i=0;i<8;i++)
000004  2300              MOVS     r3,#0
000006  e006              B        |L11.22|
                  |L11.8|
;;;316    	{
;;;317    		DM9000_WriteReg(DM9000_MAR+i,multicastaddr[i]);
000008  5ce1              LDRB     r1,[r4,r3]
00000a  f1030016          ADD      r0,r3,#0x16
00000e  f7fffffe          BL       DM9000_WriteReg
000012  1c58              ADDS     r0,r3,#1              ;315
000014  b2c3              UXTB     r3,r0                 ;315
                  |L11.22|
000016  2b08              CMP      r3,#8                 ;315
000018  dbf6              BLT      |L11.8|
;;;318    	}
;;;319    }  
00001a  bd10              POP      {r4,pc}
;;;320    //复位DM9000
                          ENDP


                          AREA ||i.DM9000_Set_PHYMode||, CODE, READONLY, ALIGN=1

                  DM9000_Set_PHYMode PROC
;;;269    //mode:PHY模式
;;;270    void DM9000_Set_PHYMode(u8 mode)
000000  b570              PUSH     {r4-r6,lr}
;;;271    {
000002  4606              MOV      r6,r0
;;;272    	u16 BMCR_Value,ANAR_Value;	
;;;273    	switch(mode)
000004  2e09              CMP      r6,#9
000006  d21b              BCS      |L12.64|
000008  e8dff006          TBB      [pc,r6]
00000c  050c1a1a          DCB      0x05,0x0c,0x1a,0x1a
000010  08101a1a          DCB      0x08,0x10,0x1a,0x1a
000014  1500              DCB      0x15,0x00
;;;274    	{
;;;275    		case DM9000_10MHD:		//10M半双工
;;;276    			BMCR_Value=0X0000;
000016  2400              MOVS     r4,#0
;;;277    			ANAR_Value=0X21;
000018  2521              MOVS     r5,#0x21
;;;278    			break;
00001a  e011              B        |L12.64|
;;;279    		case DM9000_10MFD:		//10M全双工
;;;280    			BMCR_Value=0X0100;
00001c  f44f7480          MOV      r4,#0x100
;;;281    			ANAR_Value=0X41;
000020  2541              MOVS     r5,#0x41
;;;282    			break;
000022  e00d              B        |L12.64|
;;;283    		case DM9000_100MHD:		//100M半双工
;;;284    			BMCR_Value=0X2000;
000024  f44f5400          MOV      r4,#0x2000
;;;285    			ANAR_Value=0X81;
000028  2581              MOVS     r5,#0x81
;;;286    			break;
00002a  e009              B        |L12.64|
;;;287    		case DM9000_100MFD:		//100M全双工
;;;288    			BMCR_Value=0X2100;
00002c  f44f5404          MOV      r4,#0x2100
;;;289    			ANAR_Value=0X101;
000030  f2401501          MOV      r5,#0x101
;;;290    			break;
000034  e004              B        |L12.64|
;;;291    		case DM9000_AUTO:		//自动协商模式
;;;292    			BMCR_Value=0X1000;
000036  f44f5480          MOV      r4,#0x1000
;;;293    			ANAR_Value=0X01E1;
00003a  f24015e1          MOV      r5,#0x1e1
;;;294    			break;		
00003e  bf00              NOP      
                  |L12.64|
000040  bf00              NOP                            ;278
;;;295    	}
;;;296    	DM9000_PHY_WriteReg(DM9000_PHY_BMCR,BMCR_Value);
000042  4621              MOV      r1,r4
000044  2000              MOVS     r0,#0
000046  f7fffffe          BL       DM9000_PHY_WriteReg
;;;297    	DM9000_PHY_WriteReg(DM9000_PHY_ANAR,ANAR_Value);
00004a  4629              MOV      r1,r5
00004c  2004              MOVS     r0,#4
00004e  f7fffffe          BL       DM9000_PHY_WriteReg
;;;298     	DM9000_WriteReg(DM9000_GPR,0X00);	//使能PHY
000052  2100              MOVS     r1,#0
000054  201f              MOVS     r0,#0x1f
000056  f7fffffe          BL       DM9000_WriteReg
;;;299    }
00005a  bd70              POP      {r4-r6,pc}
;;;300    //设置DM9000的MAC地址
                          ENDP


                          AREA ||i.DM9000_WriteReg||, CODE, READONLY, ALIGN=2

                  DM9000_WriteReg PROC
;;;194    //data:要写入的值
;;;195    void DM9000_WriteReg(u16 reg,u16 data)
000000  4a03              LDR      r2,|L13.16|
;;;196    {
;;;197    	DM9000->REG=reg;
000002  8010              STRH     r0,[r2,#0]
;;;198    	DM9000->DATA=data;
000004  f04f42c8          MOV      r2,#0x64000000
000008  f8a21100          STRH     r1,[r2,#0x100]
;;;199    }
00000c  4770              BX       lr
;;;200    //读取DM9000的PHY的指定寄存器
                          ENDP

00000e  0000              DCW      0x0000
                  |L13.16|
                          DCD      0x640000fe

                          AREA ||i.DMA9000_ISRHandler||, CODE, READONLY, ALIGN=2

                  DMA9000_ISRHandler PROC
;;;480    //中断处理函数
;;;481    void DMA9000_ISRHandler(void)
000000  b538              PUSH     {r3-r5,lr}
;;;482    {
;;;483        BaseType_t  pxHigherPriorityTaskWoken;
;;;484    	u16 int_status;
;;;485    	u16 last_io; 
;;;486    	last_io = DM9000->REG;
000002  4815              LDR      r0,|L14.88|
000004  8805              LDRH     r5,[r0,#0]
;;;487    	int_status=DM9000_ReadReg(DM9000_ISR); 
000006  20fe              MOVS     r0,#0xfe
000008  f7fffffe          BL       DM9000_ReadReg
00000c  4604              MOV      r4,r0
;;;488    	DM9000_WriteReg(DM9000_ISR,int_status);				//清除中断标志位，DM9000的ISR寄存器的bit0~bit5写1清零
00000e  4621              MOV      r1,r4
000010  20fe              MOVS     r0,#0xfe
000012  f7fffffe          BL       DM9000_WriteReg
;;;489    	if(int_status & ISR_ROS)printf("overflow \r\n");
000016  f0040004          AND      r0,r4,#4
00001a  b110              CBZ      r0,|L14.34|
00001c  a00f              ADR      r0,|L14.92|
00001e  f7fffffe          BL       __2printf
                  |L14.34|
;;;490        if(int_status & ISR_ROOS)printf("overflow counter overflow \r\n");	
000022  f0040008          AND      r0,r4,#8
000026  b110              CBZ      r0,|L14.46|
000028  a00f              ADR      r0,|L14.104|
00002a  f7fffffe          BL       __2printf
                  |L14.46|
;;;491    	if(int_status & ISR_PRS)		//接收中断
00002e  f0040001          AND      r0,r4,#1
000032  b170              CBZ      r0,|L14.82|
;;;492    	{  
;;;493           xSemaphoreGiveFromISR(dm9000input,&pxHigherPriorityTaskWoken);//释放信号量
000034  4669              MOV      r1,sp
000036  4814              LDR      r0,|L14.136|
000038  6800              LDR      r0,[r0,#0]  ; dm9000input
00003a  f7fffffe          BL       xQueueGiveFromISR
;;;494            portYIELD_FROM_ISR(pxHigherPriorityTaskWoken);
00003e  9800              LDR      r0,[sp,#0]
000040  b138              CBZ      r0,|L14.82|
000042  f04f5080          MOV      r0,#0x10000000
000046  4911              LDR      r1,|L14.140|
000048  6008              STR      r0,[r1,#0]
00004a  f3bf8f4f          DSB      
00004e  f3bf8f6f          ISB      
                  |L14.82|
;;;495    	} 
;;;496    	if(int_status&ISR_PTS)			//发送中断
;;;497    	{ 
;;;498    									//接收中断处理,这里没用到
;;;499    	}
;;;500    	DM9000->REG=last_io;	
000052  4801              LDR      r0,|L14.88|
000054  8005              STRH     r5,[r0,#0]
;;;501    }
000056  bd38              POP      {r3-r5,pc}
;;;502    
                          ENDP

                  |L14.88|
                          DCD      0x640000fe
                  |L14.92|
00005c  6f766572          DCB      "overflow \r\n",0
000060  666c6f77
000064  200d0a00
                  |L14.104|
000068  6f766572          DCB      "overflow counter overflow \r\n",0
00006c  666c6f77
000070  20636f75
000074  6e746572
000078  206f7665
00007c  72666c6f
000080  77200d0a
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
                  |L14.136|
                          DCD      dm9000input
                  |L14.140|
                          DCD      0xe000ed04

                          AREA ||i.EXTI9_5_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI9_5_IRQHandler PROC
;;;172    //外部中断线6的中断服务函数(放exti.c)
;;;173    void EXTI9_5_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;174    {
;;;175    	//OSIntEnter();    
;;;176    	EXTI->PR=1<<6;  			//清除LINE6上的中断标志位   
000002  2040              MOVS     r0,#0x40
000004  4904              LDR      r1,|L15.24|
000006  6008              STR      r0,[r1,#0]
;;;177    	while(DM9000_INT==0)
000008  e001              B        |L15.14|
                  |L15.10|
;;;178    	{
;;;179    		DMA9000_ISRHandler();
00000a  f7fffffe          BL       DMA9000_ISRHandler
                  |L15.14|
00000e  4803              LDR      r0,|L15.28|
000010  6800              LDR      r0,[r0,#0]            ;177
000012  2800              CMP      r0,#0                 ;177
000014  d0f9              BEQ      |L15.10|
;;;180    	}
;;;181    //	OSIntExit();  		
;;;182    } 
000016  bd10              POP      {r4,pc}
;;;183    
                          ENDP

                  |L15.24|
                          DCD      0x40010414
                  |L15.28|
                          DCD      0x42240118

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  dm9000cfg
                          %        18

                          AREA ||.data||, DATA, ALIGN=2

                  dm9000lock
                          DCD      0x00000000
                  dm9000input
                          DCD      0x00000000
