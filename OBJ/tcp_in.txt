; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\tcp_in.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\tcp_in.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\tcp_in.crf ..\LWIP\lwip-1.4.1\src\core\tcp_in.c]
                          THUMB

                          AREA ||i.tcp_input||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_input PROC
;;;91     void
;;;92     tcp_input(struct pbuf *p, struct netif *inp)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;93     {
000004  4606              MOV      r6,r0
000006  468a              MOV      r10,r1
;;;94       struct tcp_pcb *pcb, *prev;
;;;95       struct tcp_pcb_listen *lpcb;
;;;96     #if SO_REUSE
;;;97       struct tcp_pcb *lpcb_prev = NULL;
;;;98       struct tcp_pcb_listen *lpcb_any = NULL;
;;;99     #endif /* SO_REUSE */
;;;100      u8_t hdrlen;
;;;101      err_t err;
;;;102    
;;;103      PERF_START;
;;;104    
;;;105      TCP_STATS_INC(tcp.recv);
;;;106      snmp_inc_tcpinsegs();
;;;107    
;;;108      iphdr = (struct ip_hdr *)p->payload;
000008  49fd              LDR      r1,|L1.1024|
00000a  6870              LDR      r0,[r6,#4]
00000c  6008              STR      r0,[r1,#0]  ; iphdr
;;;109      tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
00000e  48fc              LDR      r0,|L1.1024|
000010  6871              LDR      r1,[r6,#4]
000012  6800              LDR      r0,[r0,#0]  ; iphdr
000014  7800              LDRB     r0,[r0,#0]
000016  f000000f          AND      r0,r0,#0xf
00001a  eb010080          ADD      r0,r1,r0,LSL #2
00001e  49f9              LDR      r1,|L1.1028|
000020  6008              STR      r0,[r1,#0]  ; tcphdr
;;;110    
;;;111    #if TCP_INPUT_DEBUG
;;;112      tcp_debug_print(tcphdr);
;;;113    #endif
;;;114    
;;;115      /* remove header from payload */
;;;116      if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
000022  48f7              LDR      r0,|L1.1024|
000024  6800              LDR      r0,[r0,#0]  ; iphdr
000026  7800              LDRB     r0,[r0,#0]
000028  0700              LSLS     r0,r0,#28
00002a  0e80              LSRS     r0,r0,#26
00002c  4241              RSBS     r1,r0,#0
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       pbuf_header
000034  b910              CBNZ     r0,|L1.60|
000036  8930              LDRH     r0,[r6,#8]
000038  2814              CMP      r0,#0x14
00003a  d202              BCS      |L1.66|
                  |L1.60|
;;;117        /* drop short packets */
;;;118        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
00003c  bf00              NOP      
00003e  bf00              NOP      
;;;119        TCP_STATS_INC(tcp.lenerr);
;;;120        goto dropped;
000040  e32f              B        |L1.1698|
                  |L1.66|
;;;121      }
;;;122    
;;;123      /* Don't even process incoming broadcasts/multicasts. */
;;;124      if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
000042  49f1              LDR      r1,|L1.1032|
000044  6808              LDR      r0,[r1,#0]  ; current_iphdr_dest
000046  4651              MOV      r1,r10
000048  f7fffffe          BL       ip4_addr_isbroadcast
00004c  b928              CBNZ     r0,|L1.90|
;;;125          ip_addr_ismulticast(&current_iphdr_dest)) {
00004e  48ee              LDR      r0,|L1.1032|
000050  7800              LDRB     r0,[r0,#0]  ; current_iphdr_dest
000052  f00000f0          AND      r0,r0,#0xf0
000056  28e0              CMP      r0,#0xe0
000058  d100              BNE      |L1.92|
                  |L1.90|
;;;126        TCP_STATS_INC(tcp.proterr);
;;;127        goto dropped;
00005a  e322              B        |L1.1698|
                  |L1.92|
;;;128      }
;;;129    
;;;130    #if CHECKSUM_CHECK_TCP
;;;131      /* Verify TCP checksum. */
;;;132      if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
00005c  8930              LDRH     r0,[r6,#8]
00005e  2306              MOVS     r3,#6
000060  4ae9              LDR      r2,|L1.1032|
000062  49ea              LDR      r1,|L1.1036|
000064  9000              STR      r0,[sp,#0]
000066  4630              MOV      r0,r6
000068  f7fffffe          BL       inet_chksum_pseudo
00006c  b110              CBZ      r0,|L1.116|
;;;133          IP_PROTO_TCP, p->tot_len) != 0) {
;;;134          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_F"\n",
00006e  bf00              NOP      
000070  bf00              NOP      
;;;135            inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
;;;136          IP_PROTO_TCP, p->tot_len)));
;;;137    #if TCP_DEBUG
;;;138        tcp_debug_print(tcphdr);
;;;139    #endif /* TCP_DEBUG */
;;;140        TCP_STATS_INC(tcp.chkerr);
;;;141        goto dropped;
000072  e316              B        |L1.1698|
                  |L1.116|
;;;142      }
;;;143    #endif
;;;144    
;;;145      /* Move the payload pointer in the pbuf so that it points to the
;;;146         TCP data instead of the TCP header. */
;;;147      hdrlen = TCPH_HDRLEN(tcphdr);
000074  49e3              LDR      r1,|L1.1028|
000076  6809              LDR      r1,[r1,#0]  ; tcphdr
000078  8988              LDRH     r0,[r1,#0xc]
00007a  f7fffffe          BL       lwip_ntohs
00007e  ea4f3920          ASR      r9,r0,#12
;;;148      if(pbuf_header(p, -(hdrlen * 4))){
000082  ea4f0089          LSL      r0,r9,#2
000086  4241              RSBS     r1,r0,#0
000088  4630              MOV      r0,r6
00008a  f7fffffe          BL       pbuf_header
00008e  b110              CBZ      r0,|L1.150|
;;;149        /* drop short packets */
;;;150        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
000090  bf00              NOP      
000092  bf00              NOP      
;;;151        TCP_STATS_INC(tcp.lenerr);
;;;152        goto dropped;
000094  e305              B        |L1.1698|
                  |L1.150|
;;;153      }
;;;154    
;;;155      /* Convert fields in TCP header to host byte order. */
;;;156      tcphdr->src = ntohs(tcphdr->src);
000096  49db              LDR      r1,|L1.1028|
000098  6809              LDR      r1,[r1,#0]  ; tcphdr
00009a  8808              LDRH     r0,[r1,#0]
00009c  f7fffffe          BL       lwip_ntohs
0000a0  49d8              LDR      r1,|L1.1028|
0000a2  6809              LDR      r1,[r1,#0]  ; tcphdr
0000a4  8008              STRH     r0,[r1,#0]
;;;157      tcphdr->dest = ntohs(tcphdr->dest);
0000a6  49d7              LDR      r1,|L1.1028|
0000a8  6809              LDR      r1,[r1,#0]  ; tcphdr
0000aa  8848              LDRH     r0,[r1,#2]
0000ac  f7fffffe          BL       lwip_ntohs
0000b0  49d4              LDR      r1,|L1.1028|
0000b2  6809              LDR      r1,[r1,#0]  ; tcphdr
0000b4  8048              STRH     r0,[r1,#2]
;;;158      seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
0000b6  49d3              LDR      r1,|L1.1028|
0000b8  6809              LDR      r1,[r1,#0]  ; tcphdr
0000ba  6848              LDR      r0,[r1,#4]
0000bc  f7fffffe          BL       lwip_ntohl
0000c0  49d0              LDR      r1,|L1.1028|
0000c2  6809              LDR      r1,[r1,#0]  ; tcphdr
0000c4  6048              STR      r0,[r1,#4]
0000c6  49d2              LDR      r1,|L1.1040|
0000c8  6008              STR      r0,[r1,#0]  ; seqno
;;;159      ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
0000ca  49ce              LDR      r1,|L1.1028|
0000cc  6809              LDR      r1,[r1,#0]  ; tcphdr
0000ce  6888              LDR      r0,[r1,#8]
0000d0  f7fffffe          BL       lwip_ntohl
0000d4  49cb              LDR      r1,|L1.1028|
0000d6  6809              LDR      r1,[r1,#0]  ; tcphdr
0000d8  6088              STR      r0,[r1,#8]
0000da  49ce              LDR      r1,|L1.1044|
0000dc  6008              STR      r0,[r1,#0]  ; ackno
;;;160      tcphdr->wnd = ntohs(tcphdr->wnd);
0000de  49c9              LDR      r1,|L1.1028|
0000e0  6809              LDR      r1,[r1,#0]  ; tcphdr
0000e2  89c8              LDRH     r0,[r1,#0xe]
0000e4  f7fffffe          BL       lwip_ntohs
0000e8  49c6              LDR      r1,|L1.1028|
0000ea  6809              LDR      r1,[r1,#0]  ; tcphdr
0000ec  81c8              STRH     r0,[r1,#0xe]
;;;161    
;;;162      flags = TCPH_FLAGS(tcphdr);
0000ee  49c5              LDR      r1,|L1.1028|
0000f0  6809              LDR      r1,[r1,#0]  ; tcphdr
0000f2  8988              LDRH     r0,[r1,#0xc]
0000f4  f7fffffe          BL       lwip_ntohs
0000f8  f000003f          AND      r0,r0,#0x3f
0000fc  49c6              LDR      r1,|L1.1048|
0000fe  7008              STRB     r0,[r1,#0]
;;;163      tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
000100  8930              LDRH     r0,[r6,#8]
000102  7809              LDRB     r1,[r1,#0]  ; flags
000104  f0010103          AND      r1,r1,#3
000108  b109              CBZ      r1,|L1.270|
00010a  2101              MOVS     r1,#1
00010c  e000              B        |L1.272|
                  |L1.270|
00010e  2100              MOVS     r1,#0
                  |L1.272|
000110  4408              ADD      r0,r0,r1
000112  49c2              LDR      r1,|L1.1052|
000114  8008              STRH     r0,[r1,#0]
;;;164    
;;;165      /* Demultiplex an incoming segment. First, we check if it is destined
;;;166         for an active connection. */
;;;167      prev = NULL;
000116  2700              MOVS     r7,#0
;;;168    
;;;169      
;;;170      for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
000118  48c1              LDR      r0,|L1.1056|
00011a  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
00011c  e060              B        |L1.480|
                  |L1.286|
;;;171        LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
00011e  bf00              NOP      
000120  7e20              LDRB     r0,[r4,#0x18]
000122  b938              CBNZ     r0,|L1.308|
000124  bf00              NOP      
000126  a3bf              ADR      r3,|L1.1060|
000128  22ab              MOVS     r2,#0xab
00012a  a1c8              ADR      r1,|L1.1100|
00012c  a0d1              ADR      r0,|L1.1140|
00012e  f7fffffe          BL       __2printf
000132  bf00              NOP      
                  |L1.308|
000134  bf00              NOP      
;;;172        LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
000136  bf00              NOP      
000138  7e20              LDRB     r0,[r4,#0x18]
00013a  280a              CMP      r0,#0xa
00013c  d107              BNE      |L1.334|
00013e  bf00              NOP      
000140  a3b8              ADR      r3,|L1.1060|
000142  22ac              MOVS     r2,#0xac
000144  a1d6              ADR      r1,|L1.1184|
000146  a0cb              ADR      r0,|L1.1140|
000148  f7fffffe          BL       __2printf
00014c  bf00              NOP      
                  |L1.334|
00014e  bf00              NOP      
;;;173        LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
000150  bf00              NOP      
000152  7e20              LDRB     r0,[r4,#0x18]
000154  2801              CMP      r0,#1
000156  d107              BNE      |L1.360|
000158  bf00              NOP      
00015a  a3b2              ADR      r3,|L1.1060|
00015c  22ad              MOVS     r2,#0xad
00015e  a1db              ADR      r1,|L1.1228|
000160  a0c4              ADR      r0,|L1.1140|
000162  f7fffffe          BL       __2printf
000166  bf00              NOP      
                  |L1.360|
000168  bf00              NOP      
;;;174        if (pcb->remote_port == tcphdr->src &&
00016a  8ba0              LDRH     r0,[r4,#0x1c]
00016c  49a5              LDR      r1,|L1.1028|
00016e  6809              LDR      r1,[r1,#0]  ; tcphdr
000170  8809              LDRH     r1,[r1,#0]
000172  4288              CMP      r0,r1
000174  d132              BNE      |L1.476|
;;;175           pcb->local_port == tcphdr->dest &&
000176  8b60              LDRH     r0,[r4,#0x1a]
000178  49a2              LDR      r1,|L1.1028|
00017a  6809              LDR      r1,[r1,#0]  ; tcphdr
00017c  8849              LDRH     r1,[r1,#2]
00017e  4288              CMP      r0,r1
000180  d12c              BNE      |L1.476|
;;;176           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
000182  49a2              LDR      r1,|L1.1036|
000184  6860              LDR      r0,[r4,#4]
000186  6809              LDR      r1,[r1,#0]  ; current_iphdr_src
000188  4288              CMP      r0,r1
00018a  d127              BNE      |L1.476|
;;;177           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
00018c  499e              LDR      r1,|L1.1032|
00018e  6820              LDR      r0,[r4,#0]
000190  6809              LDR      r1,[r1,#0]  ; current_iphdr_dest
000192  4288              CMP      r0,r1
000194  d122              BNE      |L1.476|
;;;178    
;;;179          /* Move this PCB to the front of the list so that subsequent
;;;180             lookups will be faster (we exploit locality in TCP segment
;;;181             arrivals). */
;;;182          LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
000196  bf00              NOP      
000198  68e0              LDR      r0,[r4,#0xc]
00019a  42a0              CMP      r0,r4
00019c  d107              BNE      |L1.430|
00019e  bf00              NOP      
0001a0  a3a0              ADR      r3,|L1.1060|
0001a2  22b6              MOVS     r2,#0xb6
0001a4  a1d3              ADR      r1,|L1.1268|
0001a6  a0b3              ADR      r0,|L1.1140|
0001a8  f7fffffe          BL       __2printf
0001ac  bf00              NOP      
                  |L1.430|
0001ae  bf00              NOP      
;;;183          if (prev != NULL) {
0001b0  b137              CBZ      r7,|L1.448|
;;;184            prev->next = pcb->next;
0001b2  68e0              LDR      r0,[r4,#0xc]
0001b4  60f8              STR      r0,[r7,#0xc]
;;;185            pcb->next = tcp_active_pcbs;
0001b6  489a              LDR      r0,|L1.1056|
0001b8  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
0001ba  60e0              STR      r0,[r4,#0xc]
;;;186            tcp_active_pcbs = pcb;
0001bc  4898              LDR      r0,|L1.1056|
0001be  6004              STR      r4,[r0,#0]  ; tcp_active_pcbs
                  |L1.448|
;;;187          }
;;;188          LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
0001c0  bf00              NOP      
0001c2  68e0              LDR      r0,[r4,#0xc]
0001c4  42a0              CMP      r0,r4
0001c6  d107              BNE      |L1.472|
0001c8  bf00              NOP      
0001ca  a396              ADR      r3,|L1.1060|
0001cc  22bc              MOVS     r2,#0xbc
0001ce  a1d4              ADR      r1,|L1.1312|
0001d0  a0a8              ADR      r0,|L1.1140|
0001d2  f7fffffe          BL       __2printf
0001d6  bf00              NOP      
                  |L1.472|
0001d8  bf00              NOP      
;;;189          break;
0001da  e003              B        |L1.484|
                  |L1.476|
;;;190        }
;;;191        prev = pcb;
0001dc  4627              MOV      r7,r4
0001de  68e4              LDR      r4,[r4,#0xc]          ;170
                  |L1.480|
0001e0  2c00              CMP      r4,#0                 ;170
0001e2  d19c              BNE      |L1.286|
                  |L1.484|
0001e4  bf00              NOP                            ;189
;;;192      }
;;;193    
;;;194      if (pcb == NULL) {
0001e6  2c00              CMP      r4,#0
0001e8  d15c              BNE      |L1.676|
;;;195        /* If it did not go to an active connection, we check the connections
;;;196           in the TIME-WAIT state. */
;;;197        for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
0001ea  48d8              LDR      r0,|L1.1356|
0001ec  6804              LDR      r4,[r0,#0]  ; tcp_tw_pcbs
0001ee  e02d              B        |L1.588|
                  |L1.496|
;;;198          LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
0001f0  bf00              NOP      
0001f2  7e20              LDRB     r0,[r4,#0x18]
0001f4  280a              CMP      r0,#0xa
0001f6  d007              BEQ      |L1.520|
0001f8  bf00              NOP      
0001fa  a38a              ADR      r3,|L1.1060|
0001fc  22c6              MOVS     r2,#0xc6
0001fe  a1d4              ADR      r1,|L1.1360|
000200  a09c              ADR      r0,|L1.1140|
000202  f7fffffe          BL       __2printf
000206  bf00              NOP      
                  |L1.520|
000208  bf00              NOP      
;;;199          if (pcb->remote_port == tcphdr->src &&
00020a  8ba0              LDRH     r0,[r4,#0x1c]
00020c  497d              LDR      r1,|L1.1028|
00020e  6809              LDR      r1,[r1,#0]  ; tcphdr
000210  8809              LDRH     r1,[r1,#0]
000212  4288              CMP      r0,r1
000214  d119              BNE      |L1.586|
;;;200             pcb->local_port == tcphdr->dest &&
000216  8b60              LDRH     r0,[r4,#0x1a]
000218  497a              LDR      r1,|L1.1028|
00021a  6809              LDR      r1,[r1,#0]  ; tcphdr
00021c  8849              LDRH     r1,[r1,#2]
00021e  4288              CMP      r0,r1
000220  d113              BNE      |L1.586|
;;;201             ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
000222  497a              LDR      r1,|L1.1036|
000224  6860              LDR      r0,[r4,#4]
000226  6809              LDR      r1,[r1,#0]  ; current_iphdr_src
000228  4288              CMP      r0,r1
00022a  d10e              BNE      |L1.586|
;;;202             ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
00022c  4976              LDR      r1,|L1.1032|
00022e  6820              LDR      r0,[r4,#0]
000230  6809              LDR      r1,[r1,#0]  ; current_iphdr_dest
000232  4288              CMP      r0,r1
000234  d109              BNE      |L1.586|
;;;203            /* We don't really care enough to move this PCB to the front
;;;204               of the list since we are not very likely to receive that
;;;205               many segments for connections in TIME-WAIT. */
;;;206            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
000236  bf00              NOP      
000238  bf00              NOP      
;;;207            tcp_timewait_input(pcb);
00023a  4620              MOV      r0,r4
00023c  f7fffffe          BL       tcp_timewait_input
;;;208            pbuf_free(p);
000240  4630              MOV      r0,r6
000242  f7fffffe          BL       pbuf_free
                  |L1.582|
;;;209            return;
;;;210          }
;;;211        }
;;;212    
;;;213        /* Finally, if we still did not get a match, we check all PCBs that
;;;214           are LISTENing for incoming connections. */
;;;215        prev = NULL;
;;;216        for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;217          if (lpcb->local_port == tcphdr->dest) {
;;;218    #if SO_REUSE
;;;219            if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest)) {
;;;220              /* found an exact match */
;;;221              break;
;;;222            } else if(ip_addr_isany(&(lpcb->local_ip))) {
;;;223              /* found an ANY-match */
;;;224              lpcb_any = lpcb;
;;;225              lpcb_prev = prev;
;;;226            }
;;;227    #else /* SO_REUSE */
;;;228            if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
;;;229                ip_addr_isany(&(lpcb->local_ip))) {
;;;230              /* found a match */
;;;231              break;
;;;232            }
;;;233    #endif /* SO_REUSE */
;;;234          }
;;;235          prev = (struct tcp_pcb *)lpcb;
;;;236        }
;;;237    #if SO_REUSE
;;;238        /* first try specific local IP */
;;;239        if (lpcb == NULL) {
;;;240          /* only pass to ANY if no specific local IP has been found */
;;;241          lpcb = lpcb_any;
;;;242          prev = lpcb_prev;
;;;243        }
;;;244    #endif /* SO_REUSE */
;;;245        if (lpcb != NULL) {
;;;246          /* Move this PCB to the front of the list so that subsequent
;;;247             lookups will be faster (we exploit locality in TCP segment
;;;248             arrivals). */
;;;249          if (prev != NULL) {
;;;250            ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
;;;251                  /* our successor is the remainder of the listening list */
;;;252            lpcb->next = tcp_listen_pcbs.listen_pcbs;
;;;253                  /* put this listening pcb at the head of the listening list */
;;;254            tcp_listen_pcbs.listen_pcbs = lpcb;
;;;255          }
;;;256        
;;;257          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
;;;258          tcp_listen_input(lpcb);
;;;259          pbuf_free(p);
;;;260          return;
;;;261        }
;;;262      }
;;;263    
;;;264    #if TCP_INPUT_DEBUG
;;;265      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "));
;;;266      tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
;;;267      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
;;;268    #endif /* TCP_INPUT_DEBUG */
;;;269    
;;;270    
;;;271      if (pcb != NULL) {
;;;272        /* The incoming segment belongs to a connection. */
;;;273    #if TCP_INPUT_DEBUG
;;;274    #if TCP_DEBUG
;;;275        tcp_debug_print_state(pcb->state);
;;;276    #endif /* TCP_DEBUG */
;;;277    #endif /* TCP_INPUT_DEBUG */
;;;278    
;;;279        /* Set up a tcp_seg structure. */
;;;280        inseg.next = NULL;
;;;281        inseg.len = p->tot_len;
;;;282        inseg.p = p;
;;;283        inseg.tcphdr = tcphdr;
;;;284    
;;;285        recv_data = NULL;
;;;286        recv_flags = 0;
;;;287    
;;;288        if (flags & TCP_PSH) {
;;;289          p->flags |= PBUF_FLAG_PUSH;
;;;290        }
;;;291    
;;;292        /* If there is data which was previously "refused" by upper layer */
;;;293        if (pcb->refused_data != NULL) {
;;;294          if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
;;;295            ((pcb->refused_data != NULL) && (tcplen > 0))) {
;;;296            /* pcb has been aborted or refused data is still refused and the new
;;;297               segment contains data */
;;;298            TCP_STATS_INC(tcp.drop);
;;;299            snmp_inc_tcpinerrs();
;;;300            goto aborted;
;;;301          }
;;;302        }
;;;303        tcp_input_pcb = pcb;
;;;304        err = tcp_process(pcb);
;;;305        /* A return value of ERR_ABRT means that tcp_abort() was called
;;;306           and that the pcb has been freed. If so, we don't do anything. */
;;;307        if (err != ERR_ABRT) {
;;;308          if (recv_flags & TF_RESET) {
;;;309            /* TF_RESET means that the connection was reset by the other
;;;310               end. We then call the error callback to inform the
;;;311               application that the connection is dead before we
;;;312               deallocate the PCB. */
;;;313            TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
;;;314            tcp_pcb_remove(&tcp_active_pcbs, pcb);
;;;315            memp_free(MEMP_TCP_PCB, pcb);
;;;316          } else if (recv_flags & TF_CLOSED) {
;;;317            /* The connection has been closed and we will deallocate the
;;;318               PCB. */
;;;319            if (!(pcb->flags & TF_RXCLOSED)) {
;;;320              /* Connection closed although the application has only shut down the
;;;321                 tx side: call the PCB's err callback and indicate the closure to
;;;322                 ensure the application doesn't continue using the PCB. */
;;;323              TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
;;;324            }
;;;325            tcp_pcb_remove(&tcp_active_pcbs, pcb);
;;;326            memp_free(MEMP_TCP_PCB, pcb);
;;;327          } else {
;;;328            err = ERR_OK;
;;;329            /* If the application has registered a "sent" function to be
;;;330               called when new send buffer space is available, we call it
;;;331               now. */
;;;332            if (pcb->acked > 0) {
;;;333              TCP_EVENT_SENT(pcb, pcb->acked, err);
;;;334              if (err == ERR_ABRT) {
;;;335                goto aborted;
;;;336              }
;;;337            }
;;;338    
;;;339            if (recv_data != NULL) {
;;;340              LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
;;;341              if (pcb->flags & TF_RXCLOSED) {
;;;342                /* received data although already closed -> abort (send RST) to
;;;343                   notify the remote host that not all data has been processed */
;;;344                pbuf_free(recv_data);
;;;345                tcp_abort(pcb);
;;;346                goto aborted;
;;;347              }
;;;348    
;;;349              /* Notify application that data has been received. */
;;;350              TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
;;;351              if (err == ERR_ABRT) {
;;;352                goto aborted;
;;;353              }
;;;354    
;;;355              /* If the upper layer can't receive this data, store it */
;;;356              if (err != ERR_OK) {
;;;357                pcb->refused_data = recv_data;
;;;358                LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: keep incoming packet, because pcb is \"full\"\n"));
;;;359              }
;;;360            }
;;;361    
;;;362            /* If a FIN segment was received, we call the callback
;;;363               function with a NULL buffer to indicate EOF. */
;;;364            if (recv_flags & TF_GOT_FIN) {
;;;365              if (pcb->refused_data != NULL) {
;;;366                /* Delay this if we have refused data. */
;;;367                pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
;;;368              } else {
;;;369                /* correct rcv_wnd as the application won't call tcp_recved()
;;;370                   for the FIN's seqno */
;;;371                if (pcb->rcv_wnd != TCP_WND) {
;;;372                  pcb->rcv_wnd++;
;;;373                }
;;;374                TCP_EVENT_CLOSED(pcb, err);
;;;375                if (err == ERR_ABRT) {
;;;376                  goto aborted;
;;;377                }
;;;378              }
;;;379            }
;;;380    
;;;381            tcp_input_pcb = NULL;
;;;382            /* Try to send something out. */
;;;383            tcp_output(pcb);
;;;384    #if TCP_INPUT_DEBUG
;;;385    #if TCP_DEBUG
;;;386            tcp_debug_print_state(pcb->state);
;;;387    #endif /* TCP_DEBUG */
;;;388    #endif /* TCP_INPUT_DEBUG */
;;;389          }
;;;390        }
;;;391        /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
;;;392           Below this line, 'pcb' may not be dereferenced! */
;;;393    aborted:
;;;394        tcp_input_pcb = NULL;
;;;395        recv_data = NULL;
;;;396    
;;;397        /* give up our reference to inseg.p */
;;;398        if (inseg.p != NULL)
;;;399        {
;;;400          pbuf_free(inseg.p);
;;;401          inseg.p = NULL;
;;;402        }
;;;403      } else {
;;;404    
;;;405        /* If no matching PCB was found, send a TCP RST (reset) to the
;;;406           sender. */
;;;407        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
;;;408        if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
;;;409          TCP_STATS_INC(tcp.proterr);
;;;410          TCP_STATS_INC(tcp.drop);
;;;411          tcp_rst(ackno, seqno + tcplen,
;;;412            ip_current_dest_addr(), ip_current_src_addr(),
;;;413            tcphdr->dest, tcphdr->src);
;;;414        }
;;;415        pbuf_free(p);
;;;416      }
;;;417    
;;;418      LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
;;;419      PERF_STOP("tcp_input");
;;;420      return;
;;;421    dropped:
;;;422      TCP_STATS_INC(tcp.drop);
;;;423      snmp_inc_tcpinerrs();
;;;424      pbuf_free(p);
;;;425    }
000246  e8bd87fc          POP      {r2-r10,pc}
                  |L1.586|
00024a  68e4              LDR      r4,[r4,#0xc]          ;197
                  |L1.588|
00024c  2c00              CMP      r4,#0                 ;197
00024e  d1cf              BNE      |L1.496|
000250  2700              MOVS     r7,#0                 ;215
000252  48cb              LDR      r0,|L1.1408|
000254  6805              LDR      r5,[r0,#0]            ;216  ; tcp_listen_pcbs
000256  e010              B        |L1.634|
                  |L1.600|
000258  8b68              LDRH     r0,[r5,#0x1a]         ;217
00025a  496a              LDR      r1,|L1.1028|
00025c  6809              LDR      r1,[r1,#0]            ;217  ; tcphdr
00025e  8849              LDRH     r1,[r1,#2]            ;217
000260  4288              CMP      r0,r1                 ;217
000262  d108              BNE      |L1.630|
000264  4968              LDR      r1,|L1.1032|
000266  6828              LDR      r0,[r5,#0]            ;228
000268  6809              LDR      r1,[r1,#0]            ;228  ; current_iphdr_dest
00026a  4288              CMP      r0,r1                 ;228
00026c  d002              BEQ      |L1.628|
00026e  b10d              CBZ      r5,|L1.628|
000270  6828              LDR      r0,[r5,#0]            ;229
000272  b900              CBNZ     r0,|L1.630|
                  |L1.628|
000274  e003              B        |L1.638|
                  |L1.630|
000276  462f              MOV      r7,r5                 ;235
000278  68ed              LDR      r5,[r5,#0xc]          ;216
                  |L1.634|
00027a  2d00              CMP      r5,#0                 ;216
00027c  d1ec              BNE      |L1.600|
                  |L1.638|
00027e  bf00              NOP                            ;231
000280  b185              CBZ      r5,|L1.676|
000282  b137              CBZ      r7,|L1.658|
000284  68e8              LDR      r0,[r5,#0xc]          ;250
000286  60f8              STR      r0,[r7,#0xc]          ;250
000288  48bd              LDR      r0,|L1.1408|
00028a  6800              LDR      r0,[r0,#0]            ;252  ; tcp_listen_pcbs
00028c  60e8              STR      r0,[r5,#0xc]          ;252
00028e  48bc              LDR      r0,|L1.1408|
000290  6005              STR      r5,[r0,#0]            ;254  ; tcp_listen_pcbs
                  |L1.658|
000292  bf00              NOP                            ;257
000294  bf00              NOP                            ;257
000296  4628              MOV      r0,r5                 ;258
000298  f7fffffe          BL       tcp_listen_input
00029c  4630              MOV      r0,r6                 ;259
00029e  f7fffffe          BL       pbuf_free
0002a2  e7d0              B        |L1.582|
                  |L1.676|
0002a4  2c00              CMP      r4,#0                 ;271
0002a6  d076              BEQ      |L1.918|
0002a8  2000              MOVS     r0,#0                 ;280
0002aa  49b6              LDR      r1,|L1.1412|
0002ac  6008              STR      r0,[r1,#0]            ;280  ; inseg
0002ae  8930              LDRH     r0,[r6,#8]            ;281
0002b0  8108              STRH     r0,[r1,#8]            ;281
0002b2  4608              MOV      r0,r1                 ;282
0002b4  6046              STR      r6,[r0,#4]            ;282  ; inseg
0002b6  4853              LDR      r0,|L1.1028|
0002b8  6800              LDR      r0,[r0,#0]            ;283  ; tcphdr
0002ba  6108              STR      r0,[r1,#0x10]         ;283  ; inseg
0002bc  2000              MOVS     r0,#0                 ;285
0002be  49b2              LDR      r1,|L1.1416|
0002c0  6008              STR      r0,[r1,#0]            ;285  ; recv_data
0002c2  49b2              LDR      r1,|L1.1420|
0002c4  7008              STRB     r0,[r1,#0]            ;286
0002c6  4854              LDR      r0,|L1.1048|
0002c8  7800              LDRB     r0,[r0,#0]            ;288  ; flags
0002ca  f0000008          AND      r0,r0,#8              ;288
0002ce  b118              CBZ      r0,|L1.728|
0002d0  7b70              LDRB     r0,[r6,#0xd]          ;289
0002d2  f0400001          ORR      r0,r0,#1              ;289
0002d6  7370              STRB     r0,[r6,#0xd]          ;289
                  |L1.728|
0002d8  6fa0              LDR      r0,[r4,#0x78]         ;293
0002da  b158              CBZ      r0,|L1.756|
0002dc  4620              MOV      r0,r4                 ;294
0002de  f7fffffe          BL       tcp_process_refused_data
0002e2  300a              ADDS     r0,r0,#0xa            ;294
0002e4  b128              CBZ      r0,|L1.754|
0002e6  6fa0              LDR      r0,[r4,#0x78]         ;295
0002e8  b120              CBZ      r0,|L1.756|
0002ea  484c              LDR      r0,|L1.1052|
0002ec  8800              LDRH     r0,[r0,#0]            ;295  ; tcplen
0002ee  2800              CMP      r0,#0                 ;295
0002f0  dd00              BLE      |L1.756|
                  |L1.754|
0002f2  e1a3              B        |L1.1596|
                  |L1.756|
0002f4  48a6              LDR      r0,|L1.1424|
0002f6  6004              STR      r4,[r0,#0]            ;303  ; tcp_input_pcb
0002f8  4620              MOV      r0,r4                 ;304
0002fa  f7fffffe          BL       tcp_process
0002fe  4680              MOV      r8,r0                 ;304
000300  f108000a          ADD      r0,r8,#0xa            ;307
000304  2800              CMP      r0,#0                 ;307
000306  d017              BEQ      |L1.824|
000308  48a0              LDR      r0,|L1.1420|
00030a  7800              LDRB     r0,[r0,#0]            ;308  ; recv_flags
00030c  f0000008          AND      r0,r0,#8              ;308
000310  b198              CBZ      r0,|L1.826|
000312  bf00              NOP                            ;313
000314  f8d4008c          LDR      r0,[r4,#0x8c]         ;313
000318  b128              CBZ      r0,|L1.806|
00031a  f06f010a          MVN      r1,#0xa               ;313
00031e  f8d4208c          LDR      r2,[r4,#0x8c]         ;313
000322  6920              LDR      r0,[r4,#0x10]         ;313
000324  4790              BLX      r2                    ;313
                  |L1.806|
000326  bf00              NOP                            ;313
000328  4621              MOV      r1,r4                 ;314
00032a  483d              LDR      r0,|L1.1056|
00032c  f7fffffe          BL       tcp_pcb_remove
000330  4621              MOV      r1,r4                 ;315
000332  2002              MOVS     r0,#2                 ;315
000334  f7fffffe          BL       memp_free
                  |L1.824|
000338  e17f              B        |L1.1594|
                  |L1.826|
00033a  4894              LDR      r0,|L1.1420|
00033c  7800              LDRB     r0,[r0,#0]            ;316  ; recv_flags
00033e  f0000010          AND      r0,r0,#0x10           ;316
000342  b1b8              CBZ      r0,|L1.884|
000344  7fa0              LDRB     r0,[r4,#0x1e]         ;319
000346  f0000010          AND      r0,r0,#0x10           ;319
00034a  b950              CBNZ     r0,|L1.866|
00034c  bf00              NOP                            ;323
00034e  f8d4008c          LDR      r0,[r4,#0x8c]         ;323
000352  b128              CBZ      r0,|L1.864|
000354  f06f010b          MVN      r1,#0xb               ;323
000358  f8d4208c          LDR      r2,[r4,#0x8c]         ;323
00035c  6920              LDR      r0,[r4,#0x10]         ;323
00035e  4790              BLX      r2                    ;323
                  |L1.864|
000360  bf00              NOP                            ;323
                  |L1.866|
000362  4621              MOV      r1,r4                 ;325
000364  482e              LDR      r0,|L1.1056|
000366  f7fffffe          BL       tcp_pcb_remove
00036a  4621              MOV      r1,r4                 ;326
00036c  2002              MOVS     r0,#2                 ;326
00036e  f7fffffe          BL       memp_free
000372  e162              B        |L1.1594|
                  |L1.884|
000374  f04f0800          MOV      r8,#0                 ;328
000378  f8b40064          LDRH     r0,[r4,#0x64]         ;332
00037c  2800              CMP      r0,#0                 ;332
00037e  dd12              BLE      |L1.934|
000380  bf00              NOP                            ;333
000382  6fe0              LDR      r0,[r4,#0x7c]         ;333
000384  b140              CBZ      r0,|L1.920|
000386  f8b42064          LDRH     r2,[r4,#0x64]         ;333
00038a  4621              MOV      r1,r4                 ;333
00038c  6fe3              LDR      r3,[r4,#0x7c]         ;333
00038e  6920              LDR      r0,[r4,#0x10]         ;333
000390  4798              BLX      r3                    ;333
000392  4680              MOV      r8,r0                 ;333
000394  e002              B        |L1.924|
                  |L1.918|
000396  e161              B        |L1.1628|
                  |L1.920|
000398  f04f0800          MOV      r8,#0                 ;333
                  |L1.924|
00039c  bf00              NOP                            ;333
00039e  f108000a          ADD      r0,r8,#0xa            ;334
0003a2  b900              CBNZ     r0,|L1.934|
0003a4  e14a              B        |L1.1596|
                  |L1.934|
0003a6  4878              LDR      r0,|L1.1416|
0003a8  6800              LDR      r0,[r0,#0]            ;339  ; recv_data
0003aa  b330              CBZ      r0,|L1.1018|
0003ac  bf00              NOP                            ;340
0003ae  6fa0              LDR      r0,[r4,#0x78]         ;340
0003b0  b140              CBZ      r0,|L1.964|
0003b2  bf00              NOP                            ;340
0003b4  a31b              ADR      r3,|L1.1060|
0003b6  f44f72aa          MOV      r2,#0x154             ;340
0003ba  a176              ADR      r1,|L1.1428|
0003bc  a02d              ADR      r0,|L1.1140|
0003be  f7fffffe          BL       __2printf
0003c2  bf00              NOP                            ;340
                  |L1.964|
0003c4  bf00              NOP                            ;340
0003c6  7fa0              LDRB     r0,[r4,#0x1e]         ;341
0003c8  f0000010          AND      r0,r0,#0x10           ;341
0003cc  b138              CBZ      r0,|L1.990|
0003ce  486e              LDR      r0,|L1.1416|
0003d0  6800              LDR      r0,[r0,#0]            ;344  ; recv_data
0003d2  f7fffffe          BL       pbuf_free
0003d6  4620              MOV      r0,r4                 ;345
0003d8  f7fffffe          BL       tcp_abort
0003dc  e12e              B        |L1.1596|
                  |L1.990|
0003de  bf00              NOP                            ;350
0003e0  f8d40080          LDR      r0,[r4,#0x80]         ;350
0003e4  b150              CBZ      r0,|L1.1020|
0003e6  2300              MOVS     r3,#0                 ;350
0003e8  4967              LDR      r1,|L1.1416|
0003ea  f8d4c080          LDR      r12,[r4,#0x80]        ;350
0003ee  6920              LDR      r0,[r4,#0x10]         ;350
0003f0  680a              LDR      r2,[r1,#0]            ;350  ; recv_data
0003f2  4621              MOV      r1,r4                 ;350
0003f4  47e0              BLX      r12                   ;350
0003f6  4680              MOV      r8,r0                 ;350
0003f8  e0e2              B        |L1.1472|
                  |L1.1018|
0003fa  e0ee              B        |L1.1498|
                  |L1.1020|
0003fc  e0d8              B        |L1.1456|
0003fe  0000              DCW      0x0000
                  |L1.1024|
                          DCD      iphdr
                  |L1.1028|
                          DCD      tcphdr
                  |L1.1032|
                          DCD      current_iphdr_dest
                  |L1.1036|
                          DCD      current_iphdr_src
                  |L1.1040|
                          DCD      seqno
                  |L1.1044|
                          DCD      ackno
                  |L1.1048|
                          DCD      flags
                  |L1.1052|
                          DCD      tcplen
                  |L1.1056|
                          DCD      tcp_active_pcbs
                  |L1.1060|
000424  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp_in.c",0
000428  5749505c
00042c  6c776970
000430  2d312e34
000434  2e315c73
000438  72635c63
00043c  6f72655c
000440  7463705f
000444  696e2e63
000448  00      
000449  00                DCB      0
00044a  00                DCB      0
00044b  00                DCB      0
                  |L1.1100|
00044c  7463705f          DCB      "tcp_input: active pcb->state != CLOSED",0
000450  696e7075
000454  743a2061
000458  63746976
00045c  65207063
000460  622d3e73
000464  74617465
000468  20213d20
00046c  434c4f53
000470  454400  
000473  00                DCB      0
                  |L1.1140|
000474  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000478  7274696f
00047c  6e202225
000480  73222066
000484  61696c65
000488  64206174
00048c  206c696e
000490  65202564
000494  20696e20
000498  25730d0a
00049c  00      
00049d  00                DCB      0
00049e  00                DCB      0
00049f  00                DCB      0
                  |L1.1184|
0004a0  7463705f          DCB      "tcp_input: active pcb->state != TIME-WAIT",0
0004a4  696e7075
0004a8  743a2061
0004ac  63746976
0004b0  65207063
0004b4  622d3e73
0004b8  74617465
0004bc  20213d20
0004c0  54494d45
0004c4  2d574149
0004c8  5400    
0004ca  00                DCB      0
0004cb  00                DCB      0
                  |L1.1228|
0004cc  7463705f          DCB      "tcp_input: active pcb->state != LISTEN",0
0004d0  696e7075
0004d4  743a2061
0004d8  63746976
0004dc  65207063
0004e0  622d3e73
0004e4  74617465
0004e8  20213d20
0004ec  4c495354
0004f0  454e00  
0004f3  00                DCB      0
                  |L1.1268|
0004f4  7463705f          DCB      "tcp_input: pcb->next != pcb (before cache)",0
0004f8  696e7075
0004fc  743a2070
000500  63622d3e
000504  6e657874
000508  20213d20
00050c  70636220
000510  28626566
000514  6f726520
000518  63616368
00051c  652900  
00051f  00                DCB      0
                  |L1.1312|
000520  7463705f          DCB      "tcp_input: pcb->next != pcb (after cache)",0
000524  696e7075
000528  743a2070
00052c  63622d3e
000530  6e657874
000534  20213d20
000538  70636220
00053c  28616674
000540  65722063
000544  61636865
000548  2900    
00054a  00                DCB      0
00054b  00                DCB      0
                  |L1.1356|
                          DCD      tcp_tw_pcbs
                  |L1.1360|
000550  7463705f          DCB      "tcp_input: TIME-WAIT pcb->state == TIME-WAIT",0
000554  696e7075
000558  743a2054
00055c  494d452d
000560  57414954
000564  20706362
000568  2d3e7374
00056c  61746520
000570  3d3d2054
000574  494d452d
000578  57414954
00057c  00      
00057d  00                DCB      0
00057e  00                DCB      0
00057f  00                DCB      0
                  |L1.1408|
                          DCD      tcp_listen_pcbs
                  |L1.1412|
                          DCD      inseg
                  |L1.1416|
                          DCD      recv_data
                  |L1.1420|
                          DCD      recv_flags
                  |L1.1424|
                          DCD      tcp_input_pcb
                  |L1.1428|
000594  7063622d          DCB      "pcb->refused_data == NULL",0
000598  3e726566
00059c  75736564
0005a0  5f646174
0005a4  61203d3d
0005a8  204e554c
0005ac  4c00    
0005ae  00                DCB      0
0005af  00                DCB      0
                  |L1.1456|
0005b0  2300              MOVS     r3,#0                 ;350
0005b2  483e              LDR      r0,|L1.1708|
0005b4  4621              MOV      r1,r4                 ;350
0005b6  6802              LDR      r2,[r0,#0]            ;350  ; recv_data
0005b8  4618              MOV      r0,r3                 ;350
0005ba  f7fffffe          BL       tcp_recv_null
0005be  4680              MOV      r8,r0                 ;350
                  |L1.1472|
0005c0  bf00              NOP                            ;350
0005c2  f108000a          ADD      r0,r8,#0xa            ;351
0005c6  b900              CBNZ     r0,|L1.1482|
0005c8  e038              B        |L1.1596|
                  |L1.1482|
0005ca  f1b80f00          CMP      r8,#0                 ;356
0005ce  d004              BEQ      |L1.1498|
0005d0  4836              LDR      r0,|L1.1708|
0005d2  6800              LDR      r0,[r0,#0]            ;357  ; recv_data
0005d4  67a0              STR      r0,[r4,#0x78]         ;357
0005d6  bf00              NOP                            ;358
0005d8  bf00              NOP                            ;358
                  |L1.1498|
0005da  4835              LDR      r0,|L1.1712|
0005dc  7800              LDRB     r0,[r0,#0]            ;364  ; recv_flags
0005de  f0000020          AND      r0,r0,#0x20           ;364
0005e2  b320              CBZ      r0,|L1.1582|
0005e4  6fa0              LDR      r0,[r4,#0x78]         ;365
0005e6  b130              CBZ      r0,|L1.1526|
0005e8  6fa0              LDR      r0,[r4,#0x78]         ;367
0005ea  7b40              LDRB     r0,[r0,#0xd]          ;367
0005ec  f0400020          ORR      r0,r0,#0x20           ;367
0005f0  6fa1              LDR      r1,[r4,#0x78]         ;367
0005f2  7348              STRB     r0,[r1,#0xd]          ;367
0005f4  e01b              B        |L1.1582|
                  |L1.1526|
0005f6  8da0              LDRH     r0,[r4,#0x2c]         ;371
0005f8  f6403168          MOV      r1,#0xb68             ;371
0005fc  4288              CMP      r0,r1                 ;371
0005fe  d002              BEQ      |L1.1542|
000600  8da0              LDRH     r0,[r4,#0x2c]         ;372
000602  1c40              ADDS     r0,r0,#1              ;372
000604  85a0              STRH     r0,[r4,#0x2c]         ;372
                  |L1.1542|
000606  bf00              NOP                            ;374
000608  f8d40080          LDR      r0,[r4,#0x80]         ;374
00060c  b140              CBZ      r0,|L1.1568|
00060e  2300              MOVS     r3,#0                 ;374
000610  461a              MOV      r2,r3                 ;374
000612  4621              MOV      r1,r4                 ;374
000614  f8d4c080          LDR      r12,[r4,#0x80]        ;374
000618  6920              LDR      r0,[r4,#0x10]         ;374
00061a  47e0              BLX      r12                   ;374
00061c  4680              MOV      r8,r0                 ;374
00061e  e001              B        |L1.1572|
                  |L1.1568|
000620  f04f0800          MOV      r8,#0                 ;374
                  |L1.1572|
000624  bf00              NOP                            ;374
000626  f108000a          ADD      r0,r8,#0xa            ;375
00062a  b900              CBNZ     r0,|L1.1582|
00062c  e006              B        |L1.1596|
                  |L1.1582|
00062e  2000              MOVS     r0,#0                 ;381
000630  4920              LDR      r1,|L1.1716|
000632  6008              STR      r0,[r1,#0]            ;381  ; tcp_input_pcb
000634  4620              MOV      r0,r4                 ;383
000636  f7fffffe          BL       tcp_output
                  |L1.1594|
00063a  bf00              NOP                            ;393
                  |L1.1596|
00063c  2000              MOVS     r0,#0                 ;394
00063e  491d              LDR      r1,|L1.1716|
000640  6008              STR      r0,[r1,#0]            ;394  ; tcp_input_pcb
000642  491a              LDR      r1,|L1.1708|
000644  6008              STR      r0,[r1,#0]            ;395  ; recv_data
000646  481c              LDR      r0,|L1.1720|
000648  6840              LDR      r0,[r0,#4]            ;398  ; inseg
00064a  b338              CBZ      r0,|L1.1692|
00064c  491a              LDR      r1,|L1.1720|
00064e  6848              LDR      r0,[r1,#4]            ;400  ; inseg
000650  f7fffffe          BL       pbuf_free
000654  2000              MOVS     r0,#0                 ;401
000656  4918              LDR      r1,|L1.1720|
000658  6048              STR      r0,[r1,#4]            ;401  ; inseg
00065a  e01f              B        |L1.1692|
                  |L1.1628|
00065c  bf00              NOP                            ;407
00065e  bf00              NOP                            ;407
000660  4916              LDR      r1,|L1.1724|
000662  6809              LDR      r1,[r1,#0]            ;408  ; tcphdr
000664  8988              LDRH     r0,[r1,#0xc]          ;408
000666  f7fffffe          BL       lwip_ntohs
00066a  f0000004          AND      r0,r0,#4              ;408
00066e  b990              CBNZ     r0,|L1.1686|
000670  4812              LDR      r0,|L1.1724|
000672  6800              LDR      r0,[r0,#0]            ;411  ; tcphdr
000674  8800              LDRH     r0,[r0,#0]            ;411
000676  4911              LDR      r1,|L1.1724|
000678  6809              LDR      r1,[r1,#0]            ;411  ; tcphdr
00067a  8849              LDRH     r1,[r1,#2]            ;411
00067c  e9cd1000          STRD     r1,r0,[sp,#0]         ;411
000680  480f              LDR      r0,|L1.1728|
000682  6800              LDR      r0,[r0,#0]            ;411  ; seqno
000684  4a0f              LDR      r2,|L1.1732|
000686  8812              LDRH     r2,[r2,#0]            ;411  ; tcplen
000688  1881              ADDS     r1,r0,r2              ;411
00068a  4b0f              LDR      r3,|L1.1736|
00068c  4a0f              LDR      r2,|L1.1740|
00068e  4810              LDR      r0,|L1.1744|
000690  6800              LDR      r0,[r0,#0]            ;411  ; ackno
000692  f7fffffe          BL       tcp_rst
                  |L1.1686|
000696  4630              MOV      r0,r6                 ;415
000698  f7fffffe          BL       pbuf_free
                  |L1.1692|
00069c  bf00              NOP                            ;418
00069e  bf00              NOP                            ;418
0006a0  e5d1              B        |L1.582|
                  |L1.1698|
0006a2  4630              MOV      r0,r6                 ;424
0006a4  f7fffffe          BL       pbuf_free
0006a8  bf00              NOP      
0006aa  e5cc              B        |L1.582|
;;;426    
                          ENDP

                  |L1.1708|
                          DCD      recv_data
                  |L1.1712|
                          DCD      recv_flags
                  |L1.1716|
                          DCD      tcp_input_pcb
                  |L1.1720|
                          DCD      inseg
                  |L1.1724|
                          DCD      tcphdr
                  |L1.1728|
                          DCD      seqno
                  |L1.1732|
                          DCD      tcplen
                  |L1.1736|
                          DCD      current_iphdr_src
                  |L1.1740|
                          DCD      current_iphdr_dest
                  |L1.1744|
                          DCD      ackno

                          AREA ||i.tcp_listen_input||, CODE, READONLY, ALIGN=2

                  tcp_listen_input PROC
;;;439    static err_t
;;;440    tcp_listen_input(struct tcp_pcb_listen *pcb)
000000  b57c              PUSH     {r2-r6,lr}
;;;441    {
000002  4605              MOV      r5,r0
;;;442      struct tcp_pcb *npcb;
;;;443      err_t rc;
;;;444    
;;;445      if (flags & TCP_RST) {
000004  4844              LDR      r0,|L2.280|
000006  7800              LDRB     r0,[r0,#0]  ; flags
000008  f0000004          AND      r0,r0,#4
00000c  b108              CBZ      r0,|L2.18|
;;;446        /* An incoming RST should be ignored. Return. */
;;;447        return ERR_OK;
00000e  2000              MOVS     r0,#0
                  |L2.16|
;;;448      }
;;;449    
;;;450      /* In the LISTEN state, we check for incoming SYN segments,
;;;451         creates a new PCB, and responds with a SYN|ACK. */
;;;452      if (flags & TCP_ACK) {
;;;453        /* For incoming segments with the ACK flag set, respond with a
;;;454           RST. */
;;;455        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
;;;456        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
;;;457          ip_current_src_addr(), tcphdr->dest, tcphdr->src);
;;;458      } else if (flags & TCP_SYN) {
;;;459        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->dest));
;;;460    #if TCP_LISTEN_BACKLOG
;;;461        if (pcb->accepts_pending >= pcb->backlog) {
;;;462          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
;;;463          return ERR_ABRT;
;;;464        }
;;;465    #endif /* TCP_LISTEN_BACKLOG */
;;;466        npcb = tcp_alloc(pcb->prio);
;;;467        /* If a new PCB could not be created (probably due to lack of memory),
;;;468           we don't do anything, but rely on the sender will retransmit the
;;;469           SYN at a time when we have more memory available. */
;;;470        if (npcb == NULL) {
;;;471          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
;;;472          TCP_STATS_INC(tcp.memerr);
;;;473          return ERR_MEM;
;;;474        }
;;;475    #if TCP_LISTEN_BACKLOG
;;;476        pcb->accepts_pending++;
;;;477    #endif /* TCP_LISTEN_BACKLOG */
;;;478        /* Set up the new PCB. */
;;;479        ip_addr_copy(npcb->local_ip, current_iphdr_dest);
;;;480        npcb->local_port = pcb->local_port;
;;;481        ip_addr_copy(npcb->remote_ip, current_iphdr_src);
;;;482        npcb->remote_port = tcphdr->src;
;;;483        npcb->state = SYN_RCVD;
;;;484        npcb->rcv_nxt = seqno + 1;
;;;485        npcb->rcv_ann_right_edge = npcb->rcv_nxt;
;;;486        npcb->snd_wnd = tcphdr->wnd;
;;;487        npcb->snd_wnd_max = tcphdr->wnd;
;;;488        npcb->ssthresh = npcb->snd_wnd;
;;;489        npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
;;;490        npcb->callback_arg = pcb->callback_arg;
;;;491    #if LWIP_CALLBACK_API
;;;492        npcb->accept = pcb->accept;
;;;493    #endif /* LWIP_CALLBACK_API */
;;;494        /* inherit socket options */
;;;495        npcb->so_options = pcb->so_options & SOF_INHERITED;
;;;496        /* Register the new PCB so that we can begin receiving segments
;;;497           for it. */
;;;498        TCP_REG_ACTIVE(npcb);
;;;499    
;;;500        /* Parse any options in the SYN. */
;;;501        tcp_parseopt(npcb);
;;;502    #if TCP_CALCULATE_EFF_SEND_MSS
;;;503        npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
;;;504    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;505    
;;;506        snmp_inc_tcppassiveopens();
;;;507    
;;;508        /* Send a SYN|ACK together with the MSS option. */
;;;509        rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
;;;510        if (rc != ERR_OK) {
;;;511          tcp_abandon(npcb, 0);
;;;512          return rc;
;;;513        }
;;;514        return tcp_output(npcb);
;;;515      }
;;;516      return ERR_OK;
;;;517    }
000010  bd7c              POP      {r2-r6,pc}
                  |L2.18|
000012  4841              LDR      r0,|L2.280|
000014  7800              LDRB     r0,[r0,#0]            ;452  ; flags
000016  f0000010          AND      r0,r0,#0x10           ;452
00001a  b1a8              CBZ      r0,|L2.72|
00001c  bf00              NOP                            ;455
00001e  bf00              NOP                            ;455
000020  483e              LDR      r0,|L2.284|
000022  6800              LDR      r0,[r0,#0]            ;456  ; tcphdr
000024  8800              LDRH     r0,[r0,#0]            ;456
000026  493d              LDR      r1,|L2.284|
000028  6809              LDR      r1,[r1,#0]            ;456  ; tcphdr
00002a  8849              LDRH     r1,[r1,#2]            ;456
00002c  e9cd1000          STRD     r1,r0,[sp,#0]         ;456
000030  483b              LDR      r0,|L2.288|
000032  6800              LDR      r0,[r0,#0]            ;456  ; seqno
000034  4a3b              LDR      r2,|L2.292|
000036  8812              LDRH     r2,[r2,#0]            ;456  ; tcplen
000038  1881              ADDS     r1,r0,r2              ;456
00003a  4b3b              LDR      r3,|L2.296|
00003c  4a3b              LDR      r2,|L2.300|
00003e  483c              LDR      r0,|L2.304|
000040  6800              LDR      r0,[r0,#0]            ;456  ; ackno
000042  f7fffffe          BL       tcp_rst
000046  e065              B        |L2.276|
                  |L2.72|
000048  4833              LDR      r0,|L2.280|
00004a  7800              LDRB     r0,[r0,#0]            ;458  ; flags
00004c  f0000002          AND      r0,r0,#2              ;458
000050  2800              CMP      r0,#0                 ;458
000052  d05f              BEQ      |L2.276|
000054  bf00              NOP                            ;459
000056  bf00              NOP                            ;459
000058  7e68              LDRB     r0,[r5,#0x19]         ;466
00005a  f7fffffe          BL       tcp_alloc
00005e  4604              MOV      r4,r0                 ;466
000060  b924              CBNZ     r4,|L2.108|
000062  bf00              NOP                            ;471
000064  bf00              NOP                            ;471
000066  f04f30ff          MOV      r0,#0xffffffff        ;473
00006a  e7d1              B        |L2.16|
                  |L2.108|
00006c  482f              LDR      r0,|L2.300|
00006e  6800              LDR      r0,[r0,#0]            ;479  ; current_iphdr_dest
000070  6020              STR      r0,[r4,#0]            ;479
000072  8b68              LDRH     r0,[r5,#0x1a]         ;480
000074  8360              STRH     r0,[r4,#0x1a]         ;480
000076  482c              LDR      r0,|L2.296|
000078  6800              LDR      r0,[r0,#0]            ;481  ; current_iphdr_src
00007a  6060              STR      r0,[r4,#4]            ;481
00007c  4827              LDR      r0,|L2.284|
00007e  6800              LDR      r0,[r0,#0]            ;482  ; tcphdr
000080  8800              LDRH     r0,[r0,#0]            ;482
000082  83a0              STRH     r0,[r4,#0x1c]         ;482
000084  2003              MOVS     r0,#3                 ;483
000086  7620              STRB     r0,[r4,#0x18]         ;483
000088  4825              LDR      r0,|L2.288|
00008a  6800              LDR      r0,[r0,#0]            ;484  ; seqno
00008c  1c40              ADDS     r0,r0,#1              ;484
00008e  62a0              STR      r0,[r4,#0x28]         ;484
000090  6aa0              LDR      r0,[r4,#0x28]         ;485
000092  6320              STR      r0,[r4,#0x30]         ;485
000094  4821              LDR      r0,|L2.284|
000096  6800              LDR      r0,[r0,#0]            ;486  ; tcphdr
000098  89c0              LDRH     r0,[r0,#0xe]          ;486
00009a  f8a40060          STRH     r0,[r4,#0x60]         ;486
00009e  481f              LDR      r0,|L2.284|
0000a0  6800              LDR      r0,[r0,#0]            ;487  ; tcphdr
0000a2  89c0              LDRH     r0,[r0,#0xe]          ;487
0000a4  f8a40062          STRH     r0,[r4,#0x62]         ;487
0000a8  f8b40060          LDRH     r0,[r4,#0x60]         ;488
0000ac  f8a4004e          STRH     r0,[r4,#0x4e]         ;488
0000b0  481b              LDR      r0,|L2.288|
0000b2  6800              LDR      r0,[r0,#0]            ;489  ; seqno
0000b4  1e40              SUBS     r0,r0,#1              ;489
0000b6  6560              STR      r0,[r4,#0x54]         ;489
0000b8  6928              LDR      r0,[r5,#0x10]         ;490
0000ba  6120              STR      r0,[r4,#0x10]         ;490
0000bc  6968              LDR      r0,[r5,#0x14]         ;492
0000be  6160              STR      r0,[r4,#0x14]         ;492
0000c0  7a28              LDRB     r0,[r5,#8]            ;495
0000c2  f000008c          AND      r0,r0,#0x8c           ;495
0000c6  7220              STRB     r0,[r4,#8]            ;495
0000c8  bf00              NOP                            ;498
0000ca  bf00              NOP                            ;498
0000cc  4819              LDR      r0,|L2.308|
0000ce  6800              LDR      r0,[r0,#0]            ;498  ; tcp_active_pcbs
0000d0  60e0              STR      r0,[r4,#0xc]          ;498
0000d2  4818              LDR      r0,|L2.308|
0000d4  6004              STR      r4,[r0,#0]            ;498  ; tcp_active_pcbs
0000d6  f7fffffe          BL       tcp_timer_needed
0000da  bf00              NOP                            ;498
0000dc  2001              MOVS     r0,#1                 ;498
0000de  4916              LDR      r1,|L2.312|
0000e0  7008              STRB     r0,[r1,#0]            ;498
0000e2  bf00              NOP                            ;498
0000e4  4620              MOV      r0,r4                 ;501
0000e6  f7fffffe          BL       tcp_parseopt
0000ea  8ee0              LDRH     r0,[r4,#0x36]         ;503
0000ec  1d21              ADDS     r1,r4,#4              ;503
0000ee  f7fffffe          BL       tcp_eff_send_mss
0000f2  86e0              STRH     r0,[r4,#0x36]         ;503
0000f4  2112              MOVS     r1,#0x12              ;509
0000f6  4620              MOV      r0,r4                 ;509
0000f8  f7fffffe          BL       tcp_enqueue_flags
0000fc  4606              MOV      r6,r0                 ;509
0000fe  b12e              CBZ      r6,|L2.268|
000100  2100              MOVS     r1,#0                 ;511
000102  4620              MOV      r0,r4                 ;511
000104  f7fffffe          BL       tcp_abandon
000108  4630              MOV      r0,r6                 ;512
00010a  e781              B        |L2.16|
                  |L2.268|
00010c  4620              MOV      r0,r4                 ;514
00010e  f7fffffe          BL       tcp_output
000112  e77d              B        |L2.16|
                  |L2.276|
000114  2000              MOVS     r0,#0                 ;516
000116  e77b              B        |L2.16|
;;;518    
                          ENDP

                  |L2.280|
                          DCD      flags
                  |L2.284|
                          DCD      tcphdr
                  |L2.288|
                          DCD      seqno
                  |L2.292|
                          DCD      tcplen
                  |L2.296|
                          DCD      current_iphdr_src
                  |L2.300|
                          DCD      current_iphdr_dest
                  |L2.304|
                          DCD      ackno
                  |L2.308|
                          DCD      tcp_active_pcbs
                  |L2.312|
                          DCD      tcp_active_pcbs_changed

                          AREA ||i.tcp_oos_insert_segment||, CODE, READONLY, ALIGN=2

                  tcp_oos_insert_segment PROC
;;;799    static void
;;;800    tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
000000  b570              PUSH     {r4-r6,lr}
;;;801    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;802      struct tcp_seg *old_seg;
;;;803    
;;;804      if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
000006  6929              LDR      r1,[r5,#0x10]
000008  8988              LDRH     r0,[r1,#0xc]
00000a  f7fffffe          BL       lwip_ntohs
00000e  f0000001          AND      r0,r0,#1
000012  b120              CBZ      r0,|L3.30|
;;;805        /* received segment overlaps all following segments */
;;;806        tcp_segs_free(next);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       tcp_segs_free
;;;807        next = NULL;
00001a  2400              MOVS     r4,#0
00001c  e033              B        |L3.134|
                  |L3.30|
;;;808      }
;;;809      else {
;;;810        /* delete some following segments
;;;811           oos queue may have segments with FIN flag */
;;;812        while (next &&
00001e  e013              B        |L3.72|
                  |L3.32|
;;;813               TCP_SEQ_GEQ((seqno + cseg->len),
;;;814                          (next->tcphdr->seqno + next->len))) {
;;;815          /* cseg with FIN already processed */
;;;816          if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
000020  6921              LDR      r1,[r4,#0x10]
000022  8988              LDRH     r0,[r1,#0xc]
000024  f7fffffe          BL       lwip_ntohs
000028  f0000001          AND      r0,r0,#1
00002c  b138              CBZ      r0,|L3.62|
;;;817            TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       lwip_htons
000034  6929              LDR      r1,[r5,#0x10]
000036  8989              LDRH     r1,[r1,#0xc]
000038  4308              ORRS     r0,r0,r1
00003a  6929              LDR      r1,[r5,#0x10]
00003c  8188              STRH     r0,[r1,#0xc]
                  |L3.62|
;;;818          }
;;;819          old_seg = next;
00003e  4626              MOV      r6,r4
;;;820          next = next->next;
000040  6824              LDR      r4,[r4,#0]
;;;821          tcp_seg_free(old_seg);
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       tcp_seg_free
                  |L3.72|
000048  b14c              CBZ      r4,|L3.94|
00004a  6920              LDR      r0,[r4,#0x10]         ;813
00004c  6840              LDR      r0,[r0,#4]            ;813
00004e  8921              LDRH     r1,[r4,#8]            ;813
000050  4408              ADD      r0,r0,r1              ;813
000052  8929              LDRH     r1,[r5,#8]            ;813
000054  4a0d              LDR      r2,|L3.140|
000056  6812              LDR      r2,[r2,#0]            ;813  ; seqno
000058  4411              ADD      r1,r1,r2              ;813
00005a  1a08              SUBS     r0,r1,r0              ;813
00005c  d5e0              BPL      |L3.32|
                  |L3.94|
;;;822        }
;;;823        if (next &&
00005e  b194              CBZ      r4,|L3.134|
;;;824            TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
000060  8928              LDRH     r0,[r5,#8]
000062  490a              LDR      r1,|L3.140|
000064  6809              LDR      r1,[r1,#0]  ; seqno
000066  4408              ADD      r0,r0,r1
000068  6921              LDR      r1,[r4,#0x10]
00006a  6849              LDR      r1,[r1,#4]
00006c  1a40              SUBS     r0,r0,r1
00006e  2800              CMP      r0,#0
000070  dd09              BLE      |L3.134|
;;;825          /* We need to trim the incoming segment. */
;;;826          cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
000072  6920              LDR      r0,[r4,#0x10]
000074  8880              LDRH     r0,[r0,#4]
000076  4905              LDR      r1,|L3.140|
000078  8809              LDRH     r1,[r1,#0]  ; seqno
00007a  1a40              SUBS     r0,r0,r1
00007c  8128              STRH     r0,[r5,#8]
;;;827          pbuf_realloc(cseg->p, cseg->len);
00007e  8929              LDRH     r1,[r5,#8]
000080  6868              LDR      r0,[r5,#4]
000082  f7fffffe          BL       pbuf_realloc
                  |L3.134|
;;;828        }
;;;829      }
;;;830      cseg->next = next;
000086  602c              STR      r4,[r5,#0]
;;;831    }
000088  bd70              POP      {r4-r6,pc}
;;;832    #endif /* TCP_QUEUE_OOSEQ */
                          ENDP

00008a  0000              DCW      0x0000
                  |L3.140|
                          DCD      seqno

                          AREA ||i.tcp_parseopt||, CODE, READONLY, ALIGN=2

                  tcp_parseopt PROC
;;;1541   static void
;;;1542   tcp_parseopt(struct tcp_pcb *pcb)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1543   {
000004  4680              MOV      r8,r0
;;;1544     u16_t c, max_c;
;;;1545     u16_t mss;
;;;1546     u8_t *opts, opt;
;;;1547   #if LWIP_TCP_TIMESTAMPS
;;;1548     u32_t tsval;
;;;1549   #endif
;;;1550   
;;;1551     opts = (u8_t *)tcphdr + TCP_HLEN;
000006  4831              LDR      r0,|L4.204|
000008  6800              LDR      r0,[r0,#0]  ; tcphdr
00000a  f1000514          ADD      r5,r0,#0x14
;;;1552   
;;;1553     /* Parse the TCP MSS option, if present. */
;;;1554     if(TCPH_HDRLEN(tcphdr) > 0x5) {
00000e  492f              LDR      r1,|L4.204|
000010  6809              LDR      r1,[r1,#0]  ; tcphdr
000012  8988              LDRH     r0,[r1,#0xc]
000014  f7fffffe          BL       lwip_ntohs
000018  2105              MOVS     r1,#5
00001a  ebb13f20          CMP      r1,r0,ASR #12
00001e  da52              BGE      |L4.198|
;;;1555       max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
000020  492a              LDR      r1,|L4.204|
000022  6809              LDR      r1,[r1,#0]  ; tcphdr
000024  8988              LDRH     r0,[r1,#0xc]
000026  f7fffffe          BL       lwip_ntohs
00002a  2105              MOVS     r1,#5
00002c  ebc13020          RSB      r0,r1,r0,ASR #12
000030  f64f71ff          MOV      r1,#0xffff
000034  ea010680          AND      r6,r1,r0,LSL #2
;;;1556       for (c = 0; c < max_c; ) {
000038  2400              MOVS     r4,#0
00003a  e042              B        |L4.194|
                  |L4.60|
;;;1557         opt = opts[c];
00003c  f8159004          LDRB     r9,[r5,r4]
;;;1558         switch (opt) {
000040  f1b90f00          CMP      r9,#0
000044  d006              BEQ      |L4.84|
000046  f1b90f01          CMP      r9,#1
00004a  d007              BEQ      |L4.92|
00004c  f1b90f02          CMP      r9,#2
000050  d129              BNE      |L4.166|
000052  e008              B        |L4.102|
                  |L4.84|
;;;1559         case 0x00:
;;;1560           /* End of options. */
;;;1561           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
000054  bf00              NOP      
000056  bf00              NOP      
                  |L4.88|
;;;1562           return;
;;;1563         case 0x01:
;;;1564           /* NOP option. */
;;;1565           ++c;
;;;1566           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
;;;1567           break;
;;;1568         case 0x02:
;;;1569           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
;;;1570           if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
;;;1571             /* Bad length */
;;;1572             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1573             return;
;;;1574           }
;;;1575           /* An MSS option with the right option length. */
;;;1576           mss = (opts[c + 2] << 8) | opts[c + 3];
;;;1577           /* Limit the mss to the configured TCP_MSS and prevent division by zero */
;;;1578           pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
;;;1579           /* Advance to next option */
;;;1580           c += 0x04;
;;;1581           break;
;;;1582   #if LWIP_TCP_TIMESTAMPS
;;;1583         case 0x08:
;;;1584           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: TS\n"));
;;;1585           if (opts[c + 1] != 0x0A || c + 0x0A > max_c) {
;;;1586             /* Bad length */
;;;1587             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1588             return;
;;;1589           }
;;;1590           /* TCP timestamp option with valid length */
;;;1591           tsval = (opts[c+2]) | (opts[c+3] << 8) | 
;;;1592             (opts[c+4] << 16) | (opts[c+5] << 24);
;;;1593           if (flags & TCP_SYN) {
;;;1594             pcb->ts_recent = ntohl(tsval);
;;;1595             pcb->flags |= TF_TIMESTAMP;
;;;1596           } else if (TCP_SEQ_BETWEEN(pcb->ts_lastacksent, seqno, seqno+tcplen)) {
;;;1597             pcb->ts_recent = ntohl(tsval);
;;;1598           }
;;;1599           /* Advance to next option */
;;;1600           c += 0x0A;
;;;1601           break;
;;;1602   #endif
;;;1603         default:
;;;1604           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
;;;1605           if (opts[c + 1] == 0) {
;;;1606             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1607             /* If the length field is zero, the options are malformed
;;;1608                and we don't process them further. */
;;;1609             return;
;;;1610           }
;;;1611           /* All other options have a length field, so that we easily
;;;1612              can skip past them. */
;;;1613           c += opts[c + 1];
;;;1614         }
;;;1615       }
;;;1616     }
;;;1617   }
000058  e8bd87f0          POP      {r4-r10,pc}
                  |L4.92|
00005c  1c60              ADDS     r0,r4,#1              ;1565
00005e  b284              UXTH     r4,r0                 ;1565
000060  bf00              NOP                            ;1566
000062  bf00              NOP                            ;1566
000064  e02c              B        |L4.192|
                  |L4.102|
000066  bf00              NOP                            ;1569
000068  bf00              NOP                            ;1569
00006a  1c60              ADDS     r0,r4,#1              ;1570
00006c  5c28              LDRB     r0,[r5,r0]            ;1570
00006e  2804              CMP      r0,#4                 ;1570
000070  d102              BNE      |L4.120|
000072  1d20              ADDS     r0,r4,#4              ;1570
000074  42b0              CMP      r0,r6                 ;1570
000076  dd02              BLE      |L4.126|
                  |L4.120|
000078  bf00              NOP                            ;1572
00007a  bf00              NOP                            ;1572
00007c  e7ec              B        |L4.88|
                  |L4.126|
00007e  1ce0              ADDS     r0,r4,#3              ;1576
000080  5c29              LDRB     r1,[r5,r0]            ;1576
000082  1ca0              ADDS     r0,r4,#2              ;1576
000084  5c28              LDRB     r0,[r5,r0]            ;1576
000086  ea412700          ORR      r7,r1,r0,LSL #8       ;1576
00008a  f24050b4          MOV      r0,#0x5b4             ;1578
00008e  4287              CMP      r7,r0                 ;1578
000090  dc00              BGT      |L4.148|
000092  b917              CBNZ     r7,|L4.154|
                  |L4.148|
000094  f24050b4          MOV      r0,#0x5b4             ;1578
000098  e000              B        |L4.156|
                  |L4.154|
00009a  4638              MOV      r0,r7                 ;1578
                  |L4.156|
00009c  f8a80036          STRH     r0,[r8,#0x36]         ;1578
0000a0  1d20              ADDS     r0,r4,#4              ;1580
0000a2  b284              UXTH     r4,r0                 ;1580
0000a4  e00c              B        |L4.192|
                  |L4.166|
0000a6  bf00              NOP                            ;1604
0000a8  bf00              NOP                            ;1604
0000aa  1c60              ADDS     r0,r4,#1              ;1605
0000ac  5c28              LDRB     r0,[r5,r0]            ;1605
0000ae  b910              CBNZ     r0,|L4.182|
0000b0  bf00              NOP                            ;1606
0000b2  bf00              NOP                            ;1606
0000b4  e7d0              B        |L4.88|
                  |L4.182|
0000b6  1c60              ADDS     r0,r4,#1              ;1613
0000b8  5c28              LDRB     r0,[r5,r0]            ;1613
0000ba  4420              ADD      r0,r0,r4              ;1613
0000bc  b284              UXTH     r4,r0                 ;1613
0000be  bf00              NOP                            ;1558
                  |L4.192|
0000c0  bf00              NOP                            ;1567
                  |L4.194|
0000c2  42b4              CMP      r4,r6                 ;1556
0000c4  dbba              BLT      |L4.60|
                  |L4.198|
0000c6  bf00              NOP      
0000c8  e7c6              B        |L4.88|
;;;1618   
                          ENDP

0000ca  0000              DCW      0x0000
                  |L4.204|
                          DCD      tcphdr

                          AREA ||i.tcp_process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_process PROC
;;;574    static err_t
;;;575    tcp_process(struct tcp_pcb *pcb)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;576    {
000004  4604              MOV      r4,r0
;;;577      struct tcp_seg *rseg;
;;;578      u8_t acceptable = 0;
000006  f04f0800          MOV      r8,#0
;;;579      err_t err;
;;;580    
;;;581      err = ERR_OK;
00000a  2600              MOVS     r6,#0
;;;582    
;;;583      /* Process incoming RST segments. */
;;;584      if (flags & TCP_RST) {
00000c  48f0              LDR      r0,|L5.976|
00000e  7800              LDRB     r0,[r0,#0]  ; flags
000010  f0000004          AND      r0,r0,#4
000014  2800              CMP      r0,#0
000016  d03f              BEQ      |L5.152|
;;;585        /* First, determine if the reset is acceptable. */
;;;586        if (pcb->state == SYN_SENT) {
000018  7e20              LDRB     r0,[r4,#0x18]
00001a  2802              CMP      r0,#2
00001c  d107              BNE      |L5.46|
;;;587          if (ackno == pcb->snd_nxt) {
00001e  49ed              LDR      r1,|L5.980|
000020  6d20              LDR      r0,[r4,#0x50]
000022  6809              LDR      r1,[r1,#0]  ; ackno
000024  4288              CMP      r0,r1
000026  d111              BNE      |L5.76|
;;;588            acceptable = 1;
000028  f04f0801          MOV      r8,#1
00002c  e00e              B        |L5.76|
                  |L5.46|
;;;589          }
;;;590        } else {
;;;591          if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
00002e  49ea              LDR      r1,|L5.984|
000030  6aa0              LDR      r0,[r4,#0x28]
000032  6809              LDR      r1,[r1,#0]  ; seqno
000034  1a08              SUBS     r0,r1,r0
000036  d409              BMI      |L5.76|
000038  8da1              LDRH     r1,[r4,#0x2c]
00003a  6aa0              LDR      r0,[r4,#0x28]
00003c  4408              ADD      r0,r0,r1
00003e  49e6              LDR      r1,|L5.984|
000040  6809              LDR      r1,[r1,#0]  ; seqno
000042  1a08              SUBS     r0,r1,r0
000044  2800              CMP      r0,#0
000046  dc01              BGT      |L5.76|
;;;592                              pcb->rcv_nxt+pcb->rcv_wnd)) {
;;;593            acceptable = 1;
000048  f04f0801          MOV      r8,#1
                  |L5.76|
;;;594          }
;;;595        }
;;;596    
;;;597        if (acceptable) {
00004c  f1b80f00          CMP      r8,#0
000050  d01c              BEQ      |L5.140|
;;;598          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
000052  bf00              NOP      
000054  bf00              NOP      
;;;599          LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
000056  bf00              NOP      
000058  7e20              LDRB     r0,[r4,#0x18]
00005a  b940              CBNZ     r0,|L5.110|
00005c  bf00              NOP      
00005e  a3df              ADR      r3,|L5.988|
000060  f2402257          MOV      r2,#0x257
000064  a1e7              ADR      r1,|L5.1028|
000066  a0ef              ADR      r0,|L5.1060|
000068  f7fffffe          BL       __2printf
00006c  bf00              NOP      
                  |L5.110|
00006e  bf00              NOP      
;;;600          recv_flags |= TF_RESET;
000070  48f7              LDR      r0,|L5.1104|
000072  7800              LDRB     r0,[r0,#0]  ; recv_flags
000074  f0400008          ORR      r0,r0,#8
000078  49f5              LDR      r1,|L5.1104|
00007a  7008              STRB     r0,[r1,#0]
;;;601          pcb->flags &= ~TF_ACK_DELAY;
00007c  7fa0              LDRB     r0,[r4,#0x1e]
00007e  f0200001          BIC      r0,r0,#1
000082  77a0              STRB     r0,[r4,#0x1e]
;;;602          return ERR_RST;
000084  f06f000a          MVN      r0,#0xa
                  |L5.136|
;;;603        } else {
;;;604          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;605           seqno, pcb->rcv_nxt));
;;;606          LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;607           seqno, pcb->rcv_nxt));
;;;608          return ERR_OK;
;;;609        }
;;;610      }
;;;611    
;;;612      if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
;;;613        /* Cope with new connection attempt after remote end crashed */
;;;614        tcp_ack_now(pcb);
;;;615        return ERR_OK;
;;;616      }
;;;617      
;;;618      if ((pcb->flags & TF_RXCLOSED) == 0) {
;;;619        /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
;;;620        pcb->tmr = tcp_ticks;
;;;621      }
;;;622      pcb->keep_cnt_sent = 0;
;;;623    
;;;624      tcp_parseopt(pcb);
;;;625    
;;;626      /* Do different things depending on the TCP state. */
;;;627      switch (pcb->state) {
;;;628      case SYN_SENT:
;;;629        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
;;;630         pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
;;;631        /* received SYN ACK with expected sequence number? */
;;;632        if ((flags & TCP_ACK) && (flags & TCP_SYN)
;;;633            && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
;;;634          pcb->snd_buf++;
;;;635          pcb->rcv_nxt = seqno + 1;
;;;636          pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;637          pcb->lastack = ackno;
;;;638          pcb->snd_wnd = tcphdr->wnd;
;;;639          pcb->snd_wnd_max = tcphdr->wnd;
;;;640          pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
;;;641          pcb->state = ESTABLISHED;
;;;642    
;;;643    #if TCP_CALCULATE_EFF_SEND_MSS
;;;644          pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
;;;645    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;646    
;;;647          /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
;;;648           * but for the default value of pcb->mss) */
;;;649          pcb->ssthresh = pcb->mss * 10;
;;;650    
;;;651          pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
;;;652          LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
;;;653          --pcb->snd_queuelen;
;;;654          LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;655          rseg = pcb->unacked;
;;;656          pcb->unacked = rseg->next;
;;;657          tcp_seg_free(rseg);
;;;658    
;;;659          /* If there's nothing left to acknowledge, stop the retransmit
;;;660             timer, otherwise reset it to start again */
;;;661          if(pcb->unacked == NULL)
;;;662            pcb->rtime = -1;
;;;663          else {
;;;664            pcb->rtime = 0;
;;;665            pcb->nrtx = 0;
;;;666          }
;;;667    
;;;668          /* Call the user specified function to call when sucessfully
;;;669           * connected. */
;;;670          TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
;;;671          if (err == ERR_ABRT) {
;;;672            return ERR_ABRT;
;;;673          }
;;;674          tcp_ack_now(pcb);
;;;675        }
;;;676        /* received ACK? possibly a half-open connection */
;;;677        else if (flags & TCP_ACK) {
;;;678          /* send a RST to bring the other side in a non-synchronized state. */
;;;679          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;680            tcphdr->dest, tcphdr->src);
;;;681        }
;;;682        break;
;;;683      case SYN_RCVD:
;;;684        if (flags & TCP_ACK) {
;;;685          /* expected ACK number? */
;;;686          if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
;;;687            u16_t old_cwnd;
;;;688            pcb->state = ESTABLISHED;
;;;689            LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;690    #if LWIP_CALLBACK_API
;;;691            LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
;;;692    #endif
;;;693            /* Call the accept function. */
;;;694            TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
;;;695            if (err != ERR_OK) {
;;;696              /* If the accept function returns with an error, we abort
;;;697               * the connection. */
;;;698              /* Already aborted? */
;;;699              if (err != ERR_ABRT) {
;;;700                tcp_abort(pcb);
;;;701              }
;;;702              return ERR_ABRT;
;;;703            }
;;;704            old_cwnd = pcb->cwnd;
;;;705            /* If there was any data contained within this ACK,
;;;706             * we'd better pass it on to the application as well. */
;;;707            tcp_receive(pcb);
;;;708    
;;;709            /* Prevent ACK for SYN to generate a sent event */
;;;710            if (pcb->acked != 0) {
;;;711              pcb->acked--;
;;;712            }
;;;713    
;;;714            pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
;;;715    
;;;716            if (recv_flags & TF_GOT_FIN) {
;;;717              tcp_ack_now(pcb);
;;;718              pcb->state = CLOSE_WAIT;
;;;719            }
;;;720          } else {
;;;721            /* incorrect ACK number, send RST */
;;;722            tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;723                    tcphdr->dest, tcphdr->src);
;;;724          }
;;;725        } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
;;;726          /* Looks like another copy of the SYN - retransmit our SYN-ACK */
;;;727          tcp_rexmit(pcb);
;;;728        }
;;;729        break;
;;;730      case CLOSE_WAIT:
;;;731        /* FALLTHROUGH */
;;;732      case ESTABLISHED:
;;;733        tcp_receive(pcb);
;;;734        if (recv_flags & TF_GOT_FIN) { /* passive close */
;;;735          tcp_ack_now(pcb);
;;;736          pcb->state = CLOSE_WAIT;
;;;737        }
;;;738        break;
;;;739      case FIN_WAIT_1:
;;;740        tcp_receive(pcb);
;;;741        if (recv_flags & TF_GOT_FIN) {
;;;742          if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
;;;743            LWIP_DEBUGF(TCP_DEBUG,
;;;744              ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;745            tcp_ack_now(pcb);
;;;746            tcp_pcb_purge(pcb);
;;;747            TCP_RMV_ACTIVE(pcb);
;;;748            pcb->state = TIME_WAIT;
;;;749            TCP_REG(&tcp_tw_pcbs, pcb);
;;;750          } else {
;;;751            tcp_ack_now(pcb);
;;;752            pcb->state = CLOSING;
;;;753          }
;;;754        } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
;;;755          pcb->state = FIN_WAIT_2;
;;;756        }
;;;757        break;
;;;758      case FIN_WAIT_2:
;;;759        tcp_receive(pcb);
;;;760        if (recv_flags & TF_GOT_FIN) {
;;;761          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;762          tcp_ack_now(pcb);
;;;763          tcp_pcb_purge(pcb);
;;;764          TCP_RMV_ACTIVE(pcb);
;;;765          pcb->state = TIME_WAIT;
;;;766          TCP_REG(&tcp_tw_pcbs, pcb);
;;;767        }
;;;768        break;
;;;769      case CLOSING:
;;;770        tcp_receive(pcb);
;;;771        if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
;;;772          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;773          tcp_pcb_purge(pcb);
;;;774          TCP_RMV_ACTIVE(pcb);
;;;775          pcb->state = TIME_WAIT;
;;;776          TCP_REG(&tcp_tw_pcbs, pcb);
;;;777        }
;;;778        break;
;;;779      case LAST_ACK:
;;;780        tcp_receive(pcb);
;;;781        if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
;;;782          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;783          /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
;;;784          recv_flags |= TF_CLOSED;
;;;785        }
;;;786        break;
;;;787      default:
;;;788        break;
;;;789      }
;;;790      return ERR_OK;
;;;791    }
000088  e8bd81fc          POP      {r2-r8,pc}
                  |L5.140|
00008c  bf00              NOP                            ;604
00008e  bf00              NOP                            ;604
000090  bf00              NOP                            ;606
000092  bf00              NOP                            ;606
000094  2000              MOVS     r0,#0                 ;608
000096  e7f7              B        |L5.136|
                  |L5.152|
000098  48cd              LDR      r0,|L5.976|
00009a  7800              LDRB     r0,[r0,#0]            ;612  ; flags
00009c  f0000002          AND      r0,r0,#2              ;612
0000a0  b168              CBZ      r0,|L5.190|
0000a2  7e20              LDRB     r0,[r4,#0x18]         ;612
0000a4  2802              CMP      r0,#2                 ;612
0000a6  d00a              BEQ      |L5.190|
0000a8  7e20              LDRB     r0,[r4,#0x18]         ;612
0000aa  2803              CMP      r0,#3                 ;612
0000ac  d007              BEQ      |L5.190|
0000ae  bf00              NOP                            ;614
0000b0  7fa0              LDRB     r0,[r4,#0x1e]         ;614
0000b2  f0400002          ORR      r0,r0,#2              ;614
0000b6  77a0              STRB     r0,[r4,#0x1e]         ;614
0000b8  bf00              NOP                            ;614
0000ba  2000              MOVS     r0,#0                 ;615
0000bc  e7e4              B        |L5.136|
                  |L5.190|
0000be  7fa0              LDRB     r0,[r4,#0x1e]         ;618
0000c0  f0000010          AND      r0,r0,#0x10           ;618
0000c4  b910              CBNZ     r0,|L5.204|
0000c6  48e3              LDR      r0,|L5.1108|
0000c8  6800              LDR      r0,[r0,#0]            ;620  ; tcp_ticks
0000ca  6260              STR      r0,[r4,#0x24]         ;620
                  |L5.204|
0000cc  2000              MOVS     r0,#0                 ;622
0000ce  f8840096          STRB     r0,[r4,#0x96]         ;622
0000d2  4620              MOV      r0,r4                 ;624
0000d4  f7fffffe          BL       tcp_parseopt
0000d8  7e20              LDRB     r0,[r4,#0x18]         ;627
0000da  1e80              SUBS     r0,r0,#2              ;627
0000dc  2808              CMP      r0,#8                 ;627
0000de  d274              BCS      |L5.458|
0000e0  e8dff000          TBB      [pc,r0]               ;627
0000e4  04acfdfc          DCB      0x04,0xac,0xfd,0xfc
0000e8  fbfaf9f8          DCB      0xfb,0xfa,0xf9,0xf8
0000ec  bf00              NOP                            ;629
0000ee  bf00              NOP                            ;629
0000f0  48b7              LDR      r0,|L5.976|
0000f2  7800              LDRB     r0,[r0,#0]            ;632  ; flags
0000f4  f0000010          AND      r0,r0,#0x10           ;632
0000f8  2800              CMP      r0,#0                 ;632
                  |L5.250|
0000fa  d067              BEQ      |L5.460|
0000fc  48b4              LDR      r0,|L5.976|
0000fe  7800              LDRB     r0,[r0,#0]            ;632  ; flags
000100  f0000002          AND      r0,r0,#2              ;632
000104  2800              CMP      r0,#0                 ;632
000106  d0f8              BEQ      |L5.250|
000108  6f21              LDR      r1,[r4,#0x70]         ;633
00010a  6909              LDR      r1,[r1,#0x10]         ;633
00010c  6848              LDR      r0,[r1,#4]            ;633
00010e  f7fffffe          BL       lwip_ntohl
000112  1c40              ADDS     r0,r0,#1              ;633
000114  49af              LDR      r1,|L5.980|
000116  6809              LDR      r1,[r1,#0]            ;633  ; ackno
000118  4288              CMP      r0,r1                 ;633
00011a  d176              BNE      |L5.522|
00011c  3428              ADDS     r4,r4,#0x28           ;634
00011e  8fe0              LDRH     r0,[r4,#0x3e]         ;634
000120  1c40              ADDS     r0,r0,#1              ;634
000122  87e0              STRH     r0,[r4,#0x3e]         ;634
000124  48ac              LDR      r0,|L5.984|
000126  6800              LDR      r0,[r0,#0]            ;635  ; seqno
000128  1c40              ADDS     r0,r0,#1              ;635
00012a  6020              STR      r0,[r4,#0]            ;635
00012c  6820              LDR      r0,[r4,#0]            ;636
00012e  60a0              STR      r0,[r4,#8]            ;636
000130  48a8              LDR      r0,|L5.980|
000132  6800              LDR      r0,[r0,#0]            ;637  ; ackno
000134  6220              STR      r0,[r4,#0x20]         ;637
000136  48c8              LDR      r0,|L5.1112|
000138  6800              LDR      r0,[r0,#0]            ;638  ; tcphdr
00013a  89c0              LDRH     r0,[r0,#0xe]          ;638
00013c  8720              STRH     r0,[r4,#0x38]         ;638
00013e  48c6              LDR      r0,|L5.1112|
000140  6800              LDR      r0,[r0,#0]            ;639  ; tcphdr
000142  89c0              LDRH     r0,[r0,#0xe]          ;639
000144  8760              STRH     r0,[r4,#0x3a]         ;639
000146  48a4              LDR      r0,|L5.984|
000148  6800              LDR      r0,[r0,#0]            ;640  ; seqno
00014a  1e40              SUBS     r0,r0,#1              ;640
00014c  62e0              STR      r0,[r4,#0x2c]         ;640
00014e  2004              MOVS     r0,#4                 ;641
000150  f8040c10          STRB     r0,[r4,#-0x10]        ;641
000154  89e0              LDRH     r0,[r4,#0xe]          ;644
000156  3c28              SUBS     r4,r4,#0x28           ;644
000158  1d21              ADDS     r1,r4,#4              ;644
00015a  f7fffffe          BL       tcp_eff_send_mss
00015e  86e0              STRH     r0,[r4,#0x36]         ;644
000160  8ee0              LDRH     r0,[r4,#0x36]         ;649
000162  eb000080          ADD      r0,r0,r0,LSL #2       ;649
000166  f64f71ff          MOV      r1,#0xffff            ;649
00016a  ea010040          AND      r0,r1,r0,LSL #1       ;649
00016e  f8a4004e          STRH     r0,[r4,#0x4e]         ;649
000172  f8b4004c          LDRH     r0,[r4,#0x4c]         ;651
000176  2801              CMP      r0,#1                 ;651
000178  d102              BNE      |L5.384|
00017a  8ee0              LDRH     r0,[r4,#0x36]         ;651
00017c  0040              LSLS     r0,r0,#1              ;651
00017e  e000              B        |L5.386|
                  |L5.384|
000180  8ee0              LDRH     r0,[r4,#0x36]         ;651
                  |L5.386|
000182  f8a4004c          STRH     r0,[r4,#0x4c]         ;651
000186  bf00              NOP                            ;652
000188  f8b40068          LDRH     r0,[r4,#0x68]         ;652
00018c  2800              CMP      r0,#0                 ;652
00018e  dc08              BGT      |L5.418|
000190  bf00              NOP                            ;652
000192  a392              ADR      r3,|L5.988|
000194  f44f7223          MOV      r2,#0x28c             ;652
000198  a1b0              ADR      r1,|L5.1116|
00019a  a0a2              ADR      r0,|L5.1060|
00019c  f7fffffe          BL       __2printf
0001a0  bf00              NOP                            ;652
                  |L5.418|
0001a2  bf00              NOP                            ;652
0001a4  f8b40068          LDRH     r0,[r4,#0x68]         ;653
0001a8  1e40              SUBS     r0,r0,#1              ;653
0001aa  f8a40068          STRH     r0,[r4,#0x68]         ;653
0001ae  bf00              NOP                            ;654
0001b0  bf00              NOP                            ;654
0001b2  6f25              LDR      r5,[r4,#0x70]         ;655
0001b4  6828              LDR      r0,[r5,#0]            ;656
0001b6  6720              STR      r0,[r4,#0x70]         ;656
0001b8  4628              MOV      r0,r5                 ;657
0001ba  f7fffffe          BL       tcp_seg_free
0001be  6f20              LDR      r0,[r4,#0x70]         ;661
0001c0  b928              CBNZ     r0,|L5.462|
0001c2  f04f30ff          MOV      r0,#0xffffffff        ;662
0001c6  86a0              STRH     r0,[r4,#0x34]         ;662
0001c8  e005              B        |L5.470|
                  |L5.458|
0001ca  e252              B        |L5.1650|
                  |L5.460|
0001cc  e01d              B        |L5.522|
                  |L5.462|
0001ce  2000              MOVS     r0,#0                 ;664
0001d0  86a0              STRH     r0,[r4,#0x34]         ;664
0001d2  f8840046          STRB     r0,[r4,#0x46]         ;665
                  |L5.470|
0001d6  bf00              NOP                            ;670
0001d8  f8d40084          LDR      r0,[r4,#0x84]         ;670
0001dc  b138              CBZ      r0,|L5.494|
0001de  2200              MOVS     r2,#0                 ;670
0001e0  4621              MOV      r1,r4                 ;670
0001e2  f8d43084          LDR      r3,[r4,#0x84]         ;670
0001e6  6920              LDR      r0,[r4,#0x10]         ;670
0001e8  4798              BLX      r3                    ;670
0001ea  4606              MOV      r6,r0                 ;670
0001ec  e000              B        |L5.496|
                  |L5.494|
0001ee  2600              MOVS     r6,#0                 ;670
                  |L5.496|
0001f0  bf00              NOP                            ;670
0001f2  f106000a          ADD      r0,r6,#0xa            ;671
0001f6  b910              CBNZ     r0,|L5.510|
0001f8  f06f0009          MVN      r0,#9                 ;672
0001fc  e744              B        |L5.136|
                  |L5.510|
0001fe  bf00              NOP                            ;674
000200  7fa0              LDRB     r0,[r4,#0x1e]         ;674
000202  f0400002          ORR      r0,r0,#2              ;674
000206  77a0              STRB     r0,[r4,#0x1e]         ;674
000208  e017              B        |L5.570|
                  |L5.522|
00020a  4871              LDR      r0,|L5.976|
00020c  7800              LDRB     r0,[r0,#0]            ;677  ; flags
00020e  f0000010          AND      r0,r0,#0x10           ;677
000212  b190              CBZ      r0,|L5.570|
000214  4890              LDR      r0,|L5.1112|
000216  6800              LDR      r0,[r0,#0]            ;679  ; tcphdr
000218  8800              LDRH     r0,[r0,#0]            ;679
00021a  498f              LDR      r1,|L5.1112|
00021c  6809              LDR      r1,[r1,#0]            ;679  ; tcphdr
00021e  8849              LDRH     r1,[r1,#2]            ;679
000220  e9cd1000          STRD     r1,r0,[sp,#0]         ;679
000224  486c              LDR      r0,|L5.984|
000226  6800              LDR      r0,[r0,#0]            ;679  ; seqno
000228  4a92              LDR      r2,|L5.1140|
00022a  8812              LDRH     r2,[r2,#0]            ;679  ; tcplen
00022c  1881              ADDS     r1,r0,r2              ;679
00022e  4b92              LDR      r3,|L5.1144|
000230  4a92              LDR      r2,|L5.1148|
000232  4868              LDR      r0,|L5.980|
000234  6800              LDR      r0,[r0,#0]            ;679  ; ackno
000236  f7fffffe          BL       tcp_rst
                  |L5.570|
00023a  e21b              B        |L5.1652|
00023c  4864              LDR      r0,|L5.976|
00023e  7800              LDRB     r0,[r0,#0]            ;684  ; flags
000240  f0000010          AND      r0,r0,#0x10           ;684
000244  2800              CMP      r0,#0                 ;684
000246  d071              BEQ      |L5.812|
000248  6ca0              LDR      r0,[r4,#0x48]         ;686
00024a  1c40              ADDS     r0,r0,#1              ;686
00024c  4961              LDR      r1,|L5.980|
00024e  6809              LDR      r1,[r1,#0]            ;686  ; ackno
000250  1a08              SUBS     r0,r1,r0              ;686
000252  d456              BMI      |L5.770|
000254  495f              LDR      r1,|L5.980|
000256  6d20              LDR      r0,[r4,#0x50]         ;686
000258  6809              LDR      r1,[r1,#0]            ;686  ; ackno
00025a  1a08              SUBS     r0,r1,r0              ;686
00025c  2800              CMP      r0,#0                 ;686
00025e  dc50              BGT      |L5.770|
000260  2004              MOVS     r0,#4                 ;688
000262  7620              STRB     r0,[r4,#0x18]         ;688
000264  bf00              NOP                            ;689
000266  bf00              NOP                            ;689
000268  bf00              NOP                            ;691
00026a  6960              LDR      r0,[r4,#0x14]         ;691
00026c  b940              CBNZ     r0,|L5.640|
00026e  bf00              NOP                            ;691
000270  a35a              ADR      r3,|L5.988|
000272  f24022b3          MOV      r2,#0x2b3             ;691
000276  a182              ADR      r1,|L5.1152|
000278  a06a              ADR      r0,|L5.1060|
00027a  f7fffffe          BL       __2printf
00027e  bf00              NOP                            ;691
                  |L5.640|
000280  bf00              NOP                            ;691
000282  bf00              NOP                            ;694
000284  6960              LDR      r0,[r4,#0x14]         ;694
000286  b130              CBZ      r0,|L5.662|
000288  2200              MOVS     r2,#0                 ;694
00028a  4621              MOV      r1,r4                 ;694
00028c  e9d40304          LDRD     r0,r3,[r4,#0x10]      ;694
000290  4798              BLX      r3                    ;694
000292  4606              MOV      r6,r0                 ;694
000294  e001              B        |L5.666|
                  |L5.662|
000296  f06f060d          MVN      r6,#0xd               ;694
                  |L5.666|
00029a  bf00              NOP                            ;694
00029c  b146              CBZ      r6,|L5.688|
00029e  f106000a          ADD      r0,r6,#0xa            ;699
0002a2  b110              CBZ      r0,|L5.682|
0002a4  4620              MOV      r0,r4                 ;700
0002a6  f7fffffe          BL       tcp_abort
                  |L5.682|
0002aa  f06f0009          MVN      r0,#9                 ;702
0002ae  e6eb              B        |L5.136|
                  |L5.688|
0002b0  f8b4704c          LDRH     r7,[r4,#0x4c]         ;704
0002b4  4620              MOV      r0,r4                 ;707
0002b6  f7fffffe          BL       tcp_receive
0002ba  f8b40064          LDRH     r0,[r4,#0x64]         ;710
0002be  b120              CBZ      r0,|L5.714|
0002c0  f8b40064          LDRH     r0,[r4,#0x64]         ;711
0002c4  1e40              SUBS     r0,r0,#1              ;711
0002c6  f8a40064          STRH     r0,[r4,#0x64]         ;711
                  |L5.714|
0002ca  2f01              CMP      r7,#1                 ;714
0002cc  d108              BNE      |L5.736|
0002ce  8ee0              LDRH     r0,[r4,#0x36]         ;714
0002d0  0040              LSLS     r0,r0,#1              ;714
0002d2  e006              B        |L5.738|
0002d4  e1b7              B        |L5.1606|
0002d6  e16a              B        |L5.1454|
0002d8  e037              B        |L5.842|
0002da  e11b              B        |L5.1300|
0002dc  e047              B        |L5.878|
0002de  e035              B        |L5.844|
                  |L5.736|
0002e0  8ee0              LDRH     r0,[r4,#0x36]         ;714
                  |L5.738|
0002e2  f8a4004c          STRH     r0,[r4,#0x4c]         ;714
0002e6  485a              LDR      r0,|L5.1104|
0002e8  7800              LDRB     r0,[r0,#0]            ;716  ; recv_flags
0002ea  f0000020          AND      r0,r0,#0x20           ;716
0002ee  b138              CBZ      r0,|L5.768|
0002f0  bf00              NOP                            ;717
0002f2  7fa0              LDRB     r0,[r4,#0x1e]         ;717
0002f4  f0400002          ORR      r0,r0,#2              ;717
0002f8  77a0              STRB     r0,[r4,#0x1e]         ;717
0002fa  bf00              NOP                            ;717
0002fc  2007              MOVS     r0,#7                 ;718
0002fe  7620              STRB     r0,[r4,#0x18]         ;718
                  |L5.768|
000300  e022              B        |L5.840|
                  |L5.770|
000302  4855              LDR      r0,|L5.1112|
000304  6800              LDR      r0,[r0,#0]            ;722  ; tcphdr
000306  8800              LDRH     r0,[r0,#0]            ;722
000308  4953              LDR      r1,|L5.1112|
00030a  6809              LDR      r1,[r1,#0]            ;722  ; tcphdr
00030c  8849              LDRH     r1,[r1,#2]            ;722
00030e  e9cd1000          STRD     r1,r0,[sp,#0]         ;722
000312  4831              LDR      r0,|L5.984|
000314  6800              LDR      r0,[r0,#0]            ;722  ; seqno
000316  4a57              LDR      r2,|L5.1140|
000318  8812              LDRH     r2,[r2,#0]            ;722  ; tcplen
00031a  1881              ADDS     r1,r0,r2              ;722
00031c  4b56              LDR      r3,|L5.1144|
00031e  4a57              LDR      r2,|L5.1148|
000320  482c              LDR      r0,|L5.980|
000322  6800              LDR      r0,[r0,#0]            ;722  ; ackno
000324  f7fffffe          BL       tcp_rst
000328  e00e              B        |L5.840|
00032a  e7ff              B        |L5.812|
                  |L5.812|
00032c  4828              LDR      r0,|L5.976|
00032e  7800              LDRB     r0,[r0,#0]            ;725  ; flags
000330  f0000002          AND      r0,r0,#2              ;725
000334  b140              CBZ      r0,|L5.840|
000336  6aa0              LDR      r0,[r4,#0x28]         ;725
000338  1e40              SUBS     r0,r0,#1              ;725
00033a  4927              LDR      r1,|L5.984|
00033c  6809              LDR      r1,[r1,#0]            ;725  ; seqno
00033e  4288              CMP      r0,r1                 ;725
000340  d102              BNE      |L5.840|
000342  4620              MOV      r0,r4                 ;727
000344  f7fffffe          BL       tcp_rexmit
                  |L5.840|
000348  e194              B        |L5.1652|
                  |L5.842|
00034a  bf00              NOP                            ;732
                  |L5.844|
00034c  4620              MOV      r0,r4                 ;733
00034e  f7fffffe          BL       tcp_receive
000352  483f              LDR      r0,|L5.1104|
000354  7800              LDRB     r0,[r0,#0]            ;734  ; recv_flags
000356  f0000020          AND      r0,r0,#0x20           ;734
00035a  b138              CBZ      r0,|L5.876|
00035c  bf00              NOP                            ;735
00035e  7fa0              LDRB     r0,[r4,#0x1e]         ;735
000360  f0400002          ORR      r0,r0,#2              ;735
000364  77a0              STRB     r0,[r4,#0x1e]         ;735
000366  bf00              NOP                            ;735
000368  2007              MOVS     r0,#7                 ;736
00036a  7620              STRB     r0,[r4,#0x18]         ;736
                  |L5.876|
00036c  e182              B        |L5.1652|
                  |L5.878|
00036e  4620              MOV      r0,r4                 ;740
000370  f7fffffe          BL       tcp_receive
000374  4836              LDR      r0,|L5.1104|
000376  7800              LDRB     r0,[r0,#0]            ;741  ; recv_flags
000378  f0000020          AND      r0,r0,#0x20           ;741
00037c  b328              CBZ      r0,|L5.970|
00037e  4814              LDR      r0,|L5.976|
000380  7800              LDRB     r0,[r0,#0]            ;742  ; flags
000382  f0000010          AND      r0,r0,#0x10           ;742
000386  b308              CBZ      r0,|L5.972|
000388  4912              LDR      r1,|L5.980|
00038a  6d20              LDR      r0,[r4,#0x50]         ;742
00038c  6809              LDR      r1,[r1,#0]            ;742  ; ackno
00038e  4288              CMP      r0,r1                 ;742
000390  d11c              BNE      |L5.972|
000392  bf00              NOP                            ;743
000394  bf00              NOP                            ;743
000396  bf00              NOP                            ;745
000398  7fa0              LDRB     r0,[r4,#0x1e]         ;745
00039a  f0400002          ORR      r0,r0,#2              ;745
00039e  77a0              STRB     r0,[r4,#0x1e]         ;745
0003a0  bf00              NOP                            ;745
0003a2  4620              MOV      r0,r4                 ;746
0003a4  f7fffffe          BL       tcp_pcb_purge
0003a8  bf00              NOP                            ;747
0003aa  bf00              NOP                            ;747
0003ac  4839              LDR      r0,|L5.1172|
0003ae  6800              LDR      r0,[r0,#0]            ;747  ; tcp_active_pcbs
0003b0  42a0              CMP      r0,r4                 ;747
0003b2  d105              BNE      |L5.960|
0003b4  4837              LDR      r0,|L5.1172|
0003b6  6800              LDR      r0,[r0,#0]            ;747  ; tcp_active_pcbs
0003b8  68c0              LDR      r0,[r0,#0xc]          ;747
0003ba  4936              LDR      r1,|L5.1172|
0003bc  6008              STR      r0,[r1,#0]            ;747  ; tcp_active_pcbs
0003be  e081              B        |L5.1220|
                  |L5.960|
0003c0  4834              LDR      r0,|L5.1172|
0003c2  6800              LDR      r0,[r0,#0]            ;747  ; tcp_active_pcbs
0003c4  4934              LDR      r1,|L5.1176|
0003c6  6008              STR      r0,[r1,#0]            ;747  ; tcp_tmp_pcb
0003c8  e077              B        |L5.1210|
                  |L5.970|
0003ca  e096              B        |L5.1274|
                  |L5.972|
0003cc  e08c              B        |L5.1256|
0003ce  0000              DCW      0x0000
                  |L5.976|
                          DCD      flags
                  |L5.980|
                          DCD      ackno
                  |L5.984|
                          DCD      seqno
                  |L5.988|
0003dc  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp_in.c",0
0003e0  5749505c
0003e4  6c776970
0003e8  2d312e34
0003ec  2e315c73
0003f0  72635c63
0003f4  6f72655c
0003f8  7463705f
0003fc  696e2e63
000400  00      
000401  00                DCB      0
000402  00                DCB      0
000403  00                DCB      0
                  |L5.1028|
000404  7463705f          DCB      "tcp_input: pcb->state != CLOSED",0
000408  696e7075
00040c  743a2070
000410  63622d3e
000414  73746174
000418  6520213d
00041c  20434c4f
000420  53454400
                  |L5.1060|
000424  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000428  7274696f
00042c  6e202225
000430  73222066
000434  61696c65
000438  64206174
00043c  206c696e
000440  65202564
000444  20696e20
000448  25730d0a
00044c  00      
00044d  00                DCB      0
00044e  00                DCB      0
00044f  00                DCB      0
                  |L5.1104|
                          DCD      recv_flags
                  |L5.1108|
                          DCD      tcp_ticks
                  |L5.1112|
                          DCD      tcphdr
                  |L5.1116|
00045c  7063622d          DCB      "pcb->snd_queuelen > 0",0
000460  3e736e64
000464  5f717565
000468  75656c65
00046c  6e203e20
000470  3000    
000472  00                DCB      0
000473  00                DCB      0
                  |L5.1140|
                          DCD      tcplen
                  |L5.1144|
                          DCD      current_iphdr_src
                  |L5.1148|
                          DCD      current_iphdr_dest
                  |L5.1152|
000480  7063622d          DCB      "pcb->accept != NULL",0
000484  3e616363
000488  65707420
00048c  213d204e
000490  554c4c00
                  |L5.1172|
                          DCD      tcp_active_pcbs
                  |L5.1176|
                          DCD      tcp_tmp_pcb
                  |L5.1180|
00049c  4877              LDR      r0,|L5.1660|
00049e  6800              LDR      r0,[r0,#0]            ;747  ; tcp_tmp_pcb
0004a0  68c0              LDR      r0,[r0,#0xc]          ;747
0004a2  42a0              CMP      r0,r4                 ;747
0004a4  d104              BNE      |L5.1200|
0004a6  4975              LDR      r1,|L5.1660|
0004a8  68e0              LDR      r0,[r4,#0xc]          ;747
0004aa  6809              LDR      r1,[r1,#0]            ;747  ; tcp_tmp_pcb
0004ac  60c8              STR      r0,[r1,#0xc]          ;747
0004ae  e008              B        |L5.1218|
                  |L5.1200|
0004b0  4872              LDR      r0,|L5.1660|
0004b2  6800              LDR      r0,[r0,#0]            ;747  ; tcp_tmp_pcb
0004b4  68c0              LDR      r0,[r0,#0xc]          ;747
0004b6  4971              LDR      r1,|L5.1660|
0004b8  6008              STR      r0,[r1,#0]            ;747  ; tcp_tmp_pcb
                  |L5.1210|
0004ba  4870              LDR      r0,|L5.1660|
0004bc  6800              LDR      r0,[r0,#0]            ;747  ; tcp_tmp_pcb
0004be  2800              CMP      r0,#0                 ;747
0004c0  d1ec              BNE      |L5.1180|
                  |L5.1218|
0004c2  bf00              NOP                            ;747
                  |L5.1220|
0004c4  2000              MOVS     r0,#0                 ;747
0004c6  60e0              STR      r0,[r4,#0xc]          ;747
0004c8  bf00              NOP                            ;747
0004ca  2001              MOVS     r0,#1                 ;747
0004cc  496c              LDR      r1,|L5.1664|
0004ce  7008              STRB     r0,[r1,#0]            ;747
0004d0  bf00              NOP                            ;747
0004d2  200a              MOVS     r0,#0xa               ;748
0004d4  7620              STRB     r0,[r4,#0x18]         ;748
0004d6  bf00              NOP                            ;749
0004d8  486a              LDR      r0,|L5.1668|
0004da  6800              LDR      r0,[r0,#0]            ;749  ; tcp_tw_pcbs
0004dc  60e0              STR      r0,[r4,#0xc]          ;749
0004de  4869              LDR      r0,|L5.1668|
0004e0  6004              STR      r4,[r0,#0]            ;749  ; tcp_tw_pcbs
0004e2  f7fffffe          BL       tcp_timer_needed
0004e6  e014              B        |L5.1298|
                  |L5.1256|
0004e8  bf00              NOP                            ;751
0004ea  7fa0              LDRB     r0,[r4,#0x1e]         ;751
0004ec  f0400002          ORR      r0,r0,#2              ;751
0004f0  77a0              STRB     r0,[r4,#0x1e]         ;751
0004f2  bf00              NOP                            ;751
0004f4  2008              MOVS     r0,#8                 ;752
0004f6  7620              STRB     r0,[r4,#0x18]         ;752
0004f8  e00b              B        |L5.1298|
                  |L5.1274|
0004fa  4863              LDR      r0,|L5.1672|
0004fc  7800              LDRB     r0,[r0,#0]            ;754  ; flags
0004fe  f0000010          AND      r0,r0,#0x10           ;754
000502  b130              CBZ      r0,|L5.1298|
000504  4961              LDR      r1,|L5.1676|
000506  6d20              LDR      r0,[r4,#0x50]         ;754
000508  6809              LDR      r1,[r1,#0]            ;754  ; ackno
00050a  4288              CMP      r0,r1                 ;754
00050c  d101              BNE      |L5.1298|
00050e  2006              MOVS     r0,#6                 ;755
000510  7620              STRB     r0,[r4,#0x18]         ;755
                  |L5.1298|
000512  e0af              B        |L5.1652|
                  |L5.1300|
000514  4620              MOV      r0,r4                 ;759
000516  f7fffffe          BL       tcp_receive
00051a  485d              LDR      r0,|L5.1680|
00051c  7800              LDRB     r0,[r0,#0]            ;760  ; recv_flags
00051e  f0000020          AND      r0,r0,#0x20           ;760
000522  b3e8              CBZ      r0,|L5.1440|
000524  bf00              NOP                            ;761
000526  bf00              NOP                            ;761
000528  bf00              NOP                            ;762
00052a  7fa0              LDRB     r0,[r4,#0x1e]         ;762
00052c  f0400002          ORR      r0,r0,#2              ;762
000530  77a0              STRB     r0,[r4,#0x1e]         ;762
000532  bf00              NOP                            ;762
000534  4620              MOV      r0,r4                 ;763
000536  f7fffffe          BL       tcp_pcb_purge
00053a  bf00              NOP                            ;764
00053c  bf00              NOP                            ;764
00053e  4855              LDR      r0,|L5.1684|
000540  6800              LDR      r0,[r0,#0]            ;764  ; tcp_active_pcbs
000542  42a0              CMP      r0,r4                 ;764
000544  d105              BNE      |L5.1362|
000546  4853              LDR      r0,|L5.1684|
000548  6800              LDR      r0,[r0,#0]            ;764  ; tcp_active_pcbs
00054a  68c0              LDR      r0,[r0,#0xc]          ;764
00054c  4951              LDR      r1,|L5.1684|
00054e  6008              STR      r0,[r1,#0]            ;764  ; tcp_active_pcbs
000550  e018              B        |L5.1412|
                  |L5.1362|
000552  4850              LDR      r0,|L5.1684|
000554  6800              LDR      r0,[r0,#0]            ;764  ; tcp_active_pcbs
000556  4949              LDR      r1,|L5.1660|
000558  6008              STR      r0,[r1,#0]            ;764  ; tcp_tmp_pcb
00055a  e00e              B        |L5.1402|
                  |L5.1372|
00055c  4847              LDR      r0,|L5.1660|
00055e  6800              LDR      r0,[r0,#0]            ;764  ; tcp_tmp_pcb
000560  68c0              LDR      r0,[r0,#0xc]          ;764
000562  42a0              CMP      r0,r4                 ;764
000564  d104              BNE      |L5.1392|
000566  4945              LDR      r1,|L5.1660|
000568  68e0              LDR      r0,[r4,#0xc]          ;764
00056a  6809              LDR      r1,[r1,#0]            ;764  ; tcp_tmp_pcb
00056c  60c8              STR      r0,[r1,#0xc]          ;764
00056e  e008              B        |L5.1410|
                  |L5.1392|
000570  4842              LDR      r0,|L5.1660|
000572  6800              LDR      r0,[r0,#0]            ;764  ; tcp_tmp_pcb
000574  68c0              LDR      r0,[r0,#0xc]          ;764
000576  4941              LDR      r1,|L5.1660|
000578  6008              STR      r0,[r1,#0]            ;764  ; tcp_tmp_pcb
                  |L5.1402|
00057a  4840              LDR      r0,|L5.1660|
00057c  6800              LDR      r0,[r0,#0]            ;764  ; tcp_tmp_pcb
00057e  2800              CMP      r0,#0                 ;764
000580  d1ec              BNE      |L5.1372|
                  |L5.1410|
000582  bf00              NOP                            ;764
                  |L5.1412|
000584  2000              MOVS     r0,#0                 ;764
000586  60e0              STR      r0,[r4,#0xc]          ;764
000588  bf00              NOP                            ;764
00058a  2001              MOVS     r0,#1                 ;764
00058c  493c              LDR      r1,|L5.1664|
00058e  7008              STRB     r0,[r1,#0]            ;764
000590  bf00              NOP                            ;764
000592  200a              MOVS     r0,#0xa               ;765
000594  7620              STRB     r0,[r4,#0x18]         ;765
000596  bf00              NOP                            ;766
000598  483a              LDR      r0,|L5.1668|
00059a  6800              LDR      r0,[r0,#0]            ;766  ; tcp_tw_pcbs
00059c  60e0              STR      r0,[r4,#0xc]          ;766
00059e  e000              B        |L5.1442|
                  |L5.1440|
0005a0  e004              B        |L5.1452|
                  |L5.1442|
0005a2  4838              LDR      r0,|L5.1668|
0005a4  6004              STR      r4,[r0,#0]            ;766  ; tcp_tw_pcbs
0005a6  f7fffffe          BL       tcp_timer_needed
0005aa  bf00              NOP                            ;766
                  |L5.1452|
0005ac  e062              B        |L5.1652|
                  |L5.1454|
0005ae  4620              MOV      r0,r4                 ;770
0005b0  f7fffffe          BL       tcp_receive
0005b4  4834              LDR      r0,|L5.1672|
0005b6  7800              LDRB     r0,[r0,#0]            ;771  ; flags
0005b8  f0000010          AND      r0,r0,#0x10           ;771
0005bc  b3f0              CBZ      r0,|L5.1596|
0005be  4933              LDR      r1,|L5.1676|
0005c0  6d20              LDR      r0,[r4,#0x50]         ;771
0005c2  6809              LDR      r1,[r1,#0]            ;771  ; ackno
0005c4  4288              CMP      r0,r1                 ;771
0005c6  d13d              BNE      |L5.1604|
0005c8  bf00              NOP                            ;772
0005ca  bf00              NOP                            ;772
0005cc  4620              MOV      r0,r4                 ;773
0005ce  f7fffffe          BL       tcp_pcb_purge
0005d2  bf00              NOP                            ;774
0005d4  bf00              NOP                            ;774
0005d6  482f              LDR      r0,|L5.1684|
0005d8  6800              LDR      r0,[r0,#0]            ;774  ; tcp_active_pcbs
0005da  42a0              CMP      r0,r4                 ;774
0005dc  d105              BNE      |L5.1514|
0005de  482d              LDR      r0,|L5.1684|
0005e0  6800              LDR      r0,[r0,#0]            ;774  ; tcp_active_pcbs
0005e2  68c0              LDR      r0,[r0,#0xc]          ;774
0005e4  492b              LDR      r1,|L5.1684|
0005e6  6008              STR      r0,[r1,#0]            ;774  ; tcp_active_pcbs
0005e8  e018              B        |L5.1564|
                  |L5.1514|
0005ea  482a              LDR      r0,|L5.1684|
0005ec  6800              LDR      r0,[r0,#0]            ;774  ; tcp_active_pcbs
0005ee  4923              LDR      r1,|L5.1660|
0005f0  6008              STR      r0,[r1,#0]            ;774  ; tcp_tmp_pcb
0005f2  e00e              B        |L5.1554|
                  |L5.1524|
0005f4  4821              LDR      r0,|L5.1660|
0005f6  6800              LDR      r0,[r0,#0]            ;774  ; tcp_tmp_pcb
0005f8  68c0              LDR      r0,[r0,#0xc]          ;774
0005fa  42a0              CMP      r0,r4                 ;774
0005fc  d104              BNE      |L5.1544|
0005fe  491f              LDR      r1,|L5.1660|
000600  68e0              LDR      r0,[r4,#0xc]          ;774
000602  6809              LDR      r1,[r1,#0]            ;774  ; tcp_tmp_pcb
000604  60c8              STR      r0,[r1,#0xc]          ;774
000606  e008              B        |L5.1562|
                  |L5.1544|
000608  481c              LDR      r0,|L5.1660|
00060a  6800              LDR      r0,[r0,#0]            ;774  ; tcp_tmp_pcb
00060c  68c0              LDR      r0,[r0,#0xc]          ;774
00060e  491b              LDR      r1,|L5.1660|
000610  6008              STR      r0,[r1,#0]            ;774  ; tcp_tmp_pcb
                  |L5.1554|
000612  481a              LDR      r0,|L5.1660|
000614  6800              LDR      r0,[r0,#0]            ;774  ; tcp_tmp_pcb
000616  2800              CMP      r0,#0                 ;774
000618  d1ec              BNE      |L5.1524|
                  |L5.1562|
00061a  bf00              NOP                            ;774
                  |L5.1564|
00061c  2000              MOVS     r0,#0                 ;774
00061e  60e0              STR      r0,[r4,#0xc]          ;774
000620  bf00              NOP                            ;774
000622  2001              MOVS     r0,#1                 ;774
000624  4916              LDR      r1,|L5.1664|
000626  7008              STRB     r0,[r1,#0]            ;774
000628  bf00              NOP                            ;774
00062a  200a              MOVS     r0,#0xa               ;775
00062c  7620              STRB     r0,[r4,#0x18]         ;775
00062e  bf00              NOP                            ;776
000630  4814              LDR      r0,|L5.1668|
000632  6800              LDR      r0,[r0,#0]            ;776  ; tcp_tw_pcbs
000634  60e0              STR      r0,[r4,#0xc]          ;776
000636  4813              LDR      r0,|L5.1668|
000638  6004              STR      r4,[r0,#0]            ;776  ; tcp_tw_pcbs
00063a  e000              B        |L5.1598|
                  |L5.1596|
00063c  e002              B        |L5.1604|
                  |L5.1598|
00063e  f7fffffe          BL       tcp_timer_needed
000642  bf00              NOP                            ;776
                  |L5.1604|
000644  e016              B        |L5.1652|
                  |L5.1606|
000646  4620              MOV      r0,r4                 ;780
000648  f7fffffe          BL       tcp_receive
00064c  480e              LDR      r0,|L5.1672|
00064e  7800              LDRB     r0,[r0,#0]            ;781  ; flags
000650  f0000010          AND      r0,r0,#0x10           ;781
000654  b160              CBZ      r0,|L5.1648|
000656  490d              LDR      r1,|L5.1676|
000658  6d20              LDR      r0,[r4,#0x50]         ;781
00065a  6809              LDR      r1,[r1,#0]            ;781  ; ackno
00065c  4288              CMP      r0,r1                 ;781
00065e  d107              BNE      |L5.1648|
000660  bf00              NOP                            ;782
000662  bf00              NOP                            ;782
000664  480a              LDR      r0,|L5.1680|
000666  7800              LDRB     r0,[r0,#0]            ;784  ; recv_flags
000668  f0400010          ORR      r0,r0,#0x10           ;784
00066c  4908              LDR      r1,|L5.1680|
00066e  7008              STRB     r0,[r1,#0]            ;784
                  |L5.1648|
000670  e000              B        |L5.1652|
                  |L5.1650|
000672  bf00              NOP                            ;788
                  |L5.1652|
000674  bf00              NOP                            ;682
000676  2000              MOVS     r0,#0                 ;790
000678  e506              B        |L5.136|
;;;792    
                          ENDP

00067a  0000              DCW      0x0000
                  |L5.1660|
                          DCD      tcp_tmp_pcb
                  |L5.1664|
                          DCD      tcp_active_pcbs_changed
                  |L5.1668|
                          DCD      tcp_tw_pcbs
                  |L5.1672|
                          DCD      flags
                  |L5.1676|
                          DCD      ackno
                  |L5.1680|
                          DCD      recv_flags
                  |L5.1684|
                          DCD      tcp_active_pcbs

                          AREA ||i.tcp_receive||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_receive PROC
;;;846    static void
;;;847    tcp_receive(struct tcp_pcb *pcb)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;848    {
000004  4604              MOV      r4,r0
;;;849      struct tcp_seg *next;
;;;850    #if TCP_QUEUE_OOSEQ
;;;851      struct tcp_seg *prev, *cseg;
;;;852    #endif /* TCP_QUEUE_OOSEQ */
;;;853      struct pbuf *p;
;;;854      s32_t off;
;;;855      s16_t m;
;;;856      u32_t right_wnd_edge;
;;;857      u16_t new_tot_len;
;;;858      int found_dupack = 0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;859    #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
;;;860      u32_t ooseq_blen;
;;;861      u16_t ooseq_qlen;
;;;862    #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
;;;863    
;;;864      LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
00000a  bf00              NOP      
00000c  7e20              LDRB     r0,[r4,#0x18]
00000e  2804              CMP      r0,#4
000010  da08              BGE      |L6.36|
000012  bf00              NOP      
000014  a3e6              ADR      r3,|L6.944|
000016  f44f7258          MOV      r2,#0x360
00001a  a1ef              ADR      r1,|L6.984|
00001c  a0f5              ADR      r0,|L6.1012|
00001e  f7fffffe          BL       __2printf
000022  bf00              NOP      
                  |L6.36|
000024  bf00              NOP      
;;;865    
;;;866      if (flags & TCP_ACK) {
000026  48fe              LDR      r0,|L6.1056|
000028  7800              LDRB     r0,[r0,#0]  ; flags
00002a  f0000010          AND      r0,r0,#0x10
00002e  2800              CMP      r0,#0
000030  d07e              BEQ      |L6.304|
;;;867        right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
000032  f8b40060          LDRH     r0,[r4,#0x60]
000036  6da1              LDR      r1,[r4,#0x58]
000038  4408              ADD      r0,r0,r1
00003a  9002              STR      r0,[sp,#8]
;;;868    
;;;869        /* Update window. */
;;;870        if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
00003c  49f9              LDR      r1,|L6.1060|
00003e  6d60              LDR      r0,[r4,#0x54]
000040  6809              LDR      r1,[r1,#0]  ; seqno
000042  1a40              SUBS     r0,r0,r1
000044  d415              BMI      |L6.114|
;;;871           (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
000046  49f7              LDR      r1,|L6.1060|
000048  6d60              LDR      r0,[r4,#0x54]
00004a  6809              LDR      r1,[r1,#0]  ; seqno
00004c  4288              CMP      r0,r1
00004e  d104              BNE      |L6.90|
000050  49f5              LDR      r1,|L6.1064|
000052  6da0              LDR      r0,[r4,#0x58]
000054  6809              LDR      r1,[r1,#0]  ; ackno
000056  1a40              SUBS     r0,r0,r1
000058  d40b              BMI      |L6.114|
                  |L6.90|
;;;872           (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
00005a  49f3              LDR      r1,|L6.1064|
00005c  6da0              LDR      r0,[r4,#0x58]
00005e  6809              LDR      r1,[r1,#0]  ; ackno
000060  4288              CMP      r0,r1
000062  d133              BNE      |L6.204|
000064  48f1              LDR      r0,|L6.1068|
000066  6800              LDR      r0,[r0,#0]  ; tcphdr
000068  89c0              LDRH     r0,[r0,#0xe]
00006a  f8b41060          LDRH     r1,[r4,#0x60]
00006e  4288              CMP      r0,r1
000070  dd2c              BLE      |L6.204|
                  |L6.114|
;;;873          pcb->snd_wnd = tcphdr->wnd;
000072  48ee              LDR      r0,|L6.1068|
000074  6800              LDR      r0,[r0,#0]  ; tcphdr
000076  89c0              LDRH     r0,[r0,#0xe]
000078  f8a40060          STRH     r0,[r4,#0x60]
;;;874          /* keep track of the biggest window announced by the remote host to calculate
;;;875             the maximum segment size */
;;;876          if (pcb->snd_wnd_max < tcphdr->wnd) {
00007c  f8b40062          LDRH     r0,[r4,#0x62]
000080  49ea              LDR      r1,|L6.1068|
000082  6809              LDR      r1,[r1,#0]  ; tcphdr
000084  89c9              LDRH     r1,[r1,#0xe]
000086  4288              CMP      r0,r1
000088  da04              BGE      |L6.148|
;;;877            pcb->snd_wnd_max = tcphdr->wnd;
00008a  48e8              LDR      r0,|L6.1068|
00008c  6800              LDR      r0,[r0,#0]  ; tcphdr
00008e  89c0              LDRH     r0,[r0,#0xe]
000090  f8a40062          STRH     r0,[r4,#0x62]
                  |L6.148|
;;;878          }
;;;879          pcb->snd_wl1 = seqno;
000094  48e3              LDR      r0,|L6.1060|
000096  6800              LDR      r0,[r0,#0]  ; seqno
000098  6560              STR      r0,[r4,#0x54]
;;;880          pcb->snd_wl2 = ackno;
00009a  48e3              LDR      r0,|L6.1064|
00009c  6800              LDR      r0,[r0,#0]  ; ackno
00009e  65a0              STR      r0,[r4,#0x58]
;;;881          if (pcb->snd_wnd == 0) {
0000a0  f8b40060          LDRH     r0,[r4,#0x60]
0000a4  b948              CBNZ     r0,|L6.186|
;;;882            if (pcb->persist_backoff == 0) {
0000a6  f8940095          LDRB     r0,[r4,#0x95]
0000aa  b968              CBNZ     r0,|L6.200|
;;;883              /* start persist timer */
;;;884              pcb->persist_cnt = 0;
0000ac  2000              MOVS     r0,#0
0000ae  f8840094          STRB     r0,[r4,#0x94]
;;;885              pcb->persist_backoff = 1;
0000b2  2001              MOVS     r0,#1
0000b4  f8840095          STRB     r0,[r4,#0x95]
0000b8  e006              B        |L6.200|
                  |L6.186|
;;;886            }
;;;887          } else if (pcb->persist_backoff > 0) {
0000ba  f8940095          LDRB     r0,[r4,#0x95]
0000be  2800              CMP      r0,#0
0000c0  dd02              BLE      |L6.200|
;;;888            /* stop persist timer */
;;;889              pcb->persist_backoff = 0;
0000c2  2000              MOVS     r0,#0
0000c4  f8840095          STRB     r0,[r4,#0x95]
                  |L6.200|
;;;890          }
;;;891          LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: window update %"U16_F"\n", pcb->snd_wnd));
0000c8  bf00              NOP      
0000ca  bf00              NOP      
                  |L6.204|
;;;892    #if TCP_WND_DEBUG
;;;893        } else {
;;;894          if (pcb->snd_wnd != tcphdr->wnd) {
;;;895            LWIP_DEBUGF(TCP_WND_DEBUG, 
;;;896                        ("tcp_receive: no window update lastack %"U32_F" ackno %"
;;;897                         U32_F" wl1 %"U32_F" seqno %"U32_F" wl2 %"U32_F"\n",
;;;898                         pcb->lastack, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
;;;899          }
;;;900    #endif /* TCP_WND_DEBUG */
;;;901        }
;;;902    
;;;903        /* (From Stevens TCP/IP Illustrated Vol II, p970.) Its only a
;;;904         * duplicate ack if:
;;;905         * 1) It doesn't ACK new data 
;;;906         * 2) length of received packet is zero (i.e. no payload) 
;;;907         * 3) the advertised window hasn't changed 
;;;908         * 4) There is outstanding unacknowledged data (retransmission timer running)
;;;909         * 5) The ACK is == biggest ACK sequence number so far seen (snd_una)
;;;910         * 
;;;911         * If it passes all five, should process as a dupack: 
;;;912         * a) dupacks < 3: do nothing 
;;;913         * b) dupacks == 3: fast retransmit 
;;;914         * c) dupacks > 3: increase cwnd 
;;;915         * 
;;;916         * If it only passes 1-3, should reset dupack counter (and add to
;;;917         * stats, which we don't do in lwIP)
;;;918         *
;;;919         * If it only passes 1, should reset dupack counter
;;;920         *
;;;921         */
;;;922    
;;;923        /* Clause 1 */
;;;924        if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
0000cc  49d6              LDR      r1,|L6.1064|
0000ce  6ca0              LDR      r0,[r4,#0x48]
0000d0  6809              LDR      r1,[r1,#0]  ; ackno
0000d2  1a08              SUBS     r0,r1,r0
0000d4  2800              CMP      r0,#0
0000d6  dc48              BGT      |L6.362|
;;;925          pcb->acked = 0;
0000d8  2000              MOVS     r0,#0
0000da  f8a40064          STRH     r0,[r4,#0x64]
;;;926          /* Clause 2 */
;;;927          if (tcplen == 0) {
0000de  48d4              LDR      r0,|L6.1072|
0000e0  8800              LDRH     r0,[r0,#0]  ; tcplen
0000e2  bb30              CBNZ     r0,|L6.306|
;;;928            /* Clause 3 */
;;;929            if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
0000e4  f8b41060          LDRH     r1,[r4,#0x60]
0000e8  6da0              LDR      r0,[r4,#0x58]
0000ea  4401              ADD      r1,r1,r0
0000ec  9802              LDR      r0,[sp,#8]
0000ee  4281              CMP      r1,r0
0000f0  d135              BNE      |L6.350|
;;;930              /* Clause 4 */
;;;931              if (pcb->rtime >= 0) {
0000f2  f9b40034          LDRSH    r0,[r4,#0x34]
0000f6  2800              CMP      r0,#0
0000f8  db31              BLT      |L6.350|
;;;932                /* Clause 5 */
;;;933                if (pcb->lastack == ackno) {
0000fa  49cb              LDR      r1,|L6.1064|
0000fc  6ca0              LDR      r0,[r4,#0x48]
0000fe  6809              LDR      r1,[r1,#0]  ; ackno
000100  4288              CMP      r0,r1
000102  d12c              BNE      |L6.350|
;;;934                  found_dupack = 1;
000104  2001              MOVS     r0,#1
000106  9000              STR      r0,[sp,#0]
;;;935                  if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
000108  f8940047          LDRB     r0,[r4,#0x47]
00010c  1c40              ADDS     r0,r0,#1
00010e  b2c0              UXTB     r0,r0
000110  f8941047          LDRB     r1,[r4,#0x47]
000114  4288              CMP      r0,r1
000116  dd04              BLE      |L6.290|
;;;936                    ++pcb->dupacks;
000118  f8940047          LDRB     r0,[r4,#0x47]
00011c  1c40              ADDS     r0,r0,#1
00011e  f8840047          STRB     r0,[r4,#0x47]
                  |L6.290|
;;;937                  }
;;;938                  if (pcb->dupacks > 3) {
000122  f8940047          LDRB     r0,[r4,#0x47]
000126  2803              CMP      r0,#3
000128  dd12              BLE      |L6.336|
;;;939                    /* Inflate the congestion window, but not if it means that
;;;940                       the value overflows. */
;;;941                    if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
00012a  f8b4004c          LDRH     r0,[r4,#0x4c]
00012e  e001              B        |L6.308|
                  |L6.304|
000130  e202              B        |L6.1336|
                  |L6.306|
000132  e00c              B        |L6.334|
                  |L6.308|
000134  8ee1              LDRH     r1,[r4,#0x36]
000136  4408              ADD      r0,r0,r1
000138  b280              UXTH     r0,r0
00013a  f8b4104c          LDRH     r1,[r4,#0x4c]
00013e  4288              CMP      r0,r1
000140  dd0d              BLE      |L6.350|
;;;942                      pcb->cwnd += pcb->mss;
000142  f8b4004c          LDRH     r0,[r4,#0x4c]
000146  8ee1              LDRH     r1,[r4,#0x36]
000148  4408              ADD      r0,r0,r1
00014a  f8a4004c          STRH     r0,[r4,#0x4c]
                  |L6.334|
00014e  e006              B        |L6.350|
                  |L6.336|
;;;943                    }
;;;944                  } else if (pcb->dupacks == 3) {
000150  f8940047          LDRB     r0,[r4,#0x47]
000154  2803              CMP      r0,#3
000156  d102              BNE      |L6.350|
;;;945                    /* Do fast retransmit */
;;;946                    tcp_rexmit_fast(pcb);
000158  4620              MOV      r0,r4
00015a  f7fffffe          BL       tcp_rexmit_fast
                  |L6.350|
;;;947                  }
;;;948                }
;;;949              }
;;;950            }
;;;951          }
;;;952          /* If Clause (1) or more is true, but not a duplicate ack, reset
;;;953           * count of consecutive duplicate acks */
;;;954          if (!found_dupack) {
00015e  9800              LDR      r0,[sp,#0]
000160  2800              CMP      r0,#0
000162  d101              BNE      |L6.360|
;;;955            pcb->dupacks = 0;
000164  f8840047          STRB     r0,[r4,#0x47]
                  |L6.360|
000168  e0d3              B        |L6.786|
                  |L6.362|
;;;956          }
;;;957        } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
00016a  6ca0              LDR      r0,[r4,#0x48]
00016c  1c40              ADDS     r0,r0,#1
00016e  49ae              LDR      r1,|L6.1064|
000170  6809              LDR      r1,[r1,#0]  ; ackno
000172  1a08              SUBS     r0,r1,r0
000174  d47e              BMI      |L6.628|
000176  49ac              LDR      r1,|L6.1064|
000178  6d20              LDR      r0,[r4,#0x50]
00017a  6809              LDR      r1,[r1,#0]  ; ackno
00017c  1a08              SUBS     r0,r1,r0
00017e  2800              CMP      r0,#0
000180  dc78              BGT      |L6.628|
;;;958          /* We come here when the ACK acknowledges new data. */
;;;959    
;;;960          /* Reset the "IN Fast Retransmit" flag, since we are no longer
;;;961             in fast retransmit. Also reset the congestion window to the
;;;962             slow start threshold. */
;;;963          if (pcb->flags & TF_INFR) {
000182  7fa0              LDRB     r0,[r4,#0x1e]
000184  f0000004          AND      r0,r0,#4
000188  b138              CBZ      r0,|L6.410|
;;;964            pcb->flags &= ~TF_INFR;
00018a  7fa0              LDRB     r0,[r4,#0x1e]
00018c  f0200004          BIC      r0,r0,#4
000190  77a0              STRB     r0,[r4,#0x1e]
;;;965            pcb->cwnd = pcb->ssthresh;
000192  f8b4004e          LDRH     r0,[r4,#0x4e]
000196  f8a4004c          STRH     r0,[r4,#0x4c]
                  |L6.410|
;;;966          }
;;;967    
;;;968          /* Reset the number of retransmissions. */
;;;969          pcb->nrtx = 0;
00019a  2000              MOVS     r0,#0
00019c  3428              ADDS     r4,r4,#0x28
00019e  77a0              STRB     r0,[r4,#0x1e]
;;;970    
;;;971          /* Reset the retransmission time-out. */
;;;972          pcb->rto = (pcb->sa >> 3) + pcb->sv;
0001a0  8b60              LDRH     r0,[r4,#0x1a]
0001a2  f9b41018          LDRSH    r1,[r4,#0x18]
0001a6  eb0000e1          ADD      r0,r0,r1,ASR #3
0001aa  b200              SXTH     r0,r0
0001ac  83a0              STRH     r0,[r4,#0x1c]
;;;973    
;;;974          /* Update the send buffer space. Diff between the two can never exceed 64K? */
;;;975          pcb->acked = (u16_t)(ackno - pcb->lastack);
0001ae  8c20              LDRH     r0,[r4,#0x20]
0001b0  499d              LDR      r1,|L6.1064|
0001b2  8809              LDRH     r1,[r1,#0]  ; ackno
0001b4  1a08              SUBS     r0,r1,r0
0001b6  87a0              STRH     r0,[r4,#0x3c]
;;;976    
;;;977          pcb->snd_buf += pcb->acked;
0001b8  8fe0              LDRH     r0,[r4,#0x3e]
0001ba  8fa1              LDRH     r1,[r4,#0x3c]
0001bc  4408              ADD      r0,r0,r1
0001be  87e0              STRH     r0,[r4,#0x3e]
;;;978    
;;;979          /* Reset the fast retransmit variables. */
;;;980          pcb->dupacks = 0;
0001c0  2000              MOVS     r0,#0
0001c2  77e0              STRB     r0,[r4,#0x1f]
;;;981          pcb->lastack = ackno;
0001c4  4898              LDR      r0,|L6.1064|
0001c6  6800              LDR      r0,[r0,#0]  ; ackno
0001c8  6220              STR      r0,[r4,#0x20]
;;;982    
;;;983          /* Update the congestion control variables (cwnd and
;;;984             ssthresh). */
;;;985          if (pcb->state >= ESTABLISHED) {
0001ca  f8140c10          LDRB     r0,[r4,#-0x10]
0001ce  3c28              SUBS     r4,r4,#0x28
0001d0  2804              CMP      r0,#4
0001d2  db27              BLT      |L6.548|
;;;986            if (pcb->cwnd < pcb->ssthresh) {
0001d4  f8b4004c          LDRH     r0,[r4,#0x4c]
0001d8  f8b4104e          LDRH     r1,[r4,#0x4e]
0001dc  4288              CMP      r0,r1
0001de  da10              BGE      |L6.514|
;;;987              if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
0001e0  f8b4004c          LDRH     r0,[r4,#0x4c]
0001e4  8ee1              LDRH     r1,[r4,#0x36]
0001e6  4408              ADD      r0,r0,r1
0001e8  b280              UXTH     r0,r0
0001ea  f8b4104c          LDRH     r1,[r4,#0x4c]
0001ee  4288              CMP      r0,r1
0001f0  dd05              BLE      |L6.510|
;;;988                pcb->cwnd += pcb->mss;
0001f2  f8b4004c          LDRH     r0,[r4,#0x4c]
0001f6  8ee1              LDRH     r1,[r4,#0x36]
0001f8  4408              ADD      r0,r0,r1
0001fa  f8a4004c          STRH     r0,[r4,#0x4c]
                  |L6.510|
;;;989              }
;;;990              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
0001fe  bf00              NOP      
000200  e010              B        |L6.548|
                  |L6.514|
;;;991            } else {
;;;992              u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
000202  f8341f36          LDRH     r1,[r4,#0x36]!
000206  4349              MULS     r1,r1,r1
000208  8ae2              LDRH     r2,[r4,#0x16]
00020a  fb91f1f2          SDIV     r1,r1,r2
00020e  4411              ADD      r1,r1,r2
000210  b288              UXTH     r0,r1
;;;993              if (new_cwnd > pcb->cwnd) {
000212  8ae1              LDRH     r1,[r4,#0x16]
000214  3c36              SUBS     r4,r4,#0x36
000216  4281              CMP      r1,r0
000218  da01              BGE      |L6.542|
;;;994                pcb->cwnd = new_cwnd;
00021a  f8a4004c          STRH     r0,[r4,#0x4c]
                  |L6.542|
;;;995              }
;;;996              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: congestion avoidance cwnd %"U16_F"\n", pcb->cwnd));
00021e  bf00              NOP      
000220  bf00              NOP      
;;;997            }
000222  bf00              NOP      
                  |L6.548|
;;;998          }
;;;999          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: ACK for %"U32_F", unacked->seqno %"U32_F":%"U32_F"\n",
000224  bf00              NOP      
000226  bf00              NOP      
;;;1000                                       ackno,
;;;1001                                       pcb->unacked != NULL?
;;;1002                                       ntohl(pcb->unacked->tcphdr->seqno): 0,
;;;1003                                       pcb->unacked != NULL?
;;;1004                                       ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));
;;;1005   
;;;1006         /* Remove segment from the unacknowledged list if the incoming
;;;1007            ACK acknowlegdes them. */
;;;1008         while (pcb->unacked != NULL &&
000228  e049              B        |L6.702|
                  |L6.554|
;;;1009                TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
;;;1010                            TCP_TCPLEN(pcb->unacked), ackno)) {
;;;1011           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
00022a  bf00              NOP      
00022c  bf00              NOP      
;;;1012                                         ntohl(pcb->unacked->tcphdr->seqno),
;;;1013                                         ntohl(pcb->unacked->tcphdr->seqno) +
;;;1014                                         TCP_TCPLEN(pcb->unacked)));
;;;1015   
;;;1016           next = pcb->unacked;
00022e  6f25              LDR      r5,[r4,#0x70]
;;;1017           pcb->unacked = pcb->unacked->next;
000230  6f20              LDR      r0,[r4,#0x70]
000232  6800              LDR      r0,[r0,#0]
000234  6720              STR      r0,[r4,#0x70]
;;;1018   
;;;1019           LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
000236  bf00              NOP      
000238  bf00              NOP      
;;;1020           LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
00023a  bf00              NOP      
00023c  6868              LDR      r0,[r5,#4]
00023e  f7fffffe          BL       pbuf_clen
000242  f8b41068          LDRH     r1,[r4,#0x68]
000246  4288              CMP      r0,r1
000248  dd08              BLE      |L6.604|
00024a  bf00              NOP      
00024c  a358              ADR      r3,|L6.944|
00024e  f44f727f          MOV      r2,#0x3fc
000252  a178              ADR      r1,|L6.1076|
000254  a067              ADR      r0,|L6.1012|
000256  f7fffffe          BL       __2printf
00025a  bf00              NOP      
                  |L6.604|
00025c  bf00              NOP      
;;;1021           /* Prevent ACK for FIN to generate a sent event */
;;;1022           if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
00025e  f8b40064          LDRH     r0,[r4,#0x64]
000262  b168              CBZ      r0,|L6.640|
000264  6929              LDR      r1,[r5,#0x10]
000266  8988              LDRH     r0,[r1,#0xc]
000268  f7fffffe          BL       lwip_ntohs
00026c  f0000001          AND      r0,r0,#1
000270  b130              CBZ      r0,|L6.640|
;;;1023             pcb->acked--;
000272  e000              B        |L6.630|
                  |L6.628|
000274  e04a              B        |L6.780|
                  |L6.630|
000276  f8b40064          LDRH     r0,[r4,#0x64]
00027a  1e40              SUBS     r0,r0,#1
00027c  f8a40064          STRH     r0,[r4,#0x64]
                  |L6.640|
;;;1024           }
;;;1025   
;;;1026           pcb->snd_queuelen -= pbuf_clen(next->p);
000280  6868              LDR      r0,[r5,#4]
000282  f7fffffe          BL       pbuf_clen
000286  f8b41068          LDRH     r1,[r4,#0x68]
00028a  1a08              SUBS     r0,r1,r0
00028c  f8a40068          STRH     r0,[r4,#0x68]
;;;1027           tcp_seg_free(next);
000290  4628              MOV      r0,r5
000292  f7fffffe          BL       tcp_seg_free
;;;1028   
;;;1029           LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
000296  bf00              NOP      
000298  bf00              NOP      
;;;1030           if (pcb->snd_queuelen != 0) {
00029a  f8b40068          LDRH     r0,[r4,#0x68]
00029e  b170              CBZ      r0,|L6.702|
;;;1031             LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
0002a0  bf00              NOP      
0002a2  6f20              LDR      r0,[r4,#0x70]
0002a4  b950              CBNZ     r0,|L6.700|
0002a6  6ee0              LDR      r0,[r4,#0x6c]
0002a8  b940              CBNZ     r0,|L6.700|
0002aa  bf00              NOP      
0002ac  a340              ADR      r3,|L6.944|
0002ae  f2404207          MOV      r2,#0x407
0002b2  a16a              ADR      r1,|L6.1116|
0002b4  a04f              ADR      r0,|L6.1012|
0002b6  f7fffffe          BL       __2printf
0002ba  bf00              NOP      
                  |L6.700|
0002bc  bf00              NOP      
                  |L6.702|
0002be  6f20              LDR      r0,[r4,#0x70]         ;1008
0002c0  b1c8              CBZ      r0,|L6.758|
0002c2  6f21              LDR      r1,[r4,#0x70]         ;1009
0002c4  6909              LDR      r1,[r1,#0x10]         ;1009
0002c6  6848              LDR      r0,[r1,#4]            ;1009
0002c8  f7fffffe          BL       lwip_ntohl
0002cc  4683              MOV      r11,r0                ;1009
0002ce  6f21              LDR      r1,[r4,#0x70]         ;1009
0002d0  6909              LDR      r1,[r1,#0x10]         ;1009
0002d2  8988              LDRH     r0,[r1,#0xc]          ;1009
0002d4  f7fffffe          BL       lwip_ntohs
0002d8  f0000003          AND      r0,r0,#3              ;1009
0002dc  b108              CBZ      r0,|L6.738|
0002de  2001              MOVS     r0,#1                 ;1009
0002e0  e000              B        |L6.740|
                  |L6.738|
0002e2  2000              MOVS     r0,#0                 ;1009
                  |L6.740|
0002e4  6f21              LDR      r1,[r4,#0x70]         ;1009
0002e6  8909              LDRH     r1,[r1,#8]            ;1009
0002e8  4408              ADD      r0,r0,r1              ;1009
0002ea  4458              ADD      r0,r0,r11             ;1009
0002ec  494e              LDR      r1,|L6.1064|
0002ee  6809              LDR      r1,[r1,#0]            ;1009  ; ackno
0002f0  1a40              SUBS     r0,r0,r1              ;1009
0002f2  2800              CMP      r0,#0                 ;1009
0002f4  dd99              BLE      |L6.554|
                  |L6.758|
;;;1032                         pcb->unsent != NULL);
;;;1033           }
;;;1034         }
;;;1035   
;;;1036         /* If there's nothing left to acknowledge, stop the retransmit
;;;1037            timer, otherwise reset it to start again */
;;;1038         if(pcb->unacked == NULL)
0002f6  6f20              LDR      r0,[r4,#0x70]
0002f8  b918              CBNZ     r0,|L6.770|
;;;1039           pcb->rtime = -1;
0002fa  f04f30ff          MOV      r0,#0xffffffff
0002fe  86a0              STRH     r0,[r4,#0x34]
000300  e001              B        |L6.774|
                  |L6.770|
;;;1040         else
;;;1041           pcb->rtime = 0;
000302  2000              MOVS     r0,#0
000304  86a0              STRH     r0,[r4,#0x34]
                  |L6.774|
;;;1042   
;;;1043         pcb->polltmr = 0;
000306  2000              MOVS     r0,#0
000308  77e0              STRB     r0,[r4,#0x1f]
00030a  e002              B        |L6.786|
                  |L6.780|
;;;1044       } else {
;;;1045         /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
;;;1046         pcb->acked = 0;
00030c  2000              MOVS     r0,#0
00030e  f8a40064          STRH     r0,[r4,#0x64]
                  |L6.786|
;;;1047       }
;;;1048   
;;;1049       /* We go through the ->unsent list to see if any of the segments
;;;1050          on the list are acknowledged by the ACK. This may seem
;;;1051          strange since an "unsent" segment shouldn't be acked. The
;;;1052          rationale is that lwIP puts all outstanding segments on the
;;;1053          ->unsent list after a retransmission, so these segments may
;;;1054          in fact have been sent once. */
;;;1055       while (pcb->unsent != NULL &&
000312  e0b5              B        |L6.1152|
                  |L6.788|
;;;1056              TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
;;;1057                              TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
;;;1058         LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
000314  bf00              NOP      
000316  bf00              NOP      
;;;1059                                       ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
;;;1060                                       TCP_TCPLEN(pcb->unsent)));
;;;1061   
;;;1062         next = pcb->unsent;
000318  6ee5              LDR      r5,[r4,#0x6c]
;;;1063         pcb->unsent = pcb->unsent->next;
00031a  6ee0              LDR      r0,[r4,#0x6c]
00031c  6800              LDR      r0,[r0,#0]
00031e  66e0              STR      r0,[r4,#0x6c]
;;;1064   #if TCP_OVERSIZE
;;;1065         if (pcb->unsent == NULL) {
000320  6ee0              LDR      r0,[r4,#0x6c]
000322  b910              CBNZ     r0,|L6.810|
;;;1066           pcb->unsent_oversize = 0;
000324  2000              MOVS     r0,#0
000326  f8a4006a          STRH     r0,[r4,#0x6a]
                  |L6.810|
;;;1067         }
;;;1068   #endif /* TCP_OVERSIZE */ 
;;;1069         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
00032a  bf00              NOP      
00032c  bf00              NOP      
;;;1070         LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
00032e  bf00              NOP      
000330  6868              LDR      r0,[r5,#4]
000332  f7fffffe          BL       pbuf_clen
000336  f8b41068          LDRH     r1,[r4,#0x68]
00033a  4288              CMP      r0,r1
00033c  dd08              BLE      |L6.848|
00033e  bf00              NOP      
000340  a31b              ADR      r3,|L6.944|
000342  f240422e          MOV      r2,#0x42e
000346  a13b              ADR      r1,|L6.1076|
000348  a02a              ADR      r0,|L6.1012|
00034a  f7fffffe          BL       __2printf
00034e  bf00              NOP      
                  |L6.848|
000350  bf00              NOP      
;;;1071         /* Prevent ACK for FIN to generate a sent event */
;;;1072         if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
000352  f8b40064          LDRH     r0,[r4,#0x64]
000356  b158              CBZ      r0,|L6.880|
000358  6929              LDR      r1,[r5,#0x10]
00035a  8988              LDRH     r0,[r1,#0xc]
00035c  f7fffffe          BL       lwip_ntohs
000360  f0000001          AND      r0,r0,#1
000364  b120              CBZ      r0,|L6.880|
;;;1073           pcb->acked--;
000366  f8b40064          LDRH     r0,[r4,#0x64]
00036a  1e40              SUBS     r0,r0,#1
00036c  f8a40064          STRH     r0,[r4,#0x64]
                  |L6.880|
;;;1074         }
;;;1075         pcb->snd_queuelen -= pbuf_clen(next->p);
000370  6868              LDR      r0,[r5,#4]
000372  f7fffffe          BL       pbuf_clen
000376  f8b41068          LDRH     r1,[r4,#0x68]
00037a  1a08              SUBS     r0,r1,r0
00037c  f8a40068          STRH     r0,[r4,#0x68]
;;;1076         tcp_seg_free(next);
000380  4628              MOV      r0,r5
000382  f7fffffe          BL       tcp_seg_free
;;;1077         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
000386  bf00              NOP      
000388  bf00              NOP      
;;;1078         if (pcb->snd_queuelen != 0) {
00038a  f8b40068          LDRH     r0,[r4,#0x68]
00038e  b168              CBZ      r0,|L6.940|
;;;1079           LWIP_ASSERT("tcp_receive: valid queue length",
000390  bf00              NOP      
000392  6f20              LDR      r0,[r4,#0x70]
000394  b958              CBNZ     r0,|L6.942|
000396  6ee0              LDR      r0,[r4,#0x6c]
000398  b948              CBNZ     r0,|L6.942|
00039a  bf00              NOP      
00039c  a304              ADR      r3,|L6.944|
00039e  f2404237          MOV      r2,#0x437
0003a2  a12e              ADR      r1,|L6.1116|
0003a4  a013              ADR      r0,|L6.1012|
0003a6  f7fffffe          BL       __2printf
0003aa  e067              B        |L6.1148|
                  |L6.940|
0003ac  e068              B        |L6.1152|
                  |L6.942|
0003ae  e066              B        |L6.1150|
                  |L6.944|
0003b0  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp_in.c",0
0003b4  5749505c
0003b8  6c776970
0003bc  2d312e34
0003c0  2e315c73
0003c4  72635c63
0003c8  6f72655c
0003cc  7463705f
0003d0  696e2e63
0003d4  00      
0003d5  00                DCB      0
0003d6  00                DCB      0
0003d7  00                DCB      0
                  |L6.984|
0003d8  7463705f          DCB      "tcp_receive: wrong state",0
0003dc  72656365
0003e0  6976653a
0003e4  2077726f
0003e8  6e672073
0003ec  74617465
0003f0  00      
0003f1  00                DCB      0
0003f2  00                DCB      0
0003f3  00                DCB      0
                  |L6.1012|
0003f4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0003f8  7274696f
0003fc  6e202225
000400  73222066
000404  61696c65
000408  64206174
00040c  206c696e
000410  65202564
000414  20696e20
000418  25730d0a
00041c  00      
00041d  00                DCB      0
00041e  00                DCB      0
00041f  00                DCB      0
                  |L6.1056|
                          DCD      flags
                  |L6.1060|
                          DCD      seqno
                  |L6.1064|
                          DCD      ackno
                  |L6.1068|
                          DCD      tcphdr
                  |L6.1072|
                          DCD      tcplen
                  |L6.1076|
000434  7063622d          DCB      "pcb->snd_queuelen >= pbuf_clen(next->p)",0
000438  3e736e64
00043c  5f717565
000440  75656c65
000444  6e203e3d
000448  20706275
00044c  665f636c
000450  656e286e
000454  6578742d
000458  3e702900
                  |L6.1116|
00045c  7463705f          DCB      "tcp_receive: valid queue length",0
000460  72656365
000464  6976653a
000468  2076616c
00046c  69642071
000470  75657565
000474  206c656e
000478  67746800
                  |L6.1148|
00047c  bf00              NOP      
                  |L6.1150|
00047e  bf00              NOP      
                  |L6.1152|
000480  6ee0              LDR      r0,[r4,#0x6c]         ;1055
000482  b1f8              CBZ      r0,|L6.1220|
000484  6ee1              LDR      r1,[r4,#0x6c]         ;1056
000486  6909              LDR      r1,[r1,#0x10]         ;1056
000488  6848              LDR      r0,[r1,#4]            ;1056
00048a  f7fffffe          BL       lwip_ntohl
00048e  4683              MOV      r11,r0                ;1056
000490  6ee1              LDR      r1,[r4,#0x6c]         ;1056
000492  6909              LDR      r1,[r1,#0x10]         ;1056
000494  8988              LDRH     r0,[r1,#0xc]          ;1056
000496  f7fffffe          BL       lwip_ntohs
00049a  f0000003          AND      r0,r0,#3              ;1056
00049e  b108              CBZ      r0,|L6.1188|
0004a0  2001              MOVS     r0,#1                 ;1056
0004a2  e000              B        |L6.1190|
                  |L6.1188|
0004a4  2000              MOVS     r0,#0                 ;1056
                  |L6.1190|
0004a6  6ee1              LDR      r1,[r4,#0x6c]         ;1056
0004a8  8909              LDRH     r1,[r1,#8]            ;1056
0004aa  4408              ADD      r0,r0,r1              ;1056
0004ac  4458              ADD      r0,r0,r11             ;1056
0004ae  49fe              LDR      r1,|L6.2216|
0004b0  6809              LDR      r1,[r1,#0]            ;1056  ; ackno
0004b2  1a08              SUBS     r0,r1,r0              ;1056
0004b4  d406              BMI      |L6.1220|
0004b6  49fc              LDR      r1,|L6.2216|
0004b8  6d20              LDR      r0,[r4,#0x50]         ;1056
0004ba  6809              LDR      r1,[r1,#0]            ;1056  ; ackno
0004bc  1a08              SUBS     r0,r1,r0              ;1056
0004be  2800              CMP      r0,#0                 ;1056
0004c0  f77faf28          BLE      |L6.788|
                  |L6.1220|
;;;1080             pcb->unacked != NULL || pcb->unsent != NULL);
;;;1081         }
;;;1082       }
;;;1083       /* End of ACK for new data processing. */
;;;1084   
;;;1085       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: pcb->rttest %"U32_F" rtseq %"U32_F" ackno %"U32_F"\n",
0004c4  bf00              NOP      
0004c6  bf00              NOP      
;;;1086                                   pcb->rttest, pcb->rtseq, ackno));
;;;1087   
;;;1088       /* RTT estimation calculations. This is done by checking if the
;;;1089          incoming segment acknowledges the segment we use to take a
;;;1090          round-trip time measurement. */
;;;1091       if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
0004c8  6ba0              LDR      r0,[r4,#0x38]
0004ca  b3a8              CBZ      r0,|L6.1336|
0004cc  49f6              LDR      r1,|L6.2216|
0004ce  6be0              LDR      r0,[r4,#0x3c]
0004d0  6809              LDR      r1,[r1,#0]  ; ackno
0004d2  1a40              SUBS     r0,r0,r1
0004d4  d530              BPL      |L6.1336|
;;;1092         /* diff between this shouldn't exceed 32K since this are tcp timer ticks
;;;1093            and a round-trip shouldn't be that long... */
;;;1094         m = (s16_t)(tcp_ticks - pcb->rttest);
0004d6  8f20              LDRH     r0,[r4,#0x38]
0004d8  49f4              LDR      r1,|L6.2220|
0004da  8809              LDRH     r1,[r1,#0]  ; tcp_ticks
0004dc  1a08              SUBS     r0,r1,r0
0004de  fa0ffa80          SXTH     r10,r0
;;;1095   
;;;1096         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
0004e2  bf00              NOP      
0004e4  bf00              NOP      
;;;1097                                     m, m * TCP_SLOW_INTERVAL));
;;;1098   
;;;1099         /* This is taken directly from VJs original code in his paper */
;;;1100         m = m - (pcb->sa >> 3);
0004e6  f9340f40          LDRSH    r0,[r4,#0x40]!
0004ea  ebaa00e0          SUB      r0,r10,r0,ASR #3
0004ee  fa0ffa80          SXTH     r10,r0
;;;1101         pcb->sa += m;
0004f2  8820              LDRH     r0,[r4,#0]
0004f4  4450              ADD      r0,r0,r10
0004f6  b200              SXTH     r0,r0
0004f8  f8240940          STRH     r0,[r4],#-0x40
;;;1102         if (m < 0) {
0004fc  f1ba0f00          CMP      r10,#0
000500  da03              BGE      |L6.1290|
;;;1103           m = -m;
000502  f1ca0000          RSB      r0,r10,#0
000506  fa0ffa80          SXTH     r10,r0
                  |L6.1290|
;;;1104         }
;;;1105         m = m - (pcb->sv >> 2);
00050a  3440              ADDS     r4,r4,#0x40
00050c  f9b40002          LDRSH    r0,[r4,#2]
000510  ebaa00a0          SUB      r0,r10,r0,ASR #2
000514  fa0ffa80          SXTH     r10,r0
;;;1106         pcb->sv += m;
000518  8860              LDRH     r0,[r4,#2]
00051a  4450              ADD      r0,r0,r10
00051c  b200              SXTH     r0,r0
00051e  8060              STRH     r0,[r4,#2]
;;;1107         pcb->rto = (pcb->sa >> 3) + pcb->sv;
000520  8860              LDRH     r0,[r4,#2]
000522  f9b41000          LDRSH    r1,[r4,#0]
000526  eb0000e1          ADD      r0,r0,r1,ASR #3
00052a  b200              SXTH     r0,r0
00052c  80a0              STRH     r0,[r4,#4]
00052e  3c40              SUBS     r4,r4,#0x40
;;;1108   
;;;1109         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
000530  bf00              NOP      
000532  bf00              NOP      
;;;1110                                     pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));
;;;1111   
;;;1112         pcb->rttest = 0;
000534  2000              MOVS     r0,#0
000536  63a0              STR      r0,[r4,#0x38]
                  |L6.1336|
;;;1113       }
;;;1114     }
;;;1115   
;;;1116     /* If the incoming segment contains data, we must process it
;;;1117        further unless the pcb already received a FIN.
;;;1118        (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
;;;1119        LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
;;;1120     if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
000538  48dd              LDR      r0,|L6.2224|
00053a  8800              LDRH     r0,[r0,#0]  ; tcplen
00053c  2800              CMP      r0,#0
00053e  dd77              BLE      |L6.1584|
000540  7e20              LDRB     r0,[r4,#0x18]
000542  2807              CMP      r0,#7
000544  da74              BGE      |L6.1584|
;;;1121       /* This code basically does three things:
;;;1122   
;;;1123       +) If the incoming segment contains data that is the next
;;;1124       in-sequence data, this data is passed to the application. This
;;;1125       might involve trimming the first edge of the data. The rcv_nxt
;;;1126       variable and the advertised window are adjusted.
;;;1127   
;;;1128       +) If the incoming segment has data that is above the next
;;;1129       sequence number expected (->rcv_nxt), the segment is placed on
;;;1130       the ->ooseq queue. This is done by finding the appropriate
;;;1131       place in the ->ooseq queue (which is ordered by sequence
;;;1132       number) and trim the segment in both ends if needed. An
;;;1133       immediate ACK is sent to indicate that we received an
;;;1134       out-of-sequence segment.
;;;1135   
;;;1136       +) Finally, we check if the first segment on the ->ooseq queue
;;;1137       now is in sequence (i.e., if rcv_nxt >= ooseq->seqno). If
;;;1138       rcv_nxt > ooseq->seqno, we must trim the first edge of the
;;;1139       segment on ->ooseq before we adjust rcv_nxt. The data in the
;;;1140       segments that are now on sequence are chained onto the
;;;1141       incoming segment so that we only need to call the application
;;;1142       once.
;;;1143       */
;;;1144   
;;;1145       /* First, we check if we must trim the first edge. We have to do
;;;1146          this if the sequence number of the incoming segment is less
;;;1147          than rcv_nxt, and the sequence number plus the length of the
;;;1148          segment is larger than rcv_nxt. */
;;;1149       /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
;;;1150             if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
;;;1151       if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
000546  48db              LDR      r0,|L6.2228|
000548  6aa1              LDR      r1,[r4,#0x28]
00054a  6800              LDR      r0,[r0,#0]  ; seqno
00054c  1c40              ADDS     r0,r0,#1
00054e  1a08              SUBS     r0,r1,r0
000550  d46f              BMI      |L6.1586|
000552  48d8              LDR      r0,|L6.2228|
000554  6aa1              LDR      r1,[r4,#0x28]
000556  6800              LDR      r0,[r0,#0]  ; seqno
000558  4ad5              LDR      r2,|L6.2224|
00055a  8812              LDRH     r2,[r2,#0]  ; tcplen
00055c  4410              ADD      r0,r0,r2
00055e  1e40              SUBS     r0,r0,#1
000560  1a08              SUBS     r0,r1,r0
000562  2800              CMP      r0,#0
000564  dc65              BGT      |L6.1586|
;;;1152         /* Trimming the first edge is done by pushing the payload
;;;1153            pointer in the pbuf downwards. This is somewhat tricky since
;;;1154            we do not want to discard the full contents of the pbuf up to
;;;1155            the new starting point of the data since we have to keep the
;;;1156            TCP header which is present in the first pbuf in the chain.
;;;1157   
;;;1158            What is done is really quite a nasty hack: the first pbuf in
;;;1159            the pbuf chain is pointed to by inseg.p. Since we need to be
;;;1160            able to deallocate the whole pbuf, we cannot change this
;;;1161            inseg.p pointer to point to any of the later pbufs in the
;;;1162            chain. Instead, we point the ->payload pointer in the first
;;;1163            pbuf to data in one of the later pbufs. We also set the
;;;1164            inseg.data pointer to point to the right place. This way, the
;;;1165            ->p pointer will still point to the first pbuf, but the
;;;1166            ->p->payload pointer will point to data in another pbuf.
;;;1167   
;;;1168            After we are done with adjusting the pbuf pointers we must
;;;1169            adjust the ->data pointer in the seg and the segment
;;;1170            length.*/
;;;1171   
;;;1172         off = pcb->rcv_nxt - seqno;
000566  49d3              LDR      r1,|L6.2228|
000568  6aa0              LDR      r0,[r4,#0x28]
00056a  6809              LDR      r1,[r1,#0]  ; seqno
00056c  eba00801          SUB      r8,r0,r1
;;;1173         p = inseg.p;
000570  48d1              LDR      r0,|L6.2232|
000572  f8d09004          LDR      r9,[r0,#4]  ; inseg
;;;1174         LWIP_ASSERT("inseg.p != NULL", inseg.p);
000576  bf00              NOP      
000578  6840              LDR      r0,[r0,#4]  ; inseg
00057a  b950              CBNZ     r0,|L6.1426|
00057c  bf00              NOP      
00057e  f2af13d0          ADR      r3,|L6.944|
000582  f2404296          MOV      r2,#0x496
000586  a1cd              ADR      r1,|L6.2236|
000588  f2af1098          ADR      r0,|L6.1012|
00058c  f7fffffe          BL       __2printf
000590  bf00              NOP      
                  |L6.1426|
000592  bf00              NOP      
;;;1175         LWIP_ASSERT("insane offset!", (off < 0x7fff));
000594  bf00              NOP      
000596  f64770ff          MOV      r0,#0x7fff
00059a  4580              CMP      r8,r0
00059c  db0a              BLT      |L6.1460|
00059e  bf00              NOP      
0005a0  f2af13f4          ADR      r3,|L6.944|
0005a4  f2404297          MOV      r2,#0x497
0005a8  a1c8              ADR      r1,|L6.2252|
0005aa  f2af10b8          ADR      r0,|L6.1012|
0005ae  f7fffffe          BL       __2printf
0005b2  bf00              NOP      
                  |L6.1460|
0005b4  bf00              NOP      
;;;1176         if (inseg.p->len < off) {
0005b6  48c0              LDR      r0,|L6.2232|
0005b8  6840              LDR      r0,[r0,#4]  ; inseg
0005ba  8940              LDRH     r0,[r0,#0xa]
0005bc  4540              CMP      r0,r8
0005be  da40              BGE      |L6.1602|
;;;1177           LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
0005c0  bf00              NOP      
0005c2  48bd              LDR      r0,|L6.2232|
0005c4  6840              LDR      r0,[r0,#4]  ; inseg
0005c6  8900              LDRH     r0,[r0,#8]
0005c8  4540              CMP      r0,r8
0005ca  da0a              BGE      |L6.1506|
0005cc  bf00              NOP      
0005ce  f2af2320          ADR      r3,|L6.944|
0005d2  f2404299          MOV      r2,#0x499
0005d6  a1c1              ADR      r1,|L6.2268|
0005d8  f2af10e8          ADR      r0,|L6.1012|
0005dc  f7fffffe          BL       __2printf
0005e0  bf00              NOP      
                  |L6.1506|
0005e2  bf00              NOP      
;;;1178           new_tot_len = (u16_t)(inseg.p->tot_len - off);
0005e4  48b4              LDR      r0,|L6.2232|
0005e6  6840              LDR      r0,[r0,#4]  ; inseg
0005e8  8900              LDRH     r0,[r0,#8]
0005ea  eba00008          SUB      r0,r0,r8
0005ee  b280              UXTH     r0,r0
0005f0  9001              STR      r0,[sp,#4]
;;;1179           while (p->len < off) {
0005f2  e00b              B        |L6.1548|
                  |L6.1524|
;;;1180             off -= p->len;
0005f4  f8b9000a          LDRH     r0,[r9,#0xa]
0005f8  eba80800          SUB      r8,r8,r0
;;;1181             /* KJM following line changed (with addition of new_tot_len var)
;;;1182                to fix bug #9076
;;;1183                inseg.p->tot_len -= p->len; */
;;;1184             p->tot_len = new_tot_len;
0005fc  9801              LDR      r0,[sp,#4]
0005fe  f8a90008          STRH     r0,[r9,#8]
;;;1185             p->len = 0;
000602  2000              MOVS     r0,#0
000604  f8a9000a          STRH     r0,[r9,#0xa]
;;;1186             p = p->next;
000608  f8d99000          LDR      r9,[r9,#0]
                  |L6.1548|
00060c  f8b9000a          LDRH     r0,[r9,#0xa]          ;1179
000610  4540              CMP      r0,r8                 ;1179
000612  dbef              BLT      |L6.1524|
;;;1187           }
;;;1188           if(pbuf_header(p, (s16_t)-off)) {
000614  f1c80000          RSB      r0,r8,#0
000618  b201              SXTH     r1,r0
00061a  4648              MOV      r0,r9
00061c  f7fffffe          BL       pbuf_header
000620  b320              CBZ      r0,|L6.1644|
;;;1189             /* Do we need to cope with this failing?  Assert for now */
;;;1190             LWIP_ASSERT("pbuf_header failed", 0);
000622  bf00              NOP      
000624  bf00              NOP      
000626  f2af2378          ADR      r3,|L6.944|
00062a  f24042a6          MOV      r2,#0x4a6
00062e  e001              B        |L6.1588|
                  |L6.1584|
000630  e36a              B        |L6.3336|
                  |L6.1586|
000632  e02b              B        |L6.1676|
                  |L6.1588|
000634  a1ad              ADR      r1,|L6.2284|
000636  f2af2044          ADR      r0,|L6.1012|
00063a  f7fffffe          BL       __2printf
00063e  bf00              NOP      
000640  e014              B        |L6.1644|
                  |L6.1602|
;;;1191           }
;;;1192         } else {
;;;1193           if(pbuf_header(inseg.p, (s16_t)-off)) {
000642  499d              LDR      r1,|L6.2232|
000644  6848              LDR      r0,[r1,#4]  ; inseg
000646  f1c80100          RSB      r1,r8,#0
00064a  b209              SXTH     r1,r1
00064c  f7fffffe          BL       pbuf_header
000650  b160              CBZ      r0,|L6.1644|
;;;1194             /* Do we need to cope with this failing?  Assert for now */
;;;1195             LWIP_ASSERT("pbuf_header failed", 0);
000652  bf00              NOP      
000654  bf00              NOP      
000656  f2af23a8          ADR      r3,|L6.944|
00065a  f24042ab          MOV      r2,#0x4ab
00065e  a1a3              ADR      r1,|L6.2284|
000660  f2af2070          ADR      r0,|L6.1012|
000664  f7fffffe          BL       __2printf
000668  bf00              NOP      
00066a  bf00              NOP      
                  |L6.1644|
;;;1196           }
;;;1197         }
;;;1198         inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
00066c  4892              LDR      r0,|L6.2232|
00066e  8900              LDRH     r0,[r0,#8]  ; inseg
000670  8d21              LDRH     r1,[r4,#0x28]
000672  4a90              LDR      r2,|L6.2228|
000674  8812              LDRH     r2,[r2,#0]  ; seqno
000676  1a89              SUBS     r1,r1,r2
000678  1a40              SUBS     r0,r0,r1
00067a  498f              LDR      r1,|L6.2232|
00067c  8108              STRH     r0,[r1,#8]
;;;1199         inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
00067e  498d              LDR      r1,|L6.2228|
000680  6aa0              LDR      r0,[r4,#0x28]
000682  6008              STR      r0,[r1,#0]  ; seqno
000684  498c              LDR      r1,|L6.2232|
000686  6909              LDR      r1,[r1,#0x10]  ; inseg
000688  6048              STR      r0,[r1,#4]
00068a  e00c              B        |L6.1702|
                  |L6.1676|
;;;1200       }
;;;1201       else {
;;;1202         if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
00068c  4989              LDR      r1,|L6.2228|
00068e  6aa0              LDR      r0,[r4,#0x28]
000690  6809              LDR      r1,[r1,#0]  ; seqno
000692  1a08              SUBS     r0,r1,r0
000694  d507              BPL      |L6.1702|
;;;1203           /* the whole segment is < rcv_nxt */
;;;1204           /* must be a duplicate of a packet that has already been correctly handled */
;;;1205   
;;;1206           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
000696  bf00              NOP      
000698  bf00              NOP      
;;;1207           tcp_ack_now(pcb);
00069a  bf00              NOP      
00069c  7fa0              LDRB     r0,[r4,#0x1e]
00069e  f0400002          ORR      r0,r0,#2
0006a2  77a0              STRB     r0,[r4,#0x1e]
0006a4  bf00              NOP      
                  |L6.1702|
;;;1208         }
;;;1209       }
;;;1210   
;;;1211       /* The sequence number must be within the window (above rcv_nxt
;;;1212          and below rcv_nxt + rcv_wnd) in order to be further
;;;1213          processed. */
;;;1214       if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
0006a6  4983              LDR      r1,|L6.2228|
0006a8  6aa0              LDR      r0,[r4,#0x28]
0006aa  6809              LDR      r1,[r1,#0]  ; seqno
0006ac  1a08              SUBS     r0,r1,r0
0006ae  d474              BMI      |L6.1946|
0006b0  8da1              LDRH     r1,[r4,#0x2c]
0006b2  6aa0              LDR      r0,[r4,#0x28]
0006b4  4408              ADD      r0,r0,r1
0006b6  1e40              SUBS     r0,r0,#1
0006b8  497e              LDR      r1,|L6.2228|
0006ba  6809              LDR      r1,[r1,#0]  ; seqno
0006bc  1a08              SUBS     r0,r1,r0
0006be  2800              CMP      r0,#0
0006c0  dc6b              BGT      |L6.1946|
;;;1215                           pcb->rcv_nxt + pcb->rcv_wnd - 1)){
;;;1216         if (pcb->rcv_nxt == seqno) {
0006c2  497c              LDR      r1,|L6.2228|
0006c4  6aa0              LDR      r0,[r4,#0x28]
0006c6  6809              LDR      r1,[r1,#0]  ; seqno
0006c8  4288              CMP      r0,r1
0006ca  d167              BNE      |L6.1948|
;;;1217           /* The incoming segment is the next in sequence. We check if
;;;1218              we have to trim the end of the segment and update rcv_nxt
;;;1219              and pass the data to the application. */
;;;1220           tcplen = TCP_TCPLEN(&inseg);
0006cc  497a              LDR      r1,|L6.2232|
0006ce  6909              LDR      r1,[r1,#0x10]  ; inseg
0006d0  8988              LDRH     r0,[r1,#0xc]
0006d2  f7fffffe          BL       lwip_ntohs
0006d6  f0000003          AND      r0,r0,#3
0006da  b108              CBZ      r0,|L6.1760|
0006dc  2001              MOVS     r0,#1
0006de  e000              B        |L6.1762|
                  |L6.1760|
0006e0  2000              MOVS     r0,#0
                  |L6.1762|
0006e2  4975              LDR      r1,|L6.2232|
0006e4  8909              LDRH     r1,[r1,#8]  ; inseg
0006e6  4408              ADD      r0,r0,r1
0006e8  4971              LDR      r1,|L6.2224|
0006ea  8008              STRH     r0,[r1,#0]
;;;1221   
;;;1222           if (tcplen > pcb->rcv_wnd) {
0006ec  8da0              LDRH     r0,[r4,#0x2c]
0006ee  8809              LDRH     r1,[r1,#0]  ; tcplen
0006f0  4288              CMP      r0,r1
0006f2  da5b              BGE      |L6.1964|
;;;1223             LWIP_DEBUGF(TCP_INPUT_DEBUG, 
0006f4  bf00              NOP      
0006f6  bf00              NOP      
;;;1224                         ("tcp_receive: other end overran receive window"
;;;1225                          "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1226                          seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1227             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
0006f8  496f              LDR      r1,|L6.2232|
0006fa  6909              LDR      r1,[r1,#0x10]  ; inseg
0006fc  8988              LDRH     r0,[r1,#0xc]
0006fe  f7fffffe          BL       lwip_ntohs
000702  f0000001          AND      r0,r0,#1
000706  b198              CBZ      r0,|L6.1840|
;;;1228               /* Must remove the FIN from the header as we're trimming 
;;;1229                * that byte of sequence-space from the packet */
;;;1230               TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
000708  496b              LDR      r1,|L6.2232|
00070a  6909              LDR      r1,[r1,#0x10]  ; inseg
00070c  8988              LDRH     r0,[r1,#0xc]
00070e  f7fffffe          BL       lwip_ntohs
000712  f0000b3e          AND      r11,r0,#0x3e
000716  4658              MOV      r0,r11
000718  f7fffffe          BL       lwip_htons
00071c  4966              LDR      r1,|L6.2232|
00071e  6909              LDR      r1,[r1,#0x10]  ; inseg
000720  8989              LDRH     r1,[r1,#0xc]
000722  f24c02ff          MOV      r2,#0xc0ff
000726  4011              ANDS     r1,r1,r2
000728  4308              ORRS     r0,r0,r1
00072a  4963              LDR      r1,|L6.2232|
00072c  6909              LDR      r1,[r1,#0x10]  ; inseg
00072e  8188              STRH     r0,[r1,#0xc]
                  |L6.1840|
;;;1231             }
;;;1232             /* Adjust length of segment to fit in the window. */
;;;1233             inseg.len = pcb->rcv_wnd;
000730  8da0              LDRH     r0,[r4,#0x2c]
000732  4961              LDR      r1,|L6.2232|
000734  8108              STRH     r0,[r1,#8]
;;;1234             if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
000736  6909              LDR      r1,[r1,#0x10]  ; inseg
000738  8988              LDRH     r0,[r1,#0xc]
00073a  f7fffffe          BL       lwip_ntohs
00073e  f0000002          AND      r0,r0,#2
000742  b120              CBZ      r0,|L6.1870|
;;;1235               inseg.len -= 1;
000744  485c              LDR      r0,|L6.2232|
000746  8900              LDRH     r0,[r0,#8]  ; inseg
000748  1e40              SUBS     r0,r0,#1
00074a  495b              LDR      r1,|L6.2232|
00074c  8108              STRH     r0,[r1,#8]
                  |L6.1870|
;;;1236             }
;;;1237             pbuf_realloc(inseg.p, inseg.len);
00074e  4a5a              LDR      r2,|L6.2232|
000750  8911              LDRH     r1,[r2,#8]  ; inseg
000752  6850              LDR      r0,[r2,#4]  ; inseg
000754  f7fffffe          BL       pbuf_realloc
;;;1238             tcplen = TCP_TCPLEN(&inseg);
000758  4957              LDR      r1,|L6.2232|
00075a  6909              LDR      r1,[r1,#0x10]  ; inseg
00075c  8988              LDRH     r0,[r1,#0xc]
00075e  f7fffffe          BL       lwip_ntohs
000762  f0000003          AND      r0,r0,#3
000766  b108              CBZ      r0,|L6.1900|
000768  2001              MOVS     r0,#1
00076a  e000              B        |L6.1902|
                  |L6.1900|
00076c  2000              MOVS     r0,#0
                  |L6.1902|
00076e  4952              LDR      r1,|L6.2232|
000770  8909              LDRH     r1,[r1,#8]  ; inseg
000772  4408              ADD      r0,r0,r1
000774  494e              LDR      r1,|L6.2224|
000776  8008              STRH     r0,[r1,#0]
;;;1239             LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
000778  bf00              NOP      
00077a  8da1              LDRH     r1,[r4,#0x2c]
00077c  6aa0              LDR      r0,[r4,#0x28]
00077e  4408              ADD      r0,r0,r1
000780  494c              LDR      r1,|L6.2228|
000782  6809              LDR      r1,[r1,#0]  ; seqno
000784  4a4a              LDR      r2,|L6.2224|
000786  8812              LDRH     r2,[r2,#0]  ; tcplen
000788  4411              ADD      r1,r1,r2
00078a  4288              CMP      r0,r1
00078c  d00d              BEQ      |L6.1962|
00078e  bf00              NOP      
000790  f2af33e4          ADR      r3,|L6.944|
000794  f24042d7          MOV      r2,#0x4d7
000798  e001              B        |L6.1950|
                  |L6.1946|
00079a  e2b1              B        |L6.3328|
                  |L6.1948|
00079c  e1b7              B        |L6.2830|
                  |L6.1950|
00079e  a158              ADR      r1,|L6.2304|
0007a0  f2af30b0          ADR      r0,|L6.1012|
0007a4  f7fffffe          BL       __2printf
0007a8  bf00              NOP      
                  |L6.1962|
0007aa  bf00              NOP      
                  |L6.1964|
;;;1240                         (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1241           }
;;;1242   #if TCP_QUEUE_OOSEQ
;;;1243           /* Received in-sequence data, adjust ooseq data if:
;;;1244              - FIN has been received or
;;;1245              - inseq overlaps with ooseq */
;;;1246           if (pcb->ooseq != NULL) {
0007ac  6f60              LDR      r0,[r4,#0x74]
0007ae  2800              CMP      r0,#0
0007b0  d016              BEQ      |L6.2016|
;;;1247             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
0007b2  4941              LDR      r1,|L6.2232|
0007b4  6909              LDR      r1,[r1,#0x10]  ; inseg
0007b6  8988              LDRH     r0,[r1,#0xc]
0007b8  f7fffffe          BL       lwip_ntohs
0007bc  f0000001          AND      r0,r0,#1
0007c0  b178              CBZ      r0,|L6.2018|
;;;1248               LWIP_DEBUGF(TCP_INPUT_DEBUG, 
0007c2  bf00              NOP      
0007c4  bf00              NOP      
;;;1249                           ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
;;;1250               /* Received in-order FIN means anything that was received
;;;1251                * out of order must now have been received in-order, so
;;;1252                * bin the ooseq queue */
;;;1253               while (pcb->ooseq != NULL) {
0007c6  e008              B        |L6.2010|
                  |L6.1992|
;;;1254                 struct tcp_seg *old_ooseq = pcb->ooseq;
0007c8  f8d4b074          LDR      r11,[r4,#0x74]
;;;1255                 pcb->ooseq = pcb->ooseq->next;
0007cc  6f60              LDR      r0,[r4,#0x74]
0007ce  6800              LDR      r0,[r0,#0]
0007d0  6760              STR      r0,[r4,#0x74]
;;;1256                 tcp_seg_free(old_ooseq);
0007d2  4658              MOV      r0,r11
0007d4  f7fffffe          BL       tcp_seg_free
;;;1257               }
0007d8  bf00              NOP      
                  |L6.2010|
0007da  6f60              LDR      r0,[r4,#0x74]         ;1253
0007dc  2800              CMP      r0,#0                 ;1253
0007de  d1f3              BNE      |L6.1992|
                  |L6.2016|
0007e0  e0cf              B        |L6.2434|
                  |L6.2018|
;;;1258             } else {
;;;1259               next = pcb->ooseq;
0007e2  6f65              LDR      r5,[r4,#0x74]
;;;1260               /* Remove all segments on ooseq that are covered by inseg already.
;;;1261                * FIN is copied from ooseq to inseg if present. */
;;;1262               while (next &&
0007e4  e02d              B        |L6.2114|
                  |L6.2022|
;;;1263                      TCP_SEQ_GEQ(seqno + tcplen,
;;;1264                                  next->tcphdr->seqno + next->len)) {
;;;1265                 /* inseg cannot have FIN here (already processed above) */
;;;1266                 if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
0007e6  6929              LDR      r1,[r5,#0x10]
0007e8  8988              LDRH     r0,[r1,#0xc]
0007ea  f7fffffe          BL       lwip_ntohs
0007ee  f0000001          AND      r0,r0,#1
0007f2  b308              CBZ      r0,|L6.2104|
;;;1267                     (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
0007f4  4930              LDR      r1,|L6.2232|
0007f6  6909              LDR      r1,[r1,#0x10]  ; inseg
0007f8  8988              LDRH     r0,[r1,#0xc]
0007fa  f7fffffe          BL       lwip_ntohs
0007fe  f0000002          AND      r0,r0,#2
000802  b9c8              CBNZ     r0,|L6.2104|
;;;1268                   TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
000804  2001              MOVS     r0,#1
000806  f7fffffe          BL       lwip_htons
00080a  492b              LDR      r1,|L6.2232|
00080c  6909              LDR      r1,[r1,#0x10]  ; inseg
00080e  8989              LDRH     r1,[r1,#0xc]
000810  4308              ORRS     r0,r0,r1
000812  4929              LDR      r1,|L6.2232|
000814  6909              LDR      r1,[r1,#0x10]  ; inseg
000816  8188              STRH     r0,[r1,#0xc]
;;;1269                   tcplen = TCP_TCPLEN(&inseg);
000818  4927              LDR      r1,|L6.2232|
00081a  6909              LDR      r1,[r1,#0x10]  ; inseg
00081c  8988              LDRH     r0,[r1,#0xc]
00081e  f7fffffe          BL       lwip_ntohs
000822  f0000003          AND      r0,r0,#3
000826  b108              CBZ      r0,|L6.2092|
000828  2001              MOVS     r0,#1
00082a  e000              B        |L6.2094|
                  |L6.2092|
00082c  2000              MOVS     r0,#0
                  |L6.2094|
00082e  4922              LDR      r1,|L6.2232|
000830  8909              LDRH     r1,[r1,#8]  ; inseg
000832  4408              ADD      r0,r0,r1
000834  491e              LDR      r1,|L6.2224|
000836  8008              STRH     r0,[r1,#0]
                  |L6.2104|
;;;1270                 }
;;;1271                 prev = next;
000838  462f              MOV      r7,r5
;;;1272                 next = next->next;
00083a  682d              LDR      r5,[r5,#0]
;;;1273                 tcp_seg_free(prev);
00083c  4638              MOV      r0,r7
00083e  f7fffffe          BL       tcp_seg_free
                  |L6.2114|
000842  b155              CBZ      r5,|L6.2138|
000844  6928              LDR      r0,[r5,#0x10]         ;1263
000846  6840              LDR      r0,[r0,#4]            ;1263
000848  8929              LDRH     r1,[r5,#8]            ;1263
00084a  4408              ADD      r0,r0,r1              ;1263
00084c  4919              LDR      r1,|L6.2228|
00084e  6809              LDR      r1,[r1,#0]            ;1263  ; seqno
000850  4a17              LDR      r2,|L6.2224|
000852  8812              LDRH     r2,[r2,#0]            ;1263  ; tcplen
000854  4411              ADD      r1,r1,r2              ;1263
000856  1a08              SUBS     r0,r1,r0              ;1263
000858  d5c5              BPL      |L6.2022|
                  |L6.2138|
;;;1274               }
;;;1275               /* Now trim right side of inseg if it overlaps with the first
;;;1276                * segment on ooseq */
;;;1277               if (next &&
00085a  b31d              CBZ      r5,|L6.2212|
;;;1278                   TCP_SEQ_GT(seqno + tcplen,
00085c  4815              LDR      r0,|L6.2228|
00085e  6800              LDR      r0,[r0,#0]  ; seqno
000860  4913              LDR      r1,|L6.2224|
000862  8809              LDRH     r1,[r1,#0]  ; tcplen
000864  4408              ADD      r0,r0,r1
000866  6929              LDR      r1,[r5,#0x10]
000868  6849              LDR      r1,[r1,#4]
00086a  1a40              SUBS     r0,r0,r1
00086c  2800              CMP      r0,#0
00086e  dd19              BLE      |L6.2212|
;;;1279                              next->tcphdr->seqno)) {
;;;1280                 /* inseg cannot have FIN here (already processed above) */
;;;1281                 inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
000870  6928              LDR      r0,[r5,#0x10]
000872  8880              LDRH     r0,[r0,#4]
000874  490f              LDR      r1,|L6.2228|
000876  8809              LDRH     r1,[r1,#0]  ; seqno
000878  1a40              SUBS     r0,r0,r1
00087a  490f              LDR      r1,|L6.2232|
00087c  8108              STRH     r0,[r1,#8]
;;;1282                 if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
00087e  6909              LDR      r1,[r1,#0x10]  ; inseg
000880  8988              LDRH     r0,[r1,#0xc]
000882  f7fffffe          BL       lwip_ntohs
000886  f0000002          AND      r0,r0,#2
00088a  b120              CBZ      r0,|L6.2198|
;;;1283                   inseg.len -= 1;
00088c  480a              LDR      r0,|L6.2232|
00088e  8900              LDRH     r0,[r0,#8]  ; inseg
000890  1e40              SUBS     r0,r0,#1
000892  4909              LDR      r1,|L6.2232|
000894  8108              STRH     r0,[r1,#8]
                  |L6.2198|
;;;1284                 }
;;;1285                 pbuf_realloc(inseg.p, inseg.len);
000896  4a08              LDR      r2,|L6.2232|
000898  8911              LDRH     r1,[r2,#8]  ; inseg
00089a  6850              LDR      r0,[r2,#4]  ; inseg
00089c  f7fffffe          BL       pbuf_realloc
;;;1286                 tcplen = TCP_TCPLEN(&inseg);
0008a0  4905              LDR      r1,|L6.2232|
0008a2  e049              B        |L6.2360|
                  |L6.2212|
0008a4  e06c              B        |L6.2432|
0008a6  0000              DCW      0x0000
                  |L6.2216|
                          DCD      ackno
                  |L6.2220|
                          DCD      tcp_ticks
                  |L6.2224|
                          DCD      tcplen
                  |L6.2228|
                          DCD      seqno
                  |L6.2232|
                          DCD      inseg
                  |L6.2236|
0008bc  696e7365          DCB      "inseg.p != NULL",0
0008c0  672e7020
0008c4  213d204e
0008c8  554c4c00
                  |L6.2252|
0008cc  696e7361          DCB      "insane offset!",0
0008d0  6e65206f
0008d4  66667365
0008d8  742100  
0008db  00                DCB      0
                  |L6.2268|
0008dc  70627566          DCB      "pbuf too short!",0
0008e0  20746f6f
0008e4  2073686f
0008e8  72742100
                  |L6.2284|
0008ec  70627566          DCB      "pbuf_header failed",0
0008f0  5f686561
0008f4  64657220
0008f8  6661696c
0008fc  656400  
0008ff  00                DCB      0
                  |L6.2304|
000900  7463705f          DCB      "tcp_receive: segment not trimmed correctly to rcv_wnd\n"
000904  72656365
000908  6976653a
00090c  20736567
000910  6d656e74
000914  206e6f74
000918  20747269
00091c  6d6d6564
000920  20636f72
000924  72656374
000928  6c792074
00092c  6f207263
000930  765f776e
000934  640a    
000936  00                DCB      0
000937  00                DCB      0
                  |L6.2360|
000938  6909              LDR      r1,[r1,#0x10]  ; inseg
00093a  8988              LDRH     r0,[r1,#0xc]
00093c  f7fffffe          BL       lwip_ntohs
000940  f0000003          AND      r0,r0,#3
000944  b108              CBZ      r0,|L6.2378|
000946  2001              MOVS     r0,#1
000948  e000              B        |L6.2380|
                  |L6.2378|
00094a  2000              MOVS     r0,#0
                  |L6.2380|
00094c  49f9              LDR      r1,|L6.3380|
00094e  8909              LDRH     r1,[r1,#8]  ; inseg
000950  4408              ADD      r0,r0,r1
000952  49f9              LDR      r1,|L6.3384|
000954  8008              STRH     r0,[r1,#0]
;;;1287                 LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
000956  bf00              NOP      
000958  48f8              LDR      r0,|L6.3388|
00095a  6800              LDR      r0,[r0,#0]  ; seqno
00095c  8809              LDRH     r1,[r1,#0]  ; tcplen
00095e  4408              ADD      r0,r0,r1
000960  6929              LDR      r1,[r5,#0x10]
000962  6849              LDR      r1,[r1,#4]
000964  4288              CMP      r0,r1
000966  d00a              BEQ      |L6.2430|
000968  bf00              NOP      
00096a  f2af53bc          ADR      r3,|L6.944|
00096e  f2405207          MOV      r2,#0x507
000972  a1f3              ADR      r1,|L6.3392|
000974  f2af5084          ADR      r0,|L6.1012|
000978  f7fffffe          BL       __2printf
00097c  bf00              NOP      
                  |L6.2430|
00097e  bf00              NOP      
                  |L6.2432|
;;;1288                             (seqno + tcplen) == next->tcphdr->seqno);
;;;1289               }
;;;1290               pcb->ooseq = next;
000980  6765              STR      r5,[r4,#0x74]
                  |L6.2434|
;;;1291             }
;;;1292           }
;;;1293   #endif /* TCP_QUEUE_OOSEQ */
;;;1294   
;;;1295           pcb->rcv_nxt = seqno + tcplen;
000982  48ee              LDR      r0,|L6.3388|
000984  6800              LDR      r0,[r0,#0]  ; seqno
000986  49ec              LDR      r1,|L6.3384|
000988  8809              LDRH     r1,[r1,#0]  ; tcplen
00098a  4408              ADD      r0,r0,r1
00098c  62a0              STR      r0,[r4,#0x28]
;;;1296   
;;;1297           /* Update the receiver's (our) window. */
;;;1298           LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
00098e  bf00              NOP      
000990  8da0              LDRH     r0,[r4,#0x2c]
000992  49e9              LDR      r1,|L6.3384|
000994  8809              LDRH     r1,[r1,#0]  ; tcplen
000996  4288              CMP      r0,r1
000998  da0a              BGE      |L6.2480|
00099a  bf00              NOP      
00099c  f2af53f0          ADR      r3,|L6.944|
0009a0  f2405212          MOV      r2,#0x512
0009a4  a1f5              ADR      r1,|L6.3452|
0009a6  f2af50b4          ADR      r0,|L6.1012|
0009aa  f7fffffe          BL       __2printf
0009ae  bf00              NOP      
                  |L6.2480|
0009b0  bf00              NOP      
;;;1299           pcb->rcv_wnd -= tcplen;
0009b2  8da0              LDRH     r0,[r4,#0x2c]
0009b4  49e0              LDR      r1,|L6.3384|
0009b6  8809              LDRH     r1,[r1,#0]  ; tcplen
0009b8  1a40              SUBS     r0,r0,r1
0009ba  85a0              STRH     r0,[r4,#0x2c]
;;;1300   
;;;1301           tcp_update_rcv_ann_wnd(pcb);
0009bc  4620              MOV      r0,r4
0009be  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;1302   
;;;1303           /* If there is data in the segment, we make preparations to
;;;1304              pass this up to the application. The ->recv_data variable
;;;1305              is used for holding the pbuf that goes to the
;;;1306              application. The code for reassembling out-of-sequence data
;;;1307              chains its data on this pbuf as well.
;;;1308   
;;;1309              If the segment was a FIN, we set the TF_GOT_FIN flag that will
;;;1310              be used to indicate to the application that the remote side has
;;;1311              closed its end of the connection. */
;;;1312           if (inseg.p->tot_len > 0) {
0009c2  48dc              LDR      r0,|L6.3380|
0009c4  6840              LDR      r0,[r0,#4]  ; inseg
0009c6  8900              LDRH     r0,[r0,#8]
0009c8  2800              CMP      r0,#0
0009ca  dd06              BLE      |L6.2522|
;;;1313             recv_data = inseg.p;
0009cc  48d9              LDR      r0,|L6.3380|
0009ce  6840              LDR      r0,[r0,#4]  ; inseg
0009d0  49f2              LDR      r1,|L6.3484|
0009d2  6008              STR      r0,[r1,#0]  ; recv_data
;;;1314             /* Since this pbuf now is the responsibility of the
;;;1315                application, we delete our reference to it so that we won't
;;;1316                (mistakingly) deallocate it. */
;;;1317             inseg.p = NULL;
0009d4  2000              MOVS     r0,#0
0009d6  49d7              LDR      r1,|L6.3380|
0009d8  6048              STR      r0,[r1,#4]  ; inseg
                  |L6.2522|
;;;1318           }
;;;1319           if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
0009da  49d6              LDR      r1,|L6.3380|
0009dc  6909              LDR      r1,[r1,#0x10]  ; inseg
0009de  8988              LDRH     r0,[r1,#0xc]
0009e0  f7fffffe          BL       lwip_ntohs
0009e4  f0000001          AND      r0,r0,#1
0009e8  b138              CBZ      r0,|L6.2554|
;;;1320             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
0009ea  bf00              NOP      
0009ec  bf00              NOP      
;;;1321             recv_flags |= TF_GOT_FIN;
0009ee  48ec              LDR      r0,|L6.3488|
0009f0  7800              LDRB     r0,[r0,#0]  ; recv_flags
0009f2  f0400020          ORR      r0,r0,#0x20
0009f6  49ea              LDR      r1,|L6.3488|
0009f8  7008              STRB     r0,[r1,#0]
                  |L6.2554|
;;;1322           }
;;;1323   
;;;1324   #if TCP_QUEUE_OOSEQ
;;;1325           /* We now check if we have segments on the ->ooseq queue that
;;;1326              are now in sequence. */
;;;1327           while (pcb->ooseq != NULL &&
0009fa  e06d              B        |L6.2776|
                  |L6.2556|
;;;1328                  pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
;;;1329   
;;;1330             cseg = pcb->ooseq;
0009fc  6f66              LDR      r6,[r4,#0x74]
;;;1331             seqno = pcb->ooseq->tcphdr->seqno;
0009fe  6f60              LDR      r0,[r4,#0x74]
000a00  6900              LDR      r0,[r0,#0x10]
000a02  6840              LDR      r0,[r0,#4]
000a04  49cd              LDR      r1,|L6.3388|
000a06  6008              STR      r0,[r1,#0]  ; seqno
;;;1332   
;;;1333             pcb->rcv_nxt += TCP_TCPLEN(cseg);
000a08  6931              LDR      r1,[r6,#0x10]
000a0a  8988              LDRH     r0,[r1,#0xc]
000a0c  f7fffffe          BL       lwip_ntohs
000a10  f0000003          AND      r0,r0,#3
000a14  b108              CBZ      r0,|L6.2586|
000a16  2001              MOVS     r0,#1
000a18  e000              B        |L6.2588|
                  |L6.2586|
000a1a  2000              MOVS     r0,#0
                  |L6.2588|
000a1c  8931              LDRH     r1,[r6,#8]
000a1e  4408              ADD      r0,r0,r1
000a20  6aa1              LDR      r1,[r4,#0x28]
000a22  4408              ADD      r0,r0,r1
000a24  62a0              STR      r0,[r4,#0x28]
;;;1334             LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
000a26  bf00              NOP      
000a28  6931              LDR      r1,[r6,#0x10]
000a2a  8988              LDRH     r0,[r1,#0xc]
000a2c  f7fffffe          BL       lwip_ntohs
000a30  f0000003          AND      r0,r0,#3
000a34  b108              CBZ      r0,|L6.2618|
000a36  2001              MOVS     r0,#1
000a38  e000              B        |L6.2620|
                  |L6.2618|
000a3a  2000              MOVS     r0,#0
                  |L6.2620|
000a3c  8931              LDRH     r1,[r6,#8]
000a3e  4408              ADD      r0,r0,r1
000a40  8da1              LDRH     r1,[r4,#0x2c]
000a42  4288              CMP      r0,r1
000a44  dd0a              BLE      |L6.2652|
000a46  bf00              NOP      
000a48  f2af639c          ADR      r3,|L6.944|
000a4c  f2405236          MOV      r2,#0x536
000a50  a1d4              ADR      r1,|L6.3492|
000a52  f2af6060          ADR      r0,|L6.1012|
000a56  f7fffffe          BL       __2printf
000a5a  bf00              NOP      
                  |L6.2652|
000a5c  bf00              NOP      
;;;1335                         pcb->rcv_wnd >= TCP_TCPLEN(cseg));
;;;1336             pcb->rcv_wnd -= TCP_TCPLEN(cseg);
000a5e  6931              LDR      r1,[r6,#0x10]
000a60  8988              LDRH     r0,[r1,#0xc]
000a62  f7fffffe          BL       lwip_ntohs
000a66  f0000003          AND      r0,r0,#3
000a6a  b108              CBZ      r0,|L6.2672|
000a6c  2001              MOVS     r0,#1
000a6e  e000              B        |L6.2674|
                  |L6.2672|
000a70  2000              MOVS     r0,#0
                  |L6.2674|
000a72  8931              LDRH     r1,[r6,#8]
000a74  4408              ADD      r0,r0,r1
000a76  8da1              LDRH     r1,[r4,#0x2c]
000a78  1a08              SUBS     r0,r1,r0
000a7a  85a0              STRH     r0,[r4,#0x2c]
;;;1337   
;;;1338             tcp_update_rcv_ann_wnd(pcb);
000a7c  4620              MOV      r0,r4
000a7e  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;1339   
;;;1340             if (cseg->p->tot_len > 0) {
000a82  6870              LDR      r0,[r6,#4]
000a84  8900              LDRH     r0,[r0,#8]
000a86  2800              CMP      r0,#0
000a88  dd0d              BLE      |L6.2726|
;;;1341               /* Chain this pbuf onto the pbuf that we will pass to
;;;1342                  the application. */
;;;1343               if (recv_data) {
000a8a  48c4              LDR      r0,|L6.3484|
000a8c  6800              LDR      r0,[r0,#0]  ; recv_data
000a8e  b128              CBZ      r0,|L6.2716|
;;;1344                 pbuf_cat(recv_data, cseg->p);
000a90  48c2              LDR      r0,|L6.3484|
000a92  6871              LDR      r1,[r6,#4]
000a94  6800              LDR      r0,[r0,#0]  ; recv_data
000a96  f7fffffe          BL       pbuf_cat
000a9a  e002              B        |L6.2722|
                  |L6.2716|
;;;1345               } else {
;;;1346                 recv_data = cseg->p;
000a9c  49bf              LDR      r1,|L6.3484|
000a9e  6870              LDR      r0,[r6,#4]
000aa0  6008              STR      r0,[r1,#0]  ; recv_data
                  |L6.2722|
;;;1347               }
;;;1348               cseg->p = NULL;
000aa2  2000              MOVS     r0,#0
000aa4  6070              STR      r0,[r6,#4]
                  |L6.2726|
;;;1349             }
;;;1350             if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
000aa6  6931              LDR      r1,[r6,#0x10]
000aa8  8988              LDRH     r0,[r1,#0xc]
000aaa  f7fffffe          BL       lwip_ntohs
000aae  f0000001          AND      r0,r0,#1
000ab2  b160              CBZ      r0,|L6.2766|
;;;1351               LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
000ab4  bf00              NOP      
000ab6  bf00              NOP      
;;;1352               recv_flags |= TF_GOT_FIN;
000ab8  48b9              LDR      r0,|L6.3488|
000aba  7800              LDRB     r0,[r0,#0]  ; recv_flags
000abc  f0400020          ORR      r0,r0,#0x20
000ac0  49b7              LDR      r1,|L6.3488|
000ac2  7008              STRB     r0,[r1,#0]
;;;1353               if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
000ac4  7e20              LDRB     r0,[r4,#0x18]
000ac6  2804              CMP      r0,#4
000ac8  d101              BNE      |L6.2766|
;;;1354                 pcb->state = CLOSE_WAIT;
000aca  2007              MOVS     r0,#7
000acc  7620              STRB     r0,[r4,#0x18]
                  |L6.2766|
;;;1355               } 
;;;1356             }
;;;1357   
;;;1358             pcb->ooseq = cseg->next;
000ace  6830              LDR      r0,[r6,#0]
000ad0  6760              STR      r0,[r4,#0x74]
;;;1359             tcp_seg_free(cseg);
000ad2  4630              MOV      r0,r6
000ad4  f7fffffe          BL       tcp_seg_free
                  |L6.2776|
000ad8  6f60              LDR      r0,[r4,#0x74]         ;1327
000ada  b128              CBZ      r0,|L6.2792|
000adc  6f60              LDR      r0,[r4,#0x74]         ;1328
000ade  6900              LDR      r0,[r0,#0x10]         ;1328
000ae0  6840              LDR      r0,[r0,#4]            ;1328
000ae2  6aa1              LDR      r1,[r4,#0x28]         ;1328
000ae4  4288              CMP      r0,r1                 ;1328
000ae6  d089              BEQ      |L6.2556|
                  |L6.2792|
;;;1360           }
;;;1361   #endif /* TCP_QUEUE_OOSEQ */
;;;1362   
;;;1363   
;;;1364           /* Acknowledge the segment(s). */
;;;1365           tcp_ack(pcb);
000ae8  bf00              NOP      
000aea  7fa0              LDRB     r0,[r4,#0x1e]
000aec  f0000001          AND      r0,r0,#1
000af0  b140              CBZ      r0,|L6.2820|
000af2  7fa0              LDRB     r0,[r4,#0x1e]
000af4  f0200001          BIC      r0,r0,#1
000af8  77a0              STRB     r0,[r4,#0x1e]
000afa  7fa0              LDRB     r0,[r4,#0x1e]
000afc  f0400002          ORR      r0,r0,#2
000b00  77a0              STRB     r0,[r4,#0x1e]
000b02  e003              B        |L6.2828|
                  |L6.2820|
000b04  7fa0              LDRB     r0,[r4,#0x1e]
000b06  f0400001          ORR      r0,r0,#1
000b0a  77a0              STRB     r0,[r4,#0x1e]
                  |L6.2828|
000b0c  e110              B        |L6.3376|
                  |L6.2830|
;;;1366   
;;;1367         } else {
;;;1368           /* We get here if the incoming segment is out-of-sequence. */
;;;1369           tcp_send_empty_ack(pcb);
000b0e  4620              MOV      r0,r4
000b10  f7fffffe          BL       tcp_send_empty_ack
;;;1370   #if TCP_QUEUE_OOSEQ
;;;1371           /* We queue the segment on the ->ooseq queue. */
;;;1372           if (pcb->ooseq == NULL) {
000b14  6f60              LDR      r0,[r4,#0x74]
000b16  b920              CBNZ     r0,|L6.2850|
;;;1373             pcb->ooseq = tcp_seg_copy(&inseg);
000b18  4886              LDR      r0,|L6.3380|
000b1a  f7fffffe          BL       tcp_seg_copy
000b1e  6760              STR      r0,[r4,#0x74]
000b20  e106              B        |L6.3376|
                  |L6.2850|
;;;1374           } else {
;;;1375             /* If the queue is not empty, we walk through the queue and
;;;1376                try to find a place where the sequence number of the
;;;1377                incoming segment is between the sequence numbers of the
;;;1378                previous and the next segment on the ->ooseq queue. That is
;;;1379                the place where we put the incoming segment. If needed, we
;;;1380                trim the second edges of the previous and the incoming
;;;1381                segment so that it will fit into the sequence.
;;;1382   
;;;1383                If the incoming segment has the same sequence number as a
;;;1384                segment on the ->ooseq queue, we discard the segment that
;;;1385                contains less data. */
;;;1386   
;;;1387             prev = NULL;
000b22  2700              MOVS     r7,#0
;;;1388             for(next = pcb->ooseq; next != NULL; next = next->next) {
000b24  6f65              LDR      r5,[r4,#0x74]
000b26  e0e7              B        |L6.3320|
                  |L6.2856|
;;;1389               if (seqno == next->tcphdr->seqno) {
000b28  6928              LDR      r0,[r5,#0x10]
000b2a  6840              LDR      r0,[r0,#4]
000b2c  4983              LDR      r1,|L6.3388|
000b2e  6809              LDR      r1,[r1,#0]  ; seqno
000b30  4288              CMP      r0,r1
000b32  d113              BNE      |L6.2908|
;;;1390                 /* The sequence number of the incoming segment is the
;;;1391                    same as the sequence number of the segment on
;;;1392                    ->ooseq. We check the lengths to see which one to
;;;1393                    discard. */
;;;1394                 if (inseg.len > next->len) {
000b34  487f              LDR      r0,|L6.3380|
000b36  8900              LDRH     r0,[r0,#8]  ; inseg
000b38  8929              LDRH     r1,[r5,#8]
000b3a  4288              CMP      r0,r1
000b3c  dd0d              BLE      |L6.2906|
;;;1395                   /* The incoming segment is larger than the old
;;;1396                      segment. We replace some segments with the new
;;;1397                      one. */
;;;1398                   cseg = tcp_seg_copy(&inseg);
000b3e  487d              LDR      r0,|L6.3380|
000b40  f7fffffe          BL       tcp_seg_copy
000b44  4606              MOV      r6,r0
;;;1399                   if (cseg != NULL) {
000b46  b13e              CBZ      r6,|L6.2904|
;;;1400                     if (prev != NULL) {
000b48  b10f              CBZ      r7,|L6.2894|
;;;1401                       prev->next = cseg;
000b4a  603e              STR      r6,[r7,#0]
000b4c  e000              B        |L6.2896|
                  |L6.2894|
;;;1402                     } else {
;;;1403                       pcb->ooseq = cseg;
000b4e  6766              STR      r6,[r4,#0x74]
                  |L6.2896|
;;;1404                     }
;;;1405                     tcp_oos_insert_segment(cseg, next);
000b50  4629              MOV      r1,r5
000b52  4630              MOV      r0,r6
000b54  f7fffffe          BL       tcp_oos_insert_segment
                  |L6.2904|
;;;1406                   }
;;;1407                   break;
000b58  e0d1              B        |L6.3326|
                  |L6.2906|
;;;1408                 } else {
;;;1409                   /* Either the lenghts are the same or the incoming
;;;1410                      segment was smaller than the old one; in either
;;;1411                      case, we ditch the incoming segment. */
;;;1412                   break;
000b5a  e0d0              B        |L6.3326|
                  |L6.2908|
;;;1413                 }
;;;1414               } else {
;;;1415                 if (prev == NULL) {
000b5c  b987              CBNZ     r7,|L6.2944|
;;;1416                   if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
000b5e  6928              LDR      r0,[r5,#0x10]
000b60  6840              LDR      r0,[r0,#4]
000b62  4976              LDR      r1,|L6.3388|
000b64  6809              LDR      r1,[r1,#0]  ; seqno
000b66  1a08              SUBS     r0,r1,r0
000b68  d537              BPL      |L6.3034|
;;;1417                     /* The sequence number of the incoming segment is lower
;;;1418                        than the sequence number of the first segment on the
;;;1419                        queue. We put the incoming segment first on the
;;;1420                        queue. */
;;;1421                     cseg = tcp_seg_copy(&inseg);
000b6a  4872              LDR      r0,|L6.3380|
000b6c  f7fffffe          BL       tcp_seg_copy
000b70  4606              MOV      r6,r0
;;;1422                     if (cseg != NULL) {
000b72  b126              CBZ      r6,|L6.2942|
;;;1423                       pcb->ooseq = cseg;
000b74  6766              STR      r6,[r4,#0x74]
;;;1424                       tcp_oos_insert_segment(cseg, next);
000b76  4629              MOV      r1,r5
000b78  4630              MOV      r0,r6
000b7a  f7fffffe          BL       tcp_oos_insert_segment
                  |L6.2942|
;;;1425                     }
;;;1426                     break;
000b7e  e0be              B        |L6.3326|
                  |L6.2944|
;;;1427                   }
;;;1428                 } else {
;;;1429                   /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
;;;1430                     TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
;;;1431                   if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
000b80  6938              LDR      r0,[r7,#0x10]
000b82  6840              LDR      r0,[r0,#4]
000b84  1c40              ADDS     r0,r0,#1
000b86  496d              LDR      r1,|L6.3388|
000b88  6809              LDR      r1,[r1,#0]  ; seqno
000b8a  1a08              SUBS     r0,r1,r0
000b8c  d425              BMI      |L6.3034|
000b8e  6928              LDR      r0,[r5,#0x10]
000b90  6840              LDR      r0,[r0,#4]
000b92  1e40              SUBS     r0,r0,#1
000b94  4969              LDR      r1,|L6.3388|
000b96  6809              LDR      r1,[r1,#0]  ; seqno
000b98  1a08              SUBS     r0,r1,r0
000b9a  2800              CMP      r0,#0
000b9c  dc1d              BGT      |L6.3034|
;;;1432                     /* The sequence number of the incoming segment is in
;;;1433                        between the sequence numbers of the previous and
;;;1434                        the next segment on ->ooseq. We trim trim the previous
;;;1435                        segment, delete next segments that included in received segment
;;;1436                        and trim received, if needed. */
;;;1437                     cseg = tcp_seg_copy(&inseg);
000b9e  4865              LDR      r0,|L6.3380|
000ba0  f7fffffe          BL       tcp_seg_copy
000ba4  4606              MOV      r6,r0
;;;1438                     if (cseg != NULL) {
000ba6  b1be              CBZ      r6,|L6.3032|
;;;1439                       if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
000ba8  6938              LDR      r0,[r7,#0x10]
000baa  6840              LDR      r0,[r0,#4]
000bac  8939              LDRH     r1,[r7,#8]
000bae  4408              ADD      r0,r0,r1
000bb0  4962              LDR      r1,|L6.3388|
000bb2  6809              LDR      r1,[r1,#0]  ; seqno
000bb4  1a40              SUBS     r0,r0,r1
000bb6  2800              CMP      r0,#0
000bb8  dd09              BLE      |L6.3022|
;;;1440                         /* We need to trim the prev segment. */
;;;1441                         prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
000bba  6938              LDR      r0,[r7,#0x10]
000bbc  8880              LDRH     r0,[r0,#4]
000bbe  495f              LDR      r1,|L6.3388|
000bc0  8809              LDRH     r1,[r1,#0]  ; seqno
000bc2  1a08              SUBS     r0,r1,r0
000bc4  8138              STRH     r0,[r7,#8]
;;;1442                         pbuf_realloc(prev->p, prev->len);
000bc6  8939              LDRH     r1,[r7,#8]
000bc8  6878              LDR      r0,[r7,#4]
000bca  f7fffffe          BL       pbuf_realloc
                  |L6.3022|
;;;1443                       }
;;;1444                       prev->next = cseg;
000bce  603e              STR      r6,[r7,#0]
;;;1445                       tcp_oos_insert_segment(cseg, next);
000bd0  4629              MOV      r1,r5
000bd2  4630              MOV      r0,r6
000bd4  f7fffffe          BL       tcp_oos_insert_segment
                  |L6.3032|
;;;1446                     }
;;;1447                     break;
000bd8  e091              B        |L6.3326|
                  |L6.3034|
;;;1448                   }
;;;1449                 }
;;;1450                 /* If the "next" segment is the last segment on the
;;;1451                    ooseq queue, we add the incoming segment to the end
;;;1452                    of the list. */
;;;1453                 if (next->next == NULL &&
000bda  6828              LDR      r0,[r5,#0]
000bdc  2800              CMP      r0,#0
000bde  d17d              BNE      |L6.3292|
;;;1454                     TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
000be0  6928              LDR      r0,[r5,#0x10]
000be2  6840              LDR      r0,[r0,#4]
000be4  4955              LDR      r1,|L6.3388|
000be6  6809              LDR      r1,[r1,#0]  ; seqno
000be8  1a08              SUBS     r0,r1,r0
000bea  2800              CMP      r0,#0
000bec  dd76              BLE      |L6.3292|
;;;1455                   if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
000bee  6929              LDR      r1,[r5,#0x10]
000bf0  8988              LDRH     r0,[r1,#0xc]
000bf2  f7fffffe          BL       lwip_ntohs
000bf6  f0000001          AND      r0,r0,#1
000bfa  b100              CBZ      r0,|L6.3070|
;;;1456                     /* segment "next" already contains all data */
;;;1457                     break;
000bfc  e07f              B        |L6.3326|
                  |L6.3070|
;;;1458                   }
;;;1459                   next->next = tcp_seg_copy(&inseg);
000bfe  484d              LDR      r0,|L6.3380|
000c00  f7fffffe          BL       tcp_seg_copy
000c04  6028              STR      r0,[r5,#0]
;;;1460                   if (next->next != NULL) {
000c06  6828              LDR      r0,[r5,#0]
000c08  b3f0              CBZ      r0,|L6.3208|
;;;1461                     if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
000c0a  6928              LDR      r0,[r5,#0x10]
000c0c  6840              LDR      r0,[r0,#4]
000c0e  8929              LDRH     r1,[r5,#8]
000c10  4408              ADD      r0,r0,r1
000c12  494a              LDR      r1,|L6.3388|
000c14  6809              LDR      r1,[r1,#0]  ; seqno
000c16  1a40              SUBS     r0,r0,r1
000c18  2800              CMP      r0,#0
000c1a  dd09              BLE      |L6.3120|
;;;1462                       /* We need to trim the last segment. */
;;;1463                       next->len = (u16_t)(seqno - next->tcphdr->seqno);
000c1c  6928              LDR      r0,[r5,#0x10]
000c1e  8880              LDRH     r0,[r0,#4]
000c20  4946              LDR      r1,|L6.3388|
000c22  8809              LDRH     r1,[r1,#0]  ; seqno
000c24  1a08              SUBS     r0,r1,r0
000c26  8128              STRH     r0,[r5,#8]
;;;1464                       pbuf_realloc(next->p, next->len);
000c28  8929              LDRH     r1,[r5,#8]
000c2a  6868              LDR      r0,[r5,#4]
000c2c  f7fffffe          BL       pbuf_realloc
                  |L6.3120|
;;;1465                     }
;;;1466                     /* check if the remote side overruns our receive window */
;;;1467                     if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
000c30  8da1              LDRH     r1,[r4,#0x2c]
000c32  6aa0              LDR      r0,[r4,#0x28]
000c34  4401              ADD      r1,r1,r0
000c36  4840              LDR      r0,|L6.3384|
000c38  8800              LDRH     r0,[r0,#0]  ; tcplen
000c3a  4a40              LDR      r2,|L6.3388|
000c3c  6812              LDR      r2,[r2,#0]  ; seqno
000c3e  4410              ADD      r0,r0,r2
000c40  4281              CMP      r1,r0
000c42  d256              BCS      |L6.3314|
;;;1468                       LWIP_DEBUGF(TCP_INPUT_DEBUG, 
000c44  bf00              NOP      
000c46  bf00              NOP      
;;;1469                                   ("tcp_receive: other end overran receive window"
;;;1470                                    "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1471                                    seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1472                       if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
000c48  6829              LDR      r1,[r5,#0]
000c4a  6909              LDR      r1,[r1,#0x10]
000c4c  8988              LDRH     r0,[r1,#0xc]
000c4e  f7fffffe          BL       lwip_ntohs
000c52  f0000001          AND      r0,r0,#1
000c56  b198              CBZ      r0,|L6.3200|
;;;1473                         /* Must remove the FIN from the header as we're trimming 
;;;1474                          * that byte of sequence-space from the packet */
;;;1475                         TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
000c58  6829              LDR      r1,[r5,#0]
000c5a  6909              LDR      r1,[r1,#0x10]
000c5c  8988              LDRH     r0,[r1,#0xc]
000c5e  f7fffffe          BL       lwip_ntohs
000c62  f0000b3e          AND      r11,r0,#0x3e
000c66  4658              MOV      r0,r11
000c68  f7fffffe          BL       lwip_htons
000c6c  6829              LDR      r1,[r5,#0]
000c6e  6909              LDR      r1,[r1,#0x10]
000c70  8989              LDRH     r1,[r1,#0xc]
000c72  f24c02ff          MOV      r2,#0xc0ff
000c76  4011              ANDS     r1,r1,r2
000c78  4308              ORRS     r0,r0,r1
000c7a  6829              LDR      r1,[r5,#0]
000c7c  6909              LDR      r1,[r1,#0x10]
000c7e  8188              STRH     r0,[r1,#0xc]
                  |L6.3200|
;;;1476                       }
;;;1477                       /* Adjust length of segment to fit in the window. */
;;;1478                       next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
000c80  8d20              LDRH     r0,[r4,#0x28]
000c82  8da1              LDRH     r1,[r4,#0x2c]
000c84  4408              ADD      r0,r0,r1
000c86  e000              B        |L6.3210|
                  |L6.3208|
000c88  e033              B        |L6.3314|
                  |L6.3210|
000c8a  492c              LDR      r1,|L6.3388|
000c8c  8809              LDRH     r1,[r1,#0]  ; seqno
000c8e  1a40              SUBS     r0,r0,r1
000c90  6829              LDR      r1,[r5,#0]
000c92  8108              STRH     r0,[r1,#8]
;;;1479                       pbuf_realloc(next->next->p, next->next->len);
000c94  682a              LDR      r2,[r5,#0]
000c96  8911              LDRH     r1,[r2,#8]
000c98  6850              LDR      r0,[r2,#4]
000c9a  f7fffffe          BL       pbuf_realloc
;;;1480                       tcplen = TCP_TCPLEN(next->next);
000c9e  6829              LDR      r1,[r5,#0]
000ca0  6909              LDR      r1,[r1,#0x10]
000ca2  8988              LDRH     r0,[r1,#0xc]
000ca4  f7fffffe          BL       lwip_ntohs
000ca8  f0000003          AND      r0,r0,#3
000cac  b108              CBZ      r0,|L6.3250|
000cae  2001              MOVS     r0,#1
000cb0  e000              B        |L6.3252|
                  |L6.3250|
000cb2  2000              MOVS     r0,#0
                  |L6.3252|
000cb4  6829              LDR      r1,[r5,#0]
000cb6  8909              LDRH     r1,[r1,#8]
000cb8  4408              ADD      r0,r0,r1
000cba  491f              LDR      r1,|L6.3384|
000cbc  8008              STRH     r0,[r1,#0]
;;;1481                       LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
000cbe  bf00              NOP      
000cc0  8da1              LDRH     r1,[r4,#0x2c]
000cc2  6aa0              LDR      r0,[r4,#0x28]
000cc4  4408              ADD      r0,r0,r1
000cc6  491d              LDR      r1,|L6.3388|
000cc8  6809              LDR      r1,[r1,#0]  ; seqno
000cca  4a1b              LDR      r2,|L6.3384|
000ccc  8812              LDRH     r2,[r2,#0]  ; tcplen
000cce  4411              ADD      r1,r1,r2
000cd0  4288              CMP      r0,r1
000cd2  d00d              BEQ      |L6.3312|
000cd4  bf00              NOP      
000cd6  f6af1328          ADR      r3,|L6.944|
000cda  e000              B        |L6.3294|
                  |L6.3292|
000cdc  e00a              B        |L6.3316|
                  |L6.3294|
000cde  f24052c9          MOV      r2,#0x5c9
000ce2  f2af31e4          ADR      r1,|L6.2304|
000ce6  f6af00f4          ADR      r0,|L6.1012|
000cea  f7fffffe          BL       __2printf
000cee  bf00              NOP      
                  |L6.3312|
000cf0  bf00              NOP      
                  |L6.3314|
;;;1482                                   (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1483                     }
;;;1484                   }
;;;1485                   break;
000cf2  e004              B        |L6.3326|
                  |L6.3316|
;;;1486                 }
;;;1487               }
;;;1488               prev = next;
000cf4  462f              MOV      r7,r5
000cf6  682d              LDR      r5,[r5,#0]            ;1388
                  |L6.3320|
000cf8  2d00              CMP      r5,#0                 ;1388
000cfa  f47faf15          BNE      |L6.2856|
                  |L6.3326|
000cfe  e017              B        |L6.3376|
                  |L6.3328|
;;;1489             }
;;;1490           }
;;;1491   #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
;;;1492           /* Check that the data on ooseq doesn't exceed one of the limits
;;;1493              and throw away everything above that limit. */
;;;1494           ooseq_blen = 0;
;;;1495           ooseq_qlen = 0;
;;;1496           prev = NULL;
;;;1497           for(next = pcb->ooseq; next != NULL; prev = next, next = next->next) {
;;;1498             struct pbuf *p = next->p;
;;;1499             ooseq_blen += p->tot_len;
;;;1500             ooseq_qlen += pbuf_clen(p);
;;;1501             if ((ooseq_blen > TCP_OOSEQ_MAX_BYTES) ||
;;;1502                 (ooseq_qlen > TCP_OOSEQ_MAX_PBUFS)) {
;;;1503                /* too much ooseq data, dump this and everything after it */
;;;1504                tcp_segs_free(next);
;;;1505                if (prev == NULL) {
;;;1506                  /* first ooseq segment is too much, dump the whole queue */
;;;1507                  pcb->ooseq = NULL;
;;;1508                } else {
;;;1509                  /* just dump 'next' and everything after it */
;;;1510                  prev->next = NULL;
;;;1511                }
;;;1512                break;
;;;1513             }
;;;1514           }
;;;1515   #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
;;;1516   #endif /* TCP_QUEUE_OOSEQ */
;;;1517         }
;;;1518       } else {
;;;1519         /* The incoming segment is not withing the window. */
;;;1520         tcp_send_empty_ack(pcb);
000d00  4620              MOV      r0,r4
000d02  f7fffffe          BL       tcp_send_empty_ack
000d06  e013              B        |L6.3376|
                  |L6.3336|
;;;1521       }
;;;1522     } else {
;;;1523       /* Segments with length 0 is taken care of here. Segments that
;;;1524          fall out of the window are ACKed. */
;;;1525       /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
;;;1526         TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
;;;1527       if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
000d08  490c              LDR      r1,|L6.3388|
000d0a  6aa0              LDR      r0,[r4,#0x28]
000d0c  6809              LDR      r1,[r1,#0]  ; seqno
000d0e  1a08              SUBS     r0,r1,r0
000d10  d408              BMI      |L6.3364|
000d12  8da1              LDRH     r1,[r4,#0x2c]
000d14  6aa0              LDR      r0,[r4,#0x28]
000d16  4408              ADD      r0,r0,r1
000d18  1e40              SUBS     r0,r0,#1
000d1a  4908              LDR      r1,|L6.3388|
000d1c  6809              LDR      r1,[r1,#0]  ; seqno
000d1e  1a08              SUBS     r0,r1,r0
000d20  2800              CMP      r0,#0
000d22  dd05              BLE      |L6.3376|
                  |L6.3364|
;;;1528         tcp_ack_now(pcb);
000d24  bf00              NOP      
000d26  7fa0              LDRB     r0,[r4,#0x1e]
000d28  f0400002          ORR      r0,r0,#2
000d2c  77a0              STRB     r0,[r4,#0x1e]
000d2e  bf00              NOP      
                  |L6.3376|
;;;1529       }
;;;1530     }
;;;1531   }
000d30  e8bd8ffe          POP      {r1-r11,pc}
                  |L6.3380|
                          DCD      inseg
                  |L6.3384|
                          DCD      tcplen
                  |L6.3388|
                          DCD      seqno
                  |L6.3392|
000d40  7463705f          DCB      "tcp_receive: segment not trimmed correctly to ooseq que"
000d44  72656365
000d48  6976653a
000d4c  20736567
000d50  6d656e74
000d54  206e6f74
000d58  20747269
000d5c  6d6d6564
000d60  20636f72
000d64  72656374
000d68  6c792074
000d6c  6f206f6f
000d70  73657120
000d74  717565  
000d77  75650a00          DCB      "ue\n",0
000d7b  00                DCB      0
                  |L6.3452|
000d7c  7463705f          DCB      "tcp_receive: tcplen > rcv_wnd\n",0
000d80  72656365
000d84  6976653a
000d88  20746370
000d8c  6c656e20
000d90  3e207263
000d94  765f776e
000d98  640a00  
000d9b  00                DCB      0
                  |L6.3484|
                          DCD      recv_data
                  |L6.3488|
                          DCD      recv_flags
                  |L6.3492|
000da4  7463705f          DCB      "tcp_receive: ooseq tcplen > rcv_wnd\n",0
000da8  72656365
000dac  6976653a
000db0  206f6f73
000db4  65712074
000db8  63706c65
000dbc  6e203e20
000dc0  7263765f
000dc4  776e640a
000dc8  00      
000dc9  00                DCB      0
000dca  00                DCB      0
000dcb  00                DCB      0
                          ENDP


                          AREA ||i.tcp_timewait_input||, CODE, READONLY, ALIGN=2

                  tcp_timewait_input PROC
;;;528    static err_t
;;;529    tcp_timewait_input(struct tcp_pcb *pcb)
000000  b51c              PUSH     {r2-r4,lr}
;;;530    {
000002  4604              MOV      r4,r0
;;;531      /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
;;;532      /* RFC 793 3.9 Event Processing - Segment Arrives:
;;;533       * - first check sequence number - we skip that one in TIME_WAIT (always
;;;534       *   acceptable since we only send ACKs)
;;;535       * - second check the RST bit (... return) */
;;;536      if (flags & TCP_RST)  {
000004  4821              LDR      r0,|L7.140|
000006  7800              LDRB     r0,[r0,#0]  ; flags
000008  f0000004          AND      r0,r0,#4
00000c  b108              CBZ      r0,|L7.18|
;;;537        return ERR_OK;
00000e  2000              MOVS     r0,#0
                  |L7.16|
;;;538      }
;;;539      /* - fourth, check the SYN bit, */
;;;540      if (flags & TCP_SYN) {
;;;541        /* If an incoming segment is not acceptable, an acknowledgment
;;;542           should be sent in reply */
;;;543        if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
;;;544          /* If the SYN is in the window it is an error, send a reset */
;;;545          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;546            tcphdr->dest, tcphdr->src);
;;;547          return ERR_OK;
;;;548        }
;;;549      } else if (flags & TCP_FIN) {
;;;550        /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
;;;551             Restart the 2 MSL time-wait timeout.*/
;;;552        pcb->tmr = tcp_ticks;
;;;553      }
;;;554    
;;;555      if ((tcplen > 0))  {
;;;556        /* Acknowledge data, FIN or out-of-window SYN */
;;;557        pcb->flags |= TF_ACK_NOW;
;;;558        return tcp_output(pcb);
;;;559      }
;;;560      return ERR_OK;
;;;561    }
000010  bd1c              POP      {r2-r4,pc}
                  |L7.18|
000012  481e              LDR      r0,|L7.140|
000014  7800              LDRB     r0,[r0,#0]            ;540  ; flags
000016  f0000002          AND      r0,r0,#2              ;540
00001a  b308              CBZ      r0,|L7.96|
00001c  491c              LDR      r1,|L7.144|
00001e  6aa0              LDR      r0,[r4,#0x28]         ;543
000020  6809              LDR      r1,[r1,#0]            ;543  ; seqno
000022  1a08              SUBS     r0,r1,r0              ;543
000024  d424              BMI      |L7.112|
000026  8da1              LDRH     r1,[r4,#0x2c]         ;543
000028  6aa0              LDR      r0,[r4,#0x28]         ;543
00002a  4408              ADD      r0,r0,r1              ;543
00002c  4918              LDR      r1,|L7.144|
00002e  6809              LDR      r1,[r1,#0]            ;543  ; seqno
000030  1a08              SUBS     r0,r1,r0              ;543
000032  2800              CMP      r0,#0                 ;543
000034  dc1c              BGT      |L7.112|
000036  4817              LDR      r0,|L7.148|
000038  6800              LDR      r0,[r0,#0]            ;545  ; tcphdr
00003a  8800              LDRH     r0,[r0,#0]            ;545
00003c  4915              LDR      r1,|L7.148|
00003e  6809              LDR      r1,[r1,#0]            ;545  ; tcphdr
000040  8849              LDRH     r1,[r1,#2]            ;545
000042  e9cd1000          STRD     r1,r0,[sp,#0]         ;545
000046  4812              LDR      r0,|L7.144|
000048  6800              LDR      r0,[r0,#0]            ;545  ; seqno
00004a  4a13              LDR      r2,|L7.152|
00004c  8812              LDRH     r2,[r2,#0]            ;545  ; tcplen
00004e  1881              ADDS     r1,r0,r2              ;545
000050  4b12              LDR      r3,|L7.156|
000052  4a13              LDR      r2,|L7.160|
000054  4813              LDR      r0,|L7.164|
000056  6800              LDR      r0,[r0,#0]            ;545  ; ackno
000058  f7fffffe          BL       tcp_rst
00005c  2000              MOVS     r0,#0                 ;547
00005e  e7d7              B        |L7.16|
                  |L7.96|
000060  480a              LDR      r0,|L7.140|
000062  7800              LDRB     r0,[r0,#0]            ;549  ; flags
000064  f0000001          AND      r0,r0,#1              ;549
000068  b110              CBZ      r0,|L7.112|
00006a  480f              LDR      r0,|L7.168|
00006c  6800              LDR      r0,[r0,#0]            ;552  ; tcp_ticks
00006e  6260              STR      r0,[r4,#0x24]         ;552
                  |L7.112|
000070  4809              LDR      r0,|L7.152|
000072  8800              LDRH     r0,[r0,#0]            ;555  ; tcplen
000074  2800              CMP      r0,#0                 ;555
000076  dd07              BLE      |L7.136|
000078  7fa0              LDRB     r0,[r4,#0x1e]         ;557
00007a  f0400002          ORR      r0,r0,#2              ;557
00007e  77a0              STRB     r0,[r4,#0x1e]         ;557
000080  4620              MOV      r0,r4                 ;558
000082  f7fffffe          BL       tcp_output
000086  e7c3              B        |L7.16|
                  |L7.136|
000088  2000              MOVS     r0,#0                 ;560
00008a  e7c1              B        |L7.16|
;;;562    
                          ENDP

                  |L7.140|
                          DCD      flags
                  |L7.144|
                          DCD      seqno
                  |L7.148|
                          DCD      tcphdr
                  |L7.152|
                          DCD      tcplen
                  |L7.156|
                          DCD      current_iphdr_src
                  |L7.160|
                          DCD      current_iphdr_dest
                  |L7.164|
                          DCD      ackno
                  |L7.168|
                          DCD      tcp_ticks

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  inseg
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  tcphdr
                          DCD      0x00000000
                  iphdr
                          DCD      0x00000000
                  seqno
                          DCD      0x00000000
                  ackno
                          DCD      0x00000000
                  flags
000010  0000              DCB      0x00,0x00
                  tcplen
000012  0000              DCB      0x00,0x00
                  recv_flags
000014  00000000          DCB      0x00,0x00,0x00,0x00
                  recv_data
                          DCD      0x00000000
                  tcp_input_pcb
                          DCD      0x00000000
