; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\tcp_out.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\tcp_out.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\tcp_out.crf ..\LWIP\lwip-1.4.1\src\core\tcp_out.c]
                          THUMB

                          AREA ||i.tcp_create_segment||, CODE, READONLY, ALIGN=1

                  tcp_create_segment PROC
;;;158    static struct tcp_seg *
;;;159    tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;160    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4691              MOV      r9,r2
00000a  469a              MOV      r10,r3
00000c  f8dd8028          LDR      r8,[sp,#0x28]
;;;161      struct tcp_seg *seg;
;;;162      u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
000010  f0080001          AND      r0,r8,#1
000014  b108              CBZ      r0,|L1.26|
000016  2004              MOVS     r0,#4
000018  e000              B        |L1.28|
                  |L1.26|
00001a  2000              MOVS     r0,#0
                  |L1.28|
00001c  f0080102          AND      r1,r8,#2
000020  b109              CBZ      r1,|L1.38|
000022  210c              MOVS     r1,#0xc
000024  e000              B        |L1.40|
                  |L1.38|
000026  2100              MOVS     r1,#0
                  |L1.40|
000028  1845              ADDS     r5,r0,r1
;;;163    
;;;164      if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
00002a  2004              MOVS     r0,#4
00002c  f7fffffe          BL       memp_malloc
000030  1e04              SUBS     r4,r0,#0
000032  d107              BNE      |L1.68|
;;;165        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
000034  bf00              NOP      
000036  bf00              NOP      
;;;166        pbuf_free(p);
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       pbuf_free
;;;167        return NULL;
00003e  2000              MOVS     r0,#0
                  |L1.64|
;;;168      }
;;;169      seg->flags = optflags;
;;;170      seg->next = NULL;
;;;171      seg->p = p;
;;;172      seg->len = p->tot_len - optlen;
;;;173    #if TCP_OVERSIZE_DBGCHECK
;;;174      seg->oversize_left = 0;
;;;175    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;176    #if TCP_CHECKSUM_ON_COPY
;;;177      seg->chksum = 0;
;;;178      seg->chksum_swapped = 0;
;;;179      /* check optflags */
;;;180      LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
;;;181                  (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
;;;182    #endif /* TCP_CHECKSUM_ON_COPY */
;;;183    
;;;184      /* build TCP header */
;;;185      if (pbuf_header(p, TCP_HLEN)) {
;;;186        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
;;;187        TCP_STATS_INC(tcp.err);
;;;188        tcp_seg_free(seg);
;;;189        return NULL;
;;;190      }
;;;191      seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
;;;192      seg->tcphdr->src = htons(pcb->local_port);
;;;193      seg->tcphdr->dest = htons(pcb->remote_port);
;;;194      seg->tcphdr->seqno = htonl(seqno);
;;;195      /* ackno is set in tcp_output */
;;;196      TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
;;;197      /* wnd and chksum are set in tcp_output */
;;;198      seg->tcphdr->urgp = 0;
;;;199      return seg;
;;;200    } 
000040  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.68|
000044  f884800c          STRB     r8,[r4,#0xc]          ;169
000048  2000              MOVS     r0,#0                 ;170
00004a  6020              STR      r0,[r4,#0]            ;170
00004c  6066              STR      r6,[r4,#4]            ;171
00004e  8930              LDRH     r0,[r6,#8]            ;172
000050  1b40              SUBS     r0,r0,r5              ;172
000052  8120              STRH     r0,[r4,#8]            ;172
000054  2000              MOVS     r0,#0                 ;174
000056  8160              STRH     r0,[r4,#0xa]          ;174
000058  2114              MOVS     r1,#0x14              ;185
00005a  4630              MOV      r0,r6                 ;185
00005c  f7fffffe          BL       pbuf_header
000060  b130              CBZ      r0,|L1.112|
000062  bf00              NOP                            ;186
000064  bf00              NOP                            ;186
000066  4620              MOV      r0,r4                 ;188
000068  f7fffffe          BL       tcp_seg_free
00006c  2000              MOVS     r0,#0                 ;189
00006e  e7e7              B        |L1.64|
                  |L1.112|
000070  6860              LDR      r0,[r4,#4]            ;191
000072  6840              LDR      r0,[r0,#4]            ;191
000074  6120              STR      r0,[r4,#0x10]         ;191
000076  8b78              LDRH     r0,[r7,#0x1a]         ;192
000078  f7fffffe          BL       lwip_htons
00007c  6921              LDR      r1,[r4,#0x10]         ;192
00007e  8008              STRH     r0,[r1,#0]            ;192
000080  8bb8              LDRH     r0,[r7,#0x1c]         ;193
000082  f7fffffe          BL       lwip_htons
000086  6921              LDR      r1,[r4,#0x10]         ;193
000088  8048              STRH     r0,[r1,#2]            ;193
00008a  4650              MOV      r0,r10                ;194
00008c  f7fffffe          BL       lwip_htonl
000090  6921              LDR      r1,[r4,#0x10]         ;194
000092  6048              STR      r0,[r1,#4]            ;194
000094  46ab              MOV      r11,r5                ;196
000096  17e9              ASRS     r1,r5,#31             ;196
000098  eb057191          ADD      r1,r5,r1,LSR #30      ;196
00009c  1089              ASRS     r1,r1,#2              ;196
00009e  1d49              ADDS     r1,r1,#5              ;196
0000a0  ea493101          ORR      r1,r9,r1,LSL #12      ;196
0000a4  b288              UXTH     r0,r1                 ;196
0000a6  f7fffffe          BL       lwip_htons
0000aa  6921              LDR      r1,[r4,#0x10]         ;196
0000ac  8188              STRH     r0,[r1,#0xc]          ;196
0000ae  2000              MOVS     r0,#0                 ;198
0000b0  6921              LDR      r1,[r4,#0x10]         ;198
0000b2  8248              STRH     r0,[r1,#0x12]         ;198
0000b4  4620              MOV      r0,r4                 ;199
0000b6  e7c3              B        |L1.64|
;;;201    
                          ENDP


                          AREA ||i.tcp_enqueue_flags||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_enqueue_flags PROC
;;;721    err_t
;;;722    tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;723    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;724      struct pbuf *p;
;;;725      struct tcp_seg *seg;
;;;726      u8_t optflags = 0;
000008  f04f0800          MOV      r8,#0
;;;727      u8_t optlen = 0;
00000c  46c1              MOV      r9,r8
;;;728    
;;;729      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
00000e  bf00              NOP      
000010  bf00              NOP      
;;;730    
;;;731      LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
000012  bf00              NOP      
000014  f0050003          AND      r0,r5,#3
000018  b940              CBNZ     r0,|L2.44|
00001a  bf00              NOP      
00001c  a361              ADR      r3,|L2.420|
00001e  f24022db          MOV      r2,#0x2db
000022  496a              LDR      r1,|L2.460|
000024  a06a              ADR      r0,|L2.464|
000026  f7fffffe          BL       __2printf
00002a  bf00              NOP      
                  |L2.44|
00002c  bf00              NOP      
;;;732                  (flags & (TCP_SYN | TCP_FIN)) != 0);
;;;733    
;;;734      /* check for configured max queuelen and possible overflow */
;;;735      if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
00002e  f8b40068          LDRH     r0,[r4,#0x68]
000032  2808              CMP      r0,#8
000034  da05              BGE      |L2.66|
000036  f8b40068          LDRH     r0,[r4,#0x68]
00003a  f64f71fc          MOV      r1,#0xfffc
00003e  4288              CMP      r0,r1
000040  d909              BLS      |L2.86|
                  |L2.66|
;;;736        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
000042  bf00              NOP      
000044  bf00              NOP      
;;;737                                           pcb->snd_queuelen, TCP_SND_QUEUELEN));
;;;738        TCP_STATS_INC(tcp.memerr);
;;;739        pcb->flags |= TF_NAGLEMEMERR;
000046  7fa0              LDRB     r0,[r4,#0x1e]
000048  f0400080          ORR      r0,r0,#0x80
00004c  77a0              STRB     r0,[r4,#0x1e]
;;;740        return ERR_MEM;
00004e  f04f30ff          MOV      r0,#0xffffffff
                  |L2.82|
;;;741      }
;;;742    
;;;743      if (flags & TCP_SYN) {
;;;744        optflags = TF_SEG_OPTS_MSS;
;;;745      }
;;;746    #if LWIP_TCP_TIMESTAMPS
;;;747      if ((pcb->flags & TF_TIMESTAMP)) {
;;;748        optflags |= TF_SEG_OPTS_TS;
;;;749      }
;;;750    #endif /* LWIP_TCP_TIMESTAMPS */
;;;751      optlen = LWIP_TCP_OPT_LENGTH(optflags);
;;;752    
;;;753      /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
;;;754       * We need one available snd_buf byte to do that.
;;;755       * This means we can't send FIN while snd_buf==0. A better fix would be to
;;;756       * not include SYN and FIN sequence numbers in the snd_buf count. */
;;;757      if (pcb->snd_buf == 0) {
;;;758        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
;;;759        TCP_STATS_INC(tcp.memerr);
;;;760        return ERR_MEM;
;;;761      }
;;;762    
;;;763      /* Allocate pbuf with room for TCP header + options */
;;;764      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
;;;765        pcb->flags |= TF_NAGLEMEMERR;
;;;766        TCP_STATS_INC(tcp.memerr);
;;;767        return ERR_MEM;
;;;768      }
;;;769      LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
;;;770                  (p->len >= optlen));
;;;771    
;;;772      /* Allocate memory for tcp_seg, and fill in fields. */
;;;773      if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
;;;774        pcb->flags |= TF_NAGLEMEMERR;
;;;775        TCP_STATS_INC(tcp.memerr);
;;;776        return ERR_MEM;
;;;777      }
;;;778      LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
;;;779      LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
;;;780    
;;;781      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE,
;;;782                  ("tcp_enqueue_flags: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
;;;783                   ntohl(seg->tcphdr->seqno),
;;;784                   ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
;;;785                   (u16_t)flags));
;;;786    
;;;787      /* Now append seg to pcb->unsent queue */
;;;788      if (pcb->unsent == NULL) {
;;;789        pcb->unsent = seg;
;;;790      } else {
;;;791        struct tcp_seg *useg;
;;;792        for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
;;;793        useg->next = seg;
;;;794      }
;;;795    #if TCP_OVERSIZE
;;;796      /* The new unsent tail has no space */
;;;797      pcb->unsent_oversize = 0;
;;;798    #endif /* TCP_OVERSIZE */
;;;799    
;;;800      /* SYN and FIN bump the sequence number */
;;;801      if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
;;;802        pcb->snd_lbb++;
;;;803        /* optlen does not influence snd_buf */
;;;804        pcb->snd_buf--;
;;;805      }
;;;806      if (flags & TCP_FIN) {
;;;807        pcb->flags |= TF_FIN;
;;;808      }
;;;809    
;;;810      /* update number of segments on the queues */
;;;811      pcb->snd_queuelen += pbuf_clen(seg->p);
;;;812      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
;;;813      if (pcb->snd_queuelen != 0) {
;;;814        LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
;;;815          pcb->unacked != NULL || pcb->unsent != NULL);
;;;816      }
;;;817    
;;;818      return ERR_OK;
;;;819    }
000052  e8bd83f8          POP      {r3-r9,pc}
                  |L2.86|
000056  f0050002          AND      r0,r5,#2              ;743
00005a  b108              CBZ      r0,|L2.96|
00005c  f04f0801          MOV      r8,#1                 ;744
                  |L2.96|
000060  f0080001          AND      r0,r8,#1              ;751
000064  b108              CBZ      r0,|L2.106|
000066  2004              MOVS     r0,#4                 ;751
000068  e000              B        |L2.108|
                  |L2.106|
00006a  2000              MOVS     r0,#0                 ;751
                  |L2.108|
00006c  f0080102          AND      r1,r8,#2              ;751
000070  b109              CBZ      r1,|L2.118|
000072  210c              MOVS     r1,#0xc               ;751
000074  e000              B        |L2.120|
                  |L2.118|
000076  2100              MOVS     r1,#0                 ;751
                  |L2.120|
000078  eb000901          ADD      r9,r0,r1              ;751
00007c  f8b40066          LDRH     r0,[r4,#0x66]         ;757
000080  b920              CBNZ     r0,|L2.140|
000082  bf00              NOP                            ;758
000084  bf00              NOP                            ;758
000086  f04f30ff          MOV      r0,#0xffffffff        ;760
00008a  e7e2              B        |L2.82|
                  |L2.140|
00008c  2200              MOVS     r2,#0                 ;764
00008e  4649              MOV      r1,r9                 ;764
000090  4610              MOV      r0,r2                 ;764
000092  f7fffffe          BL       pbuf_alloc
000096  1e07              SUBS     r7,r0,#0              ;764
000098  d105              BNE      |L2.166|
00009a  7fa0              LDRB     r0,[r4,#0x1e]         ;765
00009c  f0400080          ORR      r0,r0,#0x80           ;765
0000a0  77a0              STRB     r0,[r4,#0x1e]         ;765
0000a2  1e78              SUBS     r0,r7,#1              ;767
0000a4  e7d5              B        |L2.82|
                  |L2.166|
0000a6  bf00              NOP                            ;769
0000a8  8978              LDRH     r0,[r7,#0xa]          ;769
0000aa  4548              CMP      r0,r9                 ;769
0000ac  da08              BGE      |L2.192|
0000ae  bf00              NOP                            ;769
0000b0  a33c              ADR      r3,|L2.420|
0000b2  f2403201          MOV      r2,#0x301             ;769
0000b6  a151              ADR      r1,|L2.508|
0000b8  a045              ADR      r0,|L2.464|
0000ba  f7fffffe          BL       __2printf
0000be  bf00              NOP                            ;769
                  |L2.192|
0000c0  bf00              NOP                            ;769
0000c2  f8cd8000          STR      r8,[sp,#0]            ;773
0000c6  462a              MOV      r2,r5                 ;773
0000c8  4639              MOV      r1,r7                 ;773
0000ca  4620              MOV      r0,r4                 ;773
0000cc  6de3              LDR      r3,[r4,#0x5c]         ;773
0000ce  f7fffffe          BL       tcp_create_segment
0000d2  1e06              SUBS     r6,r0,#0              ;773
0000d4  d105              BNE      |L2.226|
0000d6  7fa0              LDRB     r0,[r4,#0x1e]         ;774
0000d8  f0400080          ORR      r0,r0,#0x80           ;774
0000dc  77a0              STRB     r0,[r4,#0x1e]         ;774
0000de  1e70              SUBS     r0,r6,#1              ;776
0000e0  e7b7              B        |L2.82|
                  |L2.226|
0000e2  bf00              NOP                            ;778
0000e4  7c30              LDRB     r0,[r6,#0x10]         ;778
0000e6  f0000003          AND      r0,r0,#3              ;778
0000ea  b140              CBZ      r0,|L2.254|
0000ec  bf00              NOP                            ;778
0000ee  a32d              ADR      r3,|L2.420|
0000f0  f240320a          MOV      r2,#0x30a             ;778
0000f4  a150              ADR      r1,|L2.568|
0000f6  a036              ADR      r0,|L2.464|
0000f8  f7fffffe          BL       __2printf
0000fc  bf00              NOP                            ;778
                  |L2.254|
0000fe  bf00              NOP                            ;778
000100  bf00              NOP                            ;779
000102  8930              LDRH     r0,[r6,#8]            ;779
000104  b140              CBZ      r0,|L2.280|
000106  bf00              NOP                            ;779
000108  a326              ADR      r3,|L2.420|
00010a  f240320b          MOV      r2,#0x30b             ;779
00010e  a150              ADR      r1,|L2.592|
000110  a02f              ADR      r0,|L2.464|
000112  f7fffffe          BL       __2printf
000116  bf00              NOP                            ;779
                  |L2.280|
000118  bf00              NOP                            ;779
00011a  bf00              NOP                            ;781
00011c  bf00              NOP                            ;781
00011e  6ee0              LDR      r0,[r4,#0x6c]         ;788
000120  b908              CBNZ     r0,|L2.294|
000122  66e6              STR      r6,[r4,#0x6c]         ;789
000124  e007              B        |L2.310|
                  |L2.294|
000126  6ee0              LDR      r0,[r4,#0x6c]         ;792
000128  e000              B        |L2.300|
                  |L2.298|
00012a  6800              LDR      r0,[r0,#0]            ;792
                  |L2.300|
00012c  6801              LDR      r1,[r0,#0]            ;792
00012e  2900              CMP      r1,#0                 ;792
000130  d1fb              BNE      |L2.298|
000132  6006              STR      r6,[r0,#0]            ;793
000134  bf00              NOP                            ;794
                  |L2.310|
000136  2000              MOVS     r0,#0                 ;797
000138  f8a4006a          STRH     r0,[r4,#0x6a]         ;797
00013c  f0050002          AND      r0,r5,#2              ;801
000140  b910              CBNZ     r0,|L2.328|
000142  f0050001          AND      r0,r5,#1              ;801
000146  b138              CBZ      r0,|L2.344|
                  |L2.328|
000148  6de0              LDR      r0,[r4,#0x5c]         ;802
00014a  1c40              ADDS     r0,r0,#1              ;802
00014c  65e0              STR      r0,[r4,#0x5c]         ;802
00014e  f8b40066          LDRH     r0,[r4,#0x66]         ;804
000152  1e40              SUBS     r0,r0,#1              ;804
000154  f8a40066          STRH     r0,[r4,#0x66]         ;804
                  |L2.344|
000158  f0050001          AND      r0,r5,#1              ;806
00015c  b118              CBZ      r0,|L2.358|
00015e  7fa0              LDRB     r0,[r4,#0x1e]         ;807
000160  f0400020          ORR      r0,r0,#0x20           ;807
000164  77a0              STRB     r0,[r4,#0x1e]         ;807
                  |L2.358|
000166  6870              LDR      r0,[r6,#4]            ;811
000168  f7fffffe          BL       pbuf_clen
00016c  f8b41068          LDRH     r1,[r4,#0x68]         ;811
000170  4408              ADD      r0,r0,r1              ;811
000172  f8a40068          STRH     r0,[r4,#0x68]         ;811
000176  bf00              NOP                            ;812
000178  bf00              NOP                            ;812
00017a  f8b40068          LDRH     r0,[r4,#0x68]         ;813
00017e  b170              CBZ      r0,|L2.414|
000180  bf00              NOP                            ;814
000182  6f20              LDR      r0,[r4,#0x70]         ;814
000184  b950              CBNZ     r0,|L2.412|
000186  6ee0              LDR      r0,[r4,#0x6c]         ;814
000188  b940              CBNZ     r0,|L2.412|
00018a  bf00              NOP                            ;814
00018c  a305              ADR      r3,|L2.420|
00018e  f240322e          MOV      r2,#0x32e             ;814
000192  a13a              ADR      r1,|L2.636|
000194  a00e              ADR      r0,|L2.464|
000196  f7fffffe          BL       __2printf
00019a  bf00              NOP                            ;814
                  |L2.412|
00019c  bf00              NOP                            ;814
                  |L2.414|
00019e  2000              MOVS     r0,#0                 ;818
0001a0  e757              B        |L2.82|
;;;820    
                          ENDP

0001a2  0000              DCW      0x0000
                  |L2.420|
0001a4  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp_out.c",0
0001a8  5749505c
0001ac  6c776970
0001b0  2d312e34
0001b4  2e315c73
0001b8  72635c63
0001bc  6f72655c
0001c0  7463705f
0001c4  6f75742e
0001c8  6300    
0001ca  00                DCB      0
0001cb  00                DCB      0
                  |L2.460|
                          DCD      ||.conststring||
                  |L2.464|
0001d0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0001d4  7274696f
0001d8  6e202225
0001dc  73222066
0001e0  61696c65
0001e4  64206174
0001e8  206c696e
0001ec  65202564
0001f0  20696e20
0001f4  25730d0a
0001f8  00      
0001f9  00                DCB      0
0001fa  00                DCB      0
0001fb  00                DCB      0
                  |L2.508|
0001fc  7463705f          DCB      "tcp_enqueue_flags: check that first pbuf can hold optle"
000200  656e7175
000204  6575655f
000208  666c6167
00020c  733a2063
000210  6865636b
000214  20746861
000218  74206669
00021c  72737420
000220  70627566
000224  2063616e
000228  20686f6c
00022c  64206f70
000230  746c65  
000233  6e00              DCB      "n",0
000235  00                DCB      0
000236  00                DCB      0
000237  00                DCB      0
                  |L2.568|
000238  7365672d          DCB      "seg->tcphdr not aligned",0
00023c  3e746370
000240  68647220
000244  6e6f7420
000248  616c6967
00024c  6e656400
                  |L2.592|
000250  7463705f          DCB      "tcp_enqueue_flags: invalid segment length",0
000254  656e7175
000258  6575655f
00025c  666c6167
000260  733a2069
000264  6e76616c
000268  69642073
00026c  65676d65
000270  6e74206c
000274  656e6774
000278  6800    
00027a  00                DCB      0
00027b  00                DCB      0
                  |L2.636|
00027c  7463705f          DCB      "tcp_enqueue_flags: invalid queue length",0
000280  656e7175
000284  6575655f
000288  666c6167
00028c  733a2069
000290  6e76616c
000294  69642071
000298  75657565
00029c  206c656e
0002a0  67746800

                          AREA ||i.tcp_keepalive||, CODE, READONLY, ALIGN=1

                  tcp_keepalive PROC
;;;1363   void
;;;1364   tcp_keepalive(struct tcp_pcb *pcb)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;1365   {
000004  4604              MOV      r4,r0
;;;1366     struct pbuf *p;
;;;1367     struct tcp_hdr *tcphdr;
;;;1368   
;;;1369     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: sending KEEPALIVE probe to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
000006  bf00              NOP      
000008  bf00              NOP      
;;;1370                             ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;1371                             ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;1372   
;;;1373     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;1374                             tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
;;;1375      
;;;1376     p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
00000e  6d21              LDR      r1,[r4,#0x50]
000010  1e48              SUBS     r0,r1,#1
000012  f7fffffe          BL       lwip_htonl
000016  4607              MOV      r7,r0
000018  463b              MOV      r3,r7
00001a  2200              MOVS     r2,#0
00001c  4611              MOV      r1,r2
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       tcp_output_alloc_header
000024  4605              MOV      r5,r0
;;;1377     if(p == NULL) {
000026  b91d              CBNZ     r5,|L3.48|
;;;1378       LWIP_DEBUGF(TCP_DEBUG, 
000028  bf00              NOP      
00002a  bf00              NOP      
                  |L3.44|
;;;1379                   ("tcp_keepalive: could not allocate memory for pbuf\n"));
;;;1380       return;
;;;1381     }
;;;1382     tcphdr = (struct tcp_hdr *)p->payload;
;;;1383   
;;;1384   #if CHECKSUM_GEN_TCP
;;;1385     tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
;;;1386                                         IP_PROTO_TCP, p->tot_len);
;;;1387   #endif
;;;1388     TCP_STATS_INC(tcp.xmit);
;;;1389   
;;;1390     /* Send output to IP */
;;;1391   #if LWIP_NETIF_HWADDRHINT
;;;1392     ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
;;;1393       &(pcb->addr_hint));
;;;1394   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1395     ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
;;;1396   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1397   
;;;1398     pbuf_free(p);
;;;1399   
;;;1400     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
;;;1401                             pcb->snd_nxt - 1, pcb->rcv_nxt));
;;;1402   }
00002c  e8bd81fc          POP      {r2-r8,pc}
                  |L3.48|
000030  686e              LDR      r6,[r5,#4]            ;1382
000032  8928              LDRH     r0,[r5,#8]            ;1385
000034  2306              MOVS     r3,#6                 ;1385
000036  1d22              ADDS     r2,r4,#4              ;1385
000038  4621              MOV      r1,r4                 ;1385
00003a  9000              STR      r0,[sp,#0]            ;1385
00003c  4628              MOV      r0,r5                 ;1385
00003e  f7fffffe          BL       inet_chksum_pseudo
000042  8230              STRH     r0,[r6,#0x10]         ;1385
000044  2006              MOVS     r0,#6                 ;1395
000046  2100              MOVS     r1,#0                 ;1395
000048  e9cd1000          STRD     r1,r0,[sp,#0]         ;1395
00004c  7aa3              LDRB     r3,[r4,#0xa]          ;1395
00004e  1d22              ADDS     r2,r4,#4              ;1395
000050  4621              MOV      r1,r4                 ;1395
000052  4628              MOV      r0,r5                 ;1395
000054  f7fffffe          BL       ip_output
000058  4628              MOV      r0,r5                 ;1398
00005a  f7fffffe          BL       pbuf_free
00005e  bf00              NOP                            ;1400
000060  bf00              NOP                            ;1400
000062  bf00              NOP      
000064  e7e2              B        |L3.44|
;;;1403   
                          ENDP


                          AREA ||i.tcp_output||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_output PROC
;;;897    err_t
;;;898    tcp_output(struct tcp_pcb *pcb)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;899    {
000004  4604              MOV      r4,r0
;;;900      struct tcp_seg *seg, *useg;
;;;901      u32_t wnd, snd_nxt;
;;;902    #if TCP_CWND_DEBUG
;;;903      s16_t i = 0;
;;;904    #endif /* TCP_CWND_DEBUG */
;;;905    
;;;906      /* pcb->state LISTEN not allowed here */
;;;907      LWIP_ASSERT("don't call tcp_output for listen-pcbs",
000006  bf00              NOP      
000008  7e20              LDRB     r0,[r4,#0x18]
00000a  2801              CMP      r0,#1
00000c  d108              BNE      |L4.32|
00000e  bf00              NOP      
000010  a376              ADR      r3,|L4.492|
000012  f240328b          MOV      r2,#0x38b
000016  a17f              ADR      r1,|L4.532|
000018  a088              ADR      r0,|L4.572|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
                  |L4.32|
000020  bf00              NOP      
;;;908        pcb->state != LISTEN);
;;;909    
;;;910      /* First, check if we are invoked by the TCP input processing
;;;911         code. If so, we do not output anything. Instead, we rely on the
;;;912         input processing code to call us when input processing is done
;;;913         with. */
;;;914      if (tcp_input_pcb == pcb) {
000022  4891              LDR      r0,|L4.616|
000024  6800              LDR      r0,[r0,#0]  ; tcp_input_pcb
000026  42a0              CMP      r0,r4
000028  d102              BNE      |L4.48|
;;;915        return ERR_OK;
00002a  2000              MOVS     r0,#0
                  |L4.44|
;;;916      }
;;;917    
;;;918      wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
;;;919    
;;;920      seg = pcb->unsent;
;;;921    
;;;922      /* If the TF_ACK_NOW flag is set and no data will be sent (either
;;;923       * because the ->unsent queue is empty or because the window does
;;;924       * not allow it), construct an empty ACK segment and send it.
;;;925       *
;;;926       * If data is to be sent, we will just piggyback the ACK (see below).
;;;927       */
;;;928      if (pcb->flags & TF_ACK_NOW &&
;;;929         (seg == NULL ||
;;;930          ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
;;;931         return tcp_send_empty_ack(pcb);
;;;932      }
;;;933    
;;;934      /* useg should point to last segment on unacked queue */
;;;935      useg = pcb->unacked;
;;;936      if (useg != NULL) {
;;;937        for (; useg->next != NULL; useg = useg->next);
;;;938      }
;;;939    
;;;940    #if TCP_OUTPUT_DEBUG
;;;941      if (seg == NULL) {
;;;942        LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: nothing to send (%p)\n",
;;;943                                       (void*)pcb->unsent));
;;;944      }
;;;945    #endif /* TCP_OUTPUT_DEBUG */
;;;946    #if TCP_CWND_DEBUG
;;;947      if (seg == NULL) {
;;;948        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F
;;;949                                     ", cwnd %"U16_F", wnd %"U32_F
;;;950                                     ", seg == NULL, ack %"U32_F"\n",
;;;951                                     pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));
;;;952      } else {
;;;953        LWIP_DEBUGF(TCP_CWND_DEBUG, 
;;;954                    ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F
;;;955                     ", effwnd %"U32_F", seq %"U32_F", ack %"U32_F"\n",
;;;956                     pcb->snd_wnd, pcb->cwnd, wnd,
;;;957                     ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
;;;958                     ntohl(seg->tcphdr->seqno), pcb->lastack));
;;;959      }
;;;960    #endif /* TCP_CWND_DEBUG */
;;;961      /* data available and window allows it to be sent? */
;;;962      while (seg != NULL &&
;;;963             ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
;;;964        LWIP_ASSERT("RST not expected here!", 
;;;965                    (TCPH_FLAGS(seg->tcphdr) & TCP_RST) == 0);
;;;966        /* Stop sending if the nagle algorithm would prevent it
;;;967         * Don't stop:
;;;968         * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
;;;969         * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
;;;970         *   either seg->next != NULL or pcb->unacked == NULL;
;;;971         *   RST is no sent using tcp_write/tcp_output.
;;;972         */
;;;973        if((tcp_do_output_nagle(pcb) == 0) &&
;;;974          ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
;;;975          break;
;;;976        }
;;;977    #if TCP_CWND_DEBUG
;;;978        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F", effwnd %"U32_F", seq %"U32_F", ack %"U32_F", i %"S16_F"\n",
;;;979                                pcb->snd_wnd, pcb->cwnd, wnd,
;;;980                                ntohl(seg->tcphdr->seqno) + seg->len -
;;;981                                pcb->lastack,
;;;982                                ntohl(seg->tcphdr->seqno), pcb->lastack, i));
;;;983        ++i;
;;;984    #endif /* TCP_CWND_DEBUG */
;;;985    
;;;986        pcb->unsent = seg->next;
;;;987    
;;;988        if (pcb->state != SYN_SENT) {
;;;989          TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
;;;990          pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
;;;991        }
;;;992    
;;;993        tcp_output_segment(seg, pcb);
;;;994        snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
;;;995        if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
;;;996          pcb->snd_nxt = snd_nxt;
;;;997        }
;;;998        /* put segment on unacknowledged list if length > 0 */
;;;999        if (TCP_TCPLEN(seg) > 0) {
;;;1000         seg->next = NULL;
;;;1001         /* unacked list is empty? */
;;;1002         if (pcb->unacked == NULL) {
;;;1003           pcb->unacked = seg;
;;;1004           useg = seg;
;;;1005         /* unacked list is not empty? */
;;;1006         } else {
;;;1007           /* In the case of fast retransmit, the packet should not go to the tail
;;;1008            * of the unacked queue, but rather somewhere before it. We need to check for
;;;1009            * this case. -STJ Jul 27, 2004 */
;;;1010           if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
;;;1011             /* add segment to before tail of unacked list, keeping the list sorted */
;;;1012             struct tcp_seg **cur_seg = &(pcb->unacked);
;;;1013             while (*cur_seg &&
;;;1014               TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
;;;1015                 cur_seg = &((*cur_seg)->next );
;;;1016             }
;;;1017             seg->next = (*cur_seg);
;;;1018             (*cur_seg) = seg;
;;;1019           } else {
;;;1020             /* add segment to tail of unacked list */
;;;1021             useg->next = seg;
;;;1022             useg = useg->next;
;;;1023           }
;;;1024         }
;;;1025       /* do not queue empty segments on the unacked list */
;;;1026       } else {
;;;1027         tcp_seg_free(seg);
;;;1028       }
;;;1029       seg = pcb->unsent;
;;;1030     }
;;;1031   #if TCP_OVERSIZE
;;;1032     if (pcb->unsent == NULL) {
;;;1033       /* last unsent has been removed, reset unsent_oversize */
;;;1034       pcb->unsent_oversize = 0;
;;;1035     }
;;;1036   #endif /* TCP_OVERSIZE */
;;;1037   
;;;1038     pcb->flags &= ~TF_NAGLEMEMERR;
;;;1039     return ERR_OK;
;;;1040   }
00002c  e8bd87f0          POP      {r4-r10,pc}
                  |L4.48|
000030  f8b40060          LDRH     r0,[r4,#0x60]         ;918
000034  f8b4104c          LDRH     r1,[r4,#0x4c]         ;918
000038  4288              CMP      r0,r1                 ;918
00003a  da02              BGE      |L4.66|
00003c  f8b40060          LDRH     r0,[r4,#0x60]         ;918
000040  e001              B        |L4.70|
                  |L4.66|
000042  f8b4004c          LDRH     r0,[r4,#0x4c]         ;918
                  |L4.70|
000046  4681              MOV      r9,r0                 ;918
000048  6ee5              LDR      r5,[r4,#0x6c]         ;920
00004a  7fa0              LDRB     r0,[r4,#0x1e]         ;928
00004c  f0000002          AND      r0,r0,#2              ;928
000050  b170              CBZ      r0,|L4.112|
000052  b14d              CBZ      r5,|L4.104|
000054  6929              LDR      r1,[r5,#0x10]         ;930
000056  6848              LDR      r0,[r1,#4]            ;930
000058  f7fffffe          BL       lwip_ntohl
00005c  6ca1              LDR      r1,[r4,#0x48]         ;930
00005e  1a40              SUBS     r0,r0,r1              ;930
000060  8929              LDRH     r1,[r5,#8]            ;930
000062  4408              ADD      r0,r0,r1              ;930
000064  4548              CMP      r0,r9                 ;930
000066  d903              BLS      |L4.112|
                  |L4.104|
000068  4620              MOV      r0,r4                 ;931
00006a  f7fffffe          BL       tcp_send_empty_ack
00006e  e7dd              B        |L4.44|
                  |L4.112|
000070  6f26              LDR      r6,[r4,#0x70]         ;935
000072  b126              CBZ      r6,|L4.126|
000074  e000              B        |L4.120|
                  |L4.118|
000076  6836              LDR      r6,[r6,#0]            ;937
                  |L4.120|
000078  6830              LDR      r0,[r6,#0]            ;937
00007a  2800              CMP      r0,#0                 ;937
00007c  d1fb              BNE      |L4.118|
                  |L4.126|
00007e  e09d              B        |L4.444|
                  |L4.128|
000080  bf00              NOP                            ;964
000082  6929              LDR      r1,[r5,#0x10]         ;964
000084  8988              LDRH     r0,[r1,#0xc]          ;964
000086  f7fffffe          BL       lwip_ntohs
00008a  f0000004          AND      r0,r0,#4              ;964
00008e  b140              CBZ      r0,|L4.162|
000090  bf00              NOP                            ;964
000092  a356              ADR      r3,|L4.492|
000094  f44f7271          MOV      r2,#0x3c4             ;964
000098  a174              ADR      r1,|L4.620|
00009a  a068              ADR      r0,|L4.572|
00009c  f7fffffe          BL       __2printf
0000a0  bf00              NOP                            ;964
                  |L4.162|
0000a2  bf00              NOP                            ;964
0000a4  6f20              LDR      r0,[r4,#0x70]         ;973
0000a6  b1a0              CBZ      r0,|L4.210|
0000a8  7fa0              LDRB     r0,[r4,#0x1e]         ;973
0000aa  f0000044          AND      r0,r0,#0x44           ;973
0000ae  b980              CBNZ     r0,|L4.210|
0000b0  6ee0              LDR      r0,[r4,#0x6c]         ;973
0000b2  b138              CBZ      r0,|L4.196|
0000b4  6ee0              LDR      r0,[r4,#0x6c]         ;973
0000b6  6800              LDR      r0,[r0,#0]            ;973
0000b8  b958              CBNZ     r0,|L4.210|
0000ba  6ee0              LDR      r0,[r4,#0x6c]         ;973
0000bc  8900              LDRH     r0,[r0,#8]            ;973
0000be  8ee1              LDRH     r1,[r4,#0x36]         ;973
0000c0  4288              CMP      r0,r1                 ;973
0000c2  da06              BGE      |L4.210|
                  |L4.196|
0000c4  f8b40066          LDRH     r0,[r4,#0x66]         ;973
0000c8  b118              CBZ      r0,|L4.210|
0000ca  f8b40068          LDRH     r0,[r4,#0x68]         ;973
0000ce  2808              CMP      r0,#8                 ;973
0000d0  db01              BLT      |L4.214|
                  |L4.210|
0000d2  2001              MOVS     r0,#1                 ;973
0000d4  e000              B        |L4.216|
                  |L4.214|
0000d6  2000              MOVS     r0,#0                 ;973
                  |L4.216|
0000d8  b920              CBNZ     r0,|L4.228|
0000da  7fa0              LDRB     r0,[r4,#0x1e]         ;974
0000dc  f00000a0          AND      r0,r0,#0xa0           ;974
0000e0  b900              CBNZ     r0,|L4.228|
0000e2  e077              B        |L4.468|
                  |L4.228|
0000e4  6828              LDR      r0,[r5,#0]            ;986
0000e6  66e0              STR      r0,[r4,#0x6c]         ;986
0000e8  7e20              LDRB     r0,[r4,#0x18]         ;988
0000ea  2802              CMP      r0,#2                 ;988
0000ec  d00b              BEQ      |L4.262|
0000ee  2010              MOVS     r0,#0x10              ;989
0000f0  f7fffffe          BL       lwip_htons
0000f4  6929              LDR      r1,[r5,#0x10]         ;989
0000f6  8989              LDRH     r1,[r1,#0xc]          ;989
0000f8  4308              ORRS     r0,r0,r1              ;989
0000fa  6929              LDR      r1,[r5,#0x10]         ;989
0000fc  8188              STRH     r0,[r1,#0xc]          ;989
0000fe  7fa0              LDRB     r0,[r4,#0x1e]         ;990
000100  f0200003          BIC      r0,r0,#3              ;990
000104  77a0              STRB     r0,[r4,#0x1e]         ;990
                  |L4.262|
000106  4621              MOV      r1,r4                 ;993
000108  4628              MOV      r0,r5                 ;993
00010a  f7fffffe          BL       tcp_output_segment
00010e  6929              LDR      r1,[r5,#0x10]         ;994
000110  6848              LDR      r0,[r1,#4]            ;994
000112  f7fffffe          BL       lwip_ntohl
000116  4607              MOV      r7,r0                 ;994
000118  6929              LDR      r1,[r5,#0x10]         ;994
00011a  8988              LDRH     r0,[r1,#0xc]          ;994
00011c  f7fffffe          BL       lwip_ntohs
000120  f0000003          AND      r0,r0,#3              ;994
000124  b108              CBZ      r0,|L4.298|
000126  2001              MOVS     r0,#1                 ;994
000128  e000              B        |L4.300|
                  |L4.298|
00012a  2000              MOVS     r0,#0                 ;994
                  |L4.300|
00012c  8929              LDRH     r1,[r5,#8]            ;994
00012e  4408              ADD      r0,r0,r1              ;994
000130  eb070800          ADD      r8,r7,r0              ;994
000134  6d20              LDR      r0,[r4,#0x50]         ;995
000136  ebb00008          SUBS     r0,r0,r8              ;995
00013a  d501              BPL      |L4.320|
00013c  f8c48050          STR      r8,[r4,#0x50]         ;996
                  |L4.320|
000140  6929              LDR      r1,[r5,#0x10]         ;999
000142  8988              LDRH     r0,[r1,#0xc]          ;999
000144  f7fffffe          BL       lwip_ntohs
000148  f0000003          AND      r0,r0,#3              ;999
00014c  b108              CBZ      r0,|L4.338|
00014e  2001              MOVS     r0,#1                 ;999
000150  e000              B        |L4.340|
                  |L4.338|
000152  2000              MOVS     r0,#0                 ;999
                  |L4.340|
000154  8929              LDRH     r1,[r5,#8]            ;999
000156  4408              ADD      r0,r0,r1              ;999
000158  2800              CMP      r0,#0                 ;999
00015a  dd2b              BLE      |L4.436|
00015c  2000              MOVS     r0,#0                 ;1000
00015e  6028              STR      r0,[r5,#0]            ;1000
000160  6f20              LDR      r0,[r4,#0x70]         ;1002
000162  b910              CBNZ     r0,|L4.362|
000164  6725              STR      r5,[r4,#0x70]         ;1003
000166  462e              MOV      r6,r5                 ;1004
000168  e027              B        |L4.442|
                  |L4.362|
00016a  6929              LDR      r1,[r5,#0x10]         ;1010
00016c  6848              LDR      r0,[r1,#4]            ;1010
00016e  f7fffffe          BL       lwip_ntohl
000172  4607              MOV      r7,r0                 ;1010
000174  6931              LDR      r1,[r6,#0x10]         ;1010
000176  6848              LDR      r0,[r1,#4]            ;1010
000178  f7fffffe          BL       lwip_ntohl
00017c  1a38              SUBS     r0,r7,r0              ;1010
00017e  d516              BPL      |L4.430|
000180  f1040770          ADD      r7,r4,#0x70           ;1012
000184  e000              B        |L4.392|
                  |L4.390|
000186  683f              LDR      r7,[r7,#0]            ;1015
                  |L4.392|
000188  6838              LDR      r0,[r7,#0]            ;1013
00018a  b160              CBZ      r0,|L4.422|
00018c  6839              LDR      r1,[r7,#0]            ;1014
00018e  6909              LDR      r1,[r1,#0x10]         ;1014
000190  6848              LDR      r0,[r1,#4]            ;1014
000192  f7fffffe          BL       lwip_ntohl
000196  4682              MOV      r10,r0                ;1014
000198  6929              LDR      r1,[r5,#0x10]         ;1014
00019a  6848              LDR      r0,[r1,#4]            ;1014
00019c  f7fffffe          BL       lwip_ntohl
0001a0  ebba0000          SUBS     r0,r10,r0             ;1014
0001a4  d4ef              BMI      |L4.390|
                  |L4.422|
0001a6  6838              LDR      r0,[r7,#0]            ;1017
0001a8  6028              STR      r0,[r5,#0]            ;1017
0001aa  603d              STR      r5,[r7,#0]            ;1018
0001ac  e005              B        |L4.442|
                  |L4.430|
0001ae  6035              STR      r5,[r6,#0]            ;1021
0001b0  6836              LDR      r6,[r6,#0]            ;1022
0001b2  e002              B        |L4.442|
                  |L4.436|
0001b4  4628              MOV      r0,r5                 ;1027
0001b6  f7fffffe          BL       tcp_seg_free
                  |L4.442|
0001ba  6ee5              LDR      r5,[r4,#0x6c]         ;1029
                  |L4.444|
0001bc  b155              CBZ      r5,|L4.468|
0001be  6929              LDR      r1,[r5,#0x10]         ;963
0001c0  6848              LDR      r0,[r1,#4]            ;963
0001c2  f7fffffe          BL       lwip_ntohl
0001c6  6ca1              LDR      r1,[r4,#0x48]         ;963
0001c8  1a40              SUBS     r0,r0,r1              ;963
0001ca  8929              LDRH     r1,[r5,#8]            ;963
0001cc  4408              ADD      r0,r0,r1              ;963
0001ce  4548              CMP      r0,r9                 ;963
0001d0  f67faf56          BLS      |L4.128|
                  |L4.468|
0001d4  bf00              NOP                            ;975
0001d6  6ee0              LDR      r0,[r4,#0x6c]         ;1032
0001d8  b910              CBNZ     r0,|L4.480|
0001da  2000              MOVS     r0,#0                 ;1034
0001dc  f8a4006a          STRH     r0,[r4,#0x6a]         ;1034
                  |L4.480|
0001e0  7fa0              LDRB     r0,[r4,#0x1e]         ;1038
0001e2  f0200080          BIC      r0,r0,#0x80           ;1038
0001e6  77a0              STRB     r0,[r4,#0x1e]         ;1038
0001e8  2000              MOVS     r0,#0                 ;1039
0001ea  e71f              B        |L4.44|
;;;1041   
                          ENDP

                  |L4.492|
0001ec  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp_out.c",0
0001f0  5749505c
0001f4  6c776970
0001f8  2d312e34
0001fc  2e315c73
000200  72635c63
000204  6f72655c
000208  7463705f
00020c  6f75742e
000210  6300    
000212  00                DCB      0
000213  00                DCB      0
                  |L4.532|
000214  646f6e27          DCB      "don't call tcp_output for listen-pcbs",0
000218  74206361
00021c  6c6c2074
000220  63705f6f
000224  75747075
000228  7420666f
00022c  72206c69
000230  7374656e
000234  2d706362
000238  7300    
00023a  00                DCB      0
00023b  00                DCB      0
                  |L4.572|
00023c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000240  7274696f
000244  6e202225
000248  73222066
00024c  61696c65
000250  64206174
000254  206c696e
000258  65202564
00025c  20696e20
000260  25730d0a
000264  00      
000265  00                DCB      0
000266  00                DCB      0
000267  00                DCB      0
                  |L4.616|
                          DCD      tcp_input_pcb
                  |L4.620|
00026c  52535420          DCB      "RST not expected here!",0
000270  6e6f7420
000274  65787065
000278  63746564
00027c  20686572
000280  652100  
000283  00                DCB      0

                          AREA ||i.tcp_output_alloc_header||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_output_alloc_header PROC
;;;93     static struct pbuf *
;;;94     tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;95                           u32_t seqno_be /* already in network byte order */)
;;;96     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;97       struct tcp_hdr *tcphdr;
;;;98       struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
00000c  f1060014          ADD      r0,r6,#0x14
000010  4440              ADD      r0,r0,r8
000012  b281              UXTH     r1,r0
000014  2200              MOVS     r2,#0
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       pbuf_alloc
00001c  4607              MOV      r7,r0
;;;99       if (p != NULL) {
00001e  2f00              CMP      r7,#0
000020  d035              BEQ      |L5.142|
;;;100        LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
000022  bf00              NOP      
000024  8979              LDRH     r1,[r7,#0xa]
000026  f1060014          ADD      r0,r6,#0x14
00002a  4281              CMP      r1,r0
00002c  da07              BGE      |L5.62|
00002e  bf00              NOP      
000030  a318              ADR      r3,|L5.148|
000032  2264              MOVS     r2,#0x64
000034  a121              ADR      r1,|L5.188|
000036  a02d              ADR      r0,|L5.236|
000038  f7fffffe          BL       __2printf
00003c  bf00              NOP      
                  |L5.62|
00003e  bf00              NOP      
;;;101                     (p->len >= TCP_HLEN + optlen));
;;;102        tcphdr = (struct tcp_hdr *)p->payload;
000040  687c              LDR      r4,[r7,#4]
;;;103        tcphdr->src = htons(pcb->local_port);
000042  8b68              LDRH     r0,[r5,#0x1a]
000044  f7fffffe          BL       lwip_htons
000048  8020              STRH     r0,[r4,#0]
;;;104        tcphdr->dest = htons(pcb->remote_port);
00004a  8ba8              LDRH     r0,[r5,#0x1c]
00004c  f7fffffe          BL       lwip_htons
000050  8060              STRH     r0,[r4,#2]
;;;105        tcphdr->seqno = seqno_be;
000052  f8c49004          STR      r9,[r4,#4]
;;;106        tcphdr->ackno = htonl(pcb->rcv_nxt);
000056  6aa8              LDR      r0,[r5,#0x28]
000058  f7fffffe          BL       lwip_htonl
00005c  60a0              STR      r0,[r4,#8]
;;;107        TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
00005e  46b2              MOV      r10,r6
000060  17f1              ASRS     r1,r6,#31
000062  eb067191          ADD      r1,r6,r1,LSR #30
000066  1089              ASRS     r1,r1,#2
000068  1d49              ADDS     r1,r1,#5
00006a  2210              MOVS     r2,#0x10
00006c  ea423101          ORR      r1,r2,r1,LSL #12
000070  b288              UXTH     r0,r1
000072  f7fffffe          BL       lwip_htons
000076  81a0              STRH     r0,[r4,#0xc]
;;;108        tcphdr->wnd = htons(pcb->rcv_ann_wnd);
000078  8de8              LDRH     r0,[r5,#0x2e]
00007a  f7fffffe          BL       lwip_htons
00007e  81e0              STRH     r0,[r4,#0xe]
;;;109        tcphdr->chksum = 0;
000080  2000              MOVS     r0,#0
000082  8220              STRH     r0,[r4,#0x10]
;;;110        tcphdr->urgp = 0;
000084  8260              STRH     r0,[r4,#0x12]
;;;111    
;;;112        /* If we're sending a packet, update the announced right window edge */
;;;113        pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
000086  8de9              LDRH     r1,[r5,#0x2e]
000088  6aa8              LDR      r0,[r5,#0x28]
00008a  4408              ADD      r0,r0,r1
00008c  6328              STR      r0,[r5,#0x30]
                  |L5.142|
;;;114      }
;;;115      return p;
00008e  4638              MOV      r0,r7
;;;116    }
000090  e8bd87f0          POP      {r4-r10,pc}
;;;117    
                          ENDP

                  |L5.148|
000094  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp_out.c",0
000098  5749505c
00009c  6c776970
0000a0  2d312e34
0000a4  2e315c73
0000a8  72635c63
0000ac  6f72655c
0000b0  7463705f
0000b4  6f75742e
0000b8  6300    
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L5.188|
0000bc  63686563          DCB      "check that first pbuf can hold struct tcp_hdr",0
0000c0  6b207468
0000c4  61742066
0000c8  69727374
0000cc  20706275
0000d0  66206361
0000d4  6e20686f
0000d8  6c642073
0000dc  74727563
0000e0  74207463
0000e4  705f6864
0000e8  7200    
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L5.236|
0000ec  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000f0  7274696f
0000f4  6e202225
0000f8  73222066
0000fc  61696c65
000100  64206174
000104  206c696e
000108  65202564
00010c  20696e20
000110  25730d0a
000114  00      
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0

                          AREA ||i.tcp_output_segment||, CODE, READONLY, ALIGN=2

                  tcp_output_segment PROC
;;;1048   static void
;;;1049   tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1050   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1051     u16_t len;
;;;1052     struct netif *netif;
;;;1053     u32_t *opts;
;;;1054   
;;;1055     /** @bug Exclude retransmitted segments from this count. */
;;;1056     snmp_inc_tcpoutsegs();
;;;1057   
;;;1058     /* The TCP header has already been constructed, but the ackno and
;;;1059      wnd fields remain. */
;;;1060     seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
000008  6aa0              LDR      r0,[r4,#0x28]
00000a  f7fffffe          BL       lwip_htonl
00000e  6929              LDR      r1,[r5,#0x10]
000010  6088              STR      r0,[r1,#8]
;;;1061   
;;;1062     /* advertise our receive window size in this TCP segment */
;;;1063     seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
000012  8de0              LDRH     r0,[r4,#0x2e]
000014  f7fffffe          BL       lwip_htons
000018  6929              LDR      r1,[r5,#0x10]
00001a  81c8              STRH     r0,[r1,#0xe]
;;;1064   
;;;1065     pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
00001c  8de1              LDRH     r1,[r4,#0x2e]
00001e  6aa0              LDR      r0,[r4,#0x28]
000020  4408              ADD      r0,r0,r1
000022  6320              STR      r0,[r4,#0x30]
;;;1066   
;;;1067     /* Add any requested options.  NB MSS option is only set on SYN
;;;1068        packets, so ignore it here */
;;;1069     opts = (u32_t *)(void *)(seg->tcphdr + 1);
000024  6928              LDR      r0,[r5,#0x10]
000026  f1000814          ADD      r8,r0,#0x14
;;;1070     if (seg->flags & TF_SEG_OPTS_MSS) {
00002a  7b28              LDRB     r0,[r5,#0xc]
00002c  f0000001          AND      r0,r0,#1
000030  b170              CBZ      r0,|L6.80|
;;;1071       u16_t mss;
;;;1072   #if TCP_CALCULATE_EFF_SEND_MSS
;;;1073       mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
000032  1d21              ADDS     r1,r4,#4
000034  f24050b4          MOV      r0,#0x5b4
000038  f7fffffe          BL       tcp_eff_send_mss
00003c  4681              MOV      r9,r0
;;;1074   #else /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1075       mss = TCP_MSS;
;;;1076   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1077       *opts = TCP_BUILD_MSS_OPTION(mss);
00003e  f0497001          ORR      r0,r9,#0x2040000
000042  f7fffffe          BL       lwip_htonl
000046  f8c80000          STR      r0,[r8,#0]
;;;1078       opts += 1;
00004a  f1080804          ADD      r8,r8,#4
;;;1079     }
00004e  bf00              NOP      
                  |L6.80|
;;;1080   #if LWIP_TCP_TIMESTAMPS
;;;1081     pcb->ts_lastacksent = pcb->rcv_nxt;
;;;1082   
;;;1083     if (seg->flags & TF_SEG_OPTS_TS) {
;;;1084       tcp_build_timestamp_option(pcb, opts);
;;;1085       opts += 3;
;;;1086     }
;;;1087   #endif
;;;1088   
;;;1089     /* Set retransmission timer running if it is not currently enabled 
;;;1090        This must be set before checking the route. */
;;;1091     if (pcb->rtime == -1) {
000050  f9b40034          LDRSH    r0,[r4,#0x34]
000054  1c40              ADDS     r0,r0,#1
000056  b908              CBNZ     r0,|L6.92|
;;;1092       pcb->rtime = 0;
000058  2000              MOVS     r0,#0
00005a  86a0              STRH     r0,[r4,#0x34]
                  |L6.92|
;;;1093     }
;;;1094   
;;;1095     /* If we don't have a local IP address, we get one by
;;;1096        calling ip_route(). */
;;;1097     if (ip_addr_isany(&(pcb->local_ip))) {
00005c  b10c              CBZ      r4,|L6.98|
00005e  6820              LDR      r0,[r4,#0]
000060  b940              CBNZ     r0,|L6.116|
                  |L6.98|
;;;1098       netif = ip_route(&(pcb->remote_ip));
000062  1d20              ADDS     r0,r4,#4
000064  f7fffffe          BL       ip_route
000068  4606              MOV      r6,r0
;;;1099       if (netif == NULL) {
00006a  b90e              CBNZ     r6,|L6.112|
                  |L6.108|
;;;1100         return;
;;;1101       }
;;;1102       ip_addr_copy(pcb->local_ip, netif->ip_addr);
;;;1103     }
;;;1104   
;;;1105     if (pcb->rttest == 0) {
;;;1106       pcb->rttest = tcp_ticks;
;;;1107       pcb->rtseq = ntohl(seg->tcphdr->seqno);
;;;1108   
;;;1109       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_output_segment: rtseq %"U32_F"\n", pcb->rtseq));
;;;1110     }
;;;1111     LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
;;;1112             htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
;;;1113             seg->len));
;;;1114   
;;;1115     len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
;;;1116   
;;;1117     seg->p->len -= len;
;;;1118     seg->p->tot_len -= len;
;;;1119   
;;;1120     seg->p->payload = seg->tcphdr;
;;;1121   
;;;1122     seg->tcphdr->chksum = 0;
;;;1123   #if CHECKSUM_GEN_TCP
;;;1124   #if TCP_CHECKSUM_ON_COPY
;;;1125     {
;;;1126       u32_t acc;
;;;1127   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1128       u16_t chksum_slow = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
;;;1129              &(pcb->remote_ip),
;;;1130              IP_PROTO_TCP, seg->p->tot_len);
;;;1131   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1132       if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {
;;;1133         LWIP_ASSERT("data included but not checksummed",
;;;1134           seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
;;;1135       }
;;;1136   
;;;1137       /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
;;;1138       acc = inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
;;;1139                &(pcb->remote_ip),
;;;1140                IP_PROTO_TCP, seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4);
;;;1141       /* add payload checksum */
;;;1142       if (seg->chksum_swapped) {
;;;1143         seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
;;;1144         seg->chksum_swapped = 0;
;;;1145       }
;;;1146       acc += (u16_t)~(seg->chksum);
;;;1147       seg->tcphdr->chksum = FOLD_U32T(acc);
;;;1148   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1149       if (chksum_slow != seg->tcphdr->chksum) {
;;;1150         LWIP_DEBUGF(TCP_DEBUG | LWIP_DBG_LEVEL_WARNING,
;;;1151                     ("tcp_output_segment: calculated checksum is %"X16_F" instead of %"X16_F"\n",
;;;1152                     seg->tcphdr->chksum, chksum_slow));
;;;1153         seg->tcphdr->chksum = chksum_slow;
;;;1154       }
;;;1155   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1156     }
;;;1157   #else /* TCP_CHECKSUM_ON_COPY */
;;;1158     seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
;;;1159            &(pcb->remote_ip),
;;;1160            IP_PROTO_TCP, seg->p->tot_len);
;;;1161   #endif /* TCP_CHECKSUM_ON_COPY */
;;;1162   #endif /* CHECKSUM_GEN_TCP */
;;;1163     TCP_STATS_INC(tcp.xmit);
;;;1164   
;;;1165   #if LWIP_NETIF_HWADDRHINT
;;;1166     ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;1167         IP_PROTO_TCP, &(pcb->addr_hint));
;;;1168   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1169     ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;1170         IP_PROTO_TCP);
;;;1171   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1172   }
00006c  e8bd87fc          POP      {r2-r10,pc}
                  |L6.112|
000070  6870              LDR      r0,[r6,#4]            ;1102
000072  6020              STR      r0,[r4,#0]            ;1102
                  |L6.116|
000074  6ba0              LDR      r0,[r4,#0x38]         ;1105
000076  b948              CBNZ     r0,|L6.140|
000078  481b              LDR      r0,|L6.232|
00007a  6800              LDR      r0,[r0,#0]            ;1106  ; tcp_ticks
00007c  63a0              STR      r0,[r4,#0x38]         ;1106
00007e  6929              LDR      r1,[r5,#0x10]         ;1107
000080  6848              LDR      r0,[r1,#4]            ;1107
000082  f7fffffe          BL       lwip_ntohl
000086  63e0              STR      r0,[r4,#0x3c]         ;1107
000088  bf00              NOP                            ;1109
00008a  bf00              NOP                            ;1109
                  |L6.140|
00008c  bf00              NOP                            ;1111
00008e  bf00              NOP                            ;1111
000090  8a28              LDRH     r0,[r5,#0x10]         ;1115
000092  6869              LDR      r1,[r5,#4]            ;1115
000094  8889              LDRH     r1,[r1,#4]            ;1115
000096  1a40              SUBS     r0,r0,r1              ;1115
000098  b287              UXTH     r7,r0                 ;1115
00009a  6868              LDR      r0,[r5,#4]            ;1117
00009c  8940              LDRH     r0,[r0,#0xa]          ;1117
00009e  1bc0              SUBS     r0,r0,r7              ;1117
0000a0  6869              LDR      r1,[r5,#4]            ;1117
0000a2  8148              STRH     r0,[r1,#0xa]          ;1117
0000a4  6868              LDR      r0,[r5,#4]            ;1118
0000a6  8900              LDRH     r0,[r0,#8]            ;1118
0000a8  1bc0              SUBS     r0,r0,r7              ;1118
0000aa  6869              LDR      r1,[r5,#4]            ;1118
0000ac  8108              STRH     r0,[r1,#8]            ;1118
0000ae  6869              LDR      r1,[r5,#4]            ;1120
0000b0  6928              LDR      r0,[r5,#0x10]         ;1120
0000b2  6048              STR      r0,[r1,#4]            ;1120
0000b4  2000              MOVS     r0,#0                 ;1122
0000b6  6929              LDR      r1,[r5,#0x10]         ;1122
0000b8  8208              STRH     r0,[r1,#0x10]         ;1122
0000ba  6868              LDR      r0,[r5,#4]            ;1158
0000bc  8900              LDRH     r0,[r0,#8]            ;1158
0000be  9000              STR      r0,[sp,#0]            ;1158
0000c0  2306              MOVS     r3,#6                 ;1158
0000c2  1d22              ADDS     r2,r4,#4              ;1158
0000c4  4621              MOV      r1,r4                 ;1158
0000c6  6868              LDR      r0,[r5,#4]            ;1158
0000c8  f7fffffe          BL       inet_chksum_pseudo
0000cc  6929              LDR      r1,[r5,#0x10]         ;1158
0000ce  8208              STRH     r0,[r1,#0x10]         ;1158
0000d0  2106              MOVS     r1,#6                 ;1169
0000d2  7a60              LDRB     r0,[r4,#9]            ;1169
0000d4  e9cd0100          STRD     r0,r1,[sp,#0]         ;1169
0000d8  7aa3              LDRB     r3,[r4,#0xa]          ;1169
0000da  1d22              ADDS     r2,r4,#4              ;1169
0000dc  4621              MOV      r1,r4                 ;1169
0000de  6868              LDR      r0,[r5,#4]            ;1169
0000e0  f7fffffe          BL       ip_output
0000e4  bf00              NOP      
0000e6  e7c1              B        |L6.108|
;;;1173   
                          ENDP

                  |L6.232|
                          DCD      tcp_ticks

                          AREA ||i.tcp_pbuf_prealloc||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_pbuf_prealloc PROC
;;;218    static struct pbuf *
;;;219    tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;220                      u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
;;;221                      u8_t first_seg)
;;;222    {
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
000008  4698              MOV      r8,r3
00000a  e9ddab0f          LDRD     r10,r11,[sp,#0x3c]
00000e  9f0e              LDR      r7,[sp,#0x38]
;;;223      struct pbuf *p;
;;;224      u16_t alloc = length;
000010  46a1              MOV      r9,r4
;;;225    
;;;226    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;227      LWIP_UNUSED_ARG(max_length);
;;;228      LWIP_UNUSED_ARG(pcb);
;;;229      LWIP_UNUSED_ARG(apiflags);
;;;230      LWIP_UNUSED_ARG(first_seg);
;;;231      /* always create MSS-sized pbufs */
;;;232      alloc = max_length;
;;;233    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;234      if (length < max_length) {
000012  42b4              CMP      r4,r6
000014  da1b              BGE      |L7.78|
;;;235        /* Should we allocate an oversized pbuf, or just the minimum
;;;236         * length required? If tcp_write is going to be called again
;;;237         * before this segment is transmitted, we want the oversized
;;;238         * buffer. If the segment will be transmitted immediately, we can
;;;239         * save memory by allocating only length. We use a simple
;;;240         * heuristic based on the following information:
;;;241         *
;;;242         * Did the user set TCP_WRITE_FLAG_MORE?
;;;243         *
;;;244         * Will the Nagle algorithm defer transmission of this segment?
;;;245         */
;;;246        if ((apiflags & TCP_WRITE_FLAG_MORE) ||
000016  f00a0002          AND      r0,r10,#2
00001a  b950              CBNZ     r0,|L7.50|
;;;247            (!(pcb->flags & TF_NODELAY) &&
00001c  7fb8              LDRB     r0,[r7,#0x1e]
00001e  f0000040          AND      r0,r0,#0x40
000022  b9a0              CBNZ     r0,|L7.78|
;;;248             (!first_seg ||
000024  f1bb0f00          CMP      r11,#0
000028  d003              BEQ      |L7.50|
;;;249              pcb->unsent != NULL ||
00002a  6ef8              LDR      r0,[r7,#0x6c]
00002c  b908              CBNZ     r0,|L7.50|
;;;250              pcb->unacked != NULL))) {
00002e  6f38              LDR      r0,[r7,#0x70]
000030  b168              CBZ      r0,|L7.78|
                  |L7.50|
;;;251          alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
000032  f20450b7          ADD      r0,r4,#0x5b7
000036  f0200003          BIC      r0,r0,#3
00003a  42b0              CMP      r0,r6
00003c  dd01              BLE      |L7.66|
00003e  4630              MOV      r0,r6
000040  e003              B        |L7.74|
                  |L7.66|
000042  f20450b7          ADD      r0,r4,#0x5b7
000046  f0200003          BIC      r0,r0,#3
                  |L7.74|
00004a  fa1ff980          UXTH     r9,r0
                  |L7.78|
;;;252        }
;;;253      }
;;;254    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;255      p = pbuf_alloc(layer, alloc, PBUF_RAM);
00004e  2200              MOVS     r2,#0
000050  4649              MOV      r1,r9
000052  9800              LDR      r0,[sp,#0]
000054  f7fffffe          BL       pbuf_alloc
000058  4605              MOV      r5,r0
;;;256      if (p == NULL) {
00005a  b91d              CBNZ     r5,|L7.100|
;;;257        return NULL;
00005c  2000              MOVS     r0,#0
                  |L7.94|
;;;258      }
;;;259      LWIP_ASSERT("need unchained pbuf", p->next == NULL);
;;;260      *oversize = p->len - length;
;;;261      /* trim p->len to the currently used size */
;;;262      p->len = p->tot_len = length;
;;;263      return p;
;;;264    }
00005e  b004              ADD      sp,sp,#0x10
000060  e8bd9ff0          POP      {r4-r12,pc}
                  |L7.100|
000064  bf00              NOP                            ;259
000066  6828              LDR      r0,[r5,#0]            ;259
000068  b140              CBZ      r0,|L7.124|
00006a  bf00              NOP                            ;259
00006c  a308              ADR      r3,|L7.144|
00006e  f2401203          MOV      r2,#0x103             ;259
000072  a111              ADR      r1,|L7.184|
000074  a015              ADR      r0,|L7.204|
000076  f7fffffe          BL       __2printf
00007a  bf00              NOP                            ;259
                  |L7.124|
00007c  bf00              NOP                            ;259
00007e  8968              LDRH     r0,[r5,#0xa]          ;260
000080  1b00              SUBS     r0,r0,r4              ;260
000082  f8a80000          STRH     r0,[r8,#0]            ;260
000086  812c              STRH     r4,[r5,#8]            ;262
000088  816c              STRH     r4,[r5,#0xa]          ;262
00008a  4628              MOV      r0,r5                 ;263
00008c  e7e7              B        |L7.94|
;;;265    #else /* TCP_OVERSIZE */
                          ENDP

00008e  0000              DCW      0x0000
                  |L7.144|
000090  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp_out.c",0
000094  5749505c
000098  6c776970
00009c  2d312e34
0000a0  2e315c73
0000a4  72635c63
0000a8  6f72655c
0000ac  7463705f
0000b0  6f75742e
0000b4  6300    
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L7.184|
0000b8  6e656564          DCB      "need unchained pbuf",0
0000bc  20756e63
0000c0  6861696e
0000c4  65642070
0000c8  62756600
                  |L7.204|
0000cc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000d0  7274696f
0000d4  6e202225
0000d8  73222066
0000dc  61696c65
0000e0  64206174
0000e4  206c696e
0000e8  65202564
0000ec  20696e20
0000f0  25730d0a
0000f4  00      
0000f5  00                DCB      0
0000f6  00                DCB      0
0000f7  00                DCB      0

                          AREA ||i.tcp_rexmit||, CODE, READONLY, ALIGN=1

                  tcp_rexmit PROC
;;;1274   void
;;;1275   tcp_rexmit(struct tcp_pcb *pcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1276   {
000004  4604              MOV      r4,r0
;;;1277     struct tcp_seg *seg;
;;;1278     struct tcp_seg **cur_seg;
;;;1279   
;;;1280     if (pcb->unacked == NULL) {
000006  6f20              LDR      r0,[r4,#0x70]
000008  b908              CBNZ     r0,|L8.14|
                  |L8.10|
;;;1281       return;
;;;1282     }
;;;1283   
;;;1284     /* Move the first unacked segment to the unsent queue */
;;;1285     /* Keep the unsent queue sorted. */
;;;1286     seg = pcb->unacked;
;;;1287     pcb->unacked = seg->next;
;;;1288   
;;;1289     cur_seg = &(pcb->unsent);
;;;1290     while (*cur_seg &&
;;;1291       TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
;;;1292         cur_seg = &((*cur_seg)->next );
;;;1293     }
;;;1294     seg->next = *cur_seg;
;;;1295     *cur_seg = seg;
;;;1296   #if TCP_OVERSIZE
;;;1297     if (seg->next == NULL) {
;;;1298       /* the retransmitted segment is last in unsent, so reset unsent_oversize */
;;;1299       pcb->unsent_oversize = 0;
;;;1300     }
;;;1301   #endif /* TCP_OVERSIZE */
;;;1302   
;;;1303     ++pcb->nrtx;
;;;1304   
;;;1305     /* Don't take any rtt measurements after retransmitting. */
;;;1306     pcb->rttest = 0;
;;;1307   
;;;1308     /* Do the actual retransmission. */
;;;1309     snmp_inc_tcpretranssegs();
;;;1310     /* No need to call tcp_output: we are always called from tcp_input()
;;;1311        and thus tcp_output directly returns. */
;;;1312   }
00000a  e8bd81f0          POP      {r4-r8,pc}
                  |L8.14|
00000e  6f25              LDR      r5,[r4,#0x70]         ;1286
000010  6828              LDR      r0,[r5,#0]            ;1287
000012  6720              STR      r0,[r4,#0x70]         ;1287
000014  f104066c          ADD      r6,r4,#0x6c           ;1289
000018  e000              B        |L8.28|
                  |L8.26|
00001a  6836              LDR      r6,[r6,#0]            ;1292
                  |L8.28|
00001c  6830              LDR      r0,[r6,#0]            ;1290
00001e  b158              CBZ      r0,|L8.56|
000020  6831              LDR      r1,[r6,#0]            ;1291
000022  6909              LDR      r1,[r1,#0x10]         ;1291
000024  6848              LDR      r0,[r1,#4]            ;1291
000026  f7fffffe          BL       lwip_ntohl
00002a  4607              MOV      r7,r0                 ;1291
00002c  6929              LDR      r1,[r5,#0x10]         ;1291
00002e  6848              LDR      r0,[r1,#4]            ;1291
000030  f7fffffe          BL       lwip_ntohl
000034  1a38              SUBS     r0,r7,r0              ;1291
000036  d4f0              BMI      |L8.26|
                  |L8.56|
000038  6830              LDR      r0,[r6,#0]            ;1294
00003a  6028              STR      r0,[r5,#0]            ;1294
00003c  6035              STR      r5,[r6,#0]            ;1295
00003e  6828              LDR      r0,[r5,#0]            ;1297
000040  b910              CBNZ     r0,|L8.72|
000042  2000              MOVS     r0,#0                 ;1299
000044  f8a4006a          STRH     r0,[r4,#0x6a]         ;1299
                  |L8.72|
000048  f8940046          LDRB     r0,[r4,#0x46]         ;1303
00004c  1c40              ADDS     r0,r0,#1              ;1303
00004e  f8840046          STRB     r0,[r4,#0x46]         ;1303
000052  2000              MOVS     r0,#0                 ;1306
000054  63a0              STR      r0,[r4,#0x38]         ;1306
000056  bf00              NOP      
000058  e7d7              B        |L8.10|
;;;1313   
                          ENDP


                          AREA ||i.tcp_rexmit_fast||, CODE, READONLY, ALIGN=1

                  tcp_rexmit_fast PROC
;;;1320   void 
;;;1321   tcp_rexmit_fast(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;1322   {
000002  4604              MOV      r4,r0
;;;1323     if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
000004  6f20              LDR      r0,[r4,#0x70]
000006  b3b0              CBZ      r0,|L9.118|
000008  7fa0              LDRB     r0,[r4,#0x1e]
00000a  f0000004          AND      r0,r0,#4
00000e  bb90              CBNZ     r0,|L9.118|
;;;1324       /* This is fast retransmit. Retransmit the first unacked segment. */
;;;1325       LWIP_DEBUGF(TCP_FR_DEBUG, 
000010  bf00              NOP      
000012  bf00              NOP      
;;;1326                   ("tcp_receive: dupacks %"U16_F" (%"U32_F
;;;1327                    "), fast retransmit %"U32_F"\n",
;;;1328                    (u16_t)pcb->dupacks, pcb->lastack,
;;;1329                    ntohl(pcb->unacked->tcphdr->seqno)));
;;;1330       tcp_rexmit(pcb);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       tcp_rexmit
;;;1331   
;;;1332       /* Set ssthresh to half of the minimum of the current
;;;1333        * cwnd and the advertised window */
;;;1334       if (pcb->cwnd > pcb->snd_wnd) {
00001a  f8b4004c          LDRH     r0,[r4,#0x4c]
00001e  f8b41060          LDRH     r1,[r4,#0x60]
000022  4288              CMP      r0,r1
000024  dd07              BLE      |L9.54|
;;;1335         pcb->ssthresh = pcb->snd_wnd / 2;
000026  f8b40060          LDRH     r0,[r4,#0x60]
00002a  eb0071d0          ADD      r1,r0,r0,LSR #31
00002e  1049              ASRS     r1,r1,#1
000030  f8a4104e          STRH     r1,[r4,#0x4e]
000034  e006              B        |L9.68|
                  |L9.54|
;;;1336       } else {
;;;1337         pcb->ssthresh = pcb->cwnd / 2;
000036  f8b4004c          LDRH     r0,[r4,#0x4c]
00003a  eb0071d0          ADD      r1,r0,r0,LSR #31
00003e  1049              ASRS     r1,r1,#1
000040  f8a4104e          STRH     r1,[r4,#0x4e]
                  |L9.68|
;;;1338       }
;;;1339       
;;;1340       /* The minimum value for ssthresh should be 2 MSS */
;;;1341       if (pcb->ssthresh < 2*pcb->mss) {
000044  f8b4004e          LDRH     r0,[r4,#0x4e]
000048  8ee1              LDRH     r1,[r4,#0x36]
00004a  0049              LSLS     r1,r1,#1
00004c  4288              CMP      r0,r1
00004e  da06              BGE      |L9.94|
;;;1342         LWIP_DEBUGF(TCP_FR_DEBUG, 
000050  bf00              NOP      
000052  bf00              NOP      
;;;1343                     ("tcp_receive: The minimum value for ssthresh %"U16_F
;;;1344                      " should be min 2 mss %"U16_F"...\n",
;;;1345                      pcb->ssthresh, 2*pcb->mss));
;;;1346         pcb->ssthresh = 2*pcb->mss;
000054  8ee0              LDRH     r0,[r4,#0x36]
000056  0440              LSLS     r0,r0,#17
000058  0c00              LSRS     r0,r0,#16
00005a  f8a4004e          STRH     r0,[r4,#0x4e]
                  |L9.94|
;;;1347       }
;;;1348       
;;;1349       pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
00005e  f8b4004e          LDRH     r0,[r4,#0x4e]
000062  8ee1              LDRH     r1,[r4,#0x36]
000064  2203              MOVS     r2,#3
000066  fb020001          MLA      r0,r2,r1,r0
00006a  f8a4004c          STRH     r0,[r4,#0x4c]
;;;1350       pcb->flags |= TF_INFR;
00006e  7fa0              LDRB     r0,[r4,#0x1e]
000070  f0400004          ORR      r0,r0,#4
000074  77a0              STRB     r0,[r4,#0x1e]
                  |L9.118|
;;;1351     } 
;;;1352   }
000076  bd10              POP      {r4,pc}
;;;1353   
                          ENDP


                          AREA ||i.tcp_rexmit_rto||, CODE, READONLY, ALIGN=1

                  tcp_rexmit_rto PROC
;;;1238   void
;;;1239   tcp_rexmit_rto(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;1240   {
000002  4604              MOV      r4,r0
;;;1241     struct tcp_seg *seg;
;;;1242   
;;;1243     if (pcb->unacked == NULL) {
000004  6f20              LDR      r0,[r4,#0x70]
000006  b900              CBNZ     r0,|L10.10|
                  |L10.8|
;;;1244       return;
;;;1245     }
;;;1246   
;;;1247     /* Move all unacked segments to the head of the unsent queue */
;;;1248     for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
;;;1249     /* concatenate unsent queue after unacked queue */
;;;1250     seg->next = pcb->unsent;
;;;1251     /* unsent queue is the concatenated queue (of unacked, unsent) */
;;;1252     pcb->unsent = pcb->unacked;
;;;1253     /* unacked queue is now empty */
;;;1254     pcb->unacked = NULL;
;;;1255     /* last unsent hasn't changed, no need to reset unsent_oversize */
;;;1256   
;;;1257     /* increment number of retransmissions */
;;;1258     ++pcb->nrtx;
;;;1259   
;;;1260     /* Don't take any RTT measurements after retransmitting. */
;;;1261     pcb->rttest = 0;
;;;1262   
;;;1263     /* Do the actual retransmission */
;;;1264     tcp_output(pcb);
;;;1265   }
000008  bd70              POP      {r4-r6,pc}
                  |L10.10|
00000a  6f25              LDR      r5,[r4,#0x70]         ;1248
00000c  e000              B        |L10.16|
                  |L10.14|
00000e  682d              LDR      r5,[r5,#0]            ;1248
                  |L10.16|
000010  6828              LDR      r0,[r5,#0]            ;1248
000012  2800              CMP      r0,#0                 ;1248
000014  d1fb              BNE      |L10.14|
000016  6ee0              LDR      r0,[r4,#0x6c]         ;1250
000018  6028              STR      r0,[r5,#0]            ;1250
00001a  6f20              LDR      r0,[r4,#0x70]         ;1252
00001c  66e0              STR      r0,[r4,#0x6c]         ;1252
00001e  2000              MOVS     r0,#0                 ;1254
000020  6720              STR      r0,[r4,#0x70]         ;1254
000022  f8940046          LDRB     r0,[r4,#0x46]         ;1258
000026  1c40              ADDS     r0,r0,#1              ;1258
000028  f8840046          STRB     r0,[r4,#0x46]         ;1258
00002c  2000              MOVS     r0,#0                 ;1261
00002e  63a0              STR      r0,[r4,#0x38]         ;1261
000030  4620              MOV      r0,r4                 ;1264
000032  f7fffffe          BL       tcp_output
000036  bf00              NOP      
000038  e7e6              B        |L10.8|
;;;1266   
                          ENDP


                          AREA ||i.tcp_rst||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_rst PROC
;;;1194   void
;;;1195   tcp_rst(u32_t seqno, u32_t ackno,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1196     ip_addr_t *local_ip, ip_addr_t *remote_ip,
;;;1197     u16_t local_port, u16_t remote_port)
;;;1198   {
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9ddab0c          LDRD     r10,r11,[sp,#0x30]
;;;1199     struct pbuf *p;
;;;1200     struct tcp_hdr *tcphdr;
;;;1201     p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
000010  2200              MOVS     r2,#0
000012  2114              MOVS     r1,#0x14
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       pbuf_alloc
00001a  4605              MOV      r5,r0
;;;1202     if (p == NULL) {
00001c  b91d              CBNZ     r5,|L11.38|
;;;1203         LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
00001e  bf00              NOP      
000020  bf00              NOP      
                  |L11.34|
;;;1204         return;
;;;1205     }
;;;1206     LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
;;;1207                 (p->len >= sizeof(struct tcp_hdr)));
;;;1208   
;;;1209     tcphdr = (struct tcp_hdr *)p->payload;
;;;1210     tcphdr->src = htons(local_port);
;;;1211     tcphdr->dest = htons(remote_port);
;;;1212     tcphdr->seqno = htonl(seqno);
;;;1213     tcphdr->ackno = htonl(ackno);
;;;1214     TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
;;;1215     tcphdr->wnd = PP_HTONS(TCP_WND);
;;;1216     tcphdr->chksum = 0;
;;;1217     tcphdr->urgp = 0;
;;;1218   
;;;1219   #if CHECKSUM_GEN_TCP
;;;1220     tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
;;;1221                 IP_PROTO_TCP, p->tot_len);
;;;1222   #endif
;;;1223     TCP_STATS_INC(tcp.xmit);
;;;1224     snmp_inc_tcpoutrsts();
;;;1225      /* Send output with hardcoded TTL since we have no access to the pcb */
;;;1226     ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
;;;1227     pbuf_free(p);
;;;1228     LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
;;;1229   }
000022  e8bd9ffc          POP      {r2-r12,pc}
                  |L11.38|
000026  bf00              NOP                            ;1206
000028  8968              LDRH     r0,[r5,#0xa]          ;1206
00002a  2814              CMP      r0,#0x14              ;1206
00002c  d208              BCS      |L11.64|
00002e  bf00              NOP                            ;1206
000030  a31f              ADR      r3,|L11.176|
000032  f24042b6          MOV      r2,#0x4b6             ;1206
000036  a128              ADR      r1,|L11.216|
000038  a033              ADR      r0,|L11.264|
00003a  f7fffffe          BL       __2printf
00003e  bf00              NOP                            ;1206
                  |L11.64|
000040  bf00              NOP                            ;1206
000042  686c              LDR      r4,[r5,#4]            ;1209
000044  4650              MOV      r0,r10                ;1210
000046  f7fffffe          BL       lwip_htons
00004a  8020              STRH     r0,[r4,#0]            ;1210
00004c  4658              MOV      r0,r11                ;1211
00004e  f7fffffe          BL       lwip_htons
000052  8060              STRH     r0,[r4,#2]            ;1211
000054  4648              MOV      r0,r9                 ;1212
000056  f7fffffe          BL       lwip_htonl
00005a  6060              STR      r0,[r4,#4]            ;1212
00005c  4630              MOV      r0,r6                 ;1213
00005e  f7fffffe          BL       lwip_htonl
000062  60a0              STR      r0,[r4,#8]            ;1213
000064  f2450014          MOV      r0,#0x5014            ;1214
000068  f7fffffe          BL       lwip_htons
00006c  81a0              STRH     r0,[r4,#0xc]          ;1214
00006e  f646000b          MOV      r0,#0x680b            ;1215
000072  81e0              STRH     r0,[r4,#0xe]          ;1215
000074  2000              MOVS     r0,#0                 ;1216
000076  8220              STRH     r0,[r4,#0x10]         ;1216
000078  8260              STRH     r0,[r4,#0x12]         ;1217
00007a  8928              LDRH     r0,[r5,#8]            ;1220
00007c  2306              MOVS     r3,#6                 ;1220
00007e  4642              MOV      r2,r8                 ;1220
000080  4639              MOV      r1,r7                 ;1220
000082  9000              STR      r0,[sp,#0]            ;1220
000084  4628              MOV      r0,r5                 ;1220
000086  f7fffffe          BL       inet_chksum_pseudo
00008a  8220              STRH     r0,[r4,#0x10]         ;1220
00008c  2006              MOVS     r0,#6                 ;1226
00008e  2100              MOVS     r1,#0                 ;1226
000090  23ff              MOVS     r3,#0xff              ;1226
000092  4642              MOV      r2,r8                 ;1226
000094  e9cd1000          STRD     r1,r0,[sp,#0]         ;1226
000098  4639              MOV      r1,r7                 ;1226
00009a  4628              MOV      r0,r5                 ;1226
00009c  f7fffffe          BL       ip_output
0000a0  4628              MOV      r0,r5                 ;1227
0000a2  f7fffffe          BL       pbuf_free
0000a6  bf00              NOP                            ;1228
0000a8  bf00              NOP                            ;1228
0000aa  bf00              NOP      
0000ac  e7b9              B        |L11.34|
;;;1230   
                          ENDP

0000ae  0000              DCW      0x0000
                  |L11.176|
0000b0  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp_out.c",0
0000b4  5749505c
0000b8  6c776970
0000bc  2d312e34
0000c0  2e315c73
0000c4  72635c63
0000c8  6f72655c
0000cc  7463705f
0000d0  6f75742e
0000d4  6300    
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L11.216|
0000d8  63686563          DCB      "check that first pbuf can hold struct tcp_hdr",0
0000dc  6b207468
0000e0  61742066
0000e4  69727374
0000e8  20706275
0000ec  66206361
0000f0  6e20686f
0000f4  6c642073
0000f8  74727563
0000fc  74207463
000100  705f6864
000104  7200    
000106  00                DCB      0
000107  00                DCB      0
                  |L11.264|
000108  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
00010c  7274696f
000110  6e202225
000114  73222066
000118  61696c65
00011c  64206174
000120  206c696e
000124  65202564
000128  20696e20
00012c  25730d0a
000130  00      
000131  00                DCB      0
000132  00                DCB      0
000133  00                DCB      0

                          AREA ||i.tcp_send_empty_ack||, CODE, READONLY, ALIGN=1

                  tcp_send_empty_ack PROC
;;;841    err_t
;;;842    tcp_send_empty_ack(struct tcp_pcb *pcb)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;843    {
000004  4604              MOV      r4,r0
;;;844      struct pbuf *p;
;;;845      struct tcp_hdr *tcphdr;
;;;846      u8_t optlen = 0;
000006  2700              MOVS     r7,#0
;;;847    
;;;848    #if LWIP_TCP_TIMESTAMPS
;;;849      if (pcb->flags & TF_TIMESTAMP) {
;;;850        optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
;;;851      }
;;;852    #endif
;;;853    
;;;854      p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
000008  6d20              LDR      r0,[r4,#0x50]
00000a  f7fffffe          BL       lwip_htonl
00000e  4680              MOV      r8,r0
000010  4643              MOV      r3,r8
000012  2200              MOVS     r2,#0
000014  4639              MOV      r1,r7
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       tcp_output_alloc_header
00001c  4605              MOV      r5,r0
;;;855      if (p == NULL) {
00001e  b925              CBNZ     r5,|L12.42|
;;;856        LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
000020  bf00              NOP      
000022  bf00              NOP      
;;;857        return ERR_BUF;
000024  1eb8              SUBS     r0,r7,#2
                  |L12.38|
;;;858      }
;;;859      tcphdr = (struct tcp_hdr *)p->payload;
;;;860      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
;;;861                  ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
;;;862      /* remove ACK flags from the PCB, as we send an empty ACK now */
;;;863      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
;;;864    
;;;865      /* NB. MSS option is only sent on SYNs, so ignore it here */
;;;866    #if LWIP_TCP_TIMESTAMPS
;;;867      pcb->ts_lastacksent = pcb->rcv_nxt;
;;;868    
;;;869      if (pcb->flags & TF_TIMESTAMP) {
;;;870        tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
;;;871      }
;;;872    #endif 
;;;873    
;;;874    #if CHECKSUM_GEN_TCP
;;;875      tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
;;;876            IP_PROTO_TCP, p->tot_len);
;;;877    #endif
;;;878    #if LWIP_NETIF_HWADDRHINT
;;;879      ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;880          IP_PROTO_TCP, &(pcb->addr_hint));
;;;881    #else /* LWIP_NETIF_HWADDRHINT*/
;;;882      ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;883          IP_PROTO_TCP);
;;;884    #endif /* LWIP_NETIF_HWADDRHINT*/
;;;885      pbuf_free(p);
;;;886    
;;;887      return ERR_OK;
;;;888    }
000026  e8bd81fc          POP      {r2-r8,pc}
                  |L12.42|
00002a  686e              LDR      r6,[r5,#4]            ;859
00002c  bf00              NOP                            ;860
00002e  bf00              NOP                            ;860
000030  7fa0              LDRB     r0,[r4,#0x1e]         ;863
000032  f0200003          BIC      r0,r0,#3              ;863
000036  77a0              STRB     r0,[r4,#0x1e]         ;863
000038  8928              LDRH     r0,[r5,#8]            ;875
00003a  2306              MOVS     r3,#6                 ;875
00003c  1d22              ADDS     r2,r4,#4              ;875
00003e  4621              MOV      r1,r4                 ;875
000040  9000              STR      r0,[sp,#0]            ;875
000042  4628              MOV      r0,r5                 ;875
000044  f7fffffe          BL       inet_chksum_pseudo
000048  8230              STRH     r0,[r6,#0x10]         ;875
00004a  2106              MOVS     r1,#6                 ;882
00004c  7a60              LDRB     r0,[r4,#9]            ;882
00004e  e9cd0100          STRD     r0,r1,[sp,#0]         ;882
000052  7aa3              LDRB     r3,[r4,#0xa]          ;882
000054  1d22              ADDS     r2,r4,#4              ;882
000056  4621              MOV      r1,r4                 ;882
000058  4628              MOV      r0,r5                 ;882
00005a  f7fffffe          BL       ip_output
00005e  4628              MOV      r0,r5                 ;885
000060  f7fffffe          BL       pbuf_free
000064  2000              MOVS     r0,#0                 ;887
000066  e7de              B        |L12.38|
;;;889    
                          ENDP


                          AREA ||i.tcp_send_fin||, CODE, READONLY, ALIGN=1

                  tcp_send_fin PROC
;;;124    err_t
;;;125    tcp_send_fin(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;126    {
000002  4604              MOV      r4,r0
;;;127      /* first, try to add the fin to the last unsent segment */
;;;128      if (pcb->unsent != NULL) {
000004  6ee0              LDR      r0,[r4,#0x6c]
000006  b1d8              CBZ      r0,|L13.64|
;;;129        struct tcp_seg *last_unsent;
;;;130        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
000008  6ee5              LDR      r5,[r4,#0x6c]
00000a  e000              B        |L13.14|
                  |L13.12|
;;;131             last_unsent = last_unsent->next);
00000c  682d              LDR      r5,[r5,#0]
                  |L13.14|
00000e  6828              LDR      r0,[r5,#0]            ;130
000010  2800              CMP      r0,#0                 ;130
000012  d1fb              BNE      |L13.12|
;;;132    
;;;133        if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
000014  6929              LDR      r1,[r5,#0x10]
000016  8988              LDRH     r0,[r1,#0xc]
000018  f7fffffe          BL       lwip_ntohs
00001c  f0000007          AND      r0,r0,#7
000020  b968              CBNZ     r0,|L13.62|
;;;134          /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
;;;135          TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       lwip_htons
000028  6929              LDR      r1,[r5,#0x10]
00002a  8989              LDRH     r1,[r1,#0xc]
00002c  4308              ORRS     r0,r0,r1
00002e  6929              LDR      r1,[r5,#0x10]
000030  8188              STRH     r0,[r1,#0xc]
;;;136          pcb->flags |= TF_FIN;
000032  7fa0              LDRB     r0,[r4,#0x1e]
000034  f0400020          ORR      r0,r0,#0x20
000038  77a0              STRB     r0,[r4,#0x1e]
;;;137          return ERR_OK;
00003a  2000              MOVS     r0,#0
                  |L13.60|
;;;138        }
;;;139      }
;;;140      /* no data, no length, flags, copy=1, no optdata */
;;;141      return tcp_enqueue_flags(pcb, TCP_FIN);
;;;142    }
00003c  bd70              POP      {r4-r6,pc}
                  |L13.62|
00003e  bf00              NOP                            ;139
                  |L13.64|
000040  2101              MOVS     r1,#1                 ;141
000042  4620              MOV      r0,r4                 ;141
000044  f7fffffe          BL       tcp_enqueue_flags
000048  e7f8              B        |L13.60|
;;;143    
                          ENDP


                          AREA ||i.tcp_write||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_write PROC
;;;353    err_t
;;;354    tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;355    {
000004  b08f              SUB      sp,sp,#0x3c
000006  4604              MOV      r4,r0
000008  4617              MOV      r7,r2
;;;356      struct pbuf *concat_p = NULL;
00000a  f04f0b00          MOV      r11,#0
;;;357      struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
00000e  2500              MOVS     r5,#0
000010  46aa              MOV      r10,r5
000012  2000              MOVS     r0,#0
000014  900e              STR      r0,[sp,#0x38]
000016  900d              STR      r0,[sp,#0x34]
;;;358      u16_t pos = 0; /* position in 'arg' data */
000018  2600              MOVS     r6,#0
;;;359      u16_t queuelen;
;;;360      u8_t optlen = 0;
00001a  900b              STR      r0,[sp,#0x2c]
;;;361      u8_t optflags = 0;
00001c  900a              STR      r0,[sp,#0x28]
;;;362    #if TCP_OVERSIZE
;;;363      u16_t oversize = 0;
00001e  9009              STR      r0,[sp,#0x24]
;;;364      u16_t oversize_used = 0;
000020  4680              MOV      r8,r0
;;;365    #endif /* TCP_OVERSIZE */
;;;366    #if TCP_CHECKSUM_ON_COPY
;;;367      u16_t concat_chksum = 0;
;;;368      u8_t concat_chksum_swapped = 0;
;;;369      u16_t concat_chksummed = 0;
;;;370    #endif /* TCP_CHECKSUM_ON_COPY */
;;;371      err_t err;
;;;372      /* don't allocate segments bigger than half the maximum window we ever received */
;;;373      u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
000022  f8b41062          LDRH     r1,[r4,#0x62]
000026  eb0172d1          ADD      r2,r1,r1,LSR #31
00002a  1052              ASRS     r2,r2,#1
00002c  8ee3              LDRH     r3,[r4,#0x36]
00002e  429a              CMP      r2,r3
000030  dd01              BLE      |L14.54|
000032  8ee2              LDRH     r2,[r4,#0x36]
000034  e004              B        |L14.64|
                  |L14.54|
000036  f8b40062          LDRH     r0,[r4,#0x62]
00003a  eb0072d0          ADD      r2,r0,r0,LSR #31
00003e  1052              ASRS     r2,r2,#1
                  |L14.64|
000040  b292              UXTH     r2,r2
000042  9207              STR      r2,[sp,#0x1c]
;;;374    
;;;375    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;376      /* Always copy to try to create single pbufs for TX */
;;;377      apiflags |= TCP_WRITE_FLAG_COPY;
;;;378    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;379    
;;;380      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
000044  bf00              NOP      
000046  bf00              NOP      
;;;381        (void *)pcb, arg, len, (u16_t)apiflags));
;;;382      LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
000048  bf00              NOP      
00004a  9810              LDR      r0,[sp,#0x40]
00004c  2800              CMP      r0,#0
00004e  d10d              BNE      |L14.108|
000050  bf00              NOP      
000052  a3e7              ADR      r3,|L14.1008|
000054  f44f72bf          MOV      r2,#0x17e
000058  a1ef              ADR      r1,|L14.1048|
00005a  a0fc              ADR      r0,|L14.1100|
00005c  f7fffffe          BL       __2printf
000060  bf00              NOP      
000062  f06f000d          MVN      r0,#0xd
                  |L14.102|
;;;383                 arg != NULL, return ERR_ARG;);
;;;384    
;;;385      err = tcp_write_checks(pcb, len);
;;;386      if (err != ERR_OK) {
;;;387        return err;
;;;388      }
;;;389      queuelen = pcb->snd_queuelen;
;;;390    
;;;391    #if LWIP_TCP_TIMESTAMPS
;;;392      if ((pcb->flags & TF_TIMESTAMP)) {
;;;393        optflags = TF_SEG_OPTS_TS;
;;;394        optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
;;;395      }
;;;396    #endif /* LWIP_TCP_TIMESTAMPS */
;;;397    
;;;398    
;;;399      /*
;;;400       * TCP segmentation is done in three phases with increasing complexity:
;;;401       *
;;;402       * 1. Copy data directly into an oversized pbuf.
;;;403       * 2. Chain a new pbuf to the end of pcb->unsent.
;;;404       * 3. Create new segments.
;;;405       *
;;;406       * We may run out of memory at any point. In that case we must
;;;407       * return ERR_MEM and not change anything in pcb. Therefore, all
;;;408       * changes are recorded in local variables and committed at the end
;;;409       * of the function. Some pcb fields are maintained in local copies:
;;;410       *
;;;411       * queuelen = pcb->snd_queuelen
;;;412       * oversize = pcb->unsent_oversize
;;;413       *
;;;414       * These variables are set consistently by the phases:
;;;415       *
;;;416       * seg points to the last segment tampered with.
;;;417       *
;;;418       * pos records progress as data is segmented.
;;;419       */
;;;420    
;;;421      /* Find the tail of the unsent queue. */
;;;422      if (pcb->unsent != NULL) {
;;;423        u16_t space;
;;;424        u16_t unsent_optlen;
;;;425    
;;;426        /* @todo: this could be sped up by keeping last_unsent in the pcb */
;;;427        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
;;;428             last_unsent = last_unsent->next);
;;;429    
;;;430        /* Usable space at the end of the last unsent segment */
;;;431        unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
;;;432        space = mss_local - (last_unsent->len + unsent_optlen);
;;;433    
;;;434        /*
;;;435         * Phase 1: Copy data directly into an oversized pbuf.
;;;436         *
;;;437         * The number of bytes copied is recorded in the oversize_used
;;;438         * variable. The actual copying is done at the bottom of the
;;;439         * function.
;;;440         */
;;;441    #if TCP_OVERSIZE
;;;442    #if TCP_OVERSIZE_DBGCHECK
;;;443        /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
;;;444        LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
;;;445                    pcb->unsent_oversize == last_unsent->oversize_left);
;;;446    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;447        oversize = pcb->unsent_oversize;
;;;448        if (oversize > 0) {
;;;449          LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
;;;450          seg = last_unsent;
;;;451          oversize_used = oversize < len ? oversize : len;
;;;452          pos += oversize_used;
;;;453          oversize -= oversize_used;
;;;454          space -= oversize_used;
;;;455        }
;;;456        /* now we are either finished or oversize is zero */
;;;457        LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
;;;458    #endif /* TCP_OVERSIZE */
;;;459    
;;;460        /*
;;;461         * Phase 2: Chain a new pbuf to the end of pcb->unsent.
;;;462         *
;;;463         * We don't extend segments containing SYN/FIN flags or options
;;;464         * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
;;;465         * the end.
;;;466         */
;;;467        if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
;;;468          u16_t seglen = space < len - pos ? space : len - pos;
;;;469          seg = last_unsent;
;;;470    
;;;471          /* Create a pbuf with a copy or reference to seglen bytes. We
;;;472           * can use PBUF_RAW here since the data appears in the middle of
;;;473           * a segment. A header will never be prepended. */
;;;474          if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;475            /* Data is copied */
;;;476            if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
;;;477              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
;;;478                          ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
;;;479                           seglen));
;;;480              goto memerr;
;;;481            }
;;;482    #if TCP_OVERSIZE_DBGCHECK
;;;483            last_unsent->oversize_left += oversize;
;;;484    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;485            TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
;;;486    #if TCP_CHECKSUM_ON_COPY
;;;487            concat_chksummed += seglen;
;;;488    #endif /* TCP_CHECKSUM_ON_COPY */
;;;489          } else {
;;;490            /* Data is not copied */
;;;491            if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
;;;492              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
;;;493                          ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;494              goto memerr;
;;;495            }
;;;496    #if TCP_CHECKSUM_ON_COPY
;;;497            /* calculate the checksum of nocopy-data */
;;;498            tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
;;;499              &concat_chksum, &concat_chksum_swapped);
;;;500            concat_chksummed += seglen;
;;;501    #endif /* TCP_CHECKSUM_ON_COPY */
;;;502            /* reference the non-volatile payload data */
;;;503            concat_p->payload = (u8_t*)arg + pos;
;;;504          }
;;;505    
;;;506          pos += seglen;
;;;507          queuelen += pbuf_clen(concat_p);
;;;508        }
;;;509      } else {
;;;510    #if TCP_OVERSIZE
;;;511        LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
;;;512                    pcb->unsent_oversize == 0);
;;;513    #endif /* TCP_OVERSIZE */
;;;514      }
;;;515    
;;;516      /*
;;;517       * Phase 3: Create new segments.
;;;518       *
;;;519       * The new segments are chained together in the local 'queue'
;;;520       * variable, ready to be appended to pcb->unsent.
;;;521       */
;;;522      while (pos < len) {
;;;523        struct pbuf *p;
;;;524        u16_t left = len - pos;
;;;525        u16_t max_len = mss_local - optlen;
;;;526        u16_t seglen = left > max_len ? max_len : left;
;;;527    #if TCP_CHECKSUM_ON_COPY
;;;528        u16_t chksum = 0;
;;;529        u8_t chksum_swapped = 0;
;;;530    #endif /* TCP_CHECKSUM_ON_COPY */
;;;531    
;;;532        if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;533          /* If copy is set, memory should be allocated and data copied
;;;534           * into pbuf */
;;;535          if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
;;;536            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
;;;537            goto memerr;
;;;538          }
;;;539          LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
;;;540                      (p->len >= seglen));
;;;541          TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
;;;542        } else {
;;;543          /* Copy is not set: First allocate a pbuf for holding the data.
;;;544           * Since the referenced data is available at least until it is
;;;545           * sent out on the link (as it has to be ACKed by the remote
;;;546           * party) we can safely use PBUF_ROM instead of PBUF_REF here.
;;;547           */
;;;548          struct pbuf *p2;
;;;549    #if TCP_OVERSIZE
;;;550          LWIP_ASSERT("oversize == 0", oversize == 0);
;;;551    #endif /* TCP_OVERSIZE */
;;;552          if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
;;;553            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;554            goto memerr;
;;;555          }
;;;556    #if TCP_CHECKSUM_ON_COPY
;;;557          /* calculate the checksum of nocopy-data */
;;;558          chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
;;;559    #endif /* TCP_CHECKSUM_ON_COPY */
;;;560          /* reference the non-volatile payload data */
;;;561          p2->payload = (u8_t*)arg + pos;
;;;562    
;;;563          /* Second, allocate a pbuf for the headers. */
;;;564          if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
;;;565            /* If allocation fails, we have to deallocate the data pbuf as
;;;566             * well. */
;;;567            pbuf_free(p2);
;;;568            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
;;;569            goto memerr;
;;;570          }
;;;571          /* Concatenate the headers and data pbufs together. */
;;;572          pbuf_cat(p/*header*/, p2/*data*/);
;;;573        }
;;;574    
;;;575        queuelen += pbuf_clen(p);
;;;576    
;;;577        /* Now that there are more segments queued, we check again if the
;;;578         * length of the queue exceeds the configured maximum or
;;;579         * overflows. */
;;;580        if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;581          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
;;;582          pbuf_free(p);
;;;583          goto memerr;
;;;584        }
;;;585    
;;;586        if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
;;;587          goto memerr;
;;;588        }
;;;589    #if TCP_OVERSIZE_DBGCHECK
;;;590        seg->oversize_left = oversize;
;;;591    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;592    #if TCP_CHECKSUM_ON_COPY
;;;593        seg->chksum = chksum;
;;;594        seg->chksum_swapped = chksum_swapped;
;;;595        seg->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;596    #endif /* TCP_CHECKSUM_ON_COPY */
;;;597    
;;;598        /* first segment of to-be-queued data? */
;;;599        if (queue == NULL) {
;;;600          queue = seg;
;;;601        } else {
;;;602          /* Attach the segment to the end of the queued segments */
;;;603          LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
;;;604          prev_seg->next = seg;
;;;605        }
;;;606        /* remember last segment of to-be-queued data for next iteration */
;;;607        prev_seg = seg;
;;;608    
;;;609        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
;;;610          ntohl(seg->tcphdr->seqno),
;;;611          ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));
;;;612    
;;;613        pos += seglen;
;;;614      }
;;;615    
;;;616      /*
;;;617       * All three segmentation phases were successful. We can commit the
;;;618       * transaction.
;;;619       */
;;;620    
;;;621      /*
;;;622       * Phase 1: If data has been added to the preallocated tail of
;;;623       * last_unsent, we update the length fields of the pbuf chain.
;;;624       */
;;;625    #if TCP_OVERSIZE
;;;626      if (oversize_used > 0) {
;;;627        struct pbuf *p;
;;;628        /* Bump tot_len of whole chain, len of tail */
;;;629        for (p = last_unsent->p; p; p = p->next) {
;;;630          p->tot_len += oversize_used;
;;;631          if (p->next == NULL) {
;;;632            TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
;;;633            p->len += oversize_used;
;;;634          }
;;;635        }
;;;636        last_unsent->len += oversize_used;
;;;637    #if TCP_OVERSIZE_DBGCHECK
;;;638        LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
;;;639                    last_unsent->oversize_left >= oversize_used);
;;;640        last_unsent->oversize_left -= oversize_used;
;;;641    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;642      }
;;;643      pcb->unsent_oversize = oversize;
;;;644    #endif /* TCP_OVERSIZE */
;;;645    
;;;646      /*
;;;647       * Phase 2: concat_p can be concatenated onto last_unsent->p
;;;648       */
;;;649      if (concat_p != NULL) {
;;;650        LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
;;;651          (last_unsent != NULL));
;;;652        pbuf_cat(last_unsent->p, concat_p);
;;;653        last_unsent->len += concat_p->tot_len;
;;;654    #if TCP_CHECKSUM_ON_COPY
;;;655        if (concat_chksummed) {
;;;656          tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
;;;657            &last_unsent->chksum_swapped);
;;;658          last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;659        }
;;;660    #endif /* TCP_CHECKSUM_ON_COPY */
;;;661      }
;;;662    
;;;663      /*
;;;664       * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
;;;665       * is harmless
;;;666       */
;;;667      if (last_unsent == NULL) {
;;;668        pcb->unsent = queue;
;;;669      } else {
;;;670        last_unsent->next = queue;
;;;671      }
;;;672    
;;;673      /*
;;;674       * Finally update the pcb state.
;;;675       */
;;;676      pcb->snd_lbb += len;
;;;677      pcb->snd_buf -= len;
;;;678      pcb->snd_queuelen = queuelen;
;;;679    
;;;680      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
;;;681        pcb->snd_queuelen));
;;;682      if (pcb->snd_queuelen != 0) {
;;;683        LWIP_ASSERT("tcp_write: valid queue length",
;;;684                    pcb->unacked != NULL || pcb->unsent != NULL);
;;;685      }
;;;686    
;;;687      /* Set the PSH flag in the last segment that we enqueued. */
;;;688      if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
;;;689        TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
;;;690      }
;;;691    
;;;692      return ERR_OK;
;;;693    memerr:
;;;694      pcb->flags |= TF_NAGLEMEMERR;
;;;695      TCP_STATS_INC(tcp.memerr);
;;;696    
;;;697      if (concat_p != NULL) {
;;;698        pbuf_free(concat_p);
;;;699      }
;;;700      if (queue != NULL) {
;;;701        tcp_segs_free(queue);
;;;702      }
;;;703      if (pcb->snd_queuelen != 0) {
;;;704        LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
;;;705          pcb->unsent != NULL);
;;;706      }
;;;707      LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
;;;708      return ERR_MEM;
;;;709    }
000066  b013              ADD      sp,sp,#0x4c
000068  e8bd8ff0          POP      {r4-r11,pc}
                  |L14.108|
00006c  bf00              NOP                            ;382
00006e  4639              MOV      r1,r7                 ;385
000070  4620              MOV      r0,r4                 ;385
000072  f7fffffe          BL       tcp_write_checks
000076  9008              STR      r0,[sp,#0x20]         ;385
000078  9808              LDR      r0,[sp,#0x20]         ;386
00007a  b108              CBZ      r0,|L14.128|
00007c  9808              LDR      r0,[sp,#0x20]         ;387
00007e  e7f2              B        |L14.102|
                  |L14.128|
000080  f8b40068          LDRH     r0,[r4,#0x68]         ;389
000084  900c              STR      r0,[sp,#0x30]         ;389
000086  6ee0              LDR      r0,[r4,#0x6c]         ;422
000088  2800              CMP      r0,#0                 ;422
00008a  d074              BEQ      |L14.374|
00008c  6ee5              LDR      r5,[r4,#0x6c]         ;427
00008e  e000              B        |L14.146|
                  |L14.144|
000090  682d              LDR      r5,[r5,#0]            ;428
                  |L14.146|
000092  6828              LDR      r0,[r5,#0]            ;427
000094  2800              CMP      r0,#0                 ;427
000096  d1fb              BNE      |L14.144|
000098  7b28              LDRB     r0,[r5,#0xc]          ;431
00009a  f0000001          AND      r0,r0,#1              ;431
00009e  b108              CBZ      r0,|L14.164|
0000a0  2004              MOVS     r0,#4                 ;431
0000a2  e000              B        |L14.166|
                  |L14.164|
0000a4  2000              MOVS     r0,#0                 ;431
                  |L14.166|
0000a6  7b29              LDRB     r1,[r5,#0xc]          ;431
0000a8  f0010102          AND      r1,r1,#2              ;431
0000ac  b109              CBZ      r1,|L14.178|
0000ae  210c              MOVS     r1,#0xc               ;431
0000b0  e000              B        |L14.180|
                  |L14.178|
0000b2  2100              MOVS     r1,#0                 ;431
                  |L14.180|
0000b4  4408              ADD      r0,r0,r1              ;431
0000b6  9006              STR      r0,[sp,#0x18]         ;431
0000b8  8929              LDRH     r1,[r5,#8]            ;432
0000ba  9806              LDR      r0,[sp,#0x18]         ;432
0000bc  4401              ADD      r1,r1,r0              ;432
0000be  9807              LDR      r0,[sp,#0x1c]         ;432
0000c0  1a40              SUBS     r0,r0,r1              ;432
0000c2  fa1ff980          UXTH     r9,r0                 ;432
0000c6  bf00              NOP                            ;444
0000c8  f8b4006a          LDRH     r0,[r4,#0x6a]         ;444
0000cc  8969              LDRH     r1,[r5,#0xa]          ;444
0000ce  4288              CMP      r0,r1                 ;444
0000d0  d008              BEQ      |L14.228|
0000d2  bf00              NOP                            ;444
0000d4  a3c6              ADR      r3,|L14.1008|
0000d6  f44f72de          MOV      r2,#0x1bc             ;444
0000da  a1e7              ADR      r1,|L14.1144|
0000dc  a0db              ADR      r0,|L14.1100|
0000de  f7fffffe          BL       __2printf
0000e2  bf00              NOP                            ;444
                  |L14.228|
0000e4  bf00              NOP                            ;444
0000e6  f8b4006a          LDRH     r0,[r4,#0x6a]         ;447
0000ea  9009              STR      r0,[sp,#0x24]         ;447
0000ec  f8bd0024          LDRH     r0,[sp,#0x24]         ;448
0000f0  2800              CMP      r0,#0                 ;448
0000f2  dd23              BLE      |L14.316|
0000f4  bf00              NOP                            ;449
0000f6  45c8              CMP      r8,r9                 ;449
0000f8  dd08              BLE      |L14.268|
0000fa  bf00              NOP                            ;449
0000fc  a3bc              ADR      r3,|L14.1008|
0000fe  f24012c1          MOV      r2,#0x1c1             ;449
000102  a1e9              ADR      r1,|L14.1192|
000104  a0d1              ADR      r0,|L14.1100|
000106  f7fffffe          BL       __2printf
00010a  bf00              NOP                            ;449
                  |L14.268|
00010c  bf00              NOP                            ;449
00010e  46aa              MOV      r10,r5                ;450
000110  f8bd0024          LDRH     r0,[sp,#0x24]         ;451
000114  42b8              CMP      r0,r7                 ;451
000116  da02              BGE      |L14.286|
000118  f8bd0024          LDRH     r0,[sp,#0x24]         ;451
00011c  e000              B        |L14.288|
                  |L14.286|
00011e  4638              MOV      r0,r7                 ;451
                  |L14.288|
000120  4680              MOV      r8,r0                 ;451
000122  eb060008          ADD      r0,r6,r8              ;452
000126  b286              UXTH     r6,r0                 ;452
000128  f8bd0024          LDRH     r0,[sp,#0x24]         ;453
00012c  eba00008          SUB      r0,r0,r8              ;453
000130  b280              UXTH     r0,r0                 ;453
000132  9009              STR      r0,[sp,#0x24]         ;453
000134  eba90008          SUB      r0,r9,r8              ;454
000138  fa1ff980          UXTH     r9,r0                 ;454
                  |L14.316|
00013c  bf00              NOP                            ;457
00013e  f8bd0024          LDRH     r0,[sp,#0x24]         ;457
000142  b150              CBZ      r0,|L14.346|
000144  42be              CMP      r6,r7                 ;457
000146  d008              BEQ      |L14.346|
000148  bf00              NOP                            ;457
00014a  a3a9              ADR      r3,|L14.1008|
00014c  f24012c9          MOV      r2,#0x1c9             ;457
000150  a1dd              ADR      r1,|L14.1224|
000152  a0be              ADR      r0,|L14.1100|
000154  f7fffffe          BL       __2printf
000158  bf00              NOP                            ;457
                  |L14.346|
00015a  bf00              NOP                            ;457
00015c  42be              CMP      r6,r7                 ;467
00015e  da4b              BGE      |L14.504|
000160  f1b90f00          CMP      r9,#0                 ;467
000164  dd48              BLE      |L14.504|
000166  8928              LDRH     r0,[r5,#8]            ;467
000168  2800              CMP      r0,#0                 ;467
00016a  dd45              BLE      |L14.504|
00016c  1bb8              SUBS     r0,r7,r6              ;468
00016e  4548              CMP      r0,r9                 ;468
000170  dd02              BLE      |L14.376|
000172  4648              MOV      r0,r9                 ;468
000174  e001              B        |L14.378|
                  |L14.374|
000176  e040              B        |L14.506|
                  |L14.376|
000178  1bb8              SUBS     r0,r7,r6              ;468
                  |L14.378|
00017a  b280              UXTH     r0,r0                 ;468
00017c  9005              STR      r0,[sp,#0x14]         ;468
00017e  46aa              MOV      r10,r5                ;469
000180  9812              LDR      r0,[sp,#0x48]         ;474
000182  f0000001          AND      r0,r0,#1              ;474
000186  b1e8              CBZ      r0,|L14.452|
000188  2101              MOVS     r1,#1                 ;476
00018a  9812              LDR      r0,[sp,#0x48]         ;476
00018c  ab09              ADD      r3,sp,#0x24           ;476
00018e  464a              MOV      r2,r9                 ;476
000190  e9cd4000          STRD     r4,r0,[sp,#0]         ;476
000194  9102              STR      r1,[sp,#8]            ;476
000196  2003              MOVS     r0,#3                 ;476
000198  9905              LDR      r1,[sp,#0x14]         ;476
00019a  f7fffffe          BL       tcp_pbuf_prealloc
00019e  f1b00b00          SUBS     r11,r0,#0             ;476
0001a2  d102              BNE      |L14.426|
0001a4  bf00              NOP                            ;477
0001a6  bf00              NOP                            ;477
0001a8  e24e              B        |L14.1608|
                  |L14.426|
0001aa  8968              LDRH     r0,[r5,#0xa]          ;483
0001ac  f8bd1024          LDRH     r1,[sp,#0x24]         ;483
0001b0  4408              ADD      r0,r0,r1              ;483
0001b2  8168              STRH     r0,[r5,#0xa]          ;483
0001b4  9a10              LDR      r2,[sp,#0x40]         ;485
0001b6  1991              ADDS     r1,r2,r6              ;485
0001b8  f8db0004          LDR      r0,[r11,#4]           ;485
0001bc  9a05              LDR      r2,[sp,#0x14]         ;485
0001be  f7fffffe          BL       __aeabi_memcpy
0001c2  e00e              B        |L14.482|
                  |L14.452|
0001c4  2201              MOVS     r2,#1                 ;491
0001c6  2003              MOVS     r0,#3                 ;491
0001c8  9905              LDR      r1,[sp,#0x14]         ;491
0001ca  f7fffffe          BL       pbuf_alloc
0001ce  f1b00b00          SUBS     r11,r0,#0             ;491
0001d2  d102              BNE      |L14.474|
0001d4  bf00              NOP                            ;492
0001d6  bf00              NOP                            ;492
0001d8  e236              B        |L14.1608|
                  |L14.474|
0001da  9810              LDR      r0,[sp,#0x40]         ;503
0001dc  4430              ADD      r0,r0,r6              ;503
0001de  f8cb0004          STR      r0,[r11,#4]           ;503
                  |L14.482|
0001e2  9805              LDR      r0,[sp,#0x14]         ;506
0001e4  4430              ADD      r0,r0,r6              ;506
0001e6  b286              UXTH     r6,r0                 ;506
0001e8  4658              MOV      r0,r11                ;507
0001ea  f7fffffe          BL       pbuf_clen
0001ee  990c              LDR      r1,[sp,#0x30]         ;507
0001f0  4408              ADD      r0,r0,r1              ;507
0001f2  b280              UXTH     r0,r0                 ;507
0001f4  900c              STR      r0,[sp,#0x30]         ;507
0001f6  bf00              NOP                            ;508
                  |L14.504|
0001f8  e00d              B        |L14.534|
                  |L14.506|
0001fa  bf00              NOP                            ;511
0001fc  f8b4006a          LDRH     r0,[r4,#0x6a]         ;511
000200  b140              CBZ      r0,|L14.532|
000202  bf00              NOP                            ;511
000204  a37a              ADR      r3,|L14.1008|
000206  f24012ff          MOV      r2,#0x1ff             ;511
00020a  a1b7              ADR      r1,|L14.1256|
00020c  a08f              ADR      r0,|L14.1100|
00020e  f7fffffe          BL       __2printf
000212  bf00              NOP                            ;511
                  |L14.532|
000214  bf00              NOP                            ;511
                  |L14.534|
000216  e0b8              B        |L14.906|
                  |L14.536|
000218  1bb8              SUBS     r0,r7,r6              ;524
00021a  b280              UXTH     r0,r0                 ;524
00021c  9006              STR      r0,[sp,#0x18]         ;524
00021e  990b              LDR      r1,[sp,#0x2c]         ;525
000220  9807              LDR      r0,[sp,#0x1c]         ;525
000222  1a40              SUBS     r0,r0,r1              ;525
000224  b280              UXTH     r0,r0                 ;525
000226  9005              STR      r0,[sp,#0x14]         ;525
000228  e9dd1005          LDRD     r1,r0,[sp,#0x14]      ;526
00022c  4288              CMP      r0,r1                 ;526
00022e  dd01              BLE      |L14.564|
000230  9805              LDR      r0,[sp,#0x14]         ;526
000232  e000              B        |L14.566|
                  |L14.564|
000234  9806              LDR      r0,[sp,#0x18]         ;526
                  |L14.566|
000236  9004              STR      r0,[sp,#0x10]         ;526
000238  9812              LDR      r0,[sp,#0x48]         ;532
00023a  f0000001          AND      r0,r0,#1              ;532
00023e  2800              CMP      r0,#0                 ;532
000240  d031              BEQ      |L14.678|
000242  980d              LDR      r0,[sp,#0x34]         ;535
000244  b908              CBNZ     r0,|L14.586|
000246  2101              MOVS     r1,#1                 ;535
000248  e000              B        |L14.588|
                  |L14.586|
00024a  2100              MOVS     r1,#0                 ;535
                  |L14.588|
00024c  9812              LDR      r0,[sp,#0x48]         ;535
00024e  e9cd4000          STRD     r4,r0,[sp,#0]         ;535
000252  9102              STR      r1,[sp,#8]            ;535
000254  9a0b              LDR      r2,[sp,#0x2c]         ;535
000256  9804              LDR      r0,[sp,#0x10]         ;535
000258  4410              ADD      r0,r0,r2              ;535
00025a  b281              UXTH     r1,r0                 ;535
00025c  ab09              ADD      r3,sp,#0x24           ;535
00025e  2000              MOVS     r0,#0                 ;535
000260  9a07              LDR      r2,[sp,#0x1c]         ;535
000262  f7fffffe          BL       tcp_pbuf_prealloc
000266  f1b00900          SUBS     r9,r0,#0              ;535
00026a  d102              BNE      |L14.626|
00026c  bf00              NOP                            ;536
00026e  bf00              NOP                            ;536
000270  e1ea              B        |L14.1608|
                  |L14.626|
000272  bf00              NOP                            ;539
000274  f8b9100a          LDRH     r1,[r9,#0xa]          ;539
000278  9804              LDR      r0,[sp,#0x10]         ;539
00027a  4281              CMP      r1,r0                 ;539
00027c  da08              BGE      |L14.656|
00027e  bf00              NOP                            ;539
000280  a35b              ADR      r3,|L14.1008|
000282  f240221b          MOV      r2,#0x21b             ;539
000286  a1a4              ADR      r1,|L14.1304|
000288  a070              ADR      r0,|L14.1100|
00028a  f7fffffe          BL       __2printf
00028e  bf00              NOP                            ;539
                  |L14.656|
000290  bf00              NOP                            ;539
000292  9a10              LDR      r2,[sp,#0x40]         ;541
000294  1991              ADDS     r1,r2,r6              ;541
000296  f8d93004          LDR      r3,[r9,#4]            ;541
00029a  9a0b              LDR      r2,[sp,#0x2c]         ;541
00029c  1898              ADDS     r0,r3,r2              ;541
00029e  9a04              LDR      r2,[sp,#0x10]         ;541
0002a0  f7fffffe          BL       __aeabi_memcpy
0002a4  e02e              B        |L14.772|
                  |L14.678|
0002a6  bf00              NOP                            ;550
0002a8  f8bd0024          LDRH     r0,[sp,#0x24]         ;550
0002ac  b140              CBZ      r0,|L14.704|
0002ae  bf00              NOP                            ;550
0002b0  a34f              ADR      r3,|L14.1008|
0002b2  f2402226          MOV      r2,#0x226             ;550
0002b6  a1a8              ADR      r1,|L14.1368|
0002b8  a064              ADR      r0,|L14.1100|
0002ba  f7fffffe          BL       __2printf
0002be  bf00              NOP                            ;550
                  |L14.704|
0002c0  bf00              NOP                            ;550
0002c2  2201              MOVS     r2,#1                 ;552
0002c4  2000              MOVS     r0,#0                 ;552
0002c6  9904              LDR      r1,[sp,#0x10]         ;552
0002c8  f7fffffe          BL       pbuf_alloc
0002cc  9003              STR      r0,[sp,#0xc]          ;552
0002ce  b910              CBNZ     r0,|L14.726|
0002d0  bf00              NOP                            ;553
0002d2  bf00              NOP                            ;553
0002d4  e1b8              B        |L14.1608|
                  |L14.726|
0002d6  9810              LDR      r0,[sp,#0x40]         ;561
0002d8  1981              ADDS     r1,r0,r6              ;561
0002da  9803              LDR      r0,[sp,#0xc]          ;561
0002dc  6041              STR      r1,[r0,#4]            ;561
0002de  2200              MOVS     r2,#0                 ;564
0002e0  4610              MOV      r0,r2                 ;564
0002e2  990b              LDR      r1,[sp,#0x2c]         ;564
0002e4  f7fffffe          BL       pbuf_alloc
0002e8  f1b00900          SUBS     r9,r0,#0              ;564
0002ec  d105              BNE      |L14.762|
0002ee  9803              LDR      r0,[sp,#0xc]          ;567
0002f0  f7fffffe          BL       pbuf_free
0002f4  bf00              NOP                            ;568
0002f6  bf00              NOP                            ;568
0002f8  e1a6              B        |L14.1608|
                  |L14.762|
0002fa  4648              MOV      r0,r9                 ;572
0002fc  9903              LDR      r1,[sp,#0xc]          ;572
0002fe  f7fffffe          BL       pbuf_cat
000302  bf00              NOP                            ;573
                  |L14.772|
000304  4648              MOV      r0,r9                 ;575
000306  f7fffffe          BL       pbuf_clen
00030a  990c              LDR      r1,[sp,#0x30]         ;575
00030c  4408              ADD      r0,r0,r1              ;575
00030e  b280              UXTH     r0,r0                 ;575
000310  900c              STR      r0,[sp,#0x30]         ;575
000312  980c              LDR      r0,[sp,#0x30]         ;580
000314  2808              CMP      r0,#8                 ;580
000316  dc04              BGT      |L14.802|
000318  f64f71fc          MOV      r1,#0xfffc            ;580
00031c  980c              LDR      r0,[sp,#0x30]         ;580
00031e  4288              CMP      r0,r1                 ;580
000320  d905              BLS      |L14.814|
                  |L14.802|
000322  bf00              NOP                            ;581
000324  bf00              NOP                            ;581
000326  4648              MOV      r0,r9                 ;582
000328  f7fffffe          BL       pbuf_free
00032c  e18c              B        |L14.1608|
                  |L14.814|
00032e  980a              LDR      r0,[sp,#0x28]         ;586
000330  9000              STR      r0,[sp,#0]            ;586
000332  6de0              LDR      r0,[r4,#0x5c]         ;586
000334  1983              ADDS     r3,r0,r6              ;586
000336  2200              MOVS     r2,#0                 ;586
000338  4649              MOV      r1,r9                 ;586
00033a  4620              MOV      r0,r4                 ;586
00033c  f7fffffe          BL       tcp_create_segment
000340  f1b00a00          SUBS     r10,r0,#0             ;586
000344  d100              BNE      |L14.840|
000346  e17f              B        |L14.1608|
                  |L14.840|
000348  f8bd0024          LDRH     r0,[sp,#0x24]         ;590
00034c  f8aa000a          STRH     r0,[r10,#0xa]         ;590
000350  980d              LDR      r0,[sp,#0x34]         ;599
000352  b910              CBNZ     r0,|L14.858|
000354  f8cda034          STR      r10,[sp,#0x34]        ;600
000358  e00f              B        |L14.890|
                  |L14.858|
00035a  bf00              NOP                            ;603
00035c  980e              LDR      r0,[sp,#0x38]         ;603
00035e  b940              CBNZ     r0,|L14.882|
000360  bf00              NOP                            ;603
000362  a323              ADR      r3,|L14.1008|
000364  f240225b          MOV      r2,#0x25b             ;603
000368  a17f              ADR      r1,|L14.1384|
00036a  a038              ADR      r0,|L14.1100|
00036c  f7fffffe          BL       __2printf
000370  bf00              NOP                            ;603
                  |L14.882|
000372  bf00              NOP                            ;603
000374  980e              LDR      r0,[sp,#0x38]         ;604
000376  f8c0a000          STR      r10,[r0,#0]           ;604
                  |L14.890|
00037a  f8cda038          STR      r10,[sp,#0x38]        ;607
00037e  bf00              NOP                            ;609
000380  bf00              NOP                            ;609
000382  9804              LDR      r0,[sp,#0x10]         ;613
000384  4430              ADD      r0,r0,r6              ;613
000386  b286              UXTH     r6,r0                 ;613
000388  bf00              NOP                            ;614
                  |L14.906|
00038a  42be              CMP      r6,r7                 ;522
00038c  f6ffaf44          BLT      |L14.536|
000390  f1b80f00          CMP      r8,#0                 ;626
000394  dd29              BLE      |L14.1002|
000396  f8d59004          LDR      r9,[r5,#4]            ;629
00039a  e017              B        |L14.972|
                  |L14.924|
00039c  f8b90008          LDRH     r0,[r9,#8]            ;630
0003a0  4440              ADD      r0,r0,r8              ;630
0003a2  f8a90008          STRH     r0,[r9,#8]            ;630
0003a6  f8d90000          LDR      r0,[r9,#0]            ;631
0003aa  b968              CBNZ     r0,|L14.968|
0003ac  f8b9200a          LDRH     r2,[r9,#0xa]          ;632
0003b0  f8d91004          LDR      r1,[r9,#4]            ;632
0003b4  1888              ADDS     r0,r1,r2              ;632
0003b6  4642              MOV      r2,r8                 ;632
0003b8  9910              LDR      r1,[sp,#0x40]         ;632
0003ba  f7fffffe          BL       __aeabi_memcpy
0003be  f8b9000a          LDRH     r0,[r9,#0xa]          ;633
0003c2  4440              ADD      r0,r0,r8              ;633
0003c4  f8a9000a          STRH     r0,[r9,#0xa]          ;633
                  |L14.968|
0003c8  f8d99000          LDR      r9,[r9,#0]            ;629
                  |L14.972|
0003cc  f1b90f00          CMP      r9,#0                 ;629
0003d0  d1e4              BNE      |L14.924|
0003d2  8928              LDRH     r0,[r5,#8]            ;636
0003d4  4440              ADD      r0,r0,r8              ;636
0003d6  8128              STRH     r0,[r5,#8]            ;636
0003d8  bf00              NOP                            ;638
0003da  8968              LDRH     r0,[r5,#0xa]          ;638
0003dc  4540              CMP      r0,r8                 ;638
0003de  da05              BGE      |L14.1004|
0003e0  bf00              NOP                            ;638
0003e2  a303              ADR      r3,|L14.1008|
0003e4  f240227e          MOV      r2,#0x27e             ;638
0003e8  e0c8              B        |L14.1404|
                  |L14.1002|
0003ea  e0d3              B        |L14.1428|
                  |L14.1004|
0003ec  e0cc              B        |L14.1416|
0003ee  0000              DCW      0x0000
                  |L14.1008|
0003f0  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp_out.c",0
0003f4  5749505c
0003f8  6c776970
0003fc  2d312e34
000400  2e315c73
000404  72635c63
000408  6f72655c
00040c  7463705f
000410  6f75742e
000414  6300    
000416  00                DCB      0
000417  00                DCB      0
                  |L14.1048|
000418  7463705f          DCB      "tcp_write: arg == NULL (programmer violates API)",0
00041c  77726974
000420  653a2061
000424  7267203d
000428  3d204e55
00042c  4c4c2028
000430  70726f67
000434  72616d6d
000438  65722076
00043c  696f6c61
000440  74657320
000444  41504929
000448  00      
000449  00                DCB      0
00044a  00                DCB      0
00044b  00                DCB      0
                  |L14.1100|
00044c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000450  7274696f
000454  6e202225
000458  73222066
00045c  61696c65
000460  64206174
000464  206c696e
000468  65202564
00046c  20696e20
000470  25730d0a
000474  00      
000475  00                DCB      0
000476  00                DCB      0
000477  00                DCB      0
                  |L14.1144|
000478  756e7365          DCB      "unsent_oversize mismatch (pcb vs. last_unsent)",0
00047c  6e745f6f
000480  76657273
000484  697a6520
000488  6d69736d
00048c  61746368
000490  20287063
000494  62207673
000498  2e206c61
00049c  73745f75
0004a0  6e73656e
0004a4  742900  
0004a7  00                DCB      0
                  |L14.1192|
0004a8  696e636f          DCB      "inconsistent oversize vs. space",0
0004ac  6e736973
0004b0  74656e74
0004b4  206f7665
0004b8  7273697a
0004bc  65207673
0004c0  2e207370
0004c4  61636500
                  |L14.1224|
0004c8  696e636f          DCB      "inconsistend oversize vs. len",0
0004cc  6e736973
0004d0  74656e64
0004d4  206f7665
0004d8  7273697a
0004dc  65207673
0004e0  2e206c65
0004e4  6e00    
0004e6  00                DCB      0
0004e7  00                DCB      0
                  |L14.1256|
0004e8  756e7365          DCB      "unsent_oversize mismatch (pcb->unsent is NULL)",0
0004ec  6e745f6f
0004f0  76657273
0004f4  697a6520
0004f8  6d69736d
0004fc  61746368
000500  20287063
000504  622d3e75
000508  6e73656e
00050c  74206973
000510  204e554c
000514  4c2900  
000517  00                DCB      0
                  |L14.1304|
000518  7463705f          DCB      "tcp_write: check that first pbuf can hold the complete "
00051c  77726974
000520  653a2063
000524  6865636b
000528  20746861
00052c  74206669
000530  72737420
000534  70627566
000538  2063616e
00053c  20686f6c
000540  64207468
000544  6520636f
000548  6d706c65
00054c  746520  
00054f  7365676c          DCB      "seglen",0
000553  656e00  
000556  00                DCB      0
000557  00                DCB      0
                  |L14.1368|
000558  6f766572          DCB      "oversize == 0",0
00055c  73697a65
000560  203d3d20
000564  3000    
000566  00                DCB      0
000567  00                DCB      0
                  |L14.1384|
000568  70726576          DCB      "prev_seg != NULL",0
00056c  5f736567
000570  20213d20
000574  4e554c4c
000578  00      
000579  00                DCB      0
00057a  00                DCB      0
00057b  00                DCB      0
                  |L14.1404|
00057c  a146              ADR      r1,|L14.1688|
00057e  f2af1034          ADR      r0,|L14.1100|
000582  f7fffffe          BL       __2printf
000586  bf00              NOP                            ;638
                  |L14.1416|
000588  bf00              NOP                            ;638
00058a  8968              LDRH     r0,[r5,#0xa]          ;640
00058c  eba00008          SUB      r0,r0,r8              ;640
000590  8168              STRH     r0,[r5,#0xa]          ;640
000592  bf00              NOP                            ;642
                  |L14.1428|
000594  f8bd0024          LDRH     r0,[sp,#0x24]         ;643
000598  f8a4006a          STRH     r0,[r4,#0x6a]         ;643
00059c  f1bb0f00          CMP      r11,#0                ;649
0005a0  d016              BEQ      |L14.1488|
0005a2  bf00              NOP                            ;650
0005a4  b955              CBNZ     r5,|L14.1468|
0005a6  bf00              NOP                            ;650
0005a8  f2af13bc          ADR      r3,|L14.1008|
0005ac  f240228a          MOV      r2,#0x28a             ;650
0005b0  a144              ADR      r1,|L14.1732|
0005b2  f2af1068          ADR      r0,|L14.1100|
0005b6  f7fffffe          BL       __2printf
0005ba  bf00              NOP                            ;650
                  |L14.1468|
0005bc  bf00              NOP                            ;650
0005be  4659              MOV      r1,r11                ;652
0005c0  6868              LDR      r0,[r5,#4]            ;652
0005c2  f7fffffe          BL       pbuf_cat
0005c6  8928              LDRH     r0,[r5,#8]            ;653
0005c8  f8bb1008          LDRH     r1,[r11,#8]           ;653
0005cc  4408              ADD      r0,r0,r1              ;653
0005ce  8128              STRH     r0,[r5,#8]            ;653
                  |L14.1488|
0005d0  b915              CBNZ     r5,|L14.1496|
0005d2  980d              LDR      r0,[sp,#0x34]         ;668
0005d4  66e0              STR      r0,[r4,#0x6c]         ;668
0005d6  e001              B        |L14.1500|
                  |L14.1496|
0005d8  980d              LDR      r0,[sp,#0x34]         ;670
0005da  6028              STR      r0,[r5,#0]            ;670
                  |L14.1500|
0005dc  f8540f5c          LDR      r0,[r4,#0x5c]!        ;676
0005e0  4438              ADD      r0,r0,r7              ;676
0005e2  6020              STR      r0,[r4,#0]            ;676
0005e4  8960              LDRH     r0,[r4,#0xa]          ;677
0005e6  1bc0              SUBS     r0,r0,r7              ;677
0005e8  8160              STRH     r0,[r4,#0xa]          ;677
0005ea  980c              LDR      r0,[sp,#0x30]         ;678
0005ec  81a0              STRH     r0,[r4,#0xc]          ;678
0005ee  3c5c              SUBS     r4,r4,#0x5c           ;678
0005f0  bf00              NOP                            ;680
0005f2  bf00              NOP                            ;680
0005f4  f8b40068          LDRH     r0,[r4,#0x68]         ;682
0005f8  b180              CBZ      r0,|L14.1564|
0005fa  bf00              NOP                            ;683
0005fc  6f20              LDR      r0,[r4,#0x70]         ;683
0005fe  b960              CBNZ     r0,|L14.1562|
000600  6ee0              LDR      r0,[r4,#0x6c]         ;683
000602  b950              CBNZ     r0,|L14.1562|
000604  bf00              NOP                            ;683
000606  f2af2318          ADR      r3,|L14.1008|
00060a  f24022ab          MOV      r2,#0x2ab             ;683
00060e  a13b              ADR      r1,|L14.1788|
000610  f2af10c8          ADR      r0,|L14.1100|
000614  f7fffffe          BL       __2printf
000618  bf00              NOP                            ;683
                  |L14.1562|
00061a  bf00              NOP                            ;683
                  |L14.1564|
00061c  f1ba0f00          CMP      r10,#0                ;688
000620  d010              BEQ      |L14.1604|
000622  f8da0010          LDR      r0,[r10,#0x10]        ;688
000626  b168              CBZ      r0,|L14.1604|
000628  9812              LDR      r0,[sp,#0x48]         ;688
00062a  f0000002          AND      r0,r0,#2              ;688
00062e  b948              CBNZ     r0,|L14.1604|
000630  2008              MOVS     r0,#8                 ;689
000632  f7fffffe          BL       lwip_htons
000636  f8da1010          LDR      r1,[r10,#0x10]        ;689
00063a  8989              LDRH     r1,[r1,#0xc]          ;689
00063c  4308              ORRS     r0,r0,r1              ;689
00063e  f8da1010          LDR      r1,[r10,#0x10]        ;689
000642  8188              STRH     r0,[r1,#0xc]          ;689
                  |L14.1604|
000644  2000              MOVS     r0,#0                 ;692
000646  e50e              B        |L14.102|
                  |L14.1608|
000648  7fa0              LDRB     r0,[r4,#0x1e]         ;694
00064a  f0400080          ORR      r0,r0,#0x80           ;694
00064e  77a0              STRB     r0,[r4,#0x1e]         ;694
000650  f1bb0f00          CMP      r11,#0                ;697
000654  d002              BEQ      |L14.1628|
000656  4658              MOV      r0,r11                ;698
000658  f7fffffe          BL       pbuf_free
                  |L14.1628|
00065c  980d              LDR      r0,[sp,#0x34]         ;700
00065e  b110              CBZ      r0,|L14.1638|
000660  980d              LDR      r0,[sp,#0x34]         ;701
000662  f7fffffe          BL       tcp_segs_free
                  |L14.1638|
000666  f8b40068          LDRH     r0,[r4,#0x68]         ;703
00066a  b180              CBZ      r0,|L14.1678|
00066c  bf00              NOP                            ;704
00066e  6f20              LDR      r0,[r4,#0x70]         ;704
000670  b960              CBNZ     r0,|L14.1676|
000672  6ee0              LDR      r0,[r4,#0x6c]         ;704
000674  b950              CBNZ     r0,|L14.1676|
000676  bf00              NOP                            ;704
000678  f2af238c          ADR      r3,|L14.1008|
00067c  f44f7230          MOV      r2,#0x2c0             ;704
000680  a11e              ADR      r1,|L14.1788|
000682  f2af2038          ADR      r0,|L14.1100|
000686  f7fffffe          BL       __2printf
00068a  bf00              NOP                            ;704
                  |L14.1676|
00068c  bf00              NOP                            ;704
                  |L14.1678|
00068e  bf00              NOP                            ;707
000690  bf00              NOP                            ;707
000692  f04f30ff          MOV      r0,#0xffffffff        ;708
000696  e4e6              B        |L14.102|
;;;710    
                          ENDP

                  |L14.1688|
000698  6c617374          DCB      "last_unsent->oversize_left >= oversize_used",0
00069c  5f756e73
0006a0  656e742d
0006a4  3e6f7665
0006a8  7273697a
0006ac  655f6c65
0006b0  6674203e
0006b4  3d206f76
0006b8  65727369
0006bc  7a655f75
0006c0  73656400
                  |L14.1732|
0006c4  7463705f          DCB      "tcp_write: cannot concatenate when pcb->unsent is empty"
0006c8  77726974
0006cc  653a2063
0006d0  616e6e6f
0006d4  7420636f
0006d8  6e636174
0006dc  656e6174
0006e0  65207768
0006e4  656e2070
0006e8  63622d3e
0006ec  756e7365
0006f0  6e742069
0006f4  7320656d
0006f8  707479  
0006fb  00                DCB      0
                  |L14.1788|
0006fc  7463705f          DCB      "tcp_write: valid queue length",0
000700  77726974
000704  653a2076
000708  616c6964
00070c  20717565
000710  7565206c
000714  656e6774
000718  6800    
00071a  00                DCB      0
00071b  00                DCB      0

                          AREA ||i.tcp_write_checks||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_write_checks PROC
;;;293    static err_t
;;;294    tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;295    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;296      /* connection is in invalid state for data transmission? */
;;;297      if ((pcb->state != ESTABLISHED) &&
000006  7e20              LDRB     r0,[r4,#0x18]
000008  2804              CMP      r0,#4
00000a  d00d              BEQ      |L15.40|
;;;298          (pcb->state != CLOSE_WAIT) &&
00000c  7e20              LDRB     r0,[r4,#0x18]
00000e  2807              CMP      r0,#7
000010  d00a              BEQ      |L15.40|
;;;299          (pcb->state != SYN_SENT) &&
000012  7e20              LDRB     r0,[r4,#0x18]
000014  2802              CMP      r0,#2
000016  d007              BEQ      |L15.40|
;;;300          (pcb->state != SYN_RCVD)) {
000018  7e20              LDRB     r0,[r4,#0x18]
00001a  2803              CMP      r0,#3
00001c  d004              BEQ      |L15.40|
;;;301        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
00001e  bf00              NOP      
000020  bf00              NOP      
;;;302        return ERR_CONN;
000022  f06f000c          MVN      r0,#0xc
                  |L15.38|
;;;303      } else if (len == 0) {
;;;304        return ERR_OK;
;;;305      }
;;;306    
;;;307      /* fail on too much data */
;;;308      if (len > pcb->snd_buf) {
;;;309        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
;;;310          len, pcb->snd_buf));
;;;311        pcb->flags |= TF_NAGLEMEMERR;
;;;312        return ERR_MEM;
;;;313      }
;;;314    
;;;315      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;316    
;;;317      /* If total number of pbufs on the unsent/unacked queues exceeds the
;;;318       * configured maximum, return an error */
;;;319      /* check for configured max queuelen and possible overflow */
;;;320      if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;321        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
;;;322          pcb->snd_queuelen, TCP_SND_QUEUELEN));
;;;323        TCP_STATS_INC(tcp.memerr);
;;;324        pcb->flags |= TF_NAGLEMEMERR;
;;;325        return ERR_MEM;
;;;326      }
;;;327      if (pcb->snd_queuelen != 0) {
;;;328        LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
;;;329          pcb->unacked != NULL || pcb->unsent != NULL);
;;;330      } else {
;;;331        LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
;;;332          pcb->unacked == NULL && pcb->unsent == NULL);
;;;333      }
;;;334      return ERR_OK;
;;;335    }
000026  bd70              POP      {r4-r6,pc}
                  |L15.40|
000028  b90d              CBNZ     r5,|L15.46|
00002a  2000              MOVS     r0,#0                 ;304
00002c  e7fb              B        |L15.38|
                  |L15.46|
00002e  f8b40066          LDRH     r0,[r4,#0x66]         ;308
000032  42a8              CMP      r0,r5                 ;308
000034  da08              BGE      |L15.72|
000036  bf00              NOP                            ;309
000038  bf00              NOP                            ;309
00003a  7fa0              LDRB     r0,[r4,#0x1e]         ;311
00003c  f0400080          ORR      r0,r0,#0x80           ;311
000040  77a0              STRB     r0,[r4,#0x1e]         ;311
000042  f04f30ff          MOV      r0,#0xffffffff        ;312
000046  e7ee              B        |L15.38|
                  |L15.72|
000048  bf00              NOP                            ;315
00004a  bf00              NOP                            ;315
00004c  f8b40068          LDRH     r0,[r4,#0x68]         ;320
000050  2808              CMP      r0,#8                 ;320
000052  da05              BGE      |L15.96|
000054  f8b40068          LDRH     r0,[r4,#0x68]         ;320
000058  f64f71fc          MOV      r1,#0xfffc            ;320
00005c  4288              CMP      r0,r1                 ;320
00005e  d908              BLS      |L15.114|
                  |L15.96|
000060  bf00              NOP                            ;321
000062  bf00              NOP                            ;321
000064  7fa0              LDRB     r0,[r4,#0x1e]         ;324
000066  f0400080          ORR      r0,r0,#0x80           ;324
00006a  77a0              STRB     r0,[r4,#0x1e]         ;324
00006c  f04f30ff          MOV      r0,#0xffffffff        ;325
000070  e7d9              B        |L15.38|
                  |L15.114|
000072  f8b40068          LDRH     r0,[r4,#0x68]         ;327
000076  2800              CMP      r0,#0                 ;327
000078  d010              BEQ      |L15.156|
00007a  bf00              NOP                            ;328
00007c  6f20              LDR      r0,[r4,#0x70]         ;328
00007e  2800              CMP      r0,#0                 ;328
000080  d10b              BNE      |L15.154|
000082  6ee0              LDR      r0,[r4,#0x6c]         ;328
000084  2800              CMP      r0,#0                 ;328
000086  d108              BNE      |L15.154|
000088  bf00              NOP                            ;328
00008a  a30d              ADR      r3,|L15.192|
00008c  f44f72a4          MOV      r2,#0x148             ;328
000090  a115              ADR      r1,|L15.232|
000092  a024              ADR      r0,|L15.292|
000094  f7fffffe          BL       __2printf
000098  bf00              NOP                            ;328
                  |L15.154|
00009a  e00e              B        |L15.186|
                  |L15.156|
00009c  bf00              NOP                            ;331
00009e  6f20              LDR      r0,[r4,#0x70]         ;331
0000a0  b908              CBNZ     r0,|L15.166|
0000a2  6ee0              LDR      r0,[r4,#0x6c]         ;331
0000a4  b140              CBZ      r0,|L15.184|
                  |L15.166|
0000a6  bf00              NOP                            ;331
0000a8  a305              ADR      r3,|L15.192|
0000aa  f240124b          MOV      r2,#0x14b             ;331
0000ae  a128              ADR      r1,|L15.336|
0000b0  a01c              ADR      r0,|L15.292|
0000b2  f7fffffe          BL       __2printf
0000b6  bf00              NOP                            ;331
                  |L15.184|
0000b8  bf00              NOP                            ;331
                  |L15.186|
0000ba  2000              MOVS     r0,#0                 ;334
0000bc  e7b3              B        |L15.38|
;;;336    
                          ENDP

0000be  0000              DCW      0x0000
                  |L15.192|
0000c0  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp_out.c",0
0000c4  5749505c
0000c8  6c776970
0000cc  2d312e34
0000d0  2e315c73
0000d4  72635c63
0000d8  6f72655c
0000dc  7463705f
0000e0  6f75742e
0000e4  6300    
0000e6  00                DCB      0
0000e7  00                DCB      0
                  |L15.232|
0000e8  7463705f          DCB      "tcp_write: pbufs on queue => at least one queue non-emp"
0000ec  77726974
0000f0  653a2070
0000f4  62756673
0000f8  206f6e20
0000fc  71756575
000100  65203d3e
000104  20617420
000108  6c656173
00010c  74206f6e
000110  65207175
000114  65756520
000118  6e6f6e2d
00011c  656d70  
00011f  747900            DCB      "ty",0
000122  00                DCB      0
000123  00                DCB      0
                  |L15.292|
000124  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000128  7274696f
00012c  6e202225
000130  73222066
000134  61696c65
000138  64206174
00013c  206c696e
000140  65202564
000144  20696e20
000148  25730d0a
00014c  00      
00014d  00                DCB      0
00014e  00                DCB      0
00014f  00                DCB      0
                  |L15.336|
000150  7463705f          DCB      "tcp_write: no pbufs on queue => both queues empty",0
000154  77726974
000158  653a206e
00015c  6f207062
000160  75667320
000164  6f6e2071
000168  75657565
00016c  203d3e20
000170  626f7468
000174  20717565
000178  75657320
00017c  656d7074
000180  7900    
000182  00                DCB      0
000183  00                DCB      0

                          AREA ||i.tcp_zero_window_probe||, CODE, READONLY, ALIGN=1

                  tcp_zero_window_probe PROC
;;;1413   void
;;;1414   tcp_zero_window_probe(struct tcp_pcb *pcb)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1415   {
000004  4605              MOV      r5,r0
;;;1416     struct pbuf *p;
;;;1417     struct tcp_hdr *tcphdr;
;;;1418     struct tcp_seg *seg;
;;;1419     u16_t len;
;;;1420     u8_t is_fin;
;;;1421   
;;;1422     LWIP_DEBUGF(TCP_DEBUG, 
000006  bf00              NOP      
000008  bf00              NOP      
;;;1423                 ("tcp_zero_window_probe: sending ZERO WINDOW probe to %"
;;;1424                  U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;1425                  ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;1426                  ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;1427   
;;;1428     LWIP_DEBUGF(TCP_DEBUG, 
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;1429                 ("tcp_zero_window_probe: tcp_ticks %"U32_F
;;;1430                  "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
;;;1431                  tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
;;;1432   
;;;1433     seg = pcb->unacked;
00000e  6f2c              LDR      r4,[r5,#0x70]
;;;1434   
;;;1435     if(seg == NULL) {
000010  b904              CBNZ     r4,|L16.20|
;;;1436       seg = pcb->unsent;
000012  6eec              LDR      r4,[r5,#0x6c]
                  |L16.20|
;;;1437     }
;;;1438     if(seg == NULL) {
000014  b90c              CBNZ     r4,|L16.26|
                  |L16.22|
;;;1439       return;
;;;1440     }
;;;1441   
;;;1442     is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
;;;1443     /* we want to send one seqno: either FIN or data (no options) */
;;;1444     len = is_fin ? 0 : 1;
;;;1445   
;;;1446     p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
;;;1447     if(p == NULL) {
;;;1448       LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
;;;1449       return;
;;;1450     }
;;;1451     tcphdr = (struct tcp_hdr *)p->payload;
;;;1452   
;;;1453     if (is_fin) {
;;;1454       /* FIN segment, no data */
;;;1455       TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
;;;1456     } else {
;;;1457       /* Data segment, copy in one byte from the head of the unacked queue */
;;;1458       char *d = ((char *)p->payload + TCP_HLEN);
;;;1459       /* Depending on whether the segment has already been sent (unacked) or not
;;;1460          (unsent), seg->p->payload points to the IP header or TCP header.
;;;1461          Ensure we copy the first TCP data byte: */
;;;1462       pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
;;;1463     }
;;;1464   
;;;1465   #if CHECKSUM_GEN_TCP
;;;1466     tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
;;;1467                                         IP_PROTO_TCP, p->tot_len);
;;;1468   #endif
;;;1469     TCP_STATS_INC(tcp.xmit);
;;;1470   
;;;1471     /* Send output to IP */
;;;1472   #if LWIP_NETIF_HWADDRHINT
;;;1473     ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
;;;1474       &(pcb->addr_hint));
;;;1475   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1476     ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
;;;1477   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1478   
;;;1479     pbuf_free(p);
;;;1480   
;;;1481     LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
;;;1482                             " ackno %"U32_F".\n",
;;;1483                             pcb->snd_nxt - 1, pcb->rcv_nxt));
;;;1484   }
000016  e8bd87fc          POP      {r2-r10,pc}
                  |L16.26|
00001a  6921              LDR      r1,[r4,#0x10]         ;1442
00001c  8988              LDRH     r0,[r1,#0xc]          ;1442
00001e  f7fffffe          BL       lwip_ntohs
000022  f0000001          AND      r0,r0,#1              ;1442
000026  b118              CBZ      r0,|L16.48|
000028  8920              LDRH     r0,[r4,#8]            ;1442
00002a  b908              CBNZ     r0,|L16.48|
00002c  2001              MOVS     r0,#1                 ;1442
00002e  e000              B        |L16.50|
                  |L16.48|
000030  2000              MOVS     r0,#0                 ;1442
                  |L16.50|
000032  4680              MOV      r8,r0                 ;1442
000034  f1b80f00          CMP      r8,#0                 ;1444
000038  d101              BNE      |L16.62|
00003a  2001              MOVS     r0,#1                 ;1444
00003c  e000              B        |L16.64|
                  |L16.62|
00003e  2000              MOVS     r0,#0                 ;1444
                  |L16.64|
000040  4681              MOV      r9,r0                 ;1444
000042  6920              LDR      r0,[r4,#0x10]         ;1446
000044  6843              LDR      r3,[r0,#4]            ;1446
000046  464a              MOV      r2,r9                 ;1446
000048  2100              MOVS     r1,#0                 ;1446
00004a  4628              MOV      r0,r5                 ;1446
00004c  f7fffffe          BL       tcp_output_alloc_header
000050  4606              MOV      r6,r0                 ;1446
000052  b916              CBNZ     r6,|L16.90|
000054  bf00              NOP                            ;1448
000056  bf00              NOP                            ;1448
000058  e7dd              B        |L16.22|
                  |L16.90|
00005a  6877              LDR      r7,[r6,#4]            ;1451
00005c  f1b80f00          CMP      r8,#0                 ;1453
000060  d009              BEQ      |L16.118|
000062  2011              MOVS     r0,#0x11              ;1455
000064  f7fffffe          BL       lwip_htons
000068  89b9              LDRH     r1,[r7,#0xc]          ;1455
00006a  f24c02ff          MOV      r2,#0xc0ff            ;1455
00006e  4011              ANDS     r1,r1,r2              ;1455
000070  4308              ORRS     r0,r0,r1              ;1455
000072  81b8              STRH     r0,[r7,#0xc]          ;1455
000074  e00d              B        |L16.146|
                  |L16.118|
000076  6870              LDR      r0,[r6,#4]            ;1458
000078  f1000a14          ADD      r10,r0,#0x14          ;1458
00007c  6861              LDR      r1,[r4,#4]            ;1462
00007e  8909              LDRH     r1,[r1,#8]            ;1462
000080  8922              LDRH     r2,[r4,#8]            ;1462
000082  1a89              SUBS     r1,r1,r2              ;1462
000084  b28b              UXTH     r3,r1                 ;1462
000086  2201              MOVS     r2,#1                 ;1462
000088  4651              MOV      r1,r10                ;1462
00008a  6860              LDR      r0,[r4,#4]            ;1462
00008c  f7fffffe          BL       pbuf_copy_partial
000090  bf00              NOP                            ;1463
                  |L16.146|
000092  8930              LDRH     r0,[r6,#8]            ;1466
000094  2306              MOVS     r3,#6                 ;1466
000096  1d2a              ADDS     r2,r5,#4              ;1466
000098  4629              MOV      r1,r5                 ;1466
00009a  9000              STR      r0,[sp,#0]            ;1466
00009c  4630              MOV      r0,r6                 ;1466
00009e  f7fffffe          BL       inet_chksum_pseudo
0000a2  8238              STRH     r0,[r7,#0x10]         ;1466
0000a4  2006              MOVS     r0,#6                 ;1476
0000a6  2100              MOVS     r1,#0                 ;1476
0000a8  e9cd1000          STRD     r1,r0,[sp,#0]         ;1476
0000ac  7aab              LDRB     r3,[r5,#0xa]          ;1476
0000ae  1d2a              ADDS     r2,r5,#4              ;1476
0000b0  4629              MOV      r1,r5                 ;1476
0000b2  4630              MOV      r0,r6                 ;1476
0000b4  f7fffffe          BL       ip_output
0000b8  4630              MOV      r0,r6                 ;1479
0000ba  f7fffffe          BL       pbuf_free
0000be  bf00              NOP                            ;1481
0000c0  bf00              NOP                            ;1481
0000c2  bf00              NOP      
0000c4  e7a7              B        |L16.22|
;;;1485   #endif /* LWIP_TCP */
                          ENDP


                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  7463705f          DCB      "tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in fl"
000004  656e7175
000008  6575655f
00000c  666c6167
000010  733a206e
000014  65656420
000018  65697468
00001c  65722054
000020  43505f53
000024  594e206f
000028  72205443
00002c  505f4649
000030  4e20696e
000034  20666c  
000037  61677320          DCB      "ags (programmer violates API)",0
00003b  2870726f
00003f  6772616d
000043  6d657220
000047  76696f6c
00004b  61746573
00004f  20415049
000053  2900    
