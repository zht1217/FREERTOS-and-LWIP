; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\timers_1.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\timers_1.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\timers_1.crf ..\LWIP\lwip-1.4.1\src\core\timers.c]
                          THUMB

                          AREA ||i.arp_timer||, CODE, READONLY, ALIGN=2

                  arp_timer PROC
;;;134    static void
;;;135    arp_timer(void *arg)
000000  b510              PUSH     {r4,lr}
;;;136    {
000002  4604              MOV      r4,r0
;;;137      LWIP_UNUSED_ARG(arg);
;;;138      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: etharp_tmr()\n"));
000004  bf00              NOP      
000006  bf00              NOP      
;;;139      etharp_tmr();
000008  f7fffffe          BL       etharp_tmr
;;;140      sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
00000c  2200              MOVS     r2,#0
00000e  4903              LDR      r1,|L1.28|
000010  f2413088          MOV      r0,#0x1388
000014  f7fffffe          BL       sys_timeout
;;;141    }
000018  bd10              POP      {r4,pc}
;;;142    #endif /* LWIP_ARP */
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      arp_timer

                          AREA ||i.dhcp_timer_coarse||, CODE, READONLY, ALIGN=2

                  dhcp_timer_coarse PROC
;;;150    static void
;;;151    dhcp_timer_coarse(void *arg)
000000  b510              PUSH     {r4,lr}
;;;152    {
000002  4604              MOV      r4,r0
;;;153      LWIP_UNUSED_ARG(arg);
;;;154      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
000004  bf00              NOP      
000006  bf00              NOP      
;;;155      dhcp_coarse_tmr();
000008  f7fffffe          BL       dhcp_coarse_tmr
;;;156      sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
00000c  2200              MOVS     r2,#0
00000e  4903              LDR      r1,|L2.28|
000010  f64e2060          MOV      r0,#0xea60
000014  f7fffffe          BL       sys_timeout
;;;157    }
000018  bd10              POP      {r4,pc}
;;;158    
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      dhcp_timer_coarse

                          AREA ||i.dhcp_timer_fine||, CODE, READONLY, ALIGN=2

                  dhcp_timer_fine PROC
;;;164    static void
;;;165    dhcp_timer_fine(void *arg)
000000  b510              PUSH     {r4,lr}
;;;166    {
000002  4604              MOV      r4,r0
;;;167      LWIP_UNUSED_ARG(arg);
;;;168      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
000004  bf00              NOP      
000006  bf00              NOP      
;;;169      dhcp_fine_tmr();
000008  f7fffffe          BL       dhcp_fine_tmr
;;;170      sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
00000c  2200              MOVS     r2,#0
00000e  4903              LDR      r1,|L3.28|
000010  f44f70fa          MOV      r0,#0x1f4
000014  f7fffffe          BL       sys_timeout
;;;171    }
000018  bd10              POP      {r4,pc}
;;;172    #endif /* LWIP_DHCP */
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      dhcp_timer_fine

                          AREA ||i.ip_reass_timer||, CODE, READONLY, ALIGN=2

                  ip_reass_timer PROC
;;;118    static void
;;;119    ip_reass_timer(void *arg)
000000  b510              PUSH     {r4,lr}
;;;120    {
000002  4604              MOV      r4,r0
;;;121      LWIP_UNUSED_ARG(arg);
;;;122      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: ip_reass_tmr()\n"));
000004  bf00              NOP      
000006  bf00              NOP      
;;;123      ip_reass_tmr();
000008  f7fffffe          BL       ip_reass_tmr
;;;124      sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
00000c  2200              MOVS     r2,#0
00000e  4903              LDR      r1,|L4.28|
000010  f44f707a          MOV      r0,#0x3e8
000014  f7fffffe          BL       sys_timeout
;;;125    }
000018  bd10              POP      {r4,pc}
;;;126    #endif /* IP_REASSEMBLY */
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      ip_reass_timer

                          AREA ||i.sys_timeout||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  sys_timeout PROC
;;;265    void
;;;266    sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;267    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;268    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;269      struct sys_timeo *timeout, *t;
;;;270    
;;;271      timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
00000a  200b              MOVS     r0,#0xb
00000c  f7fffffe          BL       memp_malloc
000010  4604              MOV      r4,r0
;;;272      if (timeout == NULL) {
000012  2c00              CMP      r4,#0
000014  d10d              BNE      |L5.50|
;;;273        LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
000016  bf00              NOP      
000018  d108              BNE      |L5.44|
00001a  bf00              NOP      
00001c  a324              ADR      r3,|L5.176|
00001e  f2401211          MOV      r2,#0x111
000022  a12d              ADR      r1,|L5.216|
000024  a03c              ADR      r0,|L5.280|
000026  f7fffffe          BL       __2printf
00002a  bf00              NOP      
                  |L5.44|
00002c  bf00              NOP      
                  |L5.46|
;;;274        return;
;;;275      }
;;;276      timeout->next = NULL;
;;;277      timeout->h = handler;
;;;278      timeout->arg = arg;
;;;279      timeout->time = msecs;
;;;280    #if LWIP_DEBUG_TIMERNAMES
;;;281      timeout->handler_name = handler_name;
;;;282      LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
;;;283        (void *)timeout, msecs, handler_name, (void *)arg));
;;;284    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;285    
;;;286      if (next_timeout == NULL) {
;;;287        next_timeout = timeout;
;;;288        return;
;;;289      }
;;;290    
;;;291      if (next_timeout->time > msecs) {
;;;292        next_timeout->time -= msecs;
;;;293        timeout->next = next_timeout;
;;;294        next_timeout = timeout;
;;;295      } else {
;;;296        for(t = next_timeout; t != NULL; t = t->next) {
;;;297          timeout->time -= t->time;
;;;298          if (t->next == NULL || t->next->time > timeout->time) {
;;;299            if (t->next != NULL) {
;;;300              t->next->time -= timeout->time;
;;;301            }
;;;302            timeout->next = t->next;
;;;303            t->next = timeout;
;;;304            break;
;;;305          }
;;;306        }
;;;307      }
;;;308    }
00002e  e8bd81f0          POP      {r4-r8,pc}
                  |L5.50|
000032  2000              MOVS     r0,#0                 ;276
000034  6020              STR      r0,[r4,#0]            ;276
000036  60a7              STR      r7,[r4,#8]            ;277
000038  f8c4800c          STR      r8,[r4,#0xc]          ;278
00003c  6066              STR      r6,[r4,#4]            ;279
00003e  4841              LDR      r0,|L5.324|
000040  6800              LDR      r0,[r0,#0]            ;286  ; next_timeout
000042  b910              CBNZ     r0,|L5.74|
000044  483f              LDR      r0,|L5.324|
000046  6004              STR      r4,[r0,#0]            ;287  ; next_timeout
000048  e7f1              B        |L5.46|
                  |L5.74|
00004a  483e              LDR      r0,|L5.324|
00004c  6800              LDR      r0,[r0,#0]            ;291  ; next_timeout
00004e  6840              LDR      r0,[r0,#4]            ;291
000050  42b0              CMP      r0,r6                 ;291
000052  d90c              BLS      |L5.110|
000054  483b              LDR      r0,|L5.324|
000056  6800              LDR      r0,[r0,#0]            ;292  ; next_timeout
000058  6840              LDR      r0,[r0,#4]            ;292
00005a  1b80              SUBS     r0,r0,r6              ;292
00005c  4939              LDR      r1,|L5.324|
00005e  6809              LDR      r1,[r1,#0]            ;292  ; next_timeout
000060  6048              STR      r0,[r1,#4]            ;292
000062  4838              LDR      r0,|L5.324|
000064  6800              LDR      r0,[r0,#0]            ;293  ; next_timeout
000066  6020              STR      r0,[r4,#0]            ;293
000068  4836              LDR      r0,|L5.324|
00006a  6004              STR      r4,[r0,#0]            ;294  ; next_timeout
00006c  e01d              B        |L5.170|
                  |L5.110|
00006e  4835              LDR      r0,|L5.324|
000070  6805              LDR      r5,[r0,#0]            ;296  ; next_timeout
000072  e017              B        |L5.164|
                  |L5.116|
000074  6860              LDR      r0,[r4,#4]            ;297
000076  6869              LDR      r1,[r5,#4]            ;297
000078  1a40              SUBS     r0,r0,r1              ;297
00007a  6060              STR      r0,[r4,#4]            ;297
00007c  6828              LDR      r0,[r5,#0]            ;298
00007e  b120              CBZ      r0,|L5.138|
000080  6828              LDR      r0,[r5,#0]            ;298
000082  6840              LDR      r0,[r0,#4]            ;298
000084  6861              LDR      r1,[r4,#4]            ;298
000086  4288              CMP      r0,r1                 ;298
000088  d90b              BLS      |L5.162|
                  |L5.138|
00008a  6828              LDR      r0,[r5,#0]            ;299
00008c  b128              CBZ      r0,|L5.154|
00008e  6828              LDR      r0,[r5,#0]            ;300
000090  6840              LDR      r0,[r0,#4]            ;300
000092  6861              LDR      r1,[r4,#4]            ;300
000094  1a40              SUBS     r0,r0,r1              ;300
000096  6829              LDR      r1,[r5,#0]            ;300
000098  6048              STR      r0,[r1,#4]            ;300
                  |L5.154|
00009a  6828              LDR      r0,[r5,#0]            ;302
00009c  6020              STR      r0,[r4,#0]            ;302
00009e  602c              STR      r4,[r5,#0]            ;303
0000a0  e002              B        |L5.168|
                  |L5.162|
0000a2  682d              LDR      r5,[r5,#0]            ;296
                  |L5.164|
0000a4  2d00              CMP      r5,#0                 ;296
0000a6  d1e5              BNE      |L5.116|
                  |L5.168|
0000a8  bf00              NOP                            ;304
                  |L5.170|
0000aa  bf00              NOP      
0000ac  e7bf              B        |L5.46|
;;;309    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L5.176|
0000b0  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\timers.c",0
0000b4  5749505c
0000b8  6c776970
0000bc  2d312e34
0000c0  2e315c73
0000c4  72635c63
0000c8  6f72655c
0000cc  74696d65
0000d0  72732e63
0000d4  00      
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L5.216|
0000d8  7379735f          DCB      "sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is "
0000dc  74696d65
0000e0  6f75743a
0000e4  2074696d
0000e8  656f7574
0000ec  20213d20
0000f0  4e554c4c
0000f4  2c20706f
0000f8  6f6c204d
0000fc  454d505f
000100  5359535f
000104  54494d45
000108  4f555420
00010c  697320  
00010f  656d7074          DCB      "empty",0
000113  7900    
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0
                  |L5.280|
000118  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
00011c  7274696f
000120  6e202225
000124  73222066
000128  61696c65
00012c  64206174
000130  206c696e
000134  65202564
000138  20696e20
00013c  25730d0a
000140  00      
000141  00                DCB      0
000142  00                DCB      0
000143  00                DCB      0
                  |L5.324|
                          DCD      next_timeout

                          AREA ||i.sys_timeouts_init||, CODE, READONLY, ALIGN=2

                  sys_timeouts_init PROC
;;;222    /** Initialize this module */
;;;223    void sys_timeouts_init(void)
000000  b510              PUSH     {r4,lr}
;;;224    {
;;;225    #if IP_REASSEMBLY
;;;226      sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
000002  2200              MOVS     r2,#0
000004  490b              LDR      r1,|L6.52|
000006  f44f707a          MOV      r0,#0x3e8
00000a  f7fffffe          BL       sys_timeout
;;;227    #endif /* IP_REASSEMBLY */
;;;228    #if LWIP_ARP
;;;229      sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
00000e  2200              MOVS     r2,#0
000010  4909              LDR      r1,|L6.56|
000012  f2413088          MOV      r0,#0x1388
000016  f7fffffe          BL       sys_timeout
;;;230    #endif /* LWIP_ARP */
;;;231    #if LWIP_DHCP
;;;232      sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
00001a  2200              MOVS     r2,#0
00001c  4907              LDR      r1,|L6.60|
00001e  f64e2060          MOV      r0,#0xea60
000022  f7fffffe          BL       sys_timeout
;;;233      sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
000026  2200              MOVS     r2,#0
000028  4905              LDR      r1,|L6.64|
00002a  f44f70fa          MOV      r0,#0x1f4
00002e  f7fffffe          BL       sys_timeout
;;;234    #endif /* LWIP_DHCP */
;;;235    #if LWIP_AUTOIP
;;;236      sys_timeout(AUTOIP_TMR_INTERVAL, autoip_timer, NULL);
;;;237    #endif /* LWIP_AUTOIP */
;;;238    #if LWIP_IGMP
;;;239      sys_timeout(IGMP_TMR_INTERVAL, igmp_timer, NULL);
;;;240    #endif /* LWIP_IGMP */
;;;241    #if LWIP_DNS
;;;242      sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
;;;243    #endif /* LWIP_DNS */
;;;244    
;;;245    #if NO_SYS
;;;246      /* Initialise timestamp for sys_check_timeouts */
;;;247      timeouts_last_time = sys_now();
;;;248    #endif
;;;249    }
000032  bd10              POP      {r4,pc}
;;;250    
                          ENDP

                  |L6.52|
                          DCD      ip_reass_timer
                  |L6.56|
                          DCD      arp_timer
                  |L6.60|
                          DCD      dhcp_timer_coarse
                  |L6.64|
                          DCD      dhcp_timer_fine

                          AREA ||i.sys_timeouts_mbox_fetch||, CODE, READONLY, ALIGN=2

                  sys_timeouts_mbox_fetch PROC
;;;422    void
;;;423    sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;424    {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
;;;425      u32_t time_needed;
;;;426      struct sys_timeo *tmptimeout;
;;;427      sys_timeout_handler handler;
;;;428      void *arg;
;;;429    
;;;430     again:
000008  bf00              NOP      
                  |L7.10|
;;;431      if (!next_timeout) {
00000a  481e              LDR      r0,|L7.132|
00000c  6800              LDR      r0,[r0,#0]  ; next_timeout
00000e  b930              CBNZ     r0,|L7.30|
;;;432        time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
000010  2200              MOVS     r2,#0
000012  4649              MOV      r1,r9
000014  4640              MOV      r0,r8
000016  f7fffffe          BL       sys_arch_mbox_fetch
00001a  4605              MOV      r5,r0
00001c  e030              B        |L7.128|
                  |L7.30|
;;;433      } else {
;;;434        if (next_timeout->time > 0) {
00001e  4819              LDR      r0,|L7.132|
000020  6800              LDR      r0,[r0,#0]  ; next_timeout
000022  6840              LDR      r0,[r0,#4]
000024  b140              CBZ      r0,|L7.56|
;;;435          time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
000026  4817              LDR      r0,|L7.132|
000028  6800              LDR      r0,[r0,#0]  ; next_timeout
00002a  4649              MOV      r1,r9
00002c  6842              LDR      r2,[r0,#4]
00002e  4640              MOV      r0,r8
000030  f7fffffe          BL       sys_arch_mbox_fetch
000034  4605              MOV      r5,r0
000036  e001              B        |L7.60|
                  |L7.56|
;;;436        } else {
;;;437          time_needed = SYS_ARCH_TIMEOUT;
000038  f04f35ff          MOV      r5,#0xffffffff
                  |L7.60|
;;;438        }
;;;439    
;;;440        if (time_needed == SYS_ARCH_TIMEOUT) {
00003c  1c68              ADDS     r0,r5,#1
00003e  b970              CBNZ     r0,|L7.94|
;;;441          /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
;;;442             could be fetched. We should now call the timeout handler and
;;;443             deallocate the memory allocated for the timeout. */
;;;444          tmptimeout = next_timeout;
000040  4810              LDR      r0,|L7.132|
000042  6804              LDR      r4,[r0,#0]  ; next_timeout
;;;445          next_timeout = tmptimeout->next;
000044  490f              LDR      r1,|L7.132|
000046  6820              LDR      r0,[r4,#0]
000048  6008              STR      r0,[r1,#0]  ; next_timeout
;;;446          handler = tmptimeout->h;
00004a  68a6              LDR      r6,[r4,#8]
;;;447          arg = tmptimeout->arg;
00004c  68e7              LDR      r7,[r4,#0xc]
;;;448    #if LWIP_DEBUG_TIMERNAMES
;;;449          if (handler != NULL) {
;;;450            LWIP_DEBUGF(TIMERS_DEBUG, ("stmf calling h=%s arg=%p\n",
;;;451              tmptimeout->handler_name, arg));
;;;452          }
;;;453    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;454          memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
00004e  4621              MOV      r1,r4
000050  200b              MOVS     r0,#0xb
000052  f7fffffe          BL       memp_free
;;;455          if (handler != NULL) {
000056  b10e              CBZ      r6,|L7.92|
;;;456            /* For LWIP_TCPIP_CORE_LOCKING, lock the core before calling the
;;;457               timeout handler function. */
;;;458            LOCK_TCPIP_CORE();
;;;459            handler(arg);
000058  4638              MOV      r0,r7
00005a  47b0              BLX      r6
                  |L7.92|
;;;460            UNLOCK_TCPIP_CORE();
;;;461          }
;;;462          LWIP_TCPIP_THREAD_ALIVE();
;;;463    
;;;464          /* We try again to fetch a message from the mbox. */
;;;465          goto again;
00005c  e7d5              B        |L7.10|
                  |L7.94|
;;;466        } else {
;;;467          /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
;;;468             occured. The time variable is set to the number of
;;;469             milliseconds we waited for the message. */
;;;470          if (time_needed < next_timeout->time) {
00005e  4809              LDR      r0,|L7.132|
000060  6800              LDR      r0,[r0,#0]  ; next_timeout
000062  6840              LDR      r0,[r0,#4]
000064  42a8              CMP      r0,r5
000066  d907              BLS      |L7.120|
;;;471            next_timeout->time -= time_needed;
000068  4806              LDR      r0,|L7.132|
00006a  6800              LDR      r0,[r0,#0]  ; next_timeout
00006c  6840              LDR      r0,[r0,#4]
00006e  1b40              SUBS     r0,r0,r5
000070  4904              LDR      r1,|L7.132|
000072  6809              LDR      r1,[r1,#0]  ; next_timeout
000074  6048              STR      r0,[r1,#4]
000076  e003              B        |L7.128|
                  |L7.120|
;;;472          } else {
;;;473            next_timeout->time = 0;
000078  2000              MOVS     r0,#0
00007a  4902              LDR      r1,|L7.132|
00007c  6809              LDR      r1,[r1,#0]  ; next_timeout
00007e  6048              STR      r0,[r1,#4]
                  |L7.128|
;;;474          }
;;;475        }
;;;476      }
;;;477    }
000080  e8bd87f0          POP      {r4-r10,pc}
;;;478    
                          ENDP

                  |L7.132|
                          DCD      next_timeout

                          AREA ||i.sys_untimeout||, CODE, READONLY, ALIGN=2

                  sys_untimeout PROC
;;;320    void
;;;321    sys_untimeout(sys_timeout_handler handler, void *arg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;322    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;323      struct sys_timeo *prev_t, *t;
;;;324    
;;;325      if (next_timeout == NULL) {
000008  4814              LDR      r0,|L8.92|
00000a  6800              LDR      r0,[r0,#0]  ; next_timeout
00000c  b908              CBNZ     r0,|L8.18|
                  |L8.14|
;;;326        return;
;;;327      }
;;;328    
;;;329      for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
;;;330        if ((t->h == handler) && (t->arg == arg)) {
;;;331          /* We have a match */
;;;332          /* Unlink from previous in list */
;;;333          if (prev_t == NULL) {
;;;334            next_timeout = t->next;
;;;335          } else {
;;;336            prev_t->next = t->next;
;;;337          }
;;;338          /* If not the last one, add time of this one back to next */
;;;339          if (t->next != NULL) {
;;;340            t->next->time += t->time;
;;;341          }
;;;342          memp_free(MEMP_SYS_TIMEOUT, t);
;;;343          return;
;;;344        }
;;;345      }
;;;346      return;
;;;347    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L8.18|
000012  4812              LDR      r0,|L8.92|
000014  6804              LDR      r4,[r0,#0]            ;329  ; next_timeout
000016  2500              MOVS     r5,#0                 ;329
000018  e01b              B        |L8.82|
                  |L8.26|
00001a  68a0              LDR      r0,[r4,#8]            ;330
00001c  42b0              CMP      r0,r6                 ;330
00001e  d116              BNE      |L8.78|
000020  68e0              LDR      r0,[r4,#0xc]          ;330
000022  42b8              CMP      r0,r7                 ;330
000024  d113              BNE      |L8.78|
000026  b91d              CBNZ     r5,|L8.48|
000028  490c              LDR      r1,|L8.92|
00002a  6820              LDR      r0,[r4,#0]            ;334
00002c  6008              STR      r0,[r1,#0]            ;334  ; next_timeout
00002e  e001              B        |L8.52|
                  |L8.48|
000030  6820              LDR      r0,[r4,#0]            ;336
000032  6028              STR      r0,[r5,#0]            ;336
                  |L8.52|
000034  6820              LDR      r0,[r4,#0]            ;339
000036  b128              CBZ      r0,|L8.68|
000038  6820              LDR      r0,[r4,#0]            ;340
00003a  6840              LDR      r0,[r0,#4]            ;340
00003c  6861              LDR      r1,[r4,#4]            ;340
00003e  4408              ADD      r0,r0,r1              ;340
000040  6821              LDR      r1,[r4,#0]            ;340
000042  6048              STR      r0,[r1,#4]            ;340
                  |L8.68|
000044  4621              MOV      r1,r4                 ;342
000046  200b              MOVS     r0,#0xb               ;342
000048  f7fffffe          BL       memp_free
00004c  e7df              B        |L8.14|
                  |L8.78|
00004e  4625              MOV      r5,r4                 ;329
000050  6824              LDR      r4,[r4,#0]            ;329
                  |L8.82|
000052  2c00              CMP      r4,#0                 ;329
000054  d1e1              BNE      |L8.26|
000056  bf00              NOP                            ;346
000058  e7d9              B        |L8.14|
;;;348    
                          ENDP

00005a  0000              DCW      0x0000
                  |L8.92|
                          DCD      next_timeout

                          AREA ||i.tcp_timer_needed||, CODE, READONLY, ALIGN=2

                  tcp_timer_needed PROC
;;;100    void
;;;101    tcp_timer_needed(void)
000000  b510              PUSH     {r4,lr}
;;;102    {
;;;103      /* timer is off but needed again? */
;;;104      if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
000002  4809              LDR      r0,|L9.40|
000004  6800              LDR      r0,[r0,#0]  ; tcpip_tcp_timer_active
000006  b968              CBNZ     r0,|L9.36|
000008  4808              LDR      r0,|L9.44|
00000a  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
00000c  b910              CBNZ     r0,|L9.20|
00000e  4808              LDR      r0,|L9.48|
000010  6800              LDR      r0,[r0,#0]  ; tcp_tw_pcbs
000012  b138              CBZ      r0,|L9.36|
                  |L9.20|
;;;105        /* enable and start timer */
;;;106        tcpip_tcp_timer_active = 1;
000014  2001              MOVS     r0,#1
000016  4904              LDR      r1,|L9.40|
000018  6008              STR      r0,[r1,#0]  ; tcpip_tcp_timer_active
;;;107        sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
00001a  2200              MOVS     r2,#0
00001c  4905              LDR      r1,|L9.52|
00001e  20fa              MOVS     r0,#0xfa
000020  f7fffffe          BL       sys_timeout
                  |L9.36|
;;;108      }
;;;109    }
000024  bd10              POP      {r4,pc}
;;;110    #endif /* LWIP_TCP */
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      tcpip_tcp_timer_active
                  |L9.44|
                          DCD      tcp_active_pcbs
                  |L9.48|
                          DCD      tcp_tw_pcbs
                  |L9.52|
                          DCD      tcpip_tcp_timer

                          AREA ||i.tcpip_tcp_timer||, CODE, READONLY, ALIGN=2

                  tcpip_tcp_timer PROC
;;;78     static void
;;;79     tcpip_tcp_timer(void *arg)
000000  b510              PUSH     {r4,lr}
;;;80     {
000002  4604              MOV      r4,r0
;;;81       LWIP_UNUSED_ARG(arg);
;;;82     
;;;83       /* call TCP timer handler */
;;;84       tcp_tmr();
000004  f7fffffe          BL       tcp_tmr
;;;85       /* timer still needed? */
;;;86       if (tcp_active_pcbs || tcp_tw_pcbs) {
000008  4807              LDR      r0,|L10.40|
00000a  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
00000c  b910              CBNZ     r0,|L10.20|
00000e  4807              LDR      r0,|L10.44|
000010  6800              LDR      r0,[r0,#0]  ; tcp_tw_pcbs
000012  b128              CBZ      r0,|L10.32|
                  |L10.20|
;;;87         /* restart timer */
;;;88         sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
000014  2200              MOVS     r2,#0
000016  4906              LDR      r1,|L10.48|
000018  20fa              MOVS     r0,#0xfa
00001a  f7fffffe          BL       sys_timeout
00001e  e002              B        |L10.38|
                  |L10.32|
;;;89       } else {
;;;90         /* disable timer */
;;;91         tcpip_tcp_timer_active = 0;
000020  2000              MOVS     r0,#0
000022  4904              LDR      r1,|L10.52|
000024  6008              STR      r0,[r1,#0]  ; tcpip_tcp_timer_active
                  |L10.38|
;;;92       }
;;;93     }
000026  bd10              POP      {r4,pc}
;;;94     
                          ENDP

                  |L10.40|
                          DCD      tcp_active_pcbs
                  |L10.44|
                          DCD      tcp_tw_pcbs
                  |L10.48|
                          DCD      tcpip_tcp_timer
                  |L10.52|
                          DCD      tcpip_tcp_timer_active

                          AREA ||.data||, DATA, ALIGN=2

                  next_timeout
                          DCD      0x00000000
                  tcpip_tcp_timer_active
                          DCD      0x00000000
