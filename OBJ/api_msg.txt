; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\api_msg.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\api_msg.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\api_msg.crf ..\LWIP\lwip-1.4.1\src\api\api_msg.c]
                          THUMB

                          AREA ||i.accept_function||, CODE, READONLY, ALIGN=1

                  accept_function PROC
;;;431    static err_t
;;;432    accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;433    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;434      struct netconn *newconn;
;;;435      struct netconn *conn = (struct netconn *)arg;
00000a  4635              MOV      r5,r6
;;;436    
;;;437      LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->tate: %s\n", tcp_debug_state_str(newpcb->state)));
00000c  bf00              NOP      
00000e  bf00              NOP      
;;;438    
;;;439      if (!sys_mbox_valid(&conn->acceptmbox)) {
000010  f1050014          ADD      r0,r5,#0x14
000014  f7fffffe          BL       sys_mbox_valid
000018  b928              CBNZ     r0,|L1.38|
;;;440        LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: acceptmbox already deleted\n"));
00001a  bf00              NOP      
00001c  bf00              NOP      
;;;441        return ERR_VAL;
00001e  f06f0005          MVN      r0,#5
                  |L1.34|
;;;442      }
;;;443    
;;;444      /* We have to set the callback here even though
;;;445       * the new socket is unknown. conn->socket is marked as -1. */
;;;446      newconn = netconn_alloc(conn->type, conn->callback);
;;;447      if (newconn == NULL) {
;;;448        return ERR_MEM;
;;;449      }
;;;450      newconn->pcb.tcp = newpcb;
;;;451      setup_tcp(newconn);
;;;452      /* no protection: when creating the pcb, the netconn is not yet known
;;;453         to the application thread */
;;;454      newconn->last_err = err;
;;;455    
;;;456      if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
;;;457        /* When returning != ERR_OK, the pcb is aborted in tcp_process(),
;;;458           so do nothing here! */
;;;459        /* remove all references to this netconn from the pcb */
;;;460        struct tcp_pcb* pcb = newconn->pcb.tcp;
;;;461        tcp_arg(pcb, NULL);
;;;462        tcp_recv(pcb, NULL);
;;;463        tcp_sent(pcb, NULL);
;;;464        tcp_poll(pcb, NULL, 4);
;;;465        tcp_err(pcb, NULL);
;;;466        /* remove reference from to the pcb from this netconn */
;;;467        newconn->pcb.tcp = NULL;
;;;468        /* no need to drain since we know the recvmbox is empty. */
;;;469        sys_mbox_free(&newconn->recvmbox);
;;;470        sys_mbox_set_invalid(&newconn->recvmbox);
;;;471        netconn_free(newconn);
;;;472        return ERR_MEM;
;;;473      } else {
;;;474        /* Register event with callback */
;;;475        API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
;;;476      }
;;;477    
;;;478      return ERR_OK;
;;;479    }
000022  e8bd87f0          POP      {r4-r10,pc}
                  |L1.38|
000026  7828              LDRB     r0,[r5,#0]            ;446
000028  6ae9              LDR      r1,[r5,#0x2c]         ;446
00002a  f7fffffe          BL       netconn_alloc
00002e  4604              MOV      r4,r0                 ;446
000030  b914              CBNZ     r4,|L1.56|
000032  f04f30ff          MOV      r0,#0xffffffff        ;448
000036  e7f4              B        |L1.34|
                  |L1.56|
000038  6067              STR      r7,[r4,#4]            ;450
00003a  4620              MOV      r0,r4                 ;451
00003c  f7fffffe          BL       setup_tcp
000040  f8848008          STRB     r8,[r4,#8]            ;454
000044  4621              MOV      r1,r4                 ;456
000046  f1050014          ADD      r0,r5,#0x14           ;456
00004a  f7fffffe          BL       sys_mbox_trypost
00004e  b330              CBZ      r0,|L1.158|
000050  f8d49004          LDR      r9,[r4,#4]            ;460
000054  2100              MOVS     r1,#0                 ;461
000056  4648              MOV      r0,r9                 ;461
000058  f7fffffe          BL       tcp_arg
00005c  2100              MOVS     r1,#0                 ;462
00005e  4648              MOV      r0,r9                 ;462
000060  f7fffffe          BL       tcp_recv
000064  2100              MOVS     r1,#0                 ;463
000066  4648              MOV      r0,r9                 ;463
000068  f7fffffe          BL       tcp_sent
00006c  2204              MOVS     r2,#4                 ;464
00006e  2100              MOVS     r1,#0                 ;464
000070  4648              MOV      r0,r9                 ;464
000072  f7fffffe          BL       tcp_poll
000076  2100              MOVS     r1,#0                 ;465
000078  4648              MOV      r0,r9                 ;465
00007a  f7fffffe          BL       tcp_err
00007e  2000              MOVS     r0,#0                 ;467
000080  6060              STR      r0,[r4,#4]            ;467
000082  f1040010          ADD      r0,r4,#0x10           ;469
000086  f7fffffe          BL       sys_mbox_free
00008a  f1040010          ADD      r0,r4,#0x10           ;470
00008e  f7fffffe          BL       sys_mbox_set_invalid
000092  4620              MOV      r0,r4                 ;471
000094  f7fffffe          BL       netconn_free
000098  f04f30ff          MOV      r0,#0xffffffff        ;472
00009c  e7c1              B        |L1.34|
                  |L1.158|
00009e  6ae8              LDR      r0,[r5,#0x2c]         ;475
0000a0  b120              CBZ      r0,|L1.172|
0000a2  2200              MOVS     r2,#0                 ;475
0000a4  4611              MOV      r1,r2                 ;475
0000a6  4628              MOV      r0,r5                 ;475
0000a8  6aeb              LDR      r3,[r5,#0x2c]         ;475
0000aa  4798              BLX      r3                    ;475
                  |L1.172|
0000ac  2000              MOVS     r0,#0                 ;478
0000ae  e7b8              B        |L1.34|
;;;480    #endif /* LWIP_TCP */
                          ENDP


                          AREA ||i.do_bind||, CODE, READONLY, ALIGN=1

                  do_bind PROC
;;;897    void
;;;898    do_bind(struct api_msg_msg *msg)
000000  b510              PUSH     {r4,lr}
;;;899    {
000002  4604              MOV      r4,r0
;;;900      if (ERR_IS_FATAL(msg->conn->last_err)) {
000004  6820              LDR      r0,[r4,#0]
000006  f9900008          LDRSB    r0,[r0,#8]
00000a  f1100f09          CMN      r0,#9
00000e  da03              BGE      |L2.24|
;;;901        msg->err = msg->conn->last_err;
000010  6820              LDR      r0,[r4,#0]
000012  7a00              LDRB     r0,[r0,#8]
000014  7120              STRB     r0,[r4,#4]
000016  e027              B        |L2.104|
                  |L2.24|
;;;902      } else {
;;;903        msg->err = ERR_VAL;
000018  20fa              MOVS     r0,#0xfa
00001a  7120              STRB     r0,[r4,#4]
;;;904        if (msg->conn->pcb.tcp != NULL) {
00001c  6820              LDR      r0,[r4,#0]
00001e  6840              LDR      r0,[r0,#4]
000020  b310              CBZ      r0,|L2.104|
;;;905          switch (NETCONNTYPE_GROUP(msg->conn->type)) {
000022  6820              LDR      r0,[r4,#0]
000024  7800              LDRB     r0,[r0,#0]
000026  f00000f0          AND      r0,r0,#0xf0
00002a  2810              CMP      r0,#0x10
00002c  d012              BEQ      |L2.84|
00002e  2820              CMP      r0,#0x20
000030  d008              BEQ      |L2.68|
000032  2840              CMP      r0,#0x40
000034  d116              BNE      |L2.100|
;;;906    #if LWIP_RAW
;;;907          case NETCONN_RAW:
;;;908            msg->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
000036  6822              LDR      r2,[r4,#0]
000038  68a1              LDR      r1,[r4,#8]
00003a  6850              LDR      r0,[r2,#4]
00003c  f7fffffe          BL       raw_bind
000040  7120              STRB     r0,[r4,#4]
;;;909            break;
000042  e010              B        |L2.102|
                  |L2.68|
;;;910    #endif /* LWIP_RAW */
;;;911    #if LWIP_UDP
;;;912          case NETCONN_UDP:
;;;913            msg->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
000044  89a2              LDRH     r2,[r4,#0xc]
000046  6823              LDR      r3,[r4,#0]
000048  68a1              LDR      r1,[r4,#8]
00004a  6858              LDR      r0,[r3,#4]
00004c  f7fffffe          BL       udp_bind
000050  7120              STRB     r0,[r4,#4]
;;;914            break;
000052  e008              B        |L2.102|
                  |L2.84|
;;;915    #endif /* LWIP_UDP */
;;;916    #if LWIP_TCP
;;;917          case NETCONN_TCP:
;;;918            msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
000054  89a2              LDRH     r2,[r4,#0xc]
000056  6823              LDR      r3,[r4,#0]
000058  68a1              LDR      r1,[r4,#8]
00005a  6858              LDR      r0,[r3,#4]
00005c  f7fffffe          BL       tcp_bind
000060  7120              STRB     r0,[r4,#4]
;;;919            break;
000062  e000              B        |L2.102|
                  |L2.100|
;;;920    #endif /* LWIP_TCP */
;;;921          default:
;;;922            break;
000064  bf00              NOP      
                  |L2.102|
000066  bf00              NOP                            ;909
                  |L2.104|
;;;923          }
;;;924        }
;;;925      }
;;;926      TCPIP_APIMSG_ACK(msg);
000068  6821              LDR      r1,[r4,#0]
00006a  f101000c          ADD      r0,r1,#0xc
00006e  f7fffffe          BL       sys_sem_signal
;;;927    }
000072  bd10              POP      {r4,pc}
;;;928    
                          ENDP


                          AREA ||i.do_close||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  do_close PROC
;;;1450   void
;;;1451   do_close(struct api_msg_msg *msg)
000000  b510              PUSH     {r4,lr}
;;;1452   {
000002  4604              MOV      r4,r0
;;;1453   #if LWIP_TCP
;;;1454     /* @todo: abort running write/connect? */
;;;1455     if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
000004  6820              LDR      r0,[r4,#0]
000006  7840              LDRB     r0,[r0,#1]
000008  2800              CMP      r0,#0
00000a  d015              BEQ      |L3.56|
00000c  6820              LDR      r0,[r4,#0]
00000e  7840              LDRB     r0,[r0,#1]
000010  2802              CMP      r0,#2
000012  d011              BEQ      |L3.56|
;;;1456       /* this only happens for TCP netconns */
;;;1457       LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
000014  bf00              NOP      
000016  6820              LDR      r0,[r4,#0]
000018  7800              LDRB     r0,[r0,#0]
00001a  2810              CMP      r0,#0x10
00001c  d008              BEQ      |L3.48|
00001e  bf00              NOP      
000020  a323              ADR      r3,|L3.176|
000022  f24052b1          MOV      r2,#0x5b1
000026  a12c              ADR      r1,|L3.216|
000028  a033              ADR      r0,|L3.248|
00002a  f7fffffe          BL       __2printf
00002e  bf00              NOP      
                  |L3.48|
000030  bf00              NOP      
;;;1458       msg->err = ERR_INPROGRESS;
000032  20fb              MOVS     r0,#0xfb
000034  7120              STRB     r0,[r4,#4]
000036  e034              B        |L3.162|
                  |L3.56|
;;;1459     } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
000038  6820              LDR      r0,[r4,#0]
00003a  6840              LDR      r0,[r0,#4]
00003c  2800              CMP      r0,#0
00003e  d02e              BEQ      |L3.158|
000040  6820              LDR      r0,[r4,#0]
000042  7800              LDRB     r0,[r0,#0]
000044  2810              CMP      r0,#0x10
000046  d12a              BNE      |L3.158|
;;;1460       if ((msg->msg.sd.shut != NETCONN_SHUT_RDWR) && (msg->conn->state == NETCONN_LISTEN)) {
000048  7a20              LDRB     r0,[r4,#8]
00004a  2803              CMP      r0,#3
00004c  d006              BEQ      |L3.92|
00004e  6820              LDR      r0,[r4,#0]
000050  7840              LDRB     r0,[r0,#1]
000052  2802              CMP      r0,#2
000054  d102              BNE      |L3.92|
;;;1461         /* LISTEN doesn't support half shutdown */
;;;1462         msg->err = ERR_CONN;
000056  20f3              MOVS     r0,#0xf3
000058  7120              STRB     r0,[r4,#4]
00005a  e022              B        |L3.162|
                  |L3.92|
;;;1463       } else {
;;;1464         if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
00005c  7a20              LDRB     r0,[r4,#8]
00005e  f0000001          AND      r0,r0,#1
000062  b110              CBZ      r0,|L3.106|
;;;1465           /* Drain and delete mboxes */
;;;1466           netconn_drain(msg->conn);
000064  6820              LDR      r0,[r4,#0]
000066  f7fffffe          BL       netconn_drain
                  |L3.106|
;;;1467         }
;;;1468         LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
00006a  bf00              NOP      
00006c  6820              LDR      r0,[r4,#0]
00006e  6a80              LDR      r0,[r0,#0x28]
000070  b910              CBNZ     r0,|L3.120|
000072  6820              LDR      r0,[r4,#0]
000074  6a40              LDR      r0,[r0,#0x24]
000076  b140              CBZ      r0,|L3.138|
                  |L3.120|
000078  bf00              NOP      
00007a  a30d              ADR      r3,|L3.176|
00007c  f24052bc          MOV      r2,#0x5bc
000080  a128              ADR      r1,|L3.292|
000082  a01d              ADR      r0,|L3.248|
000084  f7fffffe          BL       __2printf
000088  bf00              NOP      
                  |L3.138|
00008a  bf00              NOP      
;;;1469           msg->conn->write_offset == 0);
;;;1470         msg->conn->state = NETCONN_CLOSE;
00008c  2004              MOVS     r0,#4
00008e  6821              LDR      r1,[r4,#0]
000090  7048              STRB     r0,[r1,#1]
;;;1471         msg->conn->current_msg = msg;
000092  6820              LDR      r0,[r4,#0]
000094  6284              STR      r4,[r0,#0x28]
;;;1472         do_close_internal(msg->conn);
000096  6820              LDR      r0,[r4,#0]
000098  f7fffffe          BL       do_close_internal
                  |L3.156|
;;;1473         /* for tcp netconns, do_close_internal ACKs the message */
;;;1474         return;
;;;1475       }
;;;1476     } else
;;;1477   #endif /* LWIP_TCP */
;;;1478     {
;;;1479       msg->err = ERR_VAL;
;;;1480     }
;;;1481     sys_sem_signal(&msg->conn->op_completed);
;;;1482   }
00009c  bd10              POP      {r4,pc}
                  |L3.158|
00009e  20fa              MOVS     r0,#0xfa              ;1479
0000a0  7120              STRB     r0,[r4,#4]            ;1479
                  |L3.162|
0000a2  6821              LDR      r1,[r4,#0]            ;1481
0000a4  f101000c          ADD      r0,r1,#0xc            ;1481
0000a8  f7fffffe          BL       sys_sem_signal
0000ac  bf00              NOP      
0000ae  e7f5              B        |L3.156|
;;;1483   
                          ENDP

                  |L3.176|
0000b0  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\api_msg.c",0
0000b4  5749505c
0000b8  6c776970
0000bc  2d312e34
0000c0  2e315c73
0000c4  72635c61
0000c8  70695c61
0000cc  70695f6d
0000d0  73672e63
0000d4  00      
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L3.216|
0000d8  6d73672d          DCB      "msg->conn->type == NETCONN_TCP",0
0000dc  3e636f6e
0000e0  6e2d3e74
0000e4  79706520
0000e8  3d3d204e
0000ec  4554434f
0000f0  4e4e5f54
0000f4  435000  
0000f7  00                DCB      0
                  |L3.248|
0000f8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000fc  7274696f
000100  6e202225
000104  73222066
000108  61696c65
00010c  64206174
000110  206c696e
000114  65202564
000118  20696e20
00011c  25730d0a
000120  00      
000121  00                DCB      0
000122  00                DCB      0
000123  00                DCB      0
                  |L3.292|
000124  616c7265          DCB      "already writing or closing",0
000128  61647920
00012c  77726974
000130  696e6720
000134  6f722063
000138  6c6f7369
00013c  6e6700  
00013f  00                DCB      0

                          AREA ||i.do_close_internal||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  do_close_internal PROC
;;;746    static void
;;;747    do_close_internal(struct netconn *conn)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;748    {
000004  4604              MOV      r4,r0
;;;749      err_t err;
;;;750      u8_t shut, shut_rx, shut_tx, close;
;;;751    
;;;752      LWIP_ASSERT("invalid conn", (conn != NULL));
000006  bf00              NOP      
000008  b944              CBNZ     r4,|L4.28|
00000a  bf00              NOP      
00000c  a367              ADR      r3,|L4.428|
00000e  f44f723c          MOV      r2,#0x2f0
000012  a170              ADR      r1,|L4.468|
000014  a073              ADR      r0,|L4.484|
000016  f7fffffe          BL       __2printf
00001a  bf00              NOP      
                  |L4.28|
00001c  bf00              NOP      
;;;753      LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
00001e  bf00              NOP      
000020  7820              LDRB     r0,[r4,#0]
000022  2810              CMP      r0,#0x10
000024  d008              BEQ      |L4.56|
000026  bf00              NOP      
000028  a360              ADR      r3,|L4.428|
00002a  f24022f1          MOV      r2,#0x2f1
00002e  a178              ADR      r1,|L4.528|
000030  a06c              ADR      r0,|L4.484|
000032  f7fffffe          BL       __2printf
000036  bf00              NOP      
                  |L4.56|
000038  bf00              NOP      
;;;754      LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
00003a  bf00              NOP      
00003c  7860              LDRB     r0,[r4,#1]
00003e  2804              CMP      r0,#4
000040  d008              BEQ      |L4.84|
000042  bf00              NOP      
000044  a359              ADR      r3,|L4.428|
000046  f24022f2          MOV      r2,#0x2f2
00004a  a179              ADR      r1,|L4.560|
00004c  a065              ADR      r0,|L4.484|
00004e  f7fffffe          BL       __2printf
000052  bf00              NOP      
                  |L4.84|
000054  bf00              NOP      
;;;755      LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
000056  bf00              NOP      
000058  6860              LDR      r0,[r4,#4]
00005a  b940              CBNZ     r0,|L4.110|
00005c  bf00              NOP      
00005e  a353              ADR      r3,|L4.428|
000060  f24022f3          MOV      r2,#0x2f3
000064  a17b              ADR      r1,|L4.596|
000066  a05f              ADR      r0,|L4.484|
000068  f7fffffe          BL       __2printf
00006c  bf00              NOP      
                  |L4.110|
00006e  bf00              NOP      
;;;756      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
000070  bf00              NOP      
000072  6aa0              LDR      r0,[r4,#0x28]
000074  b940              CBNZ     r0,|L4.136|
000076  bf00              NOP      
000078  a34c              ADR      r3,|L4.428|
00007a  f44f723d          MOV      r2,#0x2f4
00007e  a17a              ADR      r1,|L4.616|
000080  a058              ADR      r0,|L4.484|
000082  f7fffffe          BL       __2printf
000086  bf00              NOP      
                  |L4.136|
000088  bf00              NOP      
;;;757    
;;;758      shut = conn->current_msg->msg.sd.shut;
00008a  6aa0              LDR      r0,[r4,#0x28]
00008c  7a06              LDRB     r6,[r0,#8]
;;;759      shut_rx = shut & NETCONN_SHUT_RD;
00008e  f0060701          AND      r7,r6,#1
;;;760      shut_tx = shut & NETCONN_SHUT_WR;
000092  f0060802          AND      r8,r6,#2
;;;761      /* shutting down both ends is the same as closing */
;;;762      close = shut == NETCONN_SHUT_RDWR;
000096  2e03              CMP      r6,#3
000098  d101              BNE      |L4.158|
00009a  2001              MOVS     r0,#1
00009c  e000              B        |L4.160|
                  |L4.158|
00009e  2000              MOVS     r0,#0
                  |L4.160|
0000a0  4681              MOV      r9,r0
;;;763    
;;;764      /* Set back some callback pointers */
;;;765      if (close) {
0000a2  f1b90f00          CMP      r9,#0
0000a6  d003              BEQ      |L4.176|
;;;766        tcp_arg(conn->pcb.tcp, NULL);
0000a8  2100              MOVS     r1,#0
0000aa  6860              LDR      r0,[r4,#4]
0000ac  f7fffffe          BL       tcp_arg
                  |L4.176|
;;;767      }
;;;768      if (conn->pcb.tcp->state == LISTEN) {
0000b0  6860              LDR      r0,[r4,#4]
0000b2  7e00              LDRB     r0,[r0,#0x18]
0000b4  2801              CMP      r0,#1
0000b6  d104              BNE      |L4.194|
;;;769        tcp_accept(conn->pcb.tcp, NULL);
0000b8  2100              MOVS     r1,#0
0000ba  6860              LDR      r0,[r4,#4]
0000bc  f7fffffe          BL       tcp_accept
0000c0  e01b              B        |L4.250|
                  |L4.194|
;;;770      } else {
;;;771        /* some callbacks have to be reset if tcp_close is not successful */
;;;772        if (shut_rx) {
0000c2  b13f              CBZ      r7,|L4.212|
;;;773          tcp_recv(conn->pcb.tcp, NULL);
0000c4  2100              MOVS     r1,#0
0000c6  6860              LDR      r0,[r4,#4]
0000c8  f7fffffe          BL       tcp_recv
;;;774          tcp_accept(conn->pcb.tcp, NULL);
0000cc  2100              MOVS     r1,#0
0000ce  6860              LDR      r0,[r4,#4]
0000d0  f7fffffe          BL       tcp_accept
                  |L4.212|
;;;775        }
;;;776        if (shut_tx) {
0000d4  f1b80f00          CMP      r8,#0
0000d8  d003              BEQ      |L4.226|
;;;777          tcp_sent(conn->pcb.tcp, NULL);
0000da  2100              MOVS     r1,#0
0000dc  6860              LDR      r0,[r4,#4]
0000de  f7fffffe          BL       tcp_sent
                  |L4.226|
;;;778        }
;;;779        if (close) {
0000e2  f1b90f00          CMP      r9,#0
0000e6  d008              BEQ      |L4.250|
;;;780          tcp_poll(conn->pcb.tcp, NULL, 4);
0000e8  2204              MOVS     r2,#4
0000ea  2100              MOVS     r1,#0
0000ec  6860              LDR      r0,[r4,#4]
0000ee  f7fffffe          BL       tcp_poll
;;;781          tcp_err(conn->pcb.tcp, NULL);
0000f2  2100              MOVS     r1,#0
0000f4  6860              LDR      r0,[r4,#4]
0000f6  f7fffffe          BL       tcp_err
                  |L4.250|
;;;782        }
;;;783      }
;;;784      /* Try to close the connection */
;;;785      if (close) {
0000fa  f1b90f00          CMP      r9,#0
0000fe  d004              BEQ      |L4.266|
;;;786        err = tcp_close(conn->pcb.tcp);
000100  6860              LDR      r0,[r4,#4]
000102  f7fffffe          BL       tcp_close
000106  4605              MOV      r5,r0
000108  e005              B        |L4.278|
                  |L4.266|
;;;787      } else {
;;;788        err = tcp_shutdown(conn->pcb.tcp, shut_rx, shut_tx);
00010a  4642              MOV      r2,r8
00010c  4639              MOV      r1,r7
00010e  6860              LDR      r0,[r4,#4]
000110  f7fffffe          BL       tcp_shutdown
000114  4605              MOV      r5,r0
                  |L4.278|
;;;789      }
;;;790      if (err == ERR_OK) {
000116  bb35              CBNZ     r5,|L4.358|
;;;791        /* Closing succeeded */
;;;792        conn->current_msg->err = ERR_OK;
000118  2000              MOVS     r0,#0
00011a  6aa1              LDR      r1,[r4,#0x28]
00011c  7108              STRB     r0,[r1,#4]
;;;793        conn->current_msg = NULL;
00011e  62a0              STR      r0,[r4,#0x28]
;;;794        conn->state = NETCONN_NONE;
000120  7060              STRB     r0,[r4,#1]
;;;795        if (close) {
000122  f1b90f00          CMP      r9,#0
000126  d007              BEQ      |L4.312|
;;;796          /* Set back some callback pointers as conn is going away */
;;;797          conn->pcb.tcp = NULL;
000128  6060              STR      r0,[r4,#4]
;;;798          /* Trigger select() in socket layer. Make sure everybody notices activity
;;;799           on the connection, error first! */
;;;800          API_EVENT(conn, NETCONN_EVT_ERROR, 0);
00012a  6ae0              LDR      r0,[r4,#0x2c]
00012c  b120              CBZ      r0,|L4.312|
00012e  2200              MOVS     r2,#0
000130  2104              MOVS     r1,#4
000132  4620              MOV      r0,r4
000134  6ae3              LDR      r3,[r4,#0x2c]
000136  4798              BLX      r3
                  |L4.312|
;;;801        }
;;;802        if (shut_rx) {
000138  b137              CBZ      r7,|L4.328|
;;;803          API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
00013a  6ae0              LDR      r0,[r4,#0x2c]
00013c  b120              CBZ      r0,|L4.328|
00013e  2200              MOVS     r2,#0
000140  4611              MOV      r1,r2
000142  4620              MOV      r0,r4
000144  6ae3              LDR      r3,[r4,#0x2c]
000146  4798              BLX      r3
                  |L4.328|
;;;804        }
;;;805        if (shut_tx) {
000148  f1b80f00          CMP      r8,#0
00014c  d006              BEQ      |L4.348|
;;;806          API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
00014e  6ae0              LDR      r0,[r4,#0x2c]
000150  b120              CBZ      r0,|L4.348|
000152  2200              MOVS     r2,#0
000154  2102              MOVS     r1,#2
000156  4620              MOV      r0,r4
000158  6ae3              LDR      r3,[r4,#0x2c]
00015a  4798              BLX      r3
                  |L4.348|
;;;807        }
;;;808        /* wake up the application task */
;;;809        sys_sem_signal(&conn->op_completed);
00015c  f104000c          ADD      r0,r4,#0xc
000160  f7fffffe          BL       sys_sem_signal
000164  e01f              B        |L4.422|
                  |L4.358|
;;;810      } else {
;;;811        /* Closing failed, restore some of the callbacks */
;;;812        /* Closing of listen pcb will never fail! */
;;;813        LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
000166  bf00              NOP      
000168  6860              LDR      r0,[r4,#4]
00016a  7e00              LDRB     r0,[r0,#0x18]
00016c  2801              CMP      r0,#1
00016e  d108              BNE      |L4.386|
000170  bf00              NOP      
000172  a30e              ADR      r3,|L4.428|
000174  f240322d          MOV      r2,#0x32d
000178  a142              ADR      r1,|L4.644|
00017a  a01a              ADR      r0,|L4.484|
00017c  f7fffffe          BL       __2printf
000180  bf00              NOP      
                  |L4.386|
000182  bf00              NOP      
;;;814        tcp_sent(conn->pcb.tcp, sent_tcp);
000184  4948              LDR      r1,|L4.680|
000186  6860              LDR      r0,[r4,#4]
000188  f7fffffe          BL       tcp_sent
;;;815        tcp_poll(conn->pcb.tcp, poll_tcp, 4);
00018c  2204              MOVS     r2,#4
00018e  4947              LDR      r1,|L4.684|
000190  6860              LDR      r0,[r4,#4]
000192  f7fffffe          BL       tcp_poll
;;;816        tcp_err(conn->pcb.tcp, err_tcp);
000196  4946              LDR      r1,|L4.688|
000198  6860              LDR      r0,[r4,#4]
00019a  f7fffffe          BL       tcp_err
;;;817        tcp_arg(conn->pcb.tcp, conn);
00019e  4621              MOV      r1,r4
0001a0  6860              LDR      r0,[r4,#4]
0001a2  f7fffffe          BL       tcp_arg
                  |L4.422|
;;;818        /* don't restore recv callback: we don't want to receive any more data */
;;;819      }
;;;820      /* If closing didn't succeed, we get called again either
;;;821         from poll_tcp or from sent_tcp */
;;;822    }
0001a6  e8bd87f0          POP      {r4-r10,pc}
;;;823    #endif /* LWIP_TCP */
                          ENDP

0001aa  0000              DCW      0x0000
                  |L4.428|
0001ac  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\api_msg.c",0
0001b0  5749505c
0001b4  6c776970
0001b8  2d312e34
0001bc  2e315c73
0001c0  72635c61
0001c4  70695c61
0001c8  70695f6d
0001cc  73672e63
0001d0  00      
0001d1  00                DCB      0
0001d2  00                DCB      0
0001d3  00                DCB      0
                  |L4.468|
0001d4  696e7661          DCB      "invalid conn",0
0001d8  6c696420
0001dc  636f6e6e
0001e0  00      
0001e1  00                DCB      0
0001e2  00                DCB      0
0001e3  00                DCB      0
                  |L4.484|
0001e4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0001e8  7274696f
0001ec  6e202225
0001f0  73222066
0001f4  61696c65
0001f8  64206174
0001fc  206c696e
000200  65202564
000204  20696e20
000208  25730d0a
00020c  00      
00020d  00                DCB      0
00020e  00                DCB      0
00020f  00                DCB      0
                  |L4.528|
000210  74686973          DCB      "this is for tcp netconns only",0
000214  20697320
000218  666f7220
00021c  74637020
000220  6e657463
000224  6f6e6e73
000228  206f6e6c
00022c  7900    
00022e  00                DCB      0
00022f  00                DCB      0
                  |L4.560|
000230  636f6e6e          DCB      "conn must be in state NETCONN_CLOSE",0
000234  206d7573
000238  74206265
00023c  20696e20
000240  73746174
000244  65204e45
000248  54434f4e
00024c  4e5f434c
000250  4f534500
                  |L4.596|
000254  70636220          DCB      "pcb already closed",0
000258  616c7265
00025c  61647920
000260  636c6f73
000264  656400  
000267  00                DCB      0
                  |L4.616|
000268  636f6e6e          DCB      "conn->current_msg != NULL",0
00026c  2d3e6375
000270  7272656e
000274  745f6d73
000278  6720213d
00027c  204e554c
000280  4c00    
000282  00                DCB      0
000283  00                DCB      0
                  |L4.644|
000284  436c6f73          DCB      "Closing a listen pcb may not fail!",0
000288  696e6720
00028c  61206c69
000290  7374656e
000294  20706362
000298  206d6179
00029c  206e6f74
0002a0  20666169
0002a4  6c2100  
0002a7  00                DCB      0
                  |L4.680|
                          DCD      sent_tcp
                  |L4.684|
                          DCD      poll_tcp
                  |L4.688|
                          DCD      err_tcp

                          AREA ||i.do_connect||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  do_connect PROC
;;;983    void
;;;984    do_connect(struct api_msg_msg *msg)
000000  b510              PUSH     {r4,lr}
;;;985    {
000002  4604              MOV      r4,r0
;;;986      if (msg->conn->pcb.tcp == NULL) {
000004  6820              LDR      r0,[r4,#0]
000006  6840              LDR      r0,[r0,#4]
000008  b910              CBNZ     r0,|L5.16|
;;;987        /* This may happen when calling netconn_connect() a second time */
;;;988        msg->err = ERR_CLSD;
00000a  20f4              MOVS     r0,#0xf4
00000c  7120              STRB     r0,[r4,#4]
00000e  e061              B        |L5.212|
                  |L5.16|
;;;989      } else {
;;;990        switch (NETCONNTYPE_GROUP(msg->conn->type)) {
000010  6820              LDR      r0,[r4,#0]
000012  7800              LDRB     r0,[r0,#0]
000014  f00000f0          AND      r0,r0,#0xf0
000018  2810              CMP      r0,#0x10
00001a  d012              BEQ      |L5.66|
00001c  2820              CMP      r0,#0x20
00001e  d008              BEQ      |L5.50|
000020  2840              CMP      r0,#0x40
000022  d146              BNE      |L5.178|
;;;991    #if LWIP_RAW
;;;992      case NETCONN_RAW:
;;;993        msg->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
000024  6822              LDR      r2,[r4,#0]
000026  68a1              LDR      r1,[r4,#8]
000028  6850              LDR      r0,[r2,#4]
00002a  f7fffffe          BL       raw_connect
00002e  7120              STRB     r0,[r4,#4]
;;;994        break;
000030  e04f              B        |L5.210|
                  |L5.50|
;;;995    #endif /* LWIP_RAW */
;;;996    #if LWIP_UDP
;;;997      case NETCONN_UDP:
;;;998        msg->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
000032  89a2              LDRH     r2,[r4,#0xc]
000034  6823              LDR      r3,[r4,#0]
000036  68a1              LDR      r1,[r4,#8]
000038  6858              LDR      r0,[r3,#4]
00003a  f7fffffe          BL       udp_connect
00003e  7120              STRB     r0,[r4,#4]
;;;999        break;
000040  e047              B        |L5.210|
                  |L5.66|
;;;1000   #endif /* LWIP_UDP */
;;;1001   #if LWIP_TCP
;;;1002     case NETCONN_TCP:
;;;1003       /* Prevent connect while doing any other action. */
;;;1004       if (msg->conn->state != NETCONN_NONE) {
000042  6820              LDR      r0,[r4,#0]
000044  7840              LDRB     r0,[r0,#1]
000046  b110              CBZ      r0,|L5.78|
;;;1005         msg->err = ERR_ISCONN;
000048  20f7              MOVS     r0,#0xf7
00004a  7120              STRB     r0,[r4,#4]
00004c  e030              B        |L5.176|
                  |L5.78|
;;;1006       } else {
;;;1007         setup_tcp(msg->conn);
00004e  6820              LDR      r0,[r4,#0]
000050  f7fffffe          BL       setup_tcp
;;;1008         msg->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr,
000054  89a2              LDRH     r2,[r4,#0xc]
000056  6823              LDR      r3,[r4,#0]
000058  68a1              LDR      r1,[r4,#8]
00005a  6858              LDR      r0,[r3,#4]
00005c  4b21              LDR      r3,|L5.228|
00005e  f7fffffe          BL       tcp_connect
000062  7120              STRB     r0,[r4,#4]
;;;1009           msg->msg.bc.port, do_connected);
;;;1010         if (msg->err == ERR_OK) {
000064  7920              LDRB     r0,[r4,#4]
000066  bb18              CBNZ     r0,|L5.176|
;;;1011           u8_t non_blocking = netconn_is_nonblocking(msg->conn);
000068  6821              LDR      r1,[r4,#0]
00006a  f8911020          LDRB     r1,[r1,#0x20]
00006e  f3c10040          UBFX     r0,r1,#1,#1
;;;1012           msg->conn->state = NETCONN_CONNECT;
000072  2103              MOVS     r1,#3
000074  6822              LDR      r2,[r4,#0]
000076  7051              STRB     r1,[r2,#1]
;;;1013           SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
000078  bf00              NOP      
00007a  b140              CBZ      r0,|L5.142|
00007c  6821              LDR      r1,[r4,#0]
00007e  f8911020          LDRB     r1,[r1,#0x20]
000082  f0410104          ORR      r1,r1,#4
000086  6822              LDR      r2,[r4,#0]
000088  f8821020          STRB     r1,[r2,#0x20]
00008c  e007              B        |L5.158|
                  |L5.142|
00008e  6821              LDR      r1,[r4,#0]
000090  f8911020          LDRB     r1,[r1,#0x20]
000094  f0210104          BIC      r1,r1,#4
000098  6822              LDR      r2,[r4,#0]
00009a  f8821020          STRB     r1,[r2,#0x20]
                  |L5.158|
00009e  bf00              NOP      
;;;1014           if (non_blocking) {
0000a0  b110              CBZ      r0,|L5.168|
;;;1015             msg->err = ERR_INPROGRESS;
0000a2  21fb              MOVS     r1,#0xfb
0000a4  7121              STRB     r1,[r4,#4]
0000a6  e002              B        |L5.174|
                  |L5.168|
;;;1016           } else {
;;;1017             msg->conn->current_msg = msg;
0000a8  6821              LDR      r1,[r4,#0]
0000aa  628c              STR      r4,[r1,#0x28]
                  |L5.172|
;;;1018             /* sys_sem_signal() is called from do_connected (or err_tcp()),
;;;1019             * when the connection is established! */
;;;1020             return;
;;;1021           }
;;;1022         }
;;;1023       }
;;;1024       break;
;;;1025   #endif /* LWIP_TCP */
;;;1026     default:
;;;1027       LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
;;;1028       break;
;;;1029       }
;;;1030     }
;;;1031     sys_sem_signal(&msg->conn->op_completed);
;;;1032   }
0000ac  bd10              POP      {r4,pc}
                  |L5.174|
0000ae  bf00              NOP                            ;1022
                  |L5.176|
0000b0  e00f              B        |L5.210|
                  |L5.178|
0000b2  bf00              NOP                            ;1027
0000b4  bf00              NOP                            ;1027
0000b6  a30c              ADR      r3,|L5.232|
0000b8  f2404203          MOV      r2,#0x403             ;1027
0000bc  a114              ADR      r1,|L5.272|
0000be  a01a              ADR      r0,|L5.296|
0000c0  f7fffffe          BL       __2printf
0000c4  bf00              NOP                            ;1027
0000c6  bf00              NOP                            ;1027
0000c8  20fa              MOVS     r0,#0xfa              ;1027
0000ca  7120              STRB     r0,[r4,#4]            ;1027
0000cc  bf00              NOP                            ;1027
0000ce  bf00              NOP                            ;1027
0000d0  bf00              NOP                            ;1028
                  |L5.210|
0000d2  bf00              NOP                            ;994
                  |L5.212|
0000d4  6821              LDR      r1,[r4,#0]            ;1031
0000d6  f101000c          ADD      r0,r1,#0xc            ;1031
0000da  f7fffffe          BL       sys_sem_signal
0000de  bf00              NOP      
0000e0  e7e4              B        |L5.172|
;;;1033   
                          ENDP

0000e2  0000              DCW      0x0000
                  |L5.228|
                          DCD      do_connected
                  |L5.232|
0000e8  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\api_msg.c",0
0000ec  5749505c
0000f0  6c776970
0000f4  2d312e34
0000f8  2e315c73
0000fc  72635c61
000100  70695c61
000104  70695f6d
000108  73672e63
00010c  00      
00010d  00                DCB      0
00010e  00                DCB      0
00010f  00                DCB      0
                  |L5.272|
000110  496e7661          DCB      "Invalid netconn type",0
000114  6c696420
000118  6e657463
00011c  6f6e6e20
000120  74797065
000124  00      
000125  00                DCB      0
000126  00                DCB      0
000127  00                DCB      0
                  |L5.296|
000128  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
00012c  7274696f
000130  6e202225
000134  73222066
000138  61696c65
00013c  64206174
000140  206c696e
000144  65202564
000148  20696e20
00014c  25730d0a
000150  00      
000151  00                DCB      0
000152  00                DCB      0
000153  00                DCB      0

                          AREA ||i.do_connected||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  do_connected PROC
;;;936    static err_t
;;;937    do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;938    {
000004  4605              MOV      r5,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
;;;939      struct netconn *conn;
;;;940      int was_blocking;
;;;941    
;;;942      LWIP_UNUSED_ARG(pcb);
;;;943    
;;;944      conn = (struct netconn *)arg;
00000a  462c              MOV      r4,r5
;;;945    
;;;946      if (conn == NULL) {
00000c  b91c              CBNZ     r4,|L6.22|
;;;947        return ERR_VAL;
00000e  f06f0005          MVN      r0,#5
                  |L6.18|
;;;948      }
;;;949    
;;;950      LWIP_ASSERT("conn->state == NETCONN_CONNECT", conn->state == NETCONN_CONNECT);
;;;951      LWIP_ASSERT("(conn->current_msg != NULL) || conn->in_non_blocking_connect",
;;;952        (conn->current_msg != NULL) || IN_NONBLOCKING_CONNECT(conn));
;;;953    
;;;954      if (conn->current_msg != NULL) {
;;;955        conn->current_msg->err = err;
;;;956      }
;;;957      if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
;;;958        setup_tcp(conn);
;;;959      }
;;;960      was_blocking = !IN_NONBLOCKING_CONNECT(conn);
;;;961      SET_NONBLOCKING_CONNECT(conn, 0);
;;;962      conn->current_msg = NULL;
;;;963      conn->state = NETCONN_NONE;
;;;964      if (!was_blocking) {
;;;965        NETCONN_SET_SAFE_ERR(conn, ERR_OK);
;;;966      }
;;;967      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
;;;968    
;;;969      if (was_blocking) {
;;;970        sys_sem_signal(&conn->op_completed);
;;;971      }
;;;972      return ERR_OK;
;;;973    }
000012  e8bd87f0          POP      {r4-r10,pc}
                  |L6.22|
000016  bf00              NOP                            ;950
000018  7860              LDRB     r0,[r4,#1]            ;950
00001a  2803              CMP      r0,#3                 ;950
00001c  d008              BEQ      |L6.48|
00001e  bf00              NOP                            ;950
000020  a32a              ADR      r3,|L6.204|
000022  f24032b6          MOV      r2,#0x3b6             ;950
000026  a133              ADR      r1,|L6.244|
000028  a03a              ADR      r0,|L6.276|
00002a  f7fffffe          BL       __2printf
00002e  bf00              NOP                            ;950
                  |L6.48|
000030  bf00              NOP                            ;950
000032  bf00              NOP                            ;951
000034  6aa0              LDR      r0,[r4,#0x28]         ;951
000036  2800              CMP      r0,#0                 ;951
000038  d10e              BNE      |L6.88|
00003a  f8940020          LDRB     r0,[r4,#0x20]         ;951
00003e  f0000004          AND      r0,r0,#4              ;951
000042  2800              CMP      r0,#0                 ;951
000044  d108              BNE      |L6.88|
000046  bf00              NOP                            ;951
000048  a320              ADR      r3,|L6.204|
00004a  f24032b7          MOV      r2,#0x3b7             ;951
00004e  a13c              ADR      r1,|L6.320|
000050  a030              ADR      r0,|L6.276|
000052  f7fffffe          BL       __2printf
000056  bf00              NOP                            ;951
                  |L6.88|
000058  bf00              NOP                            ;951
00005a  6aa0              LDR      r0,[r4,#0x28]         ;954
00005c  b108              CBZ      r0,|L6.98|
00005e  6aa0              LDR      r0,[r4,#0x28]         ;955
000060  7106              STRB     r6,[r0,#4]            ;955
                  |L6.98|
000062  7820              LDRB     r0,[r4,#0]            ;957
000064  2810              CMP      r0,#0x10              ;957
000066  d103              BNE      |L6.112|
000068  b916              CBNZ     r6,|L6.112|
00006a  4620              MOV      r0,r4                 ;958
00006c  f7fffffe          BL       setup_tcp
                  |L6.112|
000070  f8940020          LDRB     r0,[r4,#0x20]         ;960
000074  2101              MOVS     r1,#1                 ;960
000076  ea210790          BIC      r7,r1,r0,LSR #2       ;960
00007a  bf00              NOP                            ;961
00007c  f8940020          LDRB     r0,[r4,#0x20]         ;961
000080  f0200004          BIC      r0,r0,#4              ;961
000084  f8840020          STRB     r0,[r4,#0x20]         ;961
000088  bf00              NOP                            ;961
00008a  2000              MOVS     r0,#0                 ;962
00008c  62a0              STR      r0,[r4,#0x28]         ;962
00008e  7060              STRB     r0,[r4,#1]            ;963
000090  b977              CBNZ     r7,|L6.176|
000092  bf00              NOP                            ;965
000094  f7fffffe          BL       sys_arch_protect
000098  4680              MOV      r8,r0                 ;965
00009a  f9940008          LDRSB    r0,[r4,#8]            ;965
00009e  f1100f09          CMN      r0,#9                 ;965
0000a2  db01              BLT      |L6.168|
0000a4  2000              MOVS     r0,#0                 ;965
0000a6  7220              STRB     r0,[r4,#8]            ;965
                  |L6.168|
0000a8  4640              MOV      r0,r8                 ;965
0000aa  f7fffffe          BL       sys_arch_unprotect
0000ae  bf00              NOP                            ;965
                  |L6.176|
0000b0  6ae0              LDR      r0,[r4,#0x2c]         ;967
0000b2  b120              CBZ      r0,|L6.190|
0000b4  2200              MOVS     r2,#0                 ;967
0000b6  2102              MOVS     r1,#2                 ;967
0000b8  4620              MOV      r0,r4                 ;967
0000ba  6ae3              LDR      r3,[r4,#0x2c]         ;967
0000bc  4798              BLX      r3                    ;967
                  |L6.190|
0000be  b11f              CBZ      r7,|L6.200|
0000c0  f104000c          ADD      r0,r4,#0xc            ;970
0000c4  f7fffffe          BL       sys_sem_signal
                  |L6.200|
0000c8  2000              MOVS     r0,#0                 ;972
0000ca  e7a2              B        |L6.18|
;;;974    #endif /* LWIP_TCP */
                          ENDP

                  |L6.204|
0000cc  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\api_msg.c",0
0000d0  5749505c
0000d4  6c776970
0000d8  2d312e34
0000dc  2e315c73
0000e0  72635c61
0000e4  70695c61
0000e8  70695f6d
0000ec  73672e63
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L6.244|
0000f4  636f6e6e          DCB      "conn->state == NETCONN_CONNECT",0
0000f8  2d3e7374
0000fc  61746520
000100  3d3d204e
000104  4554434f
000108  4e4e5f43
00010c  4f4e4e45
000110  435400  
000113  00                DCB      0
                  |L6.276|
000114  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000118  7274696f
00011c  6e202225
000120  73222066
000124  61696c65
000128  64206174
00012c  206c696e
000130  65202564
000134  20696e20
000138  25730d0a
00013c  00      
00013d  00                DCB      0
00013e  00                DCB      0
00013f  00                DCB      0
                  |L6.320|
000140  28636f6e          DCB      "(conn->current_msg != NULL) || conn->in_non_blocking_co"
000144  6e2d3e63
000148  75727265
00014c  6e745f6d
000150  73672021
000154  3d204e55
000158  4c4c2920
00015c  7c7c2063
000160  6f6e6e2d
000164  3e696e5f
000168  6e6f6e5f
00016c  626c6f63
000170  6b696e67
000174  5f636f  
000177  6e6e6563          DCB      "nnect",0
00017b  7400    
00017d  00                DCB      0
00017e  00                DCB      0
00017f  00                DCB      0

                          AREA ||i.do_delconn||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  do_delconn PROC
;;;831    void
;;;832    do_delconn(struct api_msg_msg *msg)
000000  b510              PUSH     {r4,lr}
;;;833    {
000002  4604              MOV      r4,r0
;;;834      /* @todo TCP: abort running write/connect? */
;;;835     if ((msg->conn->state != NETCONN_NONE) &&
000004  6820              LDR      r0,[r4,#0]
000006  7840              LDRB     r0,[r0,#1]
000008  2800              CMP      r0,#0
00000a  d019              BEQ      |L7.64|
;;;836         (msg->conn->state != NETCONN_LISTEN) &&
00000c  6820              LDR      r0,[r4,#0]
00000e  7840              LDRB     r0,[r0,#1]
000010  2802              CMP      r0,#2
000012  d015              BEQ      |L7.64|
;;;837         (msg->conn->state != NETCONN_CONNECT)) {
000014  6820              LDR      r0,[r4,#0]
000016  7840              LDRB     r0,[r0,#1]
000018  2803              CMP      r0,#3
00001a  d011              BEQ      |L7.64|
;;;838        /* this only happens for TCP netconns */
;;;839        LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
00001c  bf00              NOP      
00001e  6820              LDR      r0,[r4,#0]
000020  7800              LDRB     r0,[r0,#0]
000022  2810              CMP      r0,#0x10
000024  d008              BEQ      |L7.56|
000026  bf00              NOP      
000028  a33e              ADR      r3,|L7.292|
00002a  f2403247          MOV      r2,#0x347
00002e  a147              ADR      r1,|L7.332|
000030  a04e              ADR      r0,|L7.364|
000032  f7fffffe          BL       __2printf
000036  bf00              NOP      
                  |L7.56|
000038  bf00              NOP      
;;;840        msg->err = ERR_INPROGRESS;
00003a  20fb              MOVS     r0,#0xfb
00003c  7120              STRB     r0,[r4,#4]
00003e  e064              B        |L7.266|
                  |L7.64|
;;;841      } else {
;;;842        LWIP_ASSERT("blocking connect in progress",
000040  bf00              NOP      
000042  6820              LDR      r0,[r4,#0]
000044  7840              LDRB     r0,[r0,#1]
000046  2803              CMP      r0,#3
000048  d10e              BNE      |L7.104|
00004a  6820              LDR      r0,[r4,#0]
00004c  f8900020          LDRB     r0,[r0,#0x20]
000050  f0000004          AND      r0,r0,#4
000054  b940              CBNZ     r0,|L7.104|
000056  bf00              NOP      
000058  a332              ADR      r3,|L7.292|
00005a  f240324a          MOV      r2,#0x34a
00005e  a14e              ADR      r1,|L7.408|
000060  a042              ADR      r0,|L7.364|
000062  f7fffffe          BL       __2printf
000066  bf00              NOP      
                  |L7.104|
000068  bf00              NOP      
;;;843          (msg->conn->state != NETCONN_CONNECT) || IN_NONBLOCKING_CONNECT(msg->conn));
;;;844        /* Drain and delete mboxes */
;;;845        netconn_drain(msg->conn);
00006a  6820              LDR      r0,[r4,#0]
00006c  f7fffffe          BL       netconn_drain
;;;846    
;;;847        if (msg->conn->pcb.tcp != NULL) {
000070  6820              LDR      r0,[r4,#0]
000072  6840              LDR      r0,[r0,#4]
000074  2800              CMP      r0,#0
000076  d038              BEQ      |L7.234|
;;;848    
;;;849          switch (NETCONNTYPE_GROUP(msg->conn->type)) {
000078  6820              LDR      r0,[r4,#0]
00007a  7800              LDRB     r0,[r0,#0]
00007c  f00000f0          AND      r0,r0,#0xf0
000080  2810              CMP      r0,#0x10
000082  d011              BEQ      |L7.168|
000084  2820              CMP      r0,#0x20
000086  d006              BEQ      |L7.150|
000088  2840              CMP      r0,#0x40
00008a  d129              BNE      |L7.224|
;;;850    #if LWIP_RAW
;;;851          case NETCONN_RAW:
;;;852            raw_remove(msg->conn->pcb.raw);
00008c  6821              LDR      r1,[r4,#0]
00008e  6848              LDR      r0,[r1,#4]
000090  f7fffffe          BL       raw_remove
;;;853            break;
000094  e025              B        |L7.226|
                  |L7.150|
;;;854    #endif /* LWIP_RAW */
;;;855    #if LWIP_UDP
;;;856          case NETCONN_UDP:
;;;857            msg->conn->pcb.udp->recv_arg = NULL;
000096  2000              MOVS     r0,#0
000098  6821              LDR      r1,[r4,#0]
00009a  6849              LDR      r1,[r1,#4]
00009c  61c8              STR      r0,[r1,#0x1c]
;;;858            udp_remove(msg->conn->pcb.udp);
00009e  6821              LDR      r1,[r4,#0]
0000a0  6848              LDR      r0,[r1,#4]
0000a2  f7fffffe          BL       udp_remove
;;;859            break;
0000a6  e01c              B        |L7.226|
                  |L7.168|
;;;860    #endif /* LWIP_UDP */
;;;861    #if LWIP_TCP
;;;862          case NETCONN_TCP:
;;;863            LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
0000a8  bf00              NOP      
0000aa  6820              LDR      r0,[r4,#0]
0000ac  6a80              LDR      r0,[r0,#0x28]
0000ae  b910              CBNZ     r0,|L7.182|
0000b0  6820              LDR      r0,[r4,#0]
0000b2  6a40              LDR      r0,[r0,#0x24]
0000b4  b140              CBZ      r0,|L7.200|
                  |L7.182|
0000b6  bf00              NOP      
0000b8  a31a              ADR      r3,|L7.292|
0000ba  f240325f          MOV      r2,#0x35f
0000be  a13e              ADR      r1,|L7.440|
0000c0  a02a              ADR      r0,|L7.364|
0000c2  f7fffffe          BL       __2printf
0000c6  bf00              NOP      
                  |L7.200|
0000c8  bf00              NOP      
;;;864              msg->conn->write_offset == 0);
;;;865            msg->conn->state = NETCONN_CLOSE;
0000ca  2004              MOVS     r0,#4
0000cc  6821              LDR      r1,[r4,#0]
0000ce  7048              STRB     r0,[r1,#1]
;;;866            msg->msg.sd.shut = NETCONN_SHUT_RDWR;
0000d0  2003              MOVS     r0,#3
0000d2  7220              STRB     r0,[r4,#8]
;;;867            msg->conn->current_msg = msg;
0000d4  6820              LDR      r0,[r4,#0]
0000d6  6284              STR      r4,[r0,#0x28]
;;;868            do_close_internal(msg->conn);
0000d8  6820              LDR      r0,[r4,#0]
0000da  f7fffffe          BL       do_close_internal
                  |L7.222|
;;;869            /* API_EVENT is called inside do_close_internal, before releasing
;;;870               the application thread, so we can return at this point! */
;;;871            return;
;;;872    #endif /* LWIP_TCP */
;;;873          default:
;;;874            break;
;;;875          }
;;;876          msg->conn->pcb.tcp = NULL;
;;;877        }
;;;878        /* tcp netconns don't come here! */
;;;879    
;;;880        /* @todo: this lets select make the socket readable and writable,
;;;881           which is wrong! errfd instead? */
;;;882        API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
;;;883        API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
;;;884      }
;;;885      if (sys_sem_valid(&msg->conn->op_completed)) {
;;;886        sys_sem_signal(&msg->conn->op_completed);
;;;887      }
;;;888    }
0000de  bd10              POP      {r4,pc}
                  |L7.224|
0000e0  bf00              NOP                            ;874
                  |L7.226|
0000e2  bf00              NOP                            ;853
0000e4  2000              MOVS     r0,#0                 ;876
0000e6  6821              LDR      r1,[r4,#0]            ;876
0000e8  6048              STR      r0,[r1,#4]            ;876
                  |L7.234|
0000ea  6820              LDR      r0,[r4,#0]            ;882
0000ec  6ac0              LDR      r0,[r0,#0x2c]         ;882
0000ee  b120              CBZ      r0,|L7.250|
0000f0  6820              LDR      r0,[r4,#0]            ;882
0000f2  2200              MOVS     r2,#0                 ;882
0000f4  4611              MOV      r1,r2                 ;882
0000f6  6ac3              LDR      r3,[r0,#0x2c]         ;882
0000f8  4798              BLX      r3                    ;882
                  |L7.250|
0000fa  6820              LDR      r0,[r4,#0]            ;883
0000fc  6ac0              LDR      r0,[r0,#0x2c]         ;883
0000fe  b120              CBZ      r0,|L7.266|
000100  6820              LDR      r0,[r4,#0]            ;883
000102  2200              MOVS     r2,#0                 ;883
000104  2102              MOVS     r1,#2                 ;883
000106  6ac3              LDR      r3,[r0,#0x2c]         ;883
000108  4798              BLX      r3                    ;883
                  |L7.266|
00010a  6821              LDR      r1,[r4,#0]            ;885
00010c  f101000c          ADD      r0,r1,#0xc            ;885
000110  f7fffffe          BL       sys_sem_valid
000114  b120              CBZ      r0,|L7.288|
000116  6821              LDR      r1,[r4,#0]            ;886
000118  f101000c          ADD      r0,r1,#0xc            ;886
00011c  f7fffffe          BL       sys_sem_signal
                  |L7.288|
000120  bf00              NOP      
000122  e7dc              B        |L7.222|
;;;889    
                          ENDP

                  |L7.292|
000124  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\api_msg.c",0
000128  5749505c
00012c  6c776970
000130  2d312e34
000134  2e315c73
000138  72635c61
00013c  70695c61
000140  70695f6d
000144  73672e63
000148  00      
000149  00                DCB      0
00014a  00                DCB      0
00014b  00                DCB      0
                  |L7.332|
00014c  6d73672d          DCB      "msg->conn->type == NETCONN_TCP",0
000150  3e636f6e
000154  6e2d3e74
000158  79706520
00015c  3d3d204e
000160  4554434f
000164  4e4e5f54
000168  435000  
00016b  00                DCB      0
                  |L7.364|
00016c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000170  7274696f
000174  6e202225
000178  73222066
00017c  61696c65
000180  64206174
000184  206c696e
000188  65202564
00018c  20696e20
000190  25730d0a
000194  00      
000195  00                DCB      0
000196  00                DCB      0
000197  00                DCB      0
                  |L7.408|
000198  626c6f63          DCB      "blocking connect in progress",0
00019c  6b696e67
0001a0  20636f6e
0001a4  6e656374
0001a8  20696e20
0001ac  70726f67
0001b0  72657373
0001b4  00      
0001b5  00                DCB      0
0001b6  00                DCB      0
0001b7  00                DCB      0
                  |L7.440|
0001b8  616c7265          DCB      "already writing or closing",0
0001bc  61647920
0001c0  77726974
0001c4  696e6720
0001c8  6f722063
0001cc  6c6f7369
0001d0  6e6700  
0001d3  00                DCB      0

                          AREA ||i.do_disconnect||, CODE, READONLY, ALIGN=1

                  do_disconnect PROC
;;;1041   void
;;;1042   do_disconnect(struct api_msg_msg *msg)
000000  b510              PUSH     {r4,lr}
;;;1043   {
000002  4604              MOV      r4,r0
;;;1044   #if LWIP_UDP
;;;1045     if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
000004  6820              LDR      r0,[r4,#0]
000006  7800              LDRB     r0,[r0,#0]
000008  f00000f0          AND      r0,r0,#0xf0
00000c  2820              CMP      r0,#0x20
00000e  d106              BNE      |L8.30|
;;;1046       udp_disconnect(msg->conn->pcb.udp);
000010  6821              LDR      r1,[r4,#0]
000012  6848              LDR      r0,[r1,#4]
000014  f7fffffe          BL       udp_disconnect
;;;1047       msg->err = ERR_OK;
000018  2000              MOVS     r0,#0
00001a  7120              STRB     r0,[r4,#4]
00001c  e001              B        |L8.34|
                  |L8.30|
;;;1048     } else
;;;1049   #endif /* LWIP_UDP */
;;;1050     {
;;;1051       msg->err = ERR_VAL;
00001e  20fa              MOVS     r0,#0xfa
000020  7120              STRB     r0,[r4,#4]
                  |L8.34|
;;;1052     }
;;;1053     TCPIP_APIMSG_ACK(msg);
000022  6821              LDR      r1,[r4,#0]
000024  f101000c          ADD      r0,r1,#0xc
000028  f7fffffe          BL       sys_sem_signal
;;;1054   }
00002c  bd10              POP      {r4,pc}
;;;1055   
                          ENDP


                          AREA ||i.do_getaddr||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  do_getaddr PROC
;;;1397   void
;;;1398   do_getaddr(struct api_msg_msg *msg)
000000  b510              PUSH     {r4,lr}
;;;1399   {
000002  4604              MOV      r4,r0
;;;1400     if (msg->conn->pcb.ip != NULL) {
000004  6820              LDR      r0,[r4,#0]
000006  6840              LDR      r0,[r0,#4]
000008  2800              CMP      r0,#0
00000a  d053              BEQ      |L9.180|
;;;1401       *(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip :
00000c  7c20              LDRB     r0,[r4,#0x10]
00000e  b128              CBZ      r0,|L9.28|
000010  6821              LDR      r1,[r4,#0]
000012  68a0              LDR      r0,[r4,#8]
000014  6849              LDR      r1,[r1,#4]
000016  6809              LDR      r1,[r1,#0]
000018  6001              STR      r1,[r0,#0]
00001a  e004              B        |L9.38|
                  |L9.28|
00001c  6821              LDR      r1,[r4,#0]
00001e  68a0              LDR      r0,[r4,#8]
000020  6849              LDR      r1,[r1,#4]
000022  6849              LDR      r1,[r1,#4]
000024  6001              STR      r1,[r0,#0]
                  |L9.38|
;;;1402                                msg->conn->pcb.ip->remote_ip);
;;;1403   
;;;1404       msg->err = ERR_OK;
000026  2000              MOVS     r0,#0
000028  7120              STRB     r0,[r4,#4]
;;;1405       switch (NETCONNTYPE_GROUP(msg->conn->type)) {
00002a  6820              LDR      r0,[r4,#0]
00002c  7800              LDRB     r0,[r0,#0]
00002e  f00000f0          AND      r0,r0,#0xf0
000032  2810              CMP      r0,#0x10
000034  d025              BEQ      |L9.130|
000036  2820              CMP      r0,#0x20
000038  d00c              BEQ      |L9.84|
00003a  2840              CMP      r0,#0x40
00003c  d12d              BNE      |L9.154|
;;;1406   #if LWIP_RAW
;;;1407       case NETCONN_RAW:
;;;1408         if (msg->msg.ad.local) {
00003e  7c20              LDRB     r0,[r4,#0x10]
000040  b128              CBZ      r0,|L9.78|
;;;1409           *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
000042  6820              LDR      r0,[r4,#0]
000044  6840              LDR      r0,[r0,#4]
000046  7c01              LDRB     r1,[r0,#0x10]
000048  68e0              LDR      r0,[r4,#0xc]
00004a  8001              STRH     r1,[r0,#0]
00004c  e001              B        |L9.82|
                  |L9.78|
;;;1410         } else {
;;;1411           /* return an error as connecting is only a helper for upper layers */
;;;1412           msg->err = ERR_CONN;
00004e  20f3              MOVS     r0,#0xf3
000050  7120              STRB     r0,[r4,#4]
                  |L9.82|
;;;1413         }
;;;1414         break;
000052  e02e              B        |L9.178|
                  |L9.84|
;;;1415   #endif /* LWIP_RAW */
;;;1416   #if LWIP_UDP
;;;1417       case NETCONN_UDP:
;;;1418         if (msg->msg.ad.local) {
000054  7c20              LDRB     r0,[r4,#0x10]
000056  b128              CBZ      r0,|L9.100|
;;;1419           *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
000058  6820              LDR      r0,[r4,#0]
00005a  6840              LDR      r0,[r0,#4]
00005c  8a41              LDRH     r1,[r0,#0x12]
00005e  68e0              LDR      r0,[r4,#0xc]
000060  8001              STRH     r1,[r0,#0]
000062  e00d              B        |L9.128|
                  |L9.100|
;;;1420         } else {
;;;1421           if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
000064  6820              LDR      r0,[r4,#0]
000066  6840              LDR      r0,[r0,#4]
000068  7c00              LDRB     r0,[r0,#0x10]
00006a  f0000004          AND      r0,r0,#4
00006e  b910              CBNZ     r0,|L9.118|
;;;1422             msg->err = ERR_CONN;
000070  20f3              MOVS     r0,#0xf3
000072  7120              STRB     r0,[r4,#4]
000074  e004              B        |L9.128|
                  |L9.118|
;;;1423           } else {
;;;1424             *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
000076  6820              LDR      r0,[r4,#0]
000078  6840              LDR      r0,[r0,#4]
00007a  8a81              LDRH     r1,[r0,#0x14]
00007c  68e0              LDR      r0,[r4,#0xc]
00007e  8001              STRH     r1,[r0,#0]
                  |L9.128|
;;;1425           }
;;;1426         }
;;;1427         break;
000080  e017              B        |L9.178|
                  |L9.130|
;;;1428   #endif /* LWIP_UDP */
;;;1429   #if LWIP_TCP
;;;1430       case NETCONN_TCP:
;;;1431         *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
000082  7c20              LDRB     r0,[r4,#0x10]
000084  b118              CBZ      r0,|L9.142|
000086  6820              LDR      r0,[r4,#0]
000088  6840              LDR      r0,[r0,#4]
00008a  8b40              LDRH     r0,[r0,#0x1a]
00008c  e002              B        |L9.148|
                  |L9.142|
00008e  6820              LDR      r0,[r4,#0]
000090  6840              LDR      r0,[r0,#4]
000092  8b80              LDRH     r0,[r0,#0x1c]
                  |L9.148|
000094  68e1              LDR      r1,[r4,#0xc]
000096  8008              STRH     r0,[r1,#0]
;;;1432         break;
000098  e00b              B        |L9.178|
                  |L9.154|
;;;1433   #endif /* LWIP_TCP */
;;;1434       default:
;;;1435         LWIP_ASSERT("invalid netconn_type", 0);
00009a  bf00              NOP      
00009c  bf00              NOP      
00009e  a309              ADR      r3,|L9.196|
0000a0  f240529b          MOV      r2,#0x59b
0000a4  a111              ADR      r1,|L9.236|
0000a6  a017              ADR      r0,|L9.260|
0000a8  f7fffffe          BL       __2printf
0000ac  bf00              NOP      
0000ae  bf00              NOP      
;;;1436         break;
0000b0  bf00              NOP      
                  |L9.178|
0000b2  e001              B        |L9.184|
                  |L9.180|
;;;1437       }
;;;1438     } else {
;;;1439       msg->err = ERR_CONN;
0000b4  20f3              MOVS     r0,#0xf3
0000b6  7120              STRB     r0,[r4,#4]
                  |L9.184|
;;;1440     }
;;;1441     TCPIP_APIMSG_ACK(msg);
0000b8  6821              LDR      r1,[r4,#0]
0000ba  f101000c          ADD      r0,r1,#0xc
0000be  f7fffffe          BL       sys_sem_signal
;;;1442   }
0000c2  bd10              POP      {r4,pc}
;;;1443   
                          ENDP

                  |L9.196|
0000c4  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\api_msg.c",0
0000c8  5749505c
0000cc  6c776970
0000d0  2d312e34
0000d4  2e315c73
0000d8  72635c61
0000dc  70695c61
0000e0  70695f6d
0000e4  73672e63
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L9.236|
0000ec  696e7661          DCB      "invalid netconn_type",0
0000f0  6c696420
0000f4  6e657463
0000f8  6f6e6e5f
0000fc  74797065
000100  00      
000101  00                DCB      0
000102  00                DCB      0
000103  00                DCB      0
                  |L9.260|
000104  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000108  7274696f
00010c  6e202225
000110  73222066
000114  61696c65
000118  64206174
00011c  206c696e
000120  65202564
000124  20696e20
000128  25730d0a
00012c  00      
00012d  00                DCB      0
00012e  00                DCB      0
00012f  00                DCB      0

                          AREA ||i.do_listen||, CODE, READONLY, ALIGN=2

                  do_listen PROC
;;;1063   void
;;;1064   do_listen(struct api_msg_msg *msg)
000000  b570              PUSH     {r4-r6,lr}
;;;1065   {
000002  4604              MOV      r4,r0
;;;1066     if (ERR_IS_FATAL(msg->conn->last_err)) {
000004  6820              LDR      r0,[r4,#0]
000006  f9900008          LDRSB    r0,[r0,#8]
00000a  f1100f09          CMN      r0,#9
00000e  da03              BGE      |L10.24|
;;;1067       msg->err = msg->conn->last_err;
000010  6820              LDR      r0,[r4,#0]
000012  7a00              LDRB     r0,[r0,#8]
000014  7120              STRB     r0,[r4,#4]
000016  e050              B        |L10.186|
                  |L10.24|
;;;1068     } else {
;;;1069       msg->err = ERR_CONN;
000018  20f3              MOVS     r0,#0xf3
00001a  7120              STRB     r0,[r4,#4]
;;;1070       if (msg->conn->pcb.tcp != NULL) {
00001c  6820              LDR      r0,[r4,#0]
00001e  6840              LDR      r0,[r0,#4]
000020  2800              CMP      r0,#0
000022  d04a              BEQ      |L10.186|
;;;1071         if (msg->conn->type == NETCONN_TCP) {
000024  6820              LDR      r0,[r4,#0]
000026  7800              LDRB     r0,[r0,#0]
000028  2810              CMP      r0,#0x10
00002a  d144              BNE      |L10.182|
;;;1072           if (msg->conn->state == NETCONN_NONE) {
00002c  6820              LDR      r0,[r4,#0]
00002e  7840              LDRB     r0,[r0,#1]
000030  2800              CMP      r0,#0
000032  d142              BNE      |L10.186|
;;;1073   #if TCP_LISTEN_BACKLOG
;;;1074             struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
;;;1075   #else  /* TCP_LISTEN_BACKLOG */
;;;1076             struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
000034  6821              LDR      r1,[r4,#0]
000036  6848              LDR      r0,[r1,#4]
000038  21ff              MOVS     r1,#0xff
00003a  f7fffffe          BL       tcp_listen_with_backlog
00003e  4605              MOV      r5,r0
;;;1077   #endif /* TCP_LISTEN_BACKLOG */
;;;1078             if (lpcb == NULL) {
000040  b915              CBNZ     r5,|L10.72|
;;;1079               /* in this case, the old pcb is still allocated */
;;;1080               msg->err = ERR_MEM;
000042  20ff              MOVS     r0,#0xff
000044  7120              STRB     r0,[r4,#4]
000046  e035              B        |L10.180|
                  |L10.72|
;;;1081             } else {
;;;1082               /* delete the recvmbox and allocate the acceptmbox */
;;;1083               if (sys_mbox_valid(&msg->conn->recvmbox)) {
000048  6821              LDR      r1,[r4,#0]
00004a  f1010010          ADD      r0,r1,#0x10
00004e  f7fffffe          BL       sys_mbox_valid
000052  b148              CBZ      r0,|L10.104|
;;;1084                 /** @todo: should we drain the recvmbox here? */
;;;1085                 sys_mbox_free(&msg->conn->recvmbox);
000054  6821              LDR      r1,[r4,#0]
000056  f1010010          ADD      r0,r1,#0x10
00005a  f7fffffe          BL       sys_mbox_free
;;;1086                 sys_mbox_set_invalid(&msg->conn->recvmbox);
00005e  6821              LDR      r1,[r4,#0]
000060  f1010010          ADD      r0,r1,#0x10
000064  f7fffffe          BL       sys_mbox_set_invalid
                  |L10.104|
;;;1087               }
;;;1088               msg->err = ERR_OK;
000068  2000              MOVS     r0,#0
00006a  7120              STRB     r0,[r4,#4]
;;;1089               if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
00006c  6821              LDR      r1,[r4,#0]
00006e  f1010014          ADD      r0,r1,#0x14
000072  f7fffffe          BL       sys_mbox_valid
000076  b930              CBNZ     r0,|L10.134|
;;;1090                 msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
000078  6821              LDR      r1,[r4,#0]
00007a  f1010014          ADD      r0,r1,#0x14
00007e  2114              MOVS     r1,#0x14
000080  f7fffffe          BL       sys_mbox_new
000084  7120              STRB     r0,[r4,#4]
                  |L10.134|
;;;1091               }
;;;1092               if (msg->err == ERR_OK) {
000086  7920              LDRB     r0,[r4,#4]
000088  b970              CBNZ     r0,|L10.168|
;;;1093                 msg->conn->state = NETCONN_LISTEN;
00008a  2002              MOVS     r0,#2
00008c  6821              LDR      r1,[r4,#0]
00008e  7048              STRB     r0,[r1,#1]
;;;1094                 msg->conn->pcb.tcp = lpcb;
000090  6820              LDR      r0,[r4,#0]
000092  6045              STR      r5,[r0,#4]
;;;1095                 tcp_arg(msg->conn->pcb.tcp, msg->conn);
000094  6821              LDR      r1,[r4,#0]
000096  6848              LDR      r0,[r1,#4]
000098  f7fffffe          BL       tcp_arg
;;;1096                 tcp_accept(msg->conn->pcb.tcp, accept_function);
00009c  6821              LDR      r1,[r4,#0]
00009e  6848              LDR      r0,[r1,#4]
0000a0  4909              LDR      r1,|L10.200|
0000a2  f7fffffe          BL       tcp_accept
0000a6  e005              B        |L10.180|
                  |L10.168|
;;;1097               } else {
;;;1098                 /* since the old pcb is already deallocated, free lpcb now */
;;;1099                 tcp_close(lpcb);
0000a8  4628              MOV      r0,r5
0000aa  f7fffffe          BL       tcp_close
;;;1100                 msg->conn->pcb.tcp = NULL;
0000ae  2000              MOVS     r0,#0
0000b0  6821              LDR      r1,[r4,#0]
0000b2  6048              STR      r0,[r1,#4]
                  |L10.180|
;;;1101               }
;;;1102             }
;;;1103           }
0000b4  e001              B        |L10.186|
                  |L10.182|
;;;1104         } else {
;;;1105           msg->err = ERR_ARG;
0000b6  20f2              MOVS     r0,#0xf2
0000b8  7120              STRB     r0,[r4,#4]
                  |L10.186|
;;;1106         }
;;;1107       }
;;;1108     }
;;;1109     TCPIP_APIMSG_ACK(msg);
0000ba  6821              LDR      r1,[r4,#0]
0000bc  f101000c          ADD      r0,r1,#0xc
0000c0  f7fffffe          BL       sys_sem_signal
;;;1110   }
0000c4  bd70              POP      {r4-r6,pc}
;;;1111   #endif /* LWIP_TCP */
                          ENDP

0000c6  0000              DCW      0x0000
                  |L10.200|
                          DCD      accept_function

                          AREA ||i.do_newconn||, CODE, READONLY, ALIGN=1

                  do_newconn PROC
;;;547    void
;;;548    do_newconn(struct api_msg_msg *msg)
000000  b510              PUSH     {r4,lr}
;;;549    {
000002  4604              MOV      r4,r0
;;;550      msg->err = ERR_OK;
000004  2000              MOVS     r0,#0
000006  7120              STRB     r0,[r4,#4]
;;;551      if(msg->conn->pcb.tcp == NULL) {
000008  6820              LDR      r0,[r4,#0]
00000a  6840              LDR      r0,[r0,#4]
00000c  b910              CBNZ     r0,|L11.20|
;;;552        pcb_new(msg);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       pcb_new
                  |L11.20|
;;;553      }
;;;554      /* Else? This "new" connection already has a PCB allocated. */
;;;555      /* Is this an error condition? Should it be deleted? */
;;;556      /* We currently just are happy and return. */
;;;557    
;;;558      TCPIP_APIMSG_ACK(msg);
000014  6821              LDR      r1,[r4,#0]
000016  f101000c          ADD      r0,r1,#0xc
00001a  f7fffffe          BL       sys_sem_signal
;;;559    }
00001e  bd10              POP      {r4,pc}
;;;560    
                          ENDP


                          AREA ||i.do_recv||, CODE, READONLY, ALIGN=1

                  do_recv PROC
;;;1172   void
;;;1173   do_recv(struct api_msg_msg *msg)
000000  b570              PUSH     {r4-r6,lr}
;;;1174   {
000002  4604              MOV      r4,r0
;;;1175     msg->err = ERR_OK;
000004  2000              MOVS     r0,#0
000006  7120              STRB     r0,[r4,#4]
;;;1176     if (msg->conn->pcb.tcp != NULL) {
000008  6820              LDR      r0,[r4,#0]
00000a  6840              LDR      r0,[r0,#4]
00000c  b1b0              CBZ      r0,|L12.60|
;;;1177       if (msg->conn->type == NETCONN_TCP) {
00000e  6820              LDR      r0,[r4,#0]
000010  7800              LDRB     r0,[r0,#0]
000012  2810              CMP      r0,#0x10
000014  d112              BNE      |L12.60|
;;;1178   #if TCP_LISTEN_BACKLOG
;;;1179         if (msg->conn->pcb.tcp->state == LISTEN) {
;;;1180           tcp_accepted(msg->conn->pcb.tcp);
;;;1181         } else
;;;1182   #endif /* TCP_LISTEN_BACKLOG */
;;;1183         {
;;;1184           u32_t remaining = msg->msg.r.len;
000016  68a5              LDR      r5,[r4,#8]
;;;1185           do {
000018  bf00              NOP      
                  |L12.26|
;;;1186             u16_t recved = (remaining > 0xffff) ? 0xffff : (u16_t)remaining;
00001a  f5b53f80          CMP      r5,#0x10000
00001e  d302              BCC      |L12.38|
000020  f64f70ff          MOV      r0,#0xffff
000024  e000              B        |L12.40|
                  |L12.38|
000026  b2a8              UXTH     r0,r5
                  |L12.40|
000028  4606              MOV      r6,r0
;;;1187             tcp_recved(msg->conn->pcb.tcp, recved);
00002a  6821              LDR      r1,[r4,#0]
00002c  6848              LDR      r0,[r1,#4]
00002e  4631              MOV      r1,r6
000030  f7fffffe          BL       tcp_recved
;;;1188             remaining -= recved;
000034  1bad              SUBS     r5,r5,r6
;;;1189           }while(remaining != 0);
000036  2d00              CMP      r5,#0
000038  d1ef              BNE      |L12.26|
;;;1190         }
00003a  bf00              NOP      
                  |L12.60|
;;;1191       }
;;;1192     }
;;;1193     TCPIP_APIMSG_ACK(msg);
00003c  6821              LDR      r1,[r4,#0]
00003e  f101000c          ADD      r0,r1,#0xc
000042  f7fffffe          BL       sys_sem_signal
;;;1194   }
000046  bd70              POP      {r4-r6,pc}
;;;1195   
                          ENDP


                          AREA ||i.do_send||, CODE, READONLY, ALIGN=1

                  do_send PROC
;;;1119   void
;;;1120   do_send(struct api_msg_msg *msg)
000000  b570              PUSH     {r4-r6,lr}
;;;1121   {
000002  4604              MOV      r4,r0
;;;1122     if (ERR_IS_FATAL(msg->conn->last_err)) {
000004  6820              LDR      r0,[r4,#0]
000006  f9900008          LDRSB    r0,[r0,#8]
00000a  f1100f09          CMN      r0,#9
00000e  da03              BGE      |L13.24|
;;;1123       msg->err = msg->conn->last_err;
000010  6820              LDR      r0,[r4,#0]
000012  7a00              LDRB     r0,[r0,#8]
000014  7120              STRB     r0,[r4,#4]
000016  e040              B        |L13.154|
                  |L13.24|
;;;1124     } else {
;;;1125       msg->err = ERR_CONN;
000018  20f3              MOVS     r0,#0xf3
00001a  7120              STRB     r0,[r4,#4]
;;;1126       if (msg->conn->pcb.tcp != NULL) {
00001c  6820              LDR      r0,[r4,#0]
00001e  6840              LDR      r0,[r0,#4]
000020  2800              CMP      r0,#0
000022  d03a              BEQ      |L13.154|
;;;1127         switch (NETCONNTYPE_GROUP(msg->conn->type)) {
000024  6820              LDR      r0,[r4,#0]
000026  7800              LDRB     r0,[r0,#0]
000028  f00000f0          AND      r0,r0,#0xf0
00002c  2820              CMP      r0,#0x20
00002e  d019              BEQ      |L13.100|
000030  2840              CMP      r0,#0x40
000032  d130              BNE      |L13.150|
;;;1128   #if LWIP_RAW
;;;1129         case NETCONN_RAW:
;;;1130           if (ip_addr_isany(&msg->msg.b->addr)) {
000034  68a0              LDR      r0,[r4,#8]
000036  3008              ADDS     r0,r0,#8
000038  b110              CBZ      r0,|L13.64|
00003a  68a0              LDR      r0,[r4,#8]
00003c  6880              LDR      r0,[r0,#8]
00003e  b938              CBNZ     r0,|L13.80|
                  |L13.64|
;;;1131             msg->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
000040  68a2              LDR      r2,[r4,#8]
000042  6811              LDR      r1,[r2,#0]
000044  6822              LDR      r2,[r4,#0]
000046  6850              LDR      r0,[r2,#4]
000048  f7fffffe          BL       raw_send
00004c  7120              STRB     r0,[r4,#4]
00004e  e008              B        |L13.98|
                  |L13.80|
;;;1132           } else {
;;;1133             msg->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
000050  68a3              LDR      r3,[r4,#8]
000052  f1030208          ADD      r2,r3,#8
000056  6819              LDR      r1,[r3,#0]
000058  6823              LDR      r3,[r4,#0]
00005a  6858              LDR      r0,[r3,#4]
00005c  f7fffffe          BL       raw_sendto
000060  7120              STRB     r0,[r4,#4]
                  |L13.98|
;;;1134           }
;;;1135           break;
000062  e019              B        |L13.152|
                  |L13.100|
;;;1136   #endif
;;;1137   #if LWIP_UDP
;;;1138         case NETCONN_UDP:
;;;1139   #if LWIP_CHECKSUM_ON_COPY
;;;1140           if (ip_addr_isany(&msg->msg.b->addr)) {
;;;1141             msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
;;;1142               msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
;;;1143           } else {
;;;1144             msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
;;;1145               &msg->msg.b->addr, msg->msg.b->port,
;;;1146               msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
;;;1147           }
;;;1148   #else /* LWIP_CHECKSUM_ON_COPY */
;;;1149           if (ip_addr_isany(&msg->msg.b->addr)) {
000064  68a0              LDR      r0,[r4,#8]
000066  3008              ADDS     r0,r0,#8
000068  b110              CBZ      r0,|L13.112|
00006a  68a0              LDR      r0,[r4,#8]
00006c  6880              LDR      r0,[r0,#8]
00006e  b938              CBNZ     r0,|L13.128|
                  |L13.112|
;;;1150             msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
000070  68a2              LDR      r2,[r4,#8]
000072  6811              LDR      r1,[r2,#0]
000074  6822              LDR      r2,[r4,#0]
000076  6850              LDR      r0,[r2,#4]
000078  f7fffffe          BL       udp_send
00007c  7120              STRB     r0,[r4,#4]
00007e  e009              B        |L13.148|
                  |L13.128|
;;;1151           } else {
;;;1152             msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
000080  68a5              LDR      r5,[r4,#8]
000082  89ab              LDRH     r3,[r5,#0xc]
000084  f1050208          ADD      r2,r5,#8
000088  6829              LDR      r1,[r5,#0]
00008a  6825              LDR      r5,[r4,#0]
00008c  6868              LDR      r0,[r5,#4]
00008e  f7fffffe          BL       udp_sendto
000092  7120              STRB     r0,[r4,#4]
                  |L13.148|
;;;1153           }
;;;1154   #endif /* LWIP_CHECKSUM_ON_COPY */
;;;1155           break;
000094  e000              B        |L13.152|
                  |L13.150|
;;;1156   #endif /* LWIP_UDP */
;;;1157         default:
;;;1158           break;
000096  bf00              NOP      
                  |L13.152|
000098  bf00              NOP                            ;1135
                  |L13.154|
;;;1159         }
;;;1160       }
;;;1161     }
;;;1162     TCPIP_APIMSG_ACK(msg);
00009a  6821              LDR      r1,[r4,#0]
00009c  f101000c          ADD      r0,r1,#0xc
0000a0  f7fffffe          BL       sys_sem_signal
;;;1163   }
0000a4  bd70              POP      {r4-r6,pc}
;;;1164   
                          ENDP


                          AREA ||i.do_write||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  do_write PROC
;;;1342   void
;;;1343   do_write(struct api_msg_msg *msg)
000000  b510              PUSH     {r4,lr}
;;;1344   {
000002  4604              MOV      r4,r0
;;;1345     if (ERR_IS_FATAL(msg->conn->last_err)) {
000004  6820              LDR      r0,[r4,#0]
000006  f9900008          LDRSB    r0,[r0,#8]
00000a  f1100f09          CMN      r0,#9
00000e  da03              BGE      |L14.24|
;;;1346       msg->err = msg->conn->last_err;
000010  6820              LDR      r0,[r4,#0]
000012  7a00              LDRB     r0,[r0,#8]
000014  7120              STRB     r0,[r4,#4]
000016  e03c              B        |L14.146|
                  |L14.24|
;;;1347     } else {
;;;1348       if (msg->conn->type == NETCONN_TCP) {
000018  6820              LDR      r0,[r4,#0]
00001a  7800              LDRB     r0,[r0,#0]
00001c  2810              CMP      r0,#0x10
00001e  d136              BNE      |L14.142|
;;;1349   #if LWIP_TCP
;;;1350         if (msg->conn->state != NETCONN_NONE) {
000020  6820              LDR      r0,[r4,#0]
000022  7840              LDRB     r0,[r0,#1]
000024  b110              CBZ      r0,|L14.44|
;;;1351           /* netconn is connecting, closing or in blocking write */
;;;1352           msg->err = ERR_INPROGRESS;
000026  20fb              MOVS     r0,#0xfb
000028  7120              STRB     r0,[r4,#4]
00002a  e032              B        |L14.146|
                  |L14.44|
;;;1353         } else if (msg->conn->pcb.tcp != NULL) {
00002c  6820              LDR      r0,[r4,#0]
00002e  6840              LDR      r0,[r0,#4]
000030  2800              CMP      r0,#0
000032  d029              BEQ      |L14.136|
;;;1354           msg->conn->state = NETCONN_WRITE;
000034  2001              MOVS     r0,#1
000036  6821              LDR      r1,[r4,#0]
000038  7048              STRB     r0,[r1,#1]
;;;1355           /* set all the variables used by do_writemore */
;;;1356           LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
00003a  bf00              NOP      
00003c  6820              LDR      r0,[r4,#0]
00003e  6a80              LDR      r0,[r0,#0x28]
000040  b910              CBNZ     r0,|L14.72|
000042  6820              LDR      r0,[r4,#0]
000044  6a40              LDR      r0,[r0,#0x24]
000046  b140              CBZ      r0,|L14.90|
                  |L14.72|
000048  bf00              NOP      
00004a  a315              ADR      r3,|L14.160|
00004c  f240524c          MOV      r2,#0x54c
000050  a11d              ADR      r1,|L14.200|
000052  a024              ADR      r0,|L14.228|
000054  f7fffffe          BL       __2printf
000058  bf00              NOP      
                  |L14.90|
00005a  bf00              NOP      
;;;1357             msg->conn->write_offset == 0);
;;;1358           LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
00005c  bf00              NOP      
00005e  68e0              LDR      r0,[r4,#0xc]
000060  b940              CBNZ     r0,|L14.116|
000062  bf00              NOP      
000064  a30e              ADR      r3,|L14.160|
000066  f240524e          MOV      r2,#0x54e
00006a  a129              ADR      r1,|L14.272|
00006c  a01d              ADR      r0,|L14.228|
00006e  f7fffffe          BL       __2printf
000072  bf00              NOP      
                  |L14.116|
000074  bf00              NOP      
;;;1359           msg->conn->current_msg = msg;
000076  6820              LDR      r0,[r4,#0]
000078  6284              STR      r4,[r0,#0x28]
;;;1360           msg->conn->write_offset = 0;
00007a  2000              MOVS     r0,#0
00007c  6821              LDR      r1,[r4,#0]
00007e  6248              STR      r0,[r1,#0x24]
;;;1361   #if LWIP_TCPIP_CORE_LOCKING
;;;1362           msg->conn->flags &= ~NETCONN_FLAG_WRITE_DELAYED;
;;;1363           if (do_writemore(msg->conn) != ERR_OK) {
;;;1364             LWIP_ASSERT("state!", msg->conn->state == NETCONN_WRITE);
;;;1365             UNLOCK_TCPIP_CORE();
;;;1366             sys_arch_sem_wait(&msg->conn->op_completed, 0);
;;;1367             LOCK_TCPIP_CORE();
;;;1368             LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
;;;1369           }
;;;1370   #else /* LWIP_TCPIP_CORE_LOCKING */
;;;1371           do_writemore(msg->conn);
000080  6820              LDR      r0,[r4,#0]
000082  f7fffffe          BL       do_writemore
                  |L14.134|
;;;1372   #endif /* LWIP_TCPIP_CORE_LOCKING */
;;;1373           /* for both cases: if do_writemore was called, don't ACK the APIMSG
;;;1374              since do_writemore ACKs it! */
;;;1375           return;
;;;1376         } else {
;;;1377           msg->err = ERR_CONN;
;;;1378         }
;;;1379   #else /* LWIP_TCP */
;;;1380         msg->err = ERR_VAL;
;;;1381   #endif /* LWIP_TCP */
;;;1382   #if (LWIP_UDP || LWIP_RAW)
;;;1383       } else {
;;;1384         msg->err = ERR_VAL;
;;;1385   #endif /* (LWIP_UDP || LWIP_RAW) */
;;;1386       }
;;;1387     }
;;;1388     TCPIP_APIMSG_ACK(msg);
;;;1389   }
000086  bd10              POP      {r4,pc}
                  |L14.136|
000088  20f3              MOVS     r0,#0xf3              ;1377
00008a  7120              STRB     r0,[r4,#4]            ;1377
00008c  e001              B        |L14.146|
                  |L14.142|
00008e  20fa              MOVS     r0,#0xfa              ;1384
000090  7120              STRB     r0,[r4,#4]            ;1384
                  |L14.146|
000092  6821              LDR      r1,[r4,#0]            ;1388
000094  f101000c          ADD      r0,r1,#0xc            ;1388
000098  f7fffffe          BL       sys_sem_signal
00009c  bf00              NOP      
00009e  e7f2              B        |L14.134|
;;;1390   
                          ENDP

                  |L14.160|
0000a0  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\api_msg.c",0
0000a4  5749505c
0000a8  6c776970
0000ac  2d312e34
0000b0  2e315c73
0000b4  72635c61
0000b8  70695c61
0000bc  70695f6d
0000c0  73672e63
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L14.200|
0000c8  616c7265          DCB      "already writing or closing",0
0000cc  61647920
0000d0  77726974
0000d4  696e6720
0000d8  6f722063
0000dc  6c6f7369
0000e0  6e6700  
0000e3  00                DCB      0
                  |L14.228|
0000e4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000e8  7274696f
0000ec  6e202225
0000f0  73222066
0000f4  61696c65
0000f8  64206174
0000fc  206c696e
000100  65202564
000104  20696e20
000108  25730d0a
00010c  00      
00010d  00                DCB      0
00010e  00                DCB      0
00010f  00                DCB      0
                  |L14.272|
000110  6d73672d          DCB      "msg->msg.w.len != 0",0
000114  3e6d7367
000118  2e772e6c
00011c  656e2021
000120  3d203000

                          AREA ||i.do_writemore||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  do_writemore PROC
;;;1207   static err_t
;;;1208   do_writemore(struct netconn *conn)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1209   {
000004  4604              MOV      r4,r0
;;;1210     err_t err;
;;;1211     void *dataptr;
;;;1212     u16_t len, available;
;;;1213     u8_t write_finished = 0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;1214     size_t diff;
;;;1215     u8_t dontblock = netconn_is_nonblocking(conn) ||
00000a  f8940020          LDRB     r0,[r4,#0x20]
00000e  f0000002          AND      r0,r0,#2
000012  b920              CBNZ     r0,|L15.30|
;;;1216          (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
000014  6aa0              LDR      r0,[r4,#0x28]
000016  7c00              LDRB     r0,[r0,#0x10]
000018  f0000004          AND      r0,r0,#4
00001c  b108              CBZ      r0,|L15.34|
                  |L15.30|
00001e  2001              MOVS     r0,#1
000020  e000              B        |L15.36|
                  |L15.34|
000022  2000              MOVS     r0,#0
                  |L15.36|
000024  4607              MOV      r7,r0
;;;1217     u8_t apiflags = conn->current_msg->msg.w.apiflags;
000026  6aa0              LDR      r0,[r4,#0x28]
000028  f8908010          LDRB     r8,[r0,#0x10]
;;;1218   
;;;1219     LWIP_ASSERT("conn != NULL", conn != NULL);
00002c  bf00              NOP      
00002e  b944              CBNZ     r4,|L15.66|
000030  bf00              NOP      
000032  a369              ADR      r3,|L15.472|
000034  f24042c3          MOV      r2,#0x4c3
000038  a171              ADR      r1,|L15.512|
00003a  a075              ADR      r0,|L15.528|
00003c  f7fffffe          BL       __2printf
000040  bf00              NOP      
                  |L15.66|
000042  bf00              NOP      
;;;1220     LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
000044  bf00              NOP      
000046  7860              LDRB     r0,[r4,#1]
000048  2801              CMP      r0,#1
00004a  d008              BEQ      |L15.94|
00004c  bf00              NOP      
00004e  a362              ADR      r3,|L15.472|
000050  f24042c4          MOV      r2,#0x4c4
000054  a179              ADR      r1,|L15.572|
000056  a06e              ADR      r0,|L15.528|
000058  f7fffffe          BL       __2printf
00005c  bf00              NOP      
                  |L15.94|
00005e  bf00              NOP      
;;;1221     LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
000060  bf00              NOP      
000062  6aa0              LDR      r0,[r4,#0x28]
000064  b940              CBNZ     r0,|L15.120|
000066  bf00              NOP      
000068  a35b              ADR      r3,|L15.472|
00006a  f24042c5          MOV      r2,#0x4c5
00006e  a17b              ADR      r1,|L15.604|
000070  a067              ADR      r0,|L15.528|
000072  f7fffffe          BL       __2printf
000076  bf00              NOP      
                  |L15.120|
000078  bf00              NOP      
;;;1222     LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
00007a  bf00              NOP      
00007c  6860              LDR      r0,[r4,#4]
00007e  b940              CBNZ     r0,|L15.146|
000080  bf00              NOP      
000082  a355              ADR      r3,|L15.472|
000084  f24042c6          MOV      r2,#0x4c6
000088  a17b              ADR      r1,|L15.632|
00008a  a061              ADR      r0,|L15.528|
00008c  f7fffffe          BL       __2printf
000090  bf00              NOP      
                  |L15.146|
000092  bf00              NOP      
;;;1223     LWIP_ASSERT("conn->write_offset < conn->current_msg->msg.w.len",
000094  bf00              NOP      
000096  e9d41009          LDRD     r1,r0,[r4,#0x24]
00009a  68c0              LDR      r0,[r0,#0xc]
00009c  4281              CMP      r1,r0
00009e  d308              BCC      |L15.178|
0000a0  bf00              NOP      
0000a2  a34d              ADR      r3,|L15.472|
0000a4  f24042c7          MOV      r2,#0x4c7
0000a8  a179              ADR      r1,|L15.656|
0000aa  a059              ADR      r0,|L15.528|
0000ac  f7fffffe          BL       __2printf
0000b0  bf00              NOP      
                  |L15.178|
0000b2  bf00              NOP      
;;;1224       conn->write_offset < conn->current_msg->msg.w.len);
;;;1225   
;;;1226   #if LWIP_SO_SNDTIMEO
;;;1227     if ((conn->send_timeout != 0) &&
;;;1228         ((s32_t)(sys_now() - conn->current_msg->msg.w.time_started) >= conn->send_timeout)) {
;;;1229       write_finished = 1;
;;;1230       if (conn->write_offset == 0) {
;;;1231         /* nothing has been written */
;;;1232         err = ERR_WOULDBLOCK;
;;;1233         conn->current_msg->msg.w.len = 0;
;;;1234       } else {
;;;1235         /* partial write */
;;;1236         err = ERR_OK;
;;;1237         conn->current_msg->msg.w.len = conn->write_offset;
;;;1238       }
;;;1239     } else
;;;1240   #endif /* LWIP_SO_SNDTIMEO */
;;;1241     {
;;;1242       dataptr = (u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
0000b4  6aa0              LDR      r0,[r4,#0x28]
0000b6  6880              LDR      r0,[r0,#8]
0000b8  6a61              LDR      r1,[r4,#0x24]
0000ba  eb000b01          ADD      r11,r0,r1
;;;1243       diff = conn->current_msg->msg.w.len - conn->write_offset;
0000be  6aa0              LDR      r0,[r4,#0x28]
0000c0  68c0              LDR      r0,[r0,#0xc]
0000c2  6a61              LDR      r1,[r4,#0x24]
0000c4  eba00a01          SUB      r10,r0,r1
;;;1244       if (diff > 0xffffUL) { /* max_u16_t */
0000c8  f5ba3f80          CMP      r10,#0x10000
0000cc  d304              BCC      |L15.216|
;;;1245         len = 0xffff;
0000ce  f64f76ff          MOV      r6,#0xffff
;;;1246   #if LWIP_TCPIP_CORE_LOCKING
;;;1247         conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
;;;1248   #endif
;;;1249         apiflags |= TCP_WRITE_FLAG_MORE;
0000d2  f0480802          ORR      r8,r8,#2
0000d6  e001              B        |L15.220|
                  |L15.216|
;;;1250       } else {
;;;1251         len = (u16_t)diff;
0000d8  fa1ff68a          UXTH     r6,r10
                  |L15.220|
;;;1252       }
;;;1253       available = tcp_sndbuf(conn->pcb.tcp);
0000dc  6860              LDR      r0,[r4,#4]
0000de  f8b09066          LDRH     r9,[r0,#0x66]
;;;1254       if (available < len) {
0000e2  45b1              CMP      r9,r6
0000e4  da07              BGE      |L15.246|
;;;1255         /* don't try to write more than sendbuf */
;;;1256         len = available;
0000e6  464e              MOV      r6,r9
;;;1257         if (dontblock){ 
0000e8  b11f              CBZ      r7,|L15.242|
;;;1258           if (!len) {
0000ea  b926              CBNZ     r6,|L15.246|
;;;1259             err = ERR_WOULDBLOCK;
0000ec  f06f0506          MVN      r5,#6
;;;1260             goto err_mem;
0000f0  e01d              B        |L15.302|
                  |L15.242|
;;;1261           }
;;;1262         } else {
;;;1263   #if LWIP_TCPIP_CORE_LOCKING
;;;1264           conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
;;;1265   #endif
;;;1266           apiflags |= TCP_WRITE_FLAG_MORE;
0000f2  f0480802          ORR      r8,r8,#2
                  |L15.246|
;;;1267         }
;;;1268       }
;;;1269       LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
0000f6  bf00              NOP      
0000f8  6a60              LDR      r0,[r4,#0x24]
0000fa  1981              ADDS     r1,r0,r6
0000fc  6aa0              LDR      r0,[r4,#0x28]
0000fe  68c0              LDR      r0,[r0,#0xc]
000100  4281              CMP      r1,r0
000102  d908              BLS      |L15.278|
000104  bf00              NOP      
000106  a334              ADR      r3,|L15.472|
000108  f24042f5          MOV      r2,#0x4f5
00010c  a16d              ADR      r1,|L15.708|
00010e  a040              ADR      r0,|L15.528|
000110  f7fffffe          BL       __2printf
000114  bf00              NOP      
                  |L15.278|
000116  bf00              NOP      
;;;1270       err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
000118  4643              MOV      r3,r8
00011a  4632              MOV      r2,r6
00011c  4659              MOV      r1,r11
00011e  6860              LDR      r0,[r4,#4]
000120  f7fffffe          BL       tcp_write
000124  4605              MOV      r5,r0
;;;1271       /* if OK or memory error, check available space */
;;;1272       if ((err == ERR_OK) || (err == ERR_MEM)) {
000126  b10d              CBZ      r5,|L15.300|
000128  1c68              ADDS     r0,r5,#1
00012a  bb30              CBNZ     r0,|L15.378|
                  |L15.300|
;;;1273   err_mem:
00012c  bf00              NOP      
                  |L15.302|
;;;1274         if (dontblock && (len < conn->current_msg->msg.w.len)) {
00012e  b18f              CBZ      r7,|L15.340|
000130  6aa0              LDR      r0,[r4,#0x28]
000132  68c0              LDR      r0,[r0,#0xc]
000134  42b0              CMP      r0,r6
000136  d90d              BLS      |L15.340|
;;;1275           /* non-blocking write did not write everything: mark the pcb non-writable
;;;1276              and let poll_tcp check writable space to mark the pcb writable again */
;;;1277           API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
000138  6ae0              LDR      r0,[r4,#0x2c]
00013a  b120              CBZ      r0,|L15.326|
00013c  4632              MOV      r2,r6
00013e  2103              MOVS     r1,#3
000140  4620              MOV      r0,r4
000142  6ae3              LDR      r3,[r4,#0x2c]
000144  4798              BLX      r3
                  |L15.326|
;;;1278           conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
000146  f8940020          LDRB     r0,[r4,#0x20]
00014a  f0400010          ORR      r0,r0,#0x10
00014e  f8840020          STRB     r0,[r4,#0x20]
000152  e012              B        |L15.378|
                  |L15.340|
;;;1279         } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
000154  6860              LDR      r0,[r4,#4]
000156  f8b00066          LDRH     r0,[r0,#0x66]
00015a  f6403167          MOV      r1,#0xb67
00015e  4288              CMP      r0,r1
000160  dd04              BLE      |L15.364|
;;;1280                    (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
000162  6860              LDR      r0,[r4,#4]
000164  f8b00068          LDRH     r0,[r0,#0x68]
000168  2805              CMP      r0,#5
00016a  db06              BLT      |L15.378|
                  |L15.364|
;;;1281           /* The queued byte- or pbuf-count exceeds the configured low-water limit,
;;;1282              let select mark this pcb as non-writable. */
;;;1283           API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
00016c  6ae0              LDR      r0,[r4,#0x2c]
00016e  b120              CBZ      r0,|L15.378|
000170  4632              MOV      r2,r6
000172  2103              MOVS     r1,#3
000174  4620              MOV      r0,r4
000176  6ae3              LDR      r3,[r4,#0x2c]
000178  4798              BLX      r3
                  |L15.378|
;;;1284         }
;;;1285       }
;;;1286   
;;;1287       if (err == ERR_OK) {
00017a  b99d              CBNZ     r5,|L15.420|
;;;1288         conn->write_offset += len;
00017c  6a60              LDR      r0,[r4,#0x24]
00017e  4430              ADD      r0,r0,r6
000180  6260              STR      r0,[r4,#0x24]
;;;1289         if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
000182  e9d41009          LDRD     r1,r0,[r4,#0x24]
000186  68c0              LDR      r0,[r0,#0xc]
000188  4281              CMP      r1,r0
00018a  d000              BEQ      |L15.398|
00018c  b137              CBZ      r7,|L15.412|
                  |L15.398|
;;;1290           /* return sent length */
;;;1291           conn->current_msg->msg.w.len = conn->write_offset;
00018e  e9d41009          LDRD     r1,r0,[r4,#0x24]
000192  60c1              STR      r1,[r0,#0xc]
;;;1292           /* everything was written */
;;;1293           write_finished = 1;
000194  2001              MOVS     r0,#1
000196  9000              STR      r0,[sp,#0]
;;;1294           conn->write_offset = 0;
000198  2000              MOVS     r0,#0
00019a  6260              STR      r0,[r4,#0x24]
                  |L15.412|
;;;1295         }
;;;1296         tcp_output(conn->pcb.tcp);
00019c  6860              LDR      r0,[r4,#4]
00019e  f7fffffe          BL       tcp_output
0001a2  e00b              B        |L15.444|
                  |L15.420|
;;;1297       } else if ((err == ERR_MEM) && !dontblock) {
0001a4  1c68              ADDS     r0,r5,#1
0001a6  b920              CBNZ     r0,|L15.434|
0001a8  b91f              CBNZ     r7,|L15.434|
;;;1298         /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
;;;1299            we do NOT return to the application thread, since ERR_MEM is
;;;1300            only a temporary error! */
;;;1301   
;;;1302         /* tcp_write returned ERR_MEM, try tcp_output anyway */
;;;1303         tcp_output(conn->pcb.tcp);
0001aa  6860              LDR      r0,[r4,#4]
0001ac  f7fffffe          BL       tcp_output
0001b0  e004              B        |L15.444|
                  |L15.434|
;;;1304   
;;;1305   #if LWIP_TCPIP_CORE_LOCKING
;;;1306         conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
;;;1307   #endif
;;;1308       } else {
;;;1309         /* On errors != ERR_MEM, we don't try writing any more but return
;;;1310            the error to the application thread. */
;;;1311         write_finished = 1;
0001b2  2001              MOVS     r0,#1
0001b4  9000              STR      r0,[sp,#0]
;;;1312         conn->current_msg->msg.w.len = 0;
0001b6  2100              MOVS     r1,#0
0001b8  6aa0              LDR      r0,[r4,#0x28]
0001ba  60c1              STR      r1,[r0,#0xc]
                  |L15.444|
;;;1313       }
;;;1314     }
;;;1315     if (write_finished) {
0001bc  9800              LDR      r0,[sp,#0]
0001be  b140              CBZ      r0,|L15.466|
;;;1316       /* everything was written: set back connection state
;;;1317          and back to application task */
;;;1318       conn->current_msg->err = err;
0001c0  6aa0              LDR      r0,[r4,#0x28]
0001c2  7105              STRB     r5,[r0,#4]
;;;1319       conn->current_msg = NULL;
0001c4  2000              MOVS     r0,#0
0001c6  62a0              STR      r0,[r4,#0x28]
;;;1320       conn->state = NETCONN_NONE;
0001c8  7060              STRB     r0,[r4,#1]
;;;1321   #if LWIP_TCPIP_CORE_LOCKING
;;;1322       if ((conn->flags & NETCONN_FLAG_WRITE_DELAYED) != 0)
;;;1323   #endif
;;;1324       {
;;;1325         sys_sem_signal(&conn->op_completed);
0001ca  f104000c          ADD      r0,r4,#0xc
0001ce  f7fffffe          BL       sys_sem_signal
                  |L15.466|
;;;1326       }
;;;1327     }
;;;1328   #if LWIP_TCPIP_CORE_LOCKING
;;;1329     else
;;;1330       return ERR_MEM;
;;;1331   #endif
;;;1332     return ERR_OK;
0001d2  2000              MOVS     r0,#0
;;;1333   }
0001d4  e8bd8ff8          POP      {r3-r11,pc}
;;;1334   #endif /* LWIP_TCP */
                          ENDP

                  |L15.472|
0001d8  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\api_msg.c",0
0001dc  5749505c
0001e0  6c776970
0001e4  2d312e34
0001e8  2e315c73
0001ec  72635c61
0001f0  70695c61
0001f4  70695f6d
0001f8  73672e63
0001fc  00      
0001fd  00                DCB      0
0001fe  00                DCB      0
0001ff  00                DCB      0
                  |L15.512|
000200  636f6e6e          DCB      "conn != NULL",0
000204  20213d20
000208  4e554c4c
00020c  00      
00020d  00                DCB      0
00020e  00                DCB      0
00020f  00                DCB      0
                  |L15.528|
000210  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000214  7274696f
000218  6e202225
00021c  73222066
000220  61696c65
000224  64206174
000228  206c696e
00022c  65202564
000230  20696e20
000234  25730d0a
000238  00      
000239  00                DCB      0
00023a  00                DCB      0
00023b  00                DCB      0
                  |L15.572|
00023c  636f6e6e          DCB      "conn->state == NETCONN_WRITE",0
000240  2d3e7374
000244  61746520
000248  3d3d204e
00024c  4554434f
000250  4e4e5f57
000254  52495445
000258  00      
000259  00                DCB      0
00025a  00                DCB      0
00025b  00                DCB      0
                  |L15.604|
00025c  636f6e6e          DCB      "conn->current_msg != NULL",0
000260  2d3e6375
000264  7272656e
000268  745f6d73
00026c  6720213d
000270  204e554c
000274  4c00    
000276  00                DCB      0
000277  00                DCB      0
                  |L15.632|
000278  636f6e6e          DCB      "conn->pcb.tcp != NULL",0
00027c  2d3e7063
000280  622e7463
000284  7020213d
000288  204e554c
00028c  4c00    
00028e  00                DCB      0
00028f  00                DCB      0
                  |L15.656|
000290  636f6e6e          DCB      "conn->write_offset < conn->current_msg->msg.w.len",0
000294  2d3e7772
000298  6974655f
00029c  6f666673
0002a0  6574203c
0002a4  20636f6e
0002a8  6e2d3e63
0002ac  75727265
0002b0  6e745f6d
0002b4  73672d3e
0002b8  6d73672e
0002bc  772e6c65
0002c0  6e00    
0002c2  00                DCB      0
0002c3  00                DCB      0
                  |L15.708|
0002c4  646f5f77          DCB      "do_writemore: invalid length!",0
0002c8  72697465
0002cc  6d6f7265
0002d0  3a20696e
0002d4  76616c69
0002d8  64206c65
0002dc  6e677468
0002e0  2100    
0002e2  00                DCB      0
0002e3  00                DCB      0

                          AREA ||i.err_tcp||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  err_tcp PROC
;;;346    static void
;;;347    err_tcp(void *arg, err_t err)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;348    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
;;;349      struct netconn *conn;
;;;350      enum netconn_state old_state;
;;;351      SYS_ARCH_DECL_PROTECT(lev);
;;;352    
;;;353      conn = (struct netconn *)arg;
000008  463c              MOV      r4,r7
;;;354      LWIP_ASSERT("conn != NULL", (conn != NULL));
00000a  bf00              NOP      
00000c  b944              CBNZ     r4,|L16.32|
00000e  bf00              NOP      
000010  a33b              ADR      r3,|L16.256|
000012  f44f72b1          MOV      r2,#0x162
000016  a144              ADR      r1,|L16.296|
000018  a047              ADR      r0,|L16.312|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
                  |L16.32|
000020  bf00              NOP      
;;;355    
;;;356      conn->pcb.tcp = NULL;
000022  2000              MOVS     r0,#0
000024  6060              STR      r0,[r4,#4]
;;;357    
;;;358      /* no check since this is always fatal! */
;;;359      SYS_ARCH_PROTECT(lev);
000026  f7fffffe          BL       sys_arch_protect
00002a  4681              MOV      r9,r0
;;;360      conn->last_err = err;
00002c  7226              STRB     r6,[r4,#8]
;;;361      SYS_ARCH_UNPROTECT(lev);
00002e  4648              MOV      r0,r9
000030  f7fffffe          BL       sys_arch_unprotect
;;;362    
;;;363      /* reset conn->state now before waking up other threads */
;;;364      old_state = conn->state;
000034  7865              LDRB     r5,[r4,#1]
;;;365      conn->state = NETCONN_NONE;
000036  2000              MOVS     r0,#0
000038  7060              STRB     r0,[r4,#1]
;;;366    
;;;367      /* Notify the user layer about a connection error. Used to signal
;;;368         select. */
;;;369      API_EVENT(conn, NETCONN_EVT_ERROR, 0);
00003a  6ae0              LDR      r0,[r4,#0x2c]
00003c  b120              CBZ      r0,|L16.72|
00003e  2200              MOVS     r2,#0
000040  2104              MOVS     r1,#4
000042  4620              MOV      r0,r4
000044  6ae3              LDR      r3,[r4,#0x2c]
000046  4798              BLX      r3
                  |L16.72|
;;;370      /* Try to release selects pending on 'read' or 'write', too.
;;;371         They will get an error if they actually try to read or write. */
;;;372      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
000048  6ae0              LDR      r0,[r4,#0x2c]
00004a  b120              CBZ      r0,|L16.86|
00004c  2200              MOVS     r2,#0
00004e  4611              MOV      r1,r2
000050  4620              MOV      r0,r4
000052  6ae3              LDR      r3,[r4,#0x2c]
000054  4798              BLX      r3
                  |L16.86|
;;;373      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
000056  6ae0              LDR      r0,[r4,#0x2c]
000058  b120              CBZ      r0,|L16.100|
00005a  2200              MOVS     r2,#0
00005c  2102              MOVS     r1,#2
00005e  4620              MOV      r0,r4
000060  6ae3              LDR      r3,[r4,#0x2c]
000062  4798              BLX      r3
                  |L16.100|
;;;374    
;;;375      /* pass NULL-message to recvmbox to wake up pending recv */
;;;376      if (sys_mbox_valid(&conn->recvmbox)) {
000064  f1040010          ADD      r0,r4,#0x10
000068  f7fffffe          BL       sys_mbox_valid
00006c  b120              CBZ      r0,|L16.120|
;;;377        /* use trypost to prevent deadlock */
;;;378        sys_mbox_trypost(&conn->recvmbox, NULL);
00006e  2100              MOVS     r1,#0
000070  f1040010          ADD      r0,r4,#0x10
000074  f7fffffe          BL       sys_mbox_trypost
                  |L16.120|
;;;379      }
;;;380      /* pass NULL-message to acceptmbox to wake up pending accept */
;;;381      if (sys_mbox_valid(&conn->acceptmbox)) {
000078  f1040014          ADD      r0,r4,#0x14
00007c  f7fffffe          BL       sys_mbox_valid
000080  b120              CBZ      r0,|L16.140|
;;;382        /* use trypost to preven deadlock */
;;;383        sys_mbox_trypost(&conn->acceptmbox, NULL);
000082  2100              MOVS     r1,#0
000084  f1040014          ADD      r0,r4,#0x14
000088  f7fffffe          BL       sys_mbox_trypost
                  |L16.140|
;;;384      }
;;;385    
;;;386      if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
00008c  2d01              CMP      r5,#1
00008e  d003              BEQ      |L16.152|
000090  2d04              CMP      r5,#4
000092  d001              BEQ      |L16.152|
;;;387          (old_state == NETCONN_CONNECT)) {
000094  2d03              CMP      r5,#3
000096  d124              BNE      |L16.226|
                  |L16.152|
;;;388        /* calling do_writemore/do_close_internal is not necessary
;;;389           since the pcb has already been deleted! */
;;;390        int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
000098  f8940020          LDRB     r0,[r4,#0x20]
00009c  f3c00880          UBFX     r8,r0,#2,#1
;;;391        SET_NONBLOCKING_CONNECT(conn, 0);
0000a0  bf00              NOP      
0000a2  f8940020          LDRB     r0,[r4,#0x20]
0000a6  f0200004          BIC      r0,r0,#4
0000aa  f8840020          STRB     r0,[r4,#0x20]
0000ae  bf00              NOP      
;;;392    
;;;393        if (!was_nonblocking_connect) {
0000b0  f1b80f00          CMP      r8,#0
0000b4  d114              BNE      |L16.224|
;;;394          /* set error return code */
;;;395          LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
0000b6  bf00              NOP      
0000b8  6aa0              LDR      r0,[r4,#0x28]
0000ba  b940              CBNZ     r0,|L16.206|
0000bc  bf00              NOP      
0000be  a310              ADR      r3,|L16.256|
0000c0  f240128b          MOV      r2,#0x18b
0000c4  a127              ADR      r1,|L16.356|
0000c6  a01c              ADR      r0,|L16.312|
0000c8  f7fffffe          BL       __2printf
0000cc  bf00              NOP      
                  |L16.206|
0000ce  bf00              NOP      
;;;396          conn->current_msg->err = err;
0000d0  6aa0              LDR      r0,[r4,#0x28]
0000d2  7106              STRB     r6,[r0,#4]
;;;397          conn->current_msg = NULL;
0000d4  2000              MOVS     r0,#0
0000d6  62a0              STR      r0,[r4,#0x28]
;;;398          /* wake up the waiting task */
;;;399          sys_sem_signal(&conn->op_completed);
0000d8  f104000c          ADD      r0,r4,#0xc
0000dc  f7fffffe          BL       sys_sem_signal
                  |L16.224|
;;;400        }
;;;401      } else {
0000e0  e00c              B        |L16.252|
                  |L16.226|
;;;402        LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
0000e2  bf00              NOP      
0000e4  6aa0              LDR      r0,[r4,#0x28]
0000e6  b140              CBZ      r0,|L16.250|
0000e8  bf00              NOP      
0000ea  a305              ADR      r3,|L16.256|
0000ec  f44f72c9          MOV      r2,#0x192
0000f0  a123              ADR      r1,|L16.384|
0000f2  a011              ADR      r0,|L16.312|
0000f4  f7fffffe          BL       __2printf
0000f8  bf00              NOP      
                  |L16.250|
0000fa  bf00              NOP      
                  |L16.252|
;;;403      }
;;;404    }
0000fc  e8bd87f0          POP      {r4-r10,pc}
;;;405    
                          ENDP

                  |L16.256|
000100  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\api_msg.c",0
000104  5749505c
000108  6c776970
00010c  2d312e34
000110  2e315c73
000114  72635c61
000118  70695c61
00011c  70695f6d
000120  73672e63
000124  00      
000125  00                DCB      0
000126  00                DCB      0
000127  00                DCB      0
                  |L16.296|
000128  636f6e6e          DCB      "conn != NULL",0
00012c  20213d20
000130  4e554c4c
000134  00      
000135  00                DCB      0
000136  00                DCB      0
000137  00                DCB      0
                  |L16.312|
000138  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
00013c  7274696f
000140  6e202225
000144  73222066
000148  61696c65
00014c  64206174
000150  206c696e
000154  65202564
000158  20696e20
00015c  25730d0a
000160  00      
000161  00                DCB      0
000162  00                DCB      0
000163  00                DCB      0
                  |L16.356|
000164  636f6e6e          DCB      "conn->current_msg != NULL",0
000168  2d3e6375
00016c  7272656e
000170  745f6d73
000174  6720213d
000178  204e554c
00017c  4c00    
00017e  00                DCB      0
00017f  00                DCB      0
                  |L16.384|
000180  636f6e6e          DCB      "conn->current_msg == NULL",0
000184  2d3e6375
000188  7272656e
00018c  745f6d73
000190  67203d3d
000194  204e554c
000198  4c00    
00019a  00                DCB      0
00019b  00                DCB      0

                          AREA ||i.netconn_alloc||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  netconn_alloc PROC
;;;571    struct netconn*
;;;572    netconn_alloc(enum netconn_type t, netconn_callback callback)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;573    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;574      struct netconn *conn;
;;;575      int size;
;;;576    
;;;577      conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
000008  2008              MOVS     r0,#8
00000a  f7fffffe          BL       memp_malloc
00000e  4604              MOV      r4,r0
;;;578      if (conn == NULL) {
000010  b914              CBNZ     r4,|L17.24|
;;;579        return NULL;
000012  2000              MOVS     r0,#0
                  |L17.20|
;;;580      }
;;;581    
;;;582      conn->last_err = ERR_OK;
;;;583      conn->type = t;
;;;584      conn->pcb.tcp = NULL;
;;;585    
;;;586    #if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
;;;587        (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
;;;588      size = DEFAULT_RAW_RECVMBOX_SIZE;
;;;589    #else
;;;590      switch(NETCONNTYPE_GROUP(t)) {
;;;591    #if LWIP_RAW
;;;592      case NETCONN_RAW:
;;;593        size = DEFAULT_RAW_RECVMBOX_SIZE;
;;;594        break;
;;;595    #endif /* LWIP_RAW */
;;;596    #if LWIP_UDP
;;;597      case NETCONN_UDP:
;;;598        size = DEFAULT_UDP_RECVMBOX_SIZE;
;;;599        break;
;;;600    #endif /* LWIP_UDP */
;;;601    #if LWIP_TCP
;;;602      case NETCONN_TCP:
;;;603        size = DEFAULT_TCP_RECVMBOX_SIZE;
;;;604        break;
;;;605    #endif /* LWIP_TCP */
;;;606      default:
;;;607        LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
;;;608        goto free_and_return;
;;;609      }
;;;610    #endif
;;;611    
;;;612      if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
;;;613        goto free_and_return;
;;;614      }
;;;615      if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
;;;616        sys_sem_free(&conn->op_completed);
;;;617        goto free_and_return;
;;;618      }
;;;619    
;;;620    #if LWIP_TCP
;;;621      sys_mbox_set_invalid(&conn->acceptmbox);
;;;622    #endif
;;;623      conn->state        = NETCONN_NONE;
;;;624    #if LWIP_SOCKET
;;;625      /* initialize socket to -1 since 0 is a valid socket */
;;;626      conn->socket       = -1;
;;;627    #endif /* LWIP_SOCKET */
;;;628      conn->callback     = callback;
;;;629    #if LWIP_TCP
;;;630      conn->current_msg  = NULL;
;;;631      conn->write_offset = 0;
;;;632    #endif /* LWIP_TCP */
;;;633    #if LWIP_SO_SNDTIMEO
;;;634      conn->send_timeout = 0;
;;;635    #endif /* LWIP_SO_SNDTIMEO */
;;;636    #if LWIP_SO_RCVTIMEO
;;;637      conn->recv_timeout = 0;
;;;638    #endif /* LWIP_SO_RCVTIMEO */
;;;639    #if LWIP_SO_RCVBUF
;;;640      conn->recv_bufsize = RECV_BUFSIZE_DEFAULT;
;;;641      conn->recv_avail   = 0;
;;;642    #endif /* LWIP_SO_RCVBUF */
;;;643      conn->flags = 0;
;;;644      return conn;
;;;645    free_and_return:
;;;646      memp_free(MEMP_NETCONN, conn);
;;;647      return NULL;
;;;648    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L17.24|
000018  2000              MOVS     r0,#0                 ;582
00001a  7220              STRB     r0,[r4,#8]            ;582
00001c  7026              STRB     r6,[r4,#0]            ;583
00001e  6060              STR      r0,[r4,#4]            ;584
000020  f00600f0          AND      r0,r6,#0xf0           ;590
000024  2810              CMP      r0,#0x10              ;590
000026  d008              BEQ      |L17.58|
000028  2820              CMP      r0,#0x20              ;590
00002a  d003              BEQ      |L17.52|
00002c  2840              CMP      r0,#0x40              ;590
00002e  d106              BNE      |L17.62|
000030  2500              MOVS     r5,#0                 ;593
000032  e010              B        |L17.86|
                  |L17.52|
000034  f44f65fa          MOV      r5,#0x7d0             ;598
000038  e00d              B        |L17.86|
                  |L17.58|
00003a  2514              MOVS     r5,#0x14              ;603
00003c  e00b              B        |L17.86|
                  |L17.62|
00003e  bf00              NOP                            ;607
000040  bf00              NOP                            ;607
000042  a31a              ADR      r3,|L17.172|
000044  f240225f          MOV      r2,#0x25f             ;607
000048  a122              ADR      r1,|L17.212|
00004a  a02c              ADR      r0,|L17.252|
00004c  f7fffffe          BL       __2printf
000050  bf00              NOP                            ;607
000052  bf00              NOP                            ;607
000054  e023              B        |L17.158|
                  |L17.86|
000056  bf00              NOP                            ;594
000058  2100              MOVS     r1,#0                 ;612
00005a  f104000c          ADD      r0,r4,#0xc            ;612
00005e  f7fffffe          BL       sys_sem_new
000062  b100              CBZ      r0,|L17.102|
000064  e01b              B        |L17.158|
                  |L17.102|
000066  4629              MOV      r1,r5                 ;615
000068  f1040010          ADD      r0,r4,#0x10           ;615
00006c  f7fffffe          BL       sys_mbox_new
000070  b120              CBZ      r0,|L17.124|
000072  f104000c          ADD      r0,r4,#0xc            ;616
000076  f7fffffe          BL       sys_sem_free
00007a  e010              B        |L17.158|
                  |L17.124|
00007c  f1040014          ADD      r0,r4,#0x14           ;621
000080  f7fffffe          BL       sys_mbox_set_invalid
000084  2000              MOVS     r0,#0                 ;623
000086  7060              STRB     r0,[r4,#1]            ;623
000088  1e40              SUBS     r0,r0,#1              ;626
00008a  61a0              STR      r0,[r4,#0x18]         ;626
00008c  62e7              STR      r7,[r4,#0x2c]         ;628
00008e  2000              MOVS     r0,#0                 ;630
000090  62a0              STR      r0,[r4,#0x28]         ;630
000092  6260              STR      r0,[r4,#0x24]         ;631
000094  61e0              STR      r0,[r4,#0x1c]         ;637
000096  f8840020          STRB     r0,[r4,#0x20]         ;643
00009a  4620              MOV      r0,r4                 ;644
00009c  e7ba              B        |L17.20|
                  |L17.158|
00009e  4621              MOV      r1,r4                 ;646
0000a0  2008              MOVS     r0,#8                 ;646
0000a2  f7fffffe          BL       memp_free
0000a6  2000              MOVS     r0,#0                 ;647
0000a8  e7b4              B        |L17.20|
;;;649    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L17.172|
0000ac  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\api_msg.c",0
0000b0  5749505c
0000b4  6c776970
0000b8  2d312e34
0000bc  2e315c73
0000c0  72635c61
0000c4  70695c61
0000c8  70695f6d
0000cc  73672e63
0000d0  00      
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L17.212|
0000d4  6e657463          DCB      "netconn_alloc: undefined netconn_type",0
0000d8  6f6e6e5f
0000dc  616c6c6f
0000e0  633a2075
0000e4  6e646566
0000e8  696e6564
0000ec  206e6574
0000f0  636f6e6e
0000f4  5f747970
0000f8  6500    
0000fa  00                DCB      0
0000fb  00                DCB      0
                  |L17.252|
0000fc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000100  7274696f
000104  6e202225
000108  73222066
00010c  61696c65
000110  64206174
000114  206c696e
000118  65202564
00011c  20696e20
000120  25730d0a
000124  00      
000125  00                DCB      0
000126  00                DCB      0
000127  00                DCB      0

                          AREA ||i.netconn_drain||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  netconn_drain PROC
;;;681    static void
;;;682    netconn_drain(struct netconn *conn)
000000  b5f8              PUSH     {r3-r7,lr}
;;;683    {
000002  4604              MOV      r4,r0
;;;684      void *mem;
;;;685    #if LWIP_TCP
;;;686      struct pbuf *p;
;;;687    #endif /* LWIP_TCP */
;;;688    
;;;689      /* This runs in tcpip_thread, so we don't need to lock against rx packets */
;;;690    
;;;691      /* Delete and drain the recvmbox. */
;;;692      if (sys_mbox_valid(&conn->recvmbox)) {
000004  f1040010          ADD      r0,r4,#0x10
000008  f7fffffe          BL       sys_mbox_valid
00000c  b318              CBZ      r0,|L18.86|
;;;693        while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
00000e  e012              B        |L18.54|
                  |L18.16|
;;;694    #if LWIP_TCP
;;;695          if (conn->type == NETCONN_TCP) {
000010  7820              LDRB     r0,[r4,#0]
000012  2810              CMP      r0,#0x10
000014  d10c              BNE      |L18.48|
;;;696            if(mem != NULL) {
000016  9800              LDR      r0,[sp,#0]
000018  b168              CBZ      r0,|L18.54|
;;;697              p = (struct pbuf*)mem;
00001a  9e00              LDR      r6,[sp,#0]
;;;698              /* pcb might be set to NULL already by err_tcp() */
;;;699              if (conn->pcb.tcp != NULL) {
00001c  6860              LDR      r0,[r4,#4]
00001e  b118              CBZ      r0,|L18.40|
;;;700                tcp_recved(conn->pcb.tcp, p->tot_len);
000020  8931              LDRH     r1,[r6,#8]
000022  6860              LDR      r0,[r4,#4]
000024  f7fffffe          BL       tcp_recved
                  |L18.40|
;;;701              }
;;;702              pbuf_free(p);
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       pbuf_free
00002e  e002              B        |L18.54|
                  |L18.48|
;;;703            }
;;;704          } else
;;;705    #endif /* LWIP_TCP */
;;;706          {
;;;707            netbuf_delete((struct netbuf *)mem);
000030  9800              LDR      r0,[sp,#0]
000032  f7fffffe          BL       netbuf_delete
                  |L18.54|
000036  4669              MOV      r1,sp                 ;693
000038  f1040010          ADD      r0,r4,#0x10           ;693
00003c  f7fffffe          BL       sys_arch_mbox_tryfetch
000040  1c40              ADDS     r0,r0,#1              ;693
000042  2800              CMP      r0,#0                 ;693
000044  d1e4              BNE      |L18.16|
;;;708          }
;;;709        }
;;;710        sys_mbox_free(&conn->recvmbox);
000046  f1040010          ADD      r0,r4,#0x10
00004a  f7fffffe          BL       sys_mbox_free
;;;711        sys_mbox_set_invalid(&conn->recvmbox);
00004e  f1040010          ADD      r0,r4,#0x10
000052  f7fffffe          BL       sys_mbox_set_invalid
                  |L18.86|
;;;712      }
;;;713    
;;;714      /* Delete and drain the acceptmbox. */
;;;715    #if LWIP_TCP
;;;716      if (sys_mbox_valid(&conn->acceptmbox)) {
000056  f1040014          ADD      r0,r4,#0x14
00005a  f7fffffe          BL       sys_mbox_valid
00005e  2800              CMP      r0,#0
000060  d031              BEQ      |L18.198|
;;;717        while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
000062  e020              B        |L18.166|
                  |L18.100|
;;;718          struct netconn *newconn = (struct netconn *)mem;
000064  9d00              LDR      r5,[sp,#0]
;;;719          /* Only tcp pcbs have an acceptmbox, so no need to check conn->type */
;;;720          /* pcb might be set to NULL already by err_tcp() */
;;;721          if (conn->pcb.tcp != NULL) {
000066  6860              LDR      r0,[r4,#4]
000068  2800              CMP      r0,#0
00006a  d00e              BEQ      |L18.138|
;;;722            tcp_accepted(conn->pcb.tcp);
00006c  bf00              NOP      
00006e  6860              LDR      r0,[r4,#4]
000070  7e00              LDRB     r0,[r0,#0x18]
000072  2801              CMP      r0,#1
000074  d008              BEQ      |L18.136|
000076  bf00              NOP      
000078  a313              ADR      r3,|L18.200|
00007a  f24022d2          MOV      r2,#0x2d2
00007e  a11c              ADR      r1,|L18.240|
000080  a027              ADR      r0,|L18.288|
000082  f7fffffe          BL       __2printf
000086  bf00              NOP      
                  |L18.136|
000088  bf00              NOP      
                  |L18.138|
;;;723          }
;;;724          /* drain recvmbox */
;;;725          netconn_drain(newconn);
00008a  4628              MOV      r0,r5
00008c  f7fffffe          BL       netconn_drain
;;;726          if (newconn->pcb.tcp != NULL) {
000090  6868              LDR      r0,[r5,#4]
000092  b120              CBZ      r0,|L18.158|
;;;727            tcp_abort(newconn->pcb.tcp);
000094  6868              LDR      r0,[r5,#4]
000096  f7fffffe          BL       tcp_abort
;;;728            newconn->pcb.tcp = NULL;
00009a  2000              MOVS     r0,#0
00009c  6068              STR      r0,[r5,#4]
                  |L18.158|
;;;729          }
;;;730          netconn_free(newconn);
00009e  4628              MOV      r0,r5
0000a0  f7fffffe          BL       netconn_free
;;;731        }
0000a4  bf00              NOP      
                  |L18.166|
0000a6  4669              MOV      r1,sp                 ;717
0000a8  f1040014          ADD      r0,r4,#0x14           ;717
0000ac  f7fffffe          BL       sys_arch_mbox_tryfetch
0000b0  1c40              ADDS     r0,r0,#1              ;717
0000b2  2800              CMP      r0,#0                 ;717
0000b4  d1d6              BNE      |L18.100|
;;;732        sys_mbox_free(&conn->acceptmbox);
0000b6  f1040014          ADD      r0,r4,#0x14
0000ba  f7fffffe          BL       sys_mbox_free
;;;733        sys_mbox_set_invalid(&conn->acceptmbox);
0000be  f1040014          ADD      r0,r4,#0x14
0000c2  f7fffffe          BL       sys_mbox_set_invalid
                  |L18.198|
;;;734      }
;;;735    #endif /* LWIP_TCP */
;;;736    }
0000c6  bdf8              POP      {r3-r7,pc}
;;;737    
                          ENDP

                  |L18.200|
0000c8  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\api_msg.c",0
0000cc  5749505c
0000d0  6c776970
0000d4  2d312e34
0000d8  2e315c73
0000dc  72635c61
0000e0  70695c61
0000e4  70695f6d
0000e8  73672e63
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L18.240|
0000f0  7063622d          DCB      "pcb->state == LISTEN (called for wrong pcb?)",0
0000f4  3e737461
0000f8  7465203d
0000fc  3d204c49
000100  5354454e
000104  20286361
000108  6c6c6564
00010c  20666f72
000110  2077726f
000114  6e672070
000118  63623f29
00011c  00      
00011d  00                DCB      0
00011e  00                DCB      0
00011f  00                DCB      0
                  |L18.288|
000120  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000124  7274696f
000128  6e202225
00012c  73222066
000130  61696c65
000134  64206174
000138  206c696e
00013c  65202564
000140  20696e20
000144  25730d0a
000148  00      
000149  00                DCB      0
00014a  00                DCB      0
00014b  00                DCB      0

                          AREA ||i.netconn_free||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  netconn_free PROC
;;;656    void
;;;657    netconn_free(struct netconn *conn)
000000  b510              PUSH     {r4,lr}
;;;658    {
000002  4604              MOV      r4,r0
;;;659      LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
000004  bf00              NOP      
000006  6860              LDR      r0,[r4,#4]
000008  2800              CMP      r0,#0
00000a  d008              BEQ      |L19.30|
00000c  bf00              NOP      
00000e  a31c              ADR      r3,|L19.128|
000010  f2402293          MOV      r2,#0x293
000014  a124              ADR      r1,|L19.168|
000016  a030              ADR      r0,|L19.216|
000018  f7fffffe          BL       __2printf
00001c  bf00              NOP      
                  |L19.30|
00001e  bf00              NOP      
;;;660      LWIP_ASSERT("recvmbox must be deallocated before calling this function",
000020  bf00              NOP      
000022  f1040010          ADD      r0,r4,#0x10
000026  f7fffffe          BL       sys_mbox_valid
00002a  2800              CMP      r0,#0
00002c  d008              BEQ      |L19.64|
00002e  bf00              NOP      
000030  a313              ADR      r3,|L19.128|
000032  f44f7225          MOV      r2,#0x294
000036  a133              ADR      r1,|L19.260|
000038  a027              ADR      r0,|L19.216|
00003a  f7fffffe          BL       __2printf
00003e  bf00              NOP      
                  |L19.64|
000040  bf00              NOP      
;;;661        !sys_mbox_valid(&conn->recvmbox));
;;;662    #if LWIP_TCP
;;;663      LWIP_ASSERT("acceptmbox must be deallocated before calling this function",
000042  bf00              NOP      
000044  f1040014          ADD      r0,r4,#0x14
000048  f7fffffe          BL       sys_mbox_valid
00004c  2800              CMP      r0,#0
00004e  d008              BEQ      |L19.98|
000050  bf00              NOP      
000052  a30b              ADR      r3,|L19.128|
000054  f2402297          MOV      r2,#0x297
000058  a139              ADR      r1,|L19.320|
00005a  a01f              ADR      r0,|L19.216|
00005c  f7fffffe          BL       __2printf
000060  bf00              NOP      
                  |L19.98|
000062  bf00              NOP      
;;;664        !sys_mbox_valid(&conn->acceptmbox));
;;;665    #endif /* LWIP_TCP */
;;;666    
;;;667      sys_sem_free(&conn->op_completed);
000064  f104000c          ADD      r0,r4,#0xc
000068  f7fffffe          BL       sys_sem_free
;;;668      sys_sem_set_invalid(&conn->op_completed);
00006c  f104000c          ADD      r0,r4,#0xc
000070  f7fffffe          BL       sys_sem_set_invalid
;;;669    
;;;670      memp_free(MEMP_NETCONN, conn);
000074  4621              MOV      r1,r4
000076  2008              MOVS     r0,#8
000078  f7fffffe          BL       memp_free
;;;671    }
00007c  bd10              POP      {r4,pc}
;;;672    
                          ENDP

00007e  0000              DCW      0x0000
                  |L19.128|
000080  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\api_msg.c",0
000084  5749505c
000088  6c776970
00008c  2d312e34
000090  2e315c73
000094  72635c61
000098  70695c61
00009c  70695f6d
0000a0  73672e63
0000a4  00      
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L19.168|
0000a8  50434220          DCB      "PCB must be deallocated outside this function",0
0000ac  6d757374
0000b0  20626520
0000b4  6465616c
0000b8  6c6f6361
0000bc  74656420
0000c0  6f757473
0000c4  69646520
0000c8  74686973
0000cc  2066756e
0000d0  6374696f
0000d4  6e00    
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L19.216|
0000d8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000dc  7274696f
0000e0  6e202225
0000e4  73222066
0000e8  61696c65
0000ec  64206174
0000f0  206c696e
0000f4  65202564
0000f8  20696e20
0000fc  25730d0a
000100  00      
000101  00                DCB      0
000102  00                DCB      0
000103  00                DCB      0
                  |L19.260|
000104  72656376          DCB      "recvmbox must be deallocated before calling this functi"
000108  6d626f78
00010c  206d7573
000110  74206265
000114  20646561
000118  6c6c6f63
00011c  61746564
000120  20626566
000124  6f726520
000128  63616c6c
00012c  696e6720
000130  74686973
000134  2066756e
000138  637469  
00013b  6f6e00            DCB      "on",0
00013e  00                DCB      0
00013f  00                DCB      0
                  |L19.320|
000140  61636365          DCB      "acceptmbox must be deallocated before calling this func"
000144  70746d62
000148  6f78206d
00014c  75737420
000150  62652064
000154  65616c6c
000158  6f636174
00015c  65642062
000160  65666f72
000164  65206361
000168  6c6c696e
00016c  67207468
000170  69732066
000174  756e63  
000177  74696f6e          DCB      "tion",0
00017b  00      

                          AREA ||i.pcb_new||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  pcb_new PROC
;;;489    static void
;;;490    pcb_new(struct api_msg_msg *msg)
000000  b510              PUSH     {r4,lr}
;;;491    {
000002  4604              MOV      r4,r0
;;;492      LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
000004  bf00              NOP      
000006  6820              LDR      r0,[r4,#0]
000008  6840              LDR      r0,[r0,#4]
00000a  2800              CMP      r0,#0
00000c  d008              BEQ      |L20.32|
00000e  bf00              NOP      
000010  a327              ADR      r3,|L20.176|
000012  f44f72f6          MOV      r2,#0x1ec
000016  a130              ADR      r1,|L20.216|
000018  a037              ADR      r0,|L20.248|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
                  |L20.32|
000020  bf00              NOP      
;;;493    
;;;494      /* Allocate a PCB for this connection */
;;;495      switch(NETCONNTYPE_GROUP(msg->conn->type)) {
000022  6820              LDR      r0,[r4,#0]
000024  7800              LDRB     r0,[r0,#0]
000026  f00000f0          AND      r0,r0,#0xf0
00002a  2810              CMP      r0,#0x10
00002c  d02c              BEQ      |L20.136|
00002e  2820              CMP      r0,#0x20
000030  d012              BEQ      |L20.88|
000032  2840              CMP      r0,#0x40
000034  d136              BNE      |L20.164|
;;;496    #if LWIP_RAW
;;;497      case NETCONN_RAW:
;;;498        msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
000036  7a20              LDRB     r0,[r4,#8]
000038  f7fffffe          BL       raw_new
00003c  6821              LDR      r1,[r4,#0]
00003e  6048              STR      r0,[r1,#4]
;;;499        if(msg->conn->pcb.raw == NULL) {
000040  6820              LDR      r0,[r4,#0]
000042  6840              LDR      r0,[r0,#4]
000044  b910              CBNZ     r0,|L20.76|
;;;500          msg->err = ERR_MEM;
000046  20ff              MOVS     r0,#0xff
000048  7120              STRB     r0,[r4,#4]
;;;501          break;
00004a  e02e              B        |L20.170|
                  |L20.76|
;;;502        }
;;;503        raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
00004c  6822              LDR      r2,[r4,#0]
00004e  4935              LDR      r1,|L20.292|
000050  6850              LDR      r0,[r2,#4]
000052  f7fffffe          BL       raw_recv
;;;504        break;
000056  e028              B        |L20.170|
                  |L20.88|
;;;505    #endif /* LWIP_RAW */
;;;506    #if LWIP_UDP
;;;507      case NETCONN_UDP:
;;;508        msg->conn->pcb.udp = udp_new();
000058  f7fffffe          BL       udp_new
00005c  6821              LDR      r1,[r4,#0]
00005e  6048              STR      r0,[r1,#4]
;;;509        if(msg->conn->pcb.udp == NULL) {
000060  6820              LDR      r0,[r4,#0]
000062  6840              LDR      r0,[r0,#4]
000064  b910              CBNZ     r0,|L20.108|
;;;510          msg->err = ERR_MEM;
000066  20ff              MOVS     r0,#0xff
000068  7120              STRB     r0,[r4,#4]
;;;511          break;
00006a  e01e              B        |L20.170|
                  |L20.108|
;;;512        }
;;;513    #if LWIP_UDPLITE
;;;514        if (msg->conn->type==NETCONN_UDPLITE) {
;;;515          udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
;;;516        }
;;;517    #endif /* LWIP_UDPLITE */
;;;518        if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
00006c  6820              LDR      r0,[r4,#0]
00006e  7800              LDRB     r0,[r0,#0]
000070  2822              CMP      r0,#0x22
000072  d103              BNE      |L20.124|
;;;519          udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
000074  2001              MOVS     r0,#1
000076  6821              LDR      r1,[r4,#0]
000078  6849              LDR      r1,[r1,#4]
00007a  7408              STRB     r0,[r1,#0x10]
                  |L20.124|
;;;520        }
;;;521        udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
00007c  6822              LDR      r2,[r4,#0]
00007e  492a              LDR      r1,|L20.296|
000080  6850              LDR      r0,[r2,#4]
000082  f7fffffe          BL       udp_recv
;;;522        break;
000086  e010              B        |L20.170|
                  |L20.136|
;;;523    #endif /* LWIP_UDP */
;;;524    #if LWIP_TCP
;;;525      case NETCONN_TCP:
;;;526        msg->conn->pcb.tcp = tcp_new();
000088  f7fffffe          BL       tcp_new
00008c  6821              LDR      r1,[r4,#0]
00008e  6048              STR      r0,[r1,#4]
;;;527        if(msg->conn->pcb.tcp == NULL) {
000090  6820              LDR      r0,[r4,#0]
000092  6840              LDR      r0,[r0,#4]
000094  b910              CBNZ     r0,|L20.156|
;;;528          msg->err = ERR_MEM;
000096  20ff              MOVS     r0,#0xff
000098  7120              STRB     r0,[r4,#4]
;;;529          break;
00009a  e006              B        |L20.170|
                  |L20.156|
;;;530        }
;;;531        setup_tcp(msg->conn);
00009c  6820              LDR      r0,[r4,#0]
00009e  f7fffffe          BL       setup_tcp
;;;532        break;
0000a2  e002              B        |L20.170|
                  |L20.164|
;;;533    #endif /* LWIP_TCP */
;;;534      default:
;;;535        /* Unsupported netconn type, e.g. protocol disabled */
;;;536        msg->err = ERR_VAL;
0000a4  20fa              MOVS     r0,#0xfa
0000a6  7120              STRB     r0,[r4,#4]
;;;537        break;
0000a8  bf00              NOP      
                  |L20.170|
0000aa  bf00              NOP                            ;501
;;;538      }
;;;539    }
0000ac  bd10              POP      {r4,pc}
;;;540    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L20.176|
0000b0  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\api_msg.c",0
0000b4  5749505c
0000b8  6c776970
0000bc  2d312e34
0000c0  2e315c73
0000c4  72635c61
0000c8  70695c61
0000cc  70695f6d
0000d0  73672e63
0000d4  00      
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L20.216|
0000d8  7063625f          DCB      "pcb_new: pcb already allocated",0
0000dc  6e65773a
0000e0  20706362
0000e4  20616c72
0000e8  65616479
0000ec  20616c6c
0000f0  6f636174
0000f4  656400  
0000f7  00                DCB      0
                  |L20.248|
0000f8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000fc  7274696f
000100  6e202225
000104  73222066
000108  61696c65
00010c  64206174
000110  206c696e
000114  65202564
000118  20696e20
00011c  25730d0a
000120  00      
000121  00                DCB      0
000122  00                DCB      0
000123  00                DCB      0
                  |L20.292|
                          DCD      recv_raw
                  |L20.296|
                          DCD      recv_udp

                          AREA ||i.poll_tcp||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  poll_tcp PROC
;;;276    static err_t
;;;277    poll_tcp(void *arg, struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;278    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;279      struct netconn *conn = (struct netconn *)arg;
000006  462c              MOV      r4,r5
;;;280    
;;;281      LWIP_UNUSED_ARG(pcb);
;;;282      LWIP_ASSERT("conn != NULL", (conn != NULL));
000008  bf00              NOP      
00000a  b944              CBNZ     r4,|L21.30|
00000c  bf00              NOP      
00000e  a31c              ADR      r3,|L21.128|
000010  f44f728d          MOV      r2,#0x11a
000014  a124              ADR      r1,|L21.168|
000016  a028              ADR      r0,|L21.184|
000018  f7fffffe          BL       __2printf
00001c  bf00              NOP      
                  |L21.30|
00001e  bf00              NOP      
;;;283    
;;;284      if (conn->state == NETCONN_WRITE) {
000020  7860              LDRB     r0,[r4,#1]
000022  2801              CMP      r0,#1
000024  d103              BNE      |L21.46|
;;;285        do_writemore(conn);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       do_writemore
00002c  e005              B        |L21.58|
                  |L21.46|
;;;286      } else if (conn->state == NETCONN_CLOSE) {
00002e  7860              LDRB     r0,[r4,#1]
000030  2804              CMP      r0,#4
000032  d102              BNE      |L21.58|
;;;287        do_close_internal(conn);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       do_close_internal
                  |L21.58|
;;;288      }
;;;289      /* @todo: implement connect timeout here? */
;;;290    
;;;291      /* Did a nonblocking write fail before? Then check available write-space. */
;;;292      if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
00003a  f8940020          LDRB     r0,[r4,#0x20]
00003e  f0000010          AND      r0,r0,#0x10
000042  b1d0              CBZ      r0,|L21.122|
;;;293        /* If the queued byte- or pbuf-count drops below the configured low-water limit,
;;;294           let select mark this pcb as writable again. */
;;;295        if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
000044  6860              LDR      r0,[r4,#4]
000046  b1c0              CBZ      r0,|L21.122|
000048  6860              LDR      r0,[r4,#4]
00004a  f8b00066          LDRH     r0,[r0,#0x66]
00004e  f6403167          MOV      r1,#0xb67
000052  4288              CMP      r0,r1
000054  dd11              BLE      |L21.122|
;;;296          (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
000056  6860              LDR      r0,[r4,#4]
000058  f8b00068          LDRH     r0,[r0,#0x68]
00005c  2805              CMP      r0,#5
00005e  da0c              BGE      |L21.122|
;;;297          conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
000060  f8940020          LDRB     r0,[r4,#0x20]
000064  f0200010          BIC      r0,r0,#0x10
000068  f8840020          STRB     r0,[r4,#0x20]
;;;298          API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
00006c  6ae0              LDR      r0,[r4,#0x2c]
00006e  b120              CBZ      r0,|L21.122|
000070  2200              MOVS     r2,#0
000072  2102              MOVS     r1,#2
000074  4620              MOV      r0,r4
000076  6ae3              LDR      r3,[r4,#0x2c]
000078  4798              BLX      r3
                  |L21.122|
;;;299        }
;;;300      }
;;;301    
;;;302      return ERR_OK;
00007a  2000              MOVS     r0,#0
;;;303    }
00007c  bd70              POP      {r4-r6,pc}
;;;304    
                          ENDP

00007e  0000              DCW      0x0000
                  |L21.128|
000080  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\api_msg.c",0
000084  5749505c
000088  6c776970
00008c  2d312e34
000090  2e315c73
000094  72635c61
000098  70695c61
00009c  70695f6d
0000a0  73672e63
0000a4  00      
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L21.168|
0000a8  636f6e6e          DCB      "conn != NULL",0
0000ac  20213d20
0000b0  4e554c4c
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L21.184|
0000b8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000bc  7274696f
0000c0  6e202225
0000c4  73222066
0000c8  61696c65
0000cc  64206174
0000d0  206c696e
0000d4  65202564
0000d8  20696e20
0000dc  25730d0a
0000e0  00      
0000e1  00                DCB      0
0000e2  00                DCB      0
0000e3  00                DCB      0

                          AREA ||i.recv_raw||, CODE, READONLY, ALIGN=2

                  recv_raw PROC
;;;77     static u8_t
;;;78     recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;79         ip_addr_t *addr)
;;;80     {
000004  4607              MOV      r7,r0
000006  4689              MOV      r9,r1
000008  4690              MOV      r8,r2
00000a  469b              MOV      r11,r3
;;;81       struct pbuf *q;
;;;82       struct netbuf *buf;
;;;83       struct netconn *conn;
;;;84     
;;;85       LWIP_UNUSED_ARG(addr);
;;;86       conn = (struct netconn *)arg;
00000c  463e              MOV      r6,r7
;;;87     
;;;88       if ((conn != NULL) && sys_mbox_valid(&conn->recvmbox)) {
00000e  2e00              CMP      r6,#0
000010  d03f              BEQ      |L22.146|
000012  f1060010          ADD      r0,r6,#0x10
000016  f7fffffe          BL       sys_mbox_valid
00001a  2800              CMP      r0,#0
00001c  d039              BEQ      |L22.146|
;;;89     #if LWIP_SO_RCVBUF
;;;90         int recv_avail;
;;;91         SYS_ARCH_GET(conn->recv_avail, recv_avail);
;;;92         if ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize) {
;;;93           return 0;
;;;94         }
;;;95     #endif /* LWIP_SO_RCVBUF */
;;;96         /* copy the whole packet into new pbufs */
;;;97         q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
00001e  f8b81008          LDRH     r1,[r8,#8]
000022  2200              MOVS     r2,#0
000024  2003              MOVS     r0,#3
000026  f7fffffe          BL       pbuf_alloc
00002a  4605              MOV      r5,r0
;;;98         if(q != NULL) {
00002c  b145              CBZ      r5,|L22.64|
;;;99           if (pbuf_copy(q, p) != ERR_OK) {
00002e  4641              MOV      r1,r8
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       pbuf_copy
000036  b118              CBZ      r0,|L22.64|
;;;100            pbuf_free(q);
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       pbuf_free
;;;101            q = NULL;
00003e  2500              MOVS     r5,#0
                  |L22.64|
;;;102          }
;;;103        }
;;;104    
;;;105        if (q != NULL) {
000040  b33d              CBZ      r5,|L22.146|
;;;106          u16_t len;
;;;107          buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
000042  2007              MOVS     r0,#7
000044  f7fffffe          BL       memp_malloc
000048  4604              MOV      r4,r0
;;;108          if (buf == NULL) {
00004a  b92c              CBNZ     r4,|L22.88|
;;;109            pbuf_free(q);
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       pbuf_free
;;;110            return 0;
000052  2000              MOVS     r0,#0
                  |L22.84|
;;;111          }
;;;112    
;;;113          buf->p = q;
;;;114          buf->ptr = q;
;;;115          ip_addr_copy(buf->addr, *ip_current_src_addr());
;;;116          buf->port = pcb->protocol;
;;;117    
;;;118          len = q->tot_len;
;;;119          if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
;;;120            netbuf_delete(buf);
;;;121            return 0;
;;;122          } else {
;;;123    #if LWIP_SO_RCVBUF
;;;124            SYS_ARCH_INC(conn->recv_avail, len);
;;;125    #endif /* LWIP_SO_RCVBUF */
;;;126            /* Register event with callback */
;;;127            API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
;;;128          }
;;;129        }
;;;130      }
;;;131    
;;;132      return 0; /* do not eat the packet */
;;;133    }
000054  e8bd9ff0          POP      {r4-r12,pc}
                  |L22.88|
000058  6025              STR      r5,[r4,#0]            ;113
00005a  6065              STR      r5,[r4,#4]            ;114
00005c  480e              LDR      r0,|L22.152|
00005e  6800              LDR      r0,[r0,#0]            ;115  ; current_iphdr_src
000060  60a0              STR      r0,[r4,#8]            ;115
000062  f8990010          LDRB     r0,[r9,#0x10]         ;116
000066  81a0              STRH     r0,[r4,#0xc]          ;116
000068  f8b5a008          LDRH     r10,[r5,#8]           ;118
00006c  4621              MOV      r1,r4                 ;119
00006e  f1060010          ADD      r0,r6,#0x10           ;119
000072  f7fffffe          BL       sys_mbox_trypost
000076  b120              CBZ      r0,|L22.130|
000078  4620              MOV      r0,r4                 ;120
00007a  f7fffffe          BL       netbuf_delete
00007e  2000              MOVS     r0,#0                 ;121
000080  e7e8              B        |L22.84|
                  |L22.130|
000082  6af0              LDR      r0,[r6,#0x2c]         ;127
000084  b120              CBZ      r0,|L22.144|
000086  4652              MOV      r2,r10                ;127
000088  2100              MOVS     r1,#0                 ;127
00008a  4630              MOV      r0,r6                 ;127
00008c  6af3              LDR      r3,[r6,#0x2c]         ;127
00008e  4798              BLX      r3                    ;127
                  |L22.144|
000090  bf00              NOP                            ;129
                  |L22.146|
000092  2000              MOVS     r0,#0                 ;132
000094  e7de              B        |L22.84|
;;;134    #endif /* LWIP_RAW*/
                          ENDP

000096  0000              DCW      0x0000
                  |L22.152|
                          DCD      current_iphdr_src

                          AREA ||i.recv_tcp||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  recv_tcp PROC
;;;215    static err_t
;;;216    recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;217    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  4699              MOV      r9,r3
;;;218      struct netconn *conn;
;;;219      u16_t len;
;;;220    
;;;221      LWIP_UNUSED_ARG(pcb);
;;;222      LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
00000c  bf00              NOP      
00000e  2e00              CMP      r6,#0
000010  d107              BNE      |L23.34|
000012  bf00              NOP      
000014  a32e              ADR      r3,|L23.208|
000016  22de              MOVS     r2,#0xde
000018  a137              ADR      r1,|L23.248|
00001a  a040              ADR      r0,|L23.284|
00001c  f7fffffe          BL       __2printf
000020  bf00              NOP      
                  |L23.34|
000022  bf00              NOP      
;;;223      LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
000024  bf00              NOP      
000026  2f00              CMP      r7,#0
000028  d107              BNE      |L23.58|
00002a  bf00              NOP      
00002c  a328              ADR      r3,|L23.208|
00002e  22df              MOVS     r2,#0xdf
000030  a145              ADR      r1,|L23.328|
000032  a03a              ADR      r0,|L23.284|
000034  f7fffffe          BL       __2printf
000038  bf00              NOP      
                  |L23.58|
00003a  bf00              NOP      
;;;224      conn = (struct netconn *)arg;
00003c  463c              MOV      r4,r7
;;;225      LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
00003e  bf00              NOP      
000040  6860              LDR      r0,[r4,#4]
000042  42b0              CMP      r0,r6
000044  d007              BEQ      |L23.86|
000046  bf00              NOP      
000048  a321              ADR      r3,|L23.208|
00004a  22e1              MOVS     r2,#0xe1
00004c  a146              ADR      r1,|L23.360|
00004e  a033              ADR      r0,|L23.284|
000050  f7fffffe          BL       __2printf
000054  bf00              NOP      
                  |L23.86|
000056  bf00              NOP      
;;;226    
;;;227      if (conn == NULL) {
000058  b91c              CBNZ     r4,|L23.98|
;;;228        return ERR_VAL;
00005a  f06f0005          MVN      r0,#5
                  |L23.94|
;;;229      }
;;;230      if (!sys_mbox_valid(&conn->recvmbox)) {
;;;231        /* recvmbox already deleted */
;;;232        if (p != NULL) {
;;;233          tcp_recved(pcb, p->tot_len);
;;;234          pbuf_free(p);
;;;235        }
;;;236        return ERR_OK;
;;;237      }
;;;238      /* Unlike for UDP or RAW pcbs, don't check for available space
;;;239         using recv_avail since that could break the connection
;;;240         (data is already ACKed) */
;;;241    
;;;242      /* don't overwrite fatal errors! */
;;;243      NETCONN_SET_SAFE_ERR(conn, err);
;;;244    
;;;245      if (p != NULL) {
;;;246        len = p->tot_len;
;;;247      } else {
;;;248        len = 0;
;;;249      }
;;;250    
;;;251      if (sys_mbox_trypost(&conn->recvmbox, p) != ERR_OK) {
;;;252        /* don't deallocate p: it is presented to us later again from tcp_fasttmr! */
;;;253        return ERR_MEM;
;;;254      } else {
;;;255    #if LWIP_SO_RCVBUF
;;;256        SYS_ARCH_INC(conn->recv_avail, len);
;;;257    #endif /* LWIP_SO_RCVBUF */
;;;258        /* Register event with callback */
;;;259        API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
;;;260      }
;;;261    
;;;262      return ERR_OK;
;;;263    }
00005e  e8bd87f0          POP      {r4-r10,pc}
                  |L23.98|
000062  f1040010          ADD      r0,r4,#0x10           ;230
000066  f7fffffe          BL       sys_mbox_valid
00006a  b948              CBNZ     r0,|L23.128|
00006c  b135              CBZ      r5,|L23.124|
00006e  8929              LDRH     r1,[r5,#8]            ;233
000070  4630              MOV      r0,r6                 ;233
000072  f7fffffe          BL       tcp_recved
000076  4628              MOV      r0,r5                 ;234
000078  f7fffffe          BL       pbuf_free
                  |L23.124|
00007c  2000              MOVS     r0,#0                 ;236
00007e  e7ee              B        |L23.94|
                  |L23.128|
000080  bf00              NOP                            ;243
000082  f7fffffe          BL       sys_arch_protect
000086  4682              MOV      r10,r0                ;243
000088  f9940008          LDRSB    r0,[r4,#8]            ;243
00008c  f1100f09          CMN      r0,#9                 ;243
000090  db01              BLT      |L23.150|
000092  f8849008          STRB     r9,[r4,#8]            ;243
                  |L23.150|
000096  4650              MOV      r0,r10                ;243
000098  f7fffffe          BL       sys_arch_unprotect
00009c  bf00              NOP                            ;243
00009e  b115              CBZ      r5,|L23.166|
0000a0  f8b58008          LDRH     r8,[r5,#8]            ;246
0000a4  e001              B        |L23.170|
                  |L23.166|
0000a6  f04f0800          MOV      r8,#0                 ;248
                  |L23.170|
0000aa  4629              MOV      r1,r5                 ;251
0000ac  f1040010          ADD      r0,r4,#0x10           ;251
0000b0  f7fffffe          BL       sys_mbox_trypost
0000b4  b110              CBZ      r0,|L23.188|
0000b6  f04f30ff          MOV      r0,#0xffffffff        ;253
0000ba  e7d0              B        |L23.94|
                  |L23.188|
0000bc  6ae0              LDR      r0,[r4,#0x2c]         ;259
0000be  b120              CBZ      r0,|L23.202|
0000c0  4642              MOV      r2,r8                 ;259
0000c2  2100              MOVS     r1,#0                 ;259
0000c4  4620              MOV      r0,r4                 ;259
0000c6  6ae3              LDR      r3,[r4,#0x2c]         ;259
0000c8  4798              BLX      r3                    ;259
                  |L23.202|
0000ca  2000              MOVS     r0,#0                 ;262
0000cc  e7c7              B        |L23.94|
;;;264    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L23.208|
0000d0  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\api_msg.c",0
0000d4  5749505c
0000d8  6c776970
0000dc  2d312e34
0000e0  2e315c73
0000e4  72635c61
0000e8  70695c61
0000ec  70695f6d
0000f0  73672e63
0000f4  00      
0000f5  00                DCB      0
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L23.248|
0000f8  72656376          DCB      "recv_tcp must have a pcb argument",0
0000fc  5f746370
000100  206d7573
000104  74206861
000108  76652061
00010c  20706362
000110  20617267
000114  756d656e
000118  7400    
00011a  00                DCB      0
00011b  00                DCB      0
                  |L23.284|
00011c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000120  7274696f
000124  6e202225
000128  73222066
00012c  61696c65
000130  64206174
000134  206c696e
000138  65202564
00013c  20696e20
000140  25730d0a
000144  00      
000145  00                DCB      0
000146  00                DCB      0
000147  00                DCB      0
                  |L23.328|
000148  72656376          DCB      "recv_tcp must have an argument",0
00014c  5f746370
000150  206d7573
000154  74206861
000158  76652061
00015c  6e206172
000160  67756d65
000164  6e7400  
000167  00                DCB      0
                  |L23.360|
000168  72656376          DCB      "recv_tcp: recv for wrong pcb!",0
00016c  5f746370
000170  3a207265
000174  63762066
000178  6f722077
00017c  726f6e67
000180  20706362
000184  2100    
000186  00                DCB      0
000187  00                DCB      0

                          AREA ||i.recv_udp||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  recv_udp PROC
;;;143    static void
;;;144    recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;145       ip_addr_t *addr, u16_t port)
;;;146    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  4699              MOV      r9,r3
00000c  f8ddb028          LDR      r11,[sp,#0x28]
;;;147      struct netbuf *buf;
;;;148      struct netconn *conn;
;;;149      u16_t len;
;;;150    #if LWIP_SO_RCVBUF
;;;151      int recv_avail;
;;;152    #endif /* LWIP_SO_RCVBUF */
;;;153    
;;;154      LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
;;;155      LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
000010  bf00              NOP      
000012  f1b80f00          CMP      r8,#0
000016  d107              BNE      |L24.40|
000018  bf00              NOP      
00001a  a32b              ADR      r3,|L24.200|
00001c  229b              MOVS     r2,#0x9b
00001e  a134              ADR      r1,|L24.240|
000020  a03c              ADR      r0,|L24.276|
000022  f7fffffe          BL       __2printf
000026  bf00              NOP      
                  |L24.40|
000028  bf00              NOP      
;;;156      LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
00002a  bf00              NOP      
00002c  2f00              CMP      r7,#0
00002e  d107              BNE      |L24.64|
000030  bf00              NOP      
000032  a325              ADR      r3,|L24.200|
000034  229c              MOVS     r2,#0x9c
000036  a142              ADR      r1,|L24.320|
000038  a036              ADR      r0,|L24.276|
00003a  f7fffffe          BL       __2printf
00003e  bf00              NOP      
                  |L24.64|
000040  bf00              NOP      
;;;157      conn = (struct netconn *)arg;
000042  463d              MOV      r5,r7
;;;158      LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
000044  bf00              NOP      
000046  6868              LDR      r0,[r5,#4]
000048  4540              CMP      r0,r8
00004a  d007              BEQ      |L24.92|
00004c  bf00              NOP      
00004e  a31e              ADR      r3,|L24.200|
000050  229e              MOVS     r2,#0x9e
000052  a143              ADR      r1,|L24.352|
000054  a02f              ADR      r0,|L24.276|
000056  f7fffffe          BL       __2printf
00005a  bf00              NOP      
                  |L24.92|
00005c  bf00              NOP      
;;;159    
;;;160    #if LWIP_SO_RCVBUF
;;;161      SYS_ARCH_GET(conn->recv_avail, recv_avail);
;;;162      if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox) ||
;;;163          ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
;;;164    #else  /* LWIP_SO_RCVBUF */
;;;165      if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox)) {
00005e  b125              CBZ      r5,|L24.106|
000060  f1050010          ADD      r0,r5,#0x10
000064  f7fffffe          BL       sys_mbox_valid
000068  b920              CBNZ     r0,|L24.116|
                  |L24.106|
;;;166    #endif /* LWIP_SO_RCVBUF */
;;;167        pbuf_free(p);
00006a  4630              MOV      r0,r6
00006c  f7fffffe          BL       pbuf_free
                  |L24.112|
;;;168        return;
;;;169      }
;;;170    
;;;171      buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
;;;172      if (buf == NULL) {
;;;173        pbuf_free(p);
;;;174        return;
;;;175      } else {
;;;176        buf->p = p;
;;;177        buf->ptr = p;
;;;178        ip_addr_set(&buf->addr, addr);
;;;179        buf->port = port;
;;;180    #if LWIP_NETBUF_RECVINFO
;;;181        {
;;;182          const struct ip_hdr* iphdr = ip_current_header();
;;;183          /* get the UDP header - always in the first pbuf, ensured by udp_input */
;;;184          const struct udp_hdr* udphdr = (void*)(((char*)iphdr) + IPH_LEN(iphdr));
;;;185    #if LWIP_CHECKSUM_ON_COPY
;;;186          buf->flags = NETBUF_FLAG_DESTADDR;
;;;187    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;188          ip_addr_set(&buf->toaddr, ip_current_dest_addr());
;;;189          buf->toport_chksum = udphdr->dest;
;;;190        }
;;;191    #endif /* LWIP_NETBUF_RECVINFO */
;;;192      }
;;;193    
;;;194      len = p->tot_len;
;;;195      if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
;;;196        netbuf_delete(buf);
;;;197        return;
;;;198      } else {
;;;199    #if LWIP_SO_RCVBUF
;;;200        SYS_ARCH_INC(conn->recv_avail, len);
;;;201    #endif /* LWIP_SO_RCVBUF */
;;;202        /* Register event with callback */
;;;203        API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
;;;204      }
;;;205    }
000070  e8bd9ff0          POP      {r4-r12,pc}
                  |L24.116|
000074  2007              MOVS     r0,#7                 ;171
000076  f7fffffe          BL       memp_malloc
00007a  4604              MOV      r4,r0                 ;171
00007c  b91c              CBNZ     r4,|L24.134|
00007e  4630              MOV      r0,r6                 ;173
000080  f7fffffe          BL       pbuf_free
000084  e7f4              B        |L24.112|
                  |L24.134|
000086  6026              STR      r6,[r4,#0]            ;176
000088  6066              STR      r6,[r4,#4]            ;177
00008a  f1b90f00          CMP      r9,#0                 ;178
00008e  d101              BNE      |L24.148|
000090  2000              MOVS     r0,#0                 ;178
000092  e001              B        |L24.152|
                  |L24.148|
000094  f8d90000          LDR      r0,[r9,#0]            ;178
                  |L24.152|
000098  60a0              STR      r0,[r4,#8]            ;178
00009a  f8a4b00c          STRH     r11,[r4,#0xc]         ;179
00009e  f8b6a008          LDRH     r10,[r6,#8]           ;194
0000a2  4621              MOV      r1,r4                 ;195
0000a4  f1050010          ADD      r0,r5,#0x10           ;195
0000a8  f7fffffe          BL       sys_mbox_trypost
0000ac  b118              CBZ      r0,|L24.182|
0000ae  4620              MOV      r0,r4                 ;196
0000b0  f7fffffe          BL       netbuf_delete
0000b4  e7dc              B        |L24.112|
                  |L24.182|
0000b6  6ae8              LDR      r0,[r5,#0x2c]         ;203
0000b8  b120              CBZ      r0,|L24.196|
0000ba  4652              MOV      r2,r10                ;203
0000bc  2100              MOVS     r1,#0                 ;203
0000be  4628              MOV      r0,r5                 ;203
0000c0  6aeb              LDR      r3,[r5,#0x2c]         ;203
0000c2  4798              BLX      r3                    ;203
                  |L24.196|
0000c4  bf00              NOP      
0000c6  e7d3              B        |L24.112|
;;;206    #endif /* LWIP_UDP */
                          ENDP

                  |L24.200|
0000c8  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\api_msg.c",0
0000cc  5749505c
0000d0  6c776970
0000d4  2d312e34
0000d8  2e315c73
0000dc  72635c61
0000e0  70695c61
0000e4  70695f6d
0000e8  73672e63
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L24.240|
0000f0  72656376          DCB      "recv_udp must have a pcb argument",0
0000f4  5f756470
0000f8  206d7573
0000fc  74206861
000100  76652061
000104  20706362
000108  20617267
00010c  756d656e
000110  7400    
000112  00                DCB      0
000113  00                DCB      0
                  |L24.276|
000114  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000118  7274696f
00011c  6e202225
000120  73222066
000124  61696c65
000128  64206174
00012c  206c696e
000130  65202564
000134  20696e20
000138  25730d0a
00013c  00      
00013d  00                DCB      0
00013e  00                DCB      0
00013f  00                DCB      0
                  |L24.320|
000140  72656376          DCB      "recv_udp must have an argument",0
000144  5f756470
000148  206d7573
00014c  74206861
000150  76652061
000154  6e206172
000158  67756d65
00015c  6e7400  
00015f  00                DCB      0
                  |L24.352|
000160  72656376          DCB      "recv_udp: recv for wrong pcb!",0
000164  5f756470
000168  3a207265
00016c  63762066
000170  6f722077
000174  726f6e67
000178  20706362
00017c  2100    
00017e  00                DCB      0
00017f  00                DCB      0

                          AREA ||i.sent_tcp||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  sent_tcp PROC
;;;312    static err_t
;;;313    sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;314    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;315      struct netconn *conn = (struct netconn *)arg;
00000a  462c              MOV      r4,r5
;;;316    
;;;317      LWIP_UNUSED_ARG(pcb);
;;;318      LWIP_ASSERT("conn != NULL", (conn != NULL));
00000c  bf00              NOP      
00000e  b944              CBNZ     r4,|L25.34|
000010  bf00              NOP      
000012  a31a              ADR      r3,|L25.124|
000014  f44f729f          MOV      r2,#0x13e
000018  a122              ADR      r1,|L25.164|
00001a  a026              ADR      r0,|L25.180|
00001c  f7fffffe          BL       __2printf
000020  bf00              NOP      
                  |L25.34|
000022  bf00              NOP      
;;;319    
;;;320      if (conn->state == NETCONN_WRITE) {
000024  7860              LDRB     r0,[r4,#1]
000026  2801              CMP      r0,#1
000028  d103              BNE      |L25.50|
;;;321        do_writemore(conn);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       do_writemore
000030  e005              B        |L25.62|
                  |L25.50|
;;;322      } else if (conn->state == NETCONN_CLOSE) {
000032  7860              LDRB     r0,[r4,#1]
000034  2804              CMP      r0,#4
000036  d102              BNE      |L25.62|
;;;323        do_close_internal(conn);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       do_close_internal
                  |L25.62|
;;;324      }
;;;325    
;;;326      if (conn) {
00003e  b1d4              CBZ      r4,|L25.118|
;;;327        /* If the queued byte- or pbuf-count drops below the configured low-water limit,
;;;328           let select mark this pcb as writable again. */
;;;329        if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
000040  6860              LDR      r0,[r4,#4]
000042  b1c0              CBZ      r0,|L25.118|
000044  6860              LDR      r0,[r4,#4]
000046  f8b00066          LDRH     r0,[r0,#0x66]
00004a  f6403167          MOV      r1,#0xb67
00004e  4288              CMP      r0,r1
000050  dd11              BLE      |L25.118|
;;;330          (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
000052  6860              LDR      r0,[r4,#4]
000054  f8b00068          LDRH     r0,[r0,#0x68]
000058  2805              CMP      r0,#5
00005a  da0c              BGE      |L25.118|
;;;331          conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
00005c  f8940020          LDRB     r0,[r4,#0x20]
000060  f0200010          BIC      r0,r0,#0x10
000064  f8840020          STRB     r0,[r4,#0x20]
;;;332          API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
000068  6ae0              LDR      r0,[r4,#0x2c]
00006a  b120              CBZ      r0,|L25.118|
00006c  4632              MOV      r2,r6
00006e  2102              MOVS     r1,#2
000070  4620              MOV      r0,r4
000072  6ae3              LDR      r3,[r4,#0x2c]
000074  4798              BLX      r3
                  |L25.118|
;;;333        }
;;;334      }
;;;335      
;;;336      return ERR_OK;
000076  2000              MOVS     r0,#0
;;;337    }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;338    
                          ENDP

                  |L25.124|
00007c  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\api_msg.c",0
000080  5749505c
000084  6c776970
000088  2d312e34
00008c  2e315c73
000090  72635c61
000094  70695c61
000098  70695f6d
00009c  73672e63
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L25.164|
0000a4  636f6e6e          DCB      "conn != NULL",0
0000a8  20213d20
0000ac  4e554c4c
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L25.180|
0000b4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000b8  7274696f
0000bc  6e202225
0000c0  73222066
0000c4  61696c65
0000c8  64206174
0000cc  206c696e
0000d0  65202564
0000d4  20696e20
0000d8  25730d0a
0000dc  00      
0000dd  00                DCB      0
0000de  00                DCB      0
0000df  00                DCB      0

                          AREA ||i.setup_tcp||, CODE, READONLY, ALIGN=2

                  setup_tcp PROC
;;;412    static void
;;;413    setup_tcp(struct netconn *conn)
000000  b570              PUSH     {r4-r6,lr}
;;;414    {
000002  4604              MOV      r4,r0
;;;415      struct tcp_pcb *pcb;
;;;416    
;;;417      pcb = conn->pcb.tcp;
000004  6865              LDR      r5,[r4,#4]
;;;418      tcp_arg(pcb, conn);
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       tcp_arg
;;;419      tcp_recv(pcb, recv_tcp);
00000e  4909              LDR      r1,|L26.52|
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       tcp_recv
;;;420      tcp_sent(pcb, sent_tcp);
000016  4908              LDR      r1,|L26.56|
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       tcp_sent
;;;421      tcp_poll(pcb, poll_tcp, 4);
00001e  2204              MOVS     r2,#4
000020  4906              LDR      r1,|L26.60|
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       tcp_poll
;;;422      tcp_err(pcb, err_tcp);
000028  4905              LDR      r1,|L26.64|
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       tcp_err
;;;423    }
000030  bd70              POP      {r4-r6,pc}
;;;424    
                          ENDP

000032  0000              DCW      0x0000
                  |L26.52|
                          DCD      recv_tcp
                  |L26.56|
                          DCD      sent_tcp
                  |L26.60|
                          DCD      poll_tcp
                  |L26.64|
                          DCD      err_tcp
