; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\delay.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\delay.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\delay.crf ..\SYSTEM\delay\delay.c]
                          THUMB

                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=1

                  SysTick_Handler PROC
;;;31     //systick中断服务函数,使用freertos时用到
;;;32     void SysTick_Handler(void)
000000  b510              PUSH     {r4,lr}
;;;33     {	
;;;34         if(xTaskGetSchedulerState()!=taskSCHEDULER_NOT_STARTED)//系统已经运行
000002  f7fffffe          BL       xTaskGetSchedulerState
000006  2801              CMP      r0,#1
000008  d001              BEQ      |L1.14|
;;;35         {
;;;36             xPortSysTickHandler();	
00000a  f7fffffe          BL       xPortSysTickHandler
                  |L1.14|
;;;37         }
;;;38        xTaskGetTickCount();
00000e  f7fffffe          BL       xTaskGetTickCount
;;;39     }
000012  bd10              POP      {r4,pc}
;;;40     			   
                          ENDP


                          AREA ||i.delay_init||, CODE, READONLY, ALIGN=2

                  delay_init PROC
;;;44     //SYSCLK:系统时钟频率
;;;45     void delay_init()
000000  b510              PUSH     {r4,lr}
;;;46     {
;;;47     	u32 reload;
;;;48     	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);//选择外部时钟  HCLK
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       SysTick_CLKSourceConfig
;;;49     	fac_us=SystemCoreClock/1000000;				//不论是否使用OS,fac_us都需要使用
000008  4810              LDR      r0,|L2.76|
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  4910              LDR      r1,|L2.80|
00000e  fbb0f0f1          UDIV     r0,r0,r1
000012  4910              LDR      r1,|L2.84|
000014  7008              STRB     r0,[r1,#0]
;;;50     	reload=SystemCoreClock/1000000;				//每秒钟的计数次数 单位为M  
000016  480d              LDR      r0,|L2.76|
000018  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00001a  490d              LDR      r1,|L2.80|
00001c  fbb0f4f1          UDIV     r4,r0,r1
;;;51     	reload*=1000000/configTICK_RATE_HZ;			//根据configTICK_RATE_HZ设定溢出时间
000020  f44f707a          MOV      r0,#0x3e8
000024  4344              MULS     r4,r0,r4
;;;52     												//reload为24位寄存器,最大值:16777216,在72M下,约合0.233s左右	
;;;53     	fac_ms=1000/configTICK_RATE_HZ;				//代表OS可以延时的最少单位	   
000026  2001              MOVS     r0,#1
000028  490b              LDR      r1,|L2.88|
00002a  8008              STRH     r0,[r1,#0]
;;;54     
;;;55     	SysTick->CTRL|=SysTick_CTRL_TICKINT_Msk;   	//开启SYSTICK中断
00002c  f04f20e0          MOV      r0,#0xe000e000
000030  6900              LDR      r0,[r0,#0x10]
000032  f0400002          ORR      r0,r0,#2
000036  f04f21e0          MOV      r1,#0xe000e000
00003a  6108              STR      r0,[r1,#0x10]
;;;56     	SysTick->LOAD=reload; 						//每1/configTICK_RATE_HZ秒中断一次	
00003c  4608              MOV      r0,r1
00003e  6144              STR      r4,[r0,#0x14]
;;;57     	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk;   	//开启SYSTICK    
000040  6900              LDR      r0,[r0,#0x10]
000042  f0400001          ORR      r0,r0,#1
000046  6108              STR      r0,[r1,#0x10]
;;;58     }								    
000048  bd10              POP      {r4,pc}
;;;59     
                          ENDP

00004a  0000              DCW      0x0000
                  |L2.76|
                          DCD      SystemCoreClock
                  |L2.80|
                          DCD      0x000f4240
                  |L2.84|
                          DCD      fac_us
                  |L2.88|
                          DCD      fac_ms

                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=2

                  delay_ms PROC
;;;85     //nms:0~65535
;;;86     void delay_ms(u32 nms)
000000  b570              PUSH     {r4-r6,lr}
;;;87     {	
000002  4604              MOV      r4,r0
;;;88     	if(xTaskGetSchedulerState()!=taskSCHEDULER_NOT_STARTED)//系统已经运行
000004  f7fffffe          BL       xTaskGetSchedulerState
000008  2801              CMP      r0,#1
00000a  d010              BEQ      |L3.46|
;;;89     	{		
;;;90     		if(nms>=fac_ms)						//延时的时间大于OS的最少时间周期 
00000c  480b              LDR      r0,|L3.60|
00000e  8800              LDRH     r0,[r0,#0]  ; fac_ms
000010  4284              CMP      r4,r0
000012  d306              BCC      |L3.34|
;;;91     		{ 
;;;92        			vTaskDelay(nms/fac_ms);	 		//FreeRTOS延时
000014  4809              LDR      r0,|L3.60|
000016  8800              LDRH     r0,[r0,#0]  ; fac_ms
000018  fbb4f5f0          UDIV     r5,r4,r0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       vTaskDelay
                  |L3.34|
;;;93     		}
;;;94     		nms%=fac_ms;						//OS已经无法提供这么小的延时了,采用普通方式延时    
000022  4806              LDR      r0,|L3.60|
000024  8800              LDRH     r0,[r0,#0]  ; fac_ms
000026  fbb4f1f0          UDIV     r1,r4,r0
00002a  fb004411          MLS      r4,r0,r1,r4
                  |L3.46|
;;;95     	}
;;;96     	delay_us((u32)(nms*1000));				//普通方式延时
00002e  f44f717a          MOV      r1,#0x3e8
000032  fb04f001          MUL      r0,r4,r1
000036  f7fffffe          BL       delay_us
;;;97     }
00003a  bd70              POP      {r4-r6,pc}
;;;98     
                          ENDP

                  |L3.60|
                          DCD      fac_ms

                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=2

                  delay_us PROC
;;;63     //nus:0~204522252(最大值即2^32/fac_us@fac_us=168)	    								   
;;;64     void delay_us(u32 nus)
000000  b570              PUSH     {r4-r6,lr}
;;;65     {		
000002  4603              MOV      r3,r0
;;;66     	u32 ticks;
;;;67     	u32 told,tnow,tcnt=0;
000004  2200              MOVS     r2,#0
;;;68     	u32 reload=SysTick->LOAD;				//LOAD的值	    	 
000006  f04f26e0          MOV      r6,#0xe000e000
00000a  6975              LDR      r5,[r6,#0x14]
;;;69     	ticks=nus*fac_us; 						//需要的节拍数 
00000c  4e0d              LDR      r6,|L4.68|
00000e  7836              LDRB     r6,[r6,#0]  ; fac_us
000010  fb03f406          MUL      r4,r3,r6
;;;70     	told=SysTick->VAL;        				//刚进入时的计数器值
000014  f04f26e0          MOV      r6,#0xe000e000
000018  69b1              LDR      r1,[r6,#0x18]
;;;71     	while(1)
00001a  e010              B        |L4.62|
                  |L4.28|
;;;72     	{
;;;73     		tnow=SysTick->VAL;	
00001c  f04f26e0          MOV      r6,#0xe000e000
000020  69b0              LDR      r0,[r6,#0x18]
;;;74     		if(tnow!=told)
000022  4288              CMP      r0,r1
000024  d00b              BEQ      |L4.62|
;;;75     		{	    
;;;76     			if(tnow<told)tcnt+=told-tnow;	//这里注意一下SYSTICK是一个递减的计数器就可以了.
000026  4288              CMP      r0,r1
000028  d202              BCS      |L4.48|
00002a  1a0e              SUBS     r6,r1,r0
00002c  4432              ADD      r2,r2,r6
00002e  e002              B        |L4.54|
                  |L4.48|
;;;77     			else tcnt+=reload-tnow+told;	    
000030  1a2e              SUBS     r6,r5,r0
000032  440e              ADD      r6,r6,r1
000034  4432              ADD      r2,r2,r6
                  |L4.54|
;;;78     			told=tnow;
000036  4601              MOV      r1,r0
;;;79     			if(tcnt>=ticks)break;			//时间超过/等于要延迟的时间,则退出.
000038  42a2              CMP      r2,r4
00003a  d300              BCC      |L4.62|
00003c  e000              B        |L4.64|
                  |L4.62|
00003e  e7ed              B        |L4.28|
                  |L4.64|
000040  bf00              NOP      
;;;80     		}  
;;;81     	};										    
;;;82     }  
000042  bd70              POP      {r4-r6,pc}
;;;83     //延时nms
                          ENDP

                  |L4.68|
                          DCD      fac_us

                          AREA ||i.delay_xms||, CODE, READONLY, ALIGN=1

                  delay_xms PROC
;;;100    //nms:要延时的ms数
;;;101    void delay_xms(u32 nms)
000000  b530              PUSH     {r4,r5,lr}
;;;102    {
000002  4604              MOV      r4,r0
;;;103    	u32 i;
;;;104    	for(i=0;i<nms;i++) delay_us(1000);
000004  2500              MOVS     r5,#0
000006  e004              B        |L5.18|
                  |L5.8|
000008  f44f707a          MOV      r0,#0x3e8
00000c  f7fffffe          BL       delay_us
000010  1c6d              ADDS     r5,r5,#1
                  |L5.18|
000012  42a5              CMP      r5,r4
000014  d3f8              BCC      |L5.8|
;;;105    }
000016  bd30              POP      {r4,r5,pc}
;;;106    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  fac_us
000000  0000              DCB      0x00,0x00
                  fac_ms
000002  0000              DCW      0x0000
