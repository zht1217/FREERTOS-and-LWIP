; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\sys_arch.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\sys_arch.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\sys_arch.crf ..\LWIP\arch\sys_arch.c]
                          THUMB

                          AREA ||i.sys_arch_mbox_fetch||, CODE, READONLY, ALIGN=1

                  sys_arch_mbox_fetch PROC
;;;126    //		失败的话就返回超时SYS_ARCH_TIMEOUT
;;;127    u32_t sys_arch_mbox_fetch (sys_mbox_t *mbox, void **msg, u32_t timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;128    { 
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;129    	void* dummyptr;
;;;130        portTickType StartTime, EndTime, Elapsed;
;;;131        StartTime = xTaskGetTickCount();
00000a  f7fffffe          BL       xTaskGetTickCount
00000e  4681              MOV      r9,r0
;;;132        if (msg == NULL) 
000010  b907              CBNZ     r7,|L1.20|
;;;133        {
;;;134            msg=&dummyptr;
000012  466f              MOV      r7,sp
                  |L1.20|
;;;135        }
;;;136        if (timeout != 0)
000014  f1b80f00          CMP      r8,#0
000018  d013              BEQ      |L1.66|
;;;137        {
;;;138            if (pdTRUE == xQueueReceive(mbox->xQueue,&(*msg),timeout/portTICK_RATE_MS))
00001a  2300              MOVS     r3,#0
00001c  4642              MOV      r2,r8
00001e  4639              MOV      r1,r7
000020  6830              LDR      r0,[r6,#0]
000022  f7fffffe          BL       xQueueGenericReceive
000026  2801              CMP      r0,#1
000028  d107              BNE      |L1.58|
;;;139            {
;;;140                EndTime = xTaskGetTickCount();
00002a  f7fffffe          BL       xTaskGetTickCount
00002e  4605              MOV      r5,r0
;;;141                Elapsed = (EndTime - StartTime) * portTICK_RATE_MS;
000030  eba50409          SUB      r4,r5,r9
;;;142                return Elapsed;
000034  4620              MOV      r0,r4
                  |L1.54|
;;;143            }
;;;144            else  //超时就退出
;;;145            {
;;;146                *msg = NULL;
;;;147                return SYS_ARCH_TIMEOUT;
;;;148            }
;;;149            
;;;150        }
;;;151        else
;;;152        {
;;;153            while (pdTRUE != xQueueReceive(mbox->xQueue, &(*msg),portMAX_DELAY))
;;;154            {
;;;155            }
;;;156            EndTime = xTaskGetTickCount();
;;;157            Elapsed = (EndTime - StartTime) * portTICK_RATE_MS;
;;;158            return Elapsed;
;;;159        }
;;;160    }
000036  e8bd83f8          POP      {r3-r9,pc}
                  |L1.58|
00003a  2000              MOVS     r0,#0                 ;146
00003c  6038              STR      r0,[r7,#0]            ;146
00003e  1e40              SUBS     r0,r0,#1              ;147
000040  e7f9              B        |L1.54|
                  |L1.66|
000042  bf00              NOP                            ;153
                  |L1.68|
000044  2300              MOVS     r3,#0                 ;153
000046  1e5a              SUBS     r2,r3,#1              ;153
000048  4639              MOV      r1,r7                 ;153
00004a  6830              LDR      r0,[r6,#0]            ;153
00004c  f7fffffe          BL       xQueueGenericReceive
000050  2801              CMP      r0,#1                 ;153
000052  d1f7              BNE      |L1.68|
000054  f7fffffe          BL       xTaskGetTickCount
000058  4605              MOV      r5,r0                 ;156
00005a  eba50409          SUB      r4,r5,r9              ;157
00005e  4620              MOV      r0,r4                 ;158
000060  e7e9              B        |L1.54|
;;;161        
                          ENDP


                          AREA ||i.sys_arch_mbox_tryfetch||, CODE, READONLY, ALIGN=1

                  sys_arch_mbox_tryfetch PROC
;;;220    //返回值:等待消息所用的时间/SYS_ARCH_TIMEOUT
;;;221    u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
000000  b538              PUSH     {r3-r5,lr}
;;;222    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;223        void* dummyptr;
;;;224        if (msg == NULL)
000006  b905              CBNZ     r5,|L2.10|
;;;225        {
;;;226            msg = &dummyptr;
000008  466d              MOV      r5,sp
                  |L2.10|
;;;227        }
;;;228         if (pdTRUE == xQueueReceive(mbox->xQueue,&(*msg),0))
00000a  2300              MOVS     r3,#0
00000c  461a              MOV      r2,r3
00000e  4629              MOV      r1,r5
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       xQueueGenericReceive
000016  2801              CMP      r0,#1
000018  d101              BNE      |L2.30|
;;;229         {
;;;230             return ERR_OK;
00001a  2000              MOVS     r0,#0
                  |L2.28|
;;;231         }
;;;232         else
;;;233         {
;;;234             return SYS_MBOX_EMPTY;
;;;235         }
;;;236    }
00001c  bd38              POP      {r3-r5,pc}
                  |L2.30|
00001e  f04f30ff          MOV      r0,#0xffffffff        ;234
000022  e7fb              B        |L2.28|
;;;237    
                          ENDP


                          AREA ||i.sys_arch_protect||, CODE, READONLY, ALIGN=1

                  sys_arch_protect PROC
;;;431    }
;;;432    sys_prot_t sys_arch_protect(void)
000000  b510              PUSH     {r4,lr}
;;;433    {
;;;434        vPortEnterCritical();
000002  f7fffffe          BL       vPortEnterCritical
;;;435        return 1;
000006  2001              MOVS     r0,#1
;;;436    }
000008  bd10              POP      {r4,pc}
;;;437    void sys_arch_unprotect(sys_prot_t pval)
                          ENDP


                          AREA ||i.sys_arch_sem_wait||, CODE, READONLY, ALIGN=1

                  sys_arch_sem_wait PROC
;;;292    //		失败的话就返回超时SYS_ARCH_TIMEOUT
;;;293    u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;294    { 
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;295        portTickType StartTime, EndTime, Elapsed;
;;;296        StartTime = xTaskGetTickCount();
000008  f7fffffe          BL       xTaskGetTickCount
00000c  4680              MOV      r8,r0
;;;297        if (timeout != 0)
00000e  b197              CBZ      r7,|L4.54|
;;;298        {
;;;299            if (xSemaphoreTake(*sem, timeout/portTICK_RATE_MS) == pdTRUE)
000010  2300              MOVS     r3,#0
000012  463a              MOV      r2,r7
000014  4619              MOV      r1,r3
000016  6830              LDR      r0,[r6,#0]
000018  f7fffffe          BL       xQueueGenericReceive
00001c  2801              CMP      r0,#1
00001e  d107              BNE      |L4.48|
;;;300            {
;;;301                EndTime = xTaskGetTickCount();
000020  f7fffffe          BL       xTaskGetTickCount
000024  4605              MOV      r5,r0
;;;302                Elapsed = (EndTime - StartTime) * portTICK_RATE_MS;
000026  eba50408          SUB      r4,r5,r8
;;;303                return Elapsed;
00002a  4620              MOV      r0,r4
                  |L4.44|
;;;304            }
;;;305            else
;;;306            {
;;;307                return SYS_ARCH_TIMEOUT;
;;;308            }
;;;309        }
;;;310        else
;;;311        {
;;;312            while (xSemaphoreTake(*sem, portMAX_DELAY) != pdTRUE)
;;;313            {
;;;314            }
;;;315            EndTime = xTaskGetTickCount(); 
;;;316            Elapsed = (EndTime - StartTime) * portTICK_RATE_MS;
;;;317            return Elapsed;
;;;318        }
;;;319    }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L4.48|
000030  f04f30ff          MOV      r0,#0xffffffff        ;307
000034  e7fa              B        |L4.44|
                  |L4.54|
000036  bf00              NOP                            ;312
                  |L4.56|
000038  2300              MOVS     r3,#0                 ;312
00003a  1e5a              SUBS     r2,r3,#1              ;312
00003c  4619              MOV      r1,r3                 ;312
00003e  6830              LDR      r0,[r6,#0]            ;312
000040  f7fffffe          BL       xQueueGenericReceive
000044  2801              CMP      r0,#1                 ;312
000046  d1f7              BNE      |L4.56|
000048  f7fffffe          BL       xTaskGetTickCount
00004c  4605              MOV      r5,r0                 ;315
00004e  eba50408          SUB      r4,r5,r8              ;316
000052  4620              MOV      r0,r4                 ;317
000054  e7ea              B        |L4.44|
;;;320    //	u32_t rtos_timeout, timeout_new;
                          ENDP


                          AREA ||i.sys_arch_unprotect||, CODE, READONLY, ALIGN=1

                  sys_arch_unprotect PROC
;;;436    }
;;;437    void sys_arch_unprotect(sys_prot_t pval)
000000  b510              PUSH     {r4,lr}
;;;438    {
000002  4604              MOV      r4,r0
;;;439        (void) pval;
;;;440        vPortExitCritical();
000004  f7fffffe          BL       vPortExitCritical
;;;441    }
000008  bd10              POP      {r4,pc}
;;;442    
                          ENDP


                          AREA ||i.sys_init||, CODE, READONLY, ALIGN=1

                  sys_init PROC
;;;390    //arch初始化
;;;391    void sys_init(void)
000000  4770              BX       lr
;;;392    { 
;;;393        //这里,我们在该函数,不做任何事情
;;;394    } 
;;;395    
                          ENDP


                          AREA ||i.sys_mbox_free||, CODE, READONLY, ALIGN=1

                  sys_mbox_free PROC
;;;66     //*mbox:要删除的消息邮箱
;;;67     void sys_mbox_free(sys_mbox_t *mbox)
000000  b510              PUSH     {r4,lr}
;;;68     {
000002  4604              MOV      r4,r0
;;;69     	vQueueDelete(mbox->xQueue);
000004  6820              LDR      r0,[r4,#0]
000006  f7fffffe          BL       vQueueDelete
;;;70     //	LWIP_ASSERT( "OSQDel ",mbox->xQueue == NULL ); 
;;;71     	mbox->xQueue=NULL;
00000a  2000              MOVS     r0,#0
00000c  6020              STR      r0,[r4,#0]
;;;72     }
00000e  bd10              POP      {r4,pc}
;;;73     
                          ENDP


                          AREA ||i.sys_mbox_new||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  sys_mbox_new PROC
;;;53     //         其他,创建失败
;;;54     err_t  sys_mbox_new(sys_mbox_t *mbox,int size)
000000  b570              PUSH     {r4-r6,lr}
;;;55     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;56         
;;;57     	if(size>MAX_QUEUE_ENTRIES)size=MAX_QUEUE_ENTRIES;		//消息队列最多容纳MAX_QUEUE_ENTRIES消息数目
000006  2d14              CMP      r5,#0x14
000008  dd00              BLE      |L8.12|
00000a  2514              MOVS     r5,#0x14
                  |L8.12|
;;;58      	mbox->xQueue = xQueueCreate(size, sizeof(void *));  		//创建消息队列，该消息队列存放指针
00000c  2200              MOVS     r2,#0
00000e  2104              MOVS     r1,#4
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       xQueueGenericCreate
000016  6020              STR      r0,[r4,#0]
;;;59     	LWIP_ASSERT("OSQCreate",mbox->xQueue!=NULL); 
000018  bf00              NOP      
00001a  6820              LDR      r0,[r4,#0]
00001c  b938              CBNZ     r0,|L8.46|
00001e  bf00              NOP      
000020  a307              ADR      r3,|L8.64|
000022  223b              MOVS     r2,#0x3b
000024  a10c              ADR      r1,|L8.88|
000026  a00f              ADR      r0,|L8.100|
000028  f7fffffe          BL       __2printf
00002c  bf00              NOP      
                  |L8.46|
00002e  bf00              NOP      
;;;60     	if(mbox->xQueue!=NULL)return ERR_OK;  //返回ERR_OK,表示消息队列创建成功 ERR_OK=0
000030  6820              LDR      r0,[r4,#0]
000032  b108              CBZ      r0,|L8.56|
000034  2000              MOVS     r0,#0
                  |L8.54|
;;;61     	else 
;;;62     		return ERR_MEM;  				//消息队列创建错误
;;;63     } 
000036  bd70              POP      {r4-r6,pc}
                  |L8.56|
000038  f04f30ff          MOV      r0,#0xffffffff        ;62
00003c  e7fb              B        |L8.54|
;;;64     
                          ENDP

00003e  0000              DCW      0x0000
                  |L8.64|
000040  2e2e5c4c          DCB      "..\\LWIP\\arch\\sys_arch.c",0
000044  5749505c
000048  61726368
00004c  5c737973
000050  5f617263
000054  682e6300
                  |L8.88|
000058  4f535143          DCB      "OSQCreate",0
00005c  72656174
000060  6500    
000062  00                DCB      0
000063  00                DCB      0
                  |L8.100|
000064  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000068  7274696f
00006c  6e202225
000070  73222066
000074  61696c65
000078  64206174
00007c  206c696e
000080  65202564
000084  20696e20
000088  25730d0a
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||i.sys_mbox_post||, CODE, READONLY, ALIGN=1

                  sys_mbox_post PROC
;;;76     //msg:要发送的消息
;;;77     void sys_mbox_post(sys_mbox_t *mbox,void* msg)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;78     {	 
000002  4604              MOV      r4,r0
;;;79     	//BaseType_t xHigherPriorityTaskWoken = pdFALSE;
;;;80     	//if(msg==NULL)
;;;81     	//	msg= (void*)&NullMessage;  //当msg为空时 msg等于pvNullPointer指向的值 
;;;82     	//if((SCB_ICSR_REG&0xFF) == 0)  //线程执行
;;;83     	//{
;;;84     		while(xQueueSendToBack(mbox->xQueue, &msg, portMAX_DELAY) != pdTRUE)
000004  bf00              NOP      
                  |L9.6|
000006  2300              MOVS     r3,#0
000008  1e5a              SUBS     r2,r3,#1
00000a  a901              ADD      r1,sp,#4
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       xQueueGenericSend
000012  2801              CMP      r0,#1
000014  d1f7              BNE      |L9.6|
;;;85             {}//portMAX_DELAY,死等直到发送成功
;;;86     	//}
;;;87     	//else
;;;88     	////{
;;;89     	//	while(xQueueSendToBackFromISR(mbox->xQueue, &msg, &xHigherPriorityTaskWoken) != pdPASS);
;;;90     		//portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
;;;91     	//}
;;;92     }
000016  bd1c              POP      {r2-r4,pc}
;;;93     
                          ENDP


                          AREA ||i.sys_mbox_set_invalid||, CODE, READONLY, ALIGN=1

                  sys_mbox_set_invalid PROC
;;;252    //*mbox:消息邮箱
;;;253    void sys_mbox_set_invalid(sys_mbox_t *mbox)
000000  2100              MOVS     r1,#0
;;;254    {
;;;255    	mbox->xQueue=NULL;
000002  6001              STR      r1,[r0,#0]
;;;256    } 
000004  4770              BX       lr
;;;257    
                          ENDP


                          AREA ||i.sys_mbox_trypost||, CODE, READONLY, ALIGN=1

                  sys_mbox_trypost PROC
;;;100    // 	     ERR_MEM,发送失败
;;;101    err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;102    { 
000002  4605              MOV      r5,r0
;;;103    	//BaseType_t xHigherPriorityTaskWoken = pdFALSE;
;;;104    //	if(msg==NULL)
;;;105    	//	msg= (void*)&NullMessage;//当消息为空，则用常量NullMessage的地址替换
;;;106    	//if((SCB_ICSR_REG&0xFF) == 0)
;;;107    	//{
;;;108        err_t result;
;;;109    		if(xQueueSend(mbox->xQueue, &msg, 0)== pdPASS){
000004  2300              MOVS     r3,#0
000006  461a              MOV      r2,r3
000008  a901              ADD      r1,sp,#4
00000a  6828              LDR      r0,[r5,#0]
00000c  f7fffffe          BL       xQueueGenericSend
000010  2801              CMP      r0,#1
000012  d101              BNE      |L11.24|
;;;110    			result = ERR_OK;
000014  2400              MOVS     r4,#0
000016  e001              B        |L11.28|
                  |L11.24|
;;;111    	}
;;;112    	else
;;;113    	{
;;;114    		//if(xQueueSendToBackFromISR(mbox->xQueue, &msg, &xHigherPriorityTaskWoken)!= pdPASS)
;;;115    			result = ERR_MEM;
000018  f04f34ff          MOV      r4,#0xffffffff
                  |L11.28|
;;;116    	//	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
;;;117    	}
;;;118    	return result;
00001c  4620              MOV      r0,r4
;;;119    }
00001e  bd7c              POP      {r2-r6,pc}
;;;120    
                          ENDP


                          AREA ||i.sys_mbox_valid||, CODE, READONLY, ALIGN=1

                  sys_mbox_valid PROC
;;;241    //      0,无效
;;;242    int sys_mbox_valid(sys_mbox_t *mbox)
000000  4601              MOV      r1,r0
;;;243    {  
;;;244    	if(mbox->xQueue != NULL)
000002  6808              LDR      r0,[r1,#0]
000004  b108              CBZ      r0,|L12.10|
;;;245    	{
;;;246    	   return 1;
000006  2001              MOVS     r0,#1
                  |L12.8|
;;;247    	}		
;;;248    	return 0;
;;;249    } 
000008  4770              BX       lr
                  |L12.10|
00000a  2000              MOVS     r0,#0                 ;248
00000c  e7fc              B        |L12.8|
;;;250    
                          ENDP


                          AREA ||i.sys_msleep1||, CODE, READONLY, ALIGN=1

                  sys_msleep1 PROC
;;;418    //ms:要延时的ms数
;;;419    void sys_msleep1(u32_t ms)
000000  b510              PUSH     {r4,lr}
;;;420    {
000002  4604              MOV      r4,r0
;;;421    	delay_ms(ms);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       delay_ms
;;;422    }
00000a  bd10              POP      {r4,pc}
;;;423    
                          ENDP


                          AREA ||i.sys_now||, CODE, READONLY, ALIGN=1

                  sys_now PROC
;;;425    //返回值:当前系统时间(单位:毫秒)
;;;426    u32_t sys_now(void)
000000  b510              PUSH     {r4,lr}
;;;427    {
;;;428    	u32_t lwip_time;
;;;429    	lwip_time=(xTaskGetTickCount()*1000/configTICK_RATE_HZ+1);//将节拍数转换为LWIP的时间MS
000002  f7fffffe          BL       xTaskGetTickCount
000006  f44f717a          MOV      r1,#0x3e8
00000a  4348              MULS     r0,r1,r0
00000c  fbb0f0f1          UDIV     r0,r0,r1
000010  1c44              ADDS     r4,r0,#1
;;;430    	return lwip_time; 		//返回lwip_time;
000012  4620              MOV      r0,r4
;;;431    }
000014  bd10              POP      {r4,pc}
;;;432    sys_prot_t sys_arch_protect(void)
                          ENDP


                          AREA ||i.sys_sem_free||, CODE, READONLY, ALIGN=1

                  sys_sem_free PROC
;;;364    //sem:信号量指针
;;;365    void sys_sem_free(sys_sem_t *sem)
000000  b510              PUSH     {r4,lr}
;;;366    {
000002  4604              MOV      r4,r0
;;;367    	vSemaphoreDelete(*sem); 
000004  6820              LDR      r0,[r4,#0]
000006  f7fffffe          BL       vQueueDelete
;;;368    	*sem = NULL;
00000a  2000              MOVS     r0,#0
00000c  6020              STR      r0,[r4,#0]
;;;369    }
00000e  bd10              POP      {r4,pc}
;;;370    
                          ENDP


                          AREA ||i.sys_sem_new||, CODE, READONLY, ALIGN=1

                  sys_sem_new PROC
;;;262    // 	     ERR_MEM,创建失败
;;;263    err_t sys_sem_new(sys_sem_t* sem, u8_t count)
000000  b570              PUSH     {r4-r6,lr}
;;;264    {  
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;265        *sem = xSemaphoreCreateCounting(0xFF, count);
000006  4629              MOV      r1,r5
000008  20ff              MOVS     r0,#0xff
00000a  f7fffffe          BL       xQueueCreateCountingSemaphore
00000e  6020              STR      r0,[r4,#0]
;;;266    	if (*sem == NULL)
000010  6820              LDR      r0,[r4,#0]
000012  b910              CBNZ     r0,|L16.26|
;;;267        {
;;;268          
;;;269        return ERR_MEM;
000014  f04f30ff          MOV      r0,#0xffffffff
                  |L16.24|
;;;270        }
;;;271        else 
;;;272        {
;;;273    	return ERR_OK;
;;;274        }
;;;275    } 
000018  bd70              POP      {r4-r6,pc}
                  |L16.26|
00001a  2000              MOVS     r0,#0                 ;273
00001c  e7fc              B        |L16.24|
;;;276    
                          ENDP


                          AREA ||i.sys_sem_set_invalid||, CODE, READONLY, ALIGN=1

                  sys_sem_set_invalid PROC
;;;384    //sem:信号量指针
;;;385    void sys_sem_set_invalid(sys_sem_t *sem)
000000  2100              MOVS     r1,#0
;;;386    {
;;;387    	*sem=NULL;
000002  6001              STR      r1,[r0,#0]
;;;388    } 
000004  4770              BX       lr
;;;389    
                          ENDP


                          AREA ||i.sys_sem_signal||, CODE, READONLY, ALIGN=1

                  sys_sem_signal PROC
;;;356    //sem:信号量指针
;;;357    void sys_sem_signal(sys_sem_t *sem)
000000  b510              PUSH     {r4,lr}
;;;358    {
000002  4604              MOV      r4,r0
;;;359        xSemaphoreGive(*sem);
000004  2300              MOVS     r3,#0
000006  461a              MOV      r2,r3
000008  4619              MOV      r1,r3
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       xQueueGenericSend
;;;360    	
;;;361    }
000010  bd10              POP      {r4,pc}
;;;362    
                          ENDP


                          AREA ||i.sys_sem_valid||, CODE, READONLY, ALIGN=1

                  sys_sem_valid PROC
;;;374    //      0,无效
;;;375    int sys_sem_valid(sys_sem_t *sem)
000000  4601              MOV      r1,r0
;;;376    {
;;;377    	if(*sem != NULL)
000002  6808              LDR      r0,[r1,#0]
000004  b108              CBZ      r0,|L19.10|
;;;378        return 1;
000006  2001              MOVS     r0,#1
                  |L19.8|
;;;379      else
;;;380        return 0;		
;;;381    } 
000008  4770              BX       lr
                  |L19.10|
00000a  2000              MOVS     r0,#0                 ;380
00000c  e7fc              B        |L19.8|
;;;382    
                          ENDP


                          AREA ||i.sys_thread_new||, CODE, READONLY, ALIGN=2

                  sys_thread_new PROC
;;;403    TaskHandle_t LWIP_ThreadHandler;
;;;404    sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread, void *arg, int stacksize, int prio)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;405    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
00000c  9f08              LDR      r7,[sp,#0x20]
;;;406    	taskENTER_CRITICAL();  //进入临界区 
00000e  f7fffffe          BL       vPortEnterCritical
;;;407    	xTaskCreate((TaskFunction_t)thread,
000012  4807              LDR      r0,|L20.48|
000014  b2b2              UXTH     r2,r6
000016  2300              MOVS     r3,#0
000018  4621              MOV      r1,r4
00001a  e9cd7000          STRD     r7,r0,[sp,#0]
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       xTaskCreate
;;;408    						name,
;;;409    						(uint16_t     )stacksize,
;;;410    						(void*        )NULL,
;;;411    						(UBaseType_t  )prio,
;;;412    						(TaskHandle_t*)&LWIP_ThreadHandler);//创建TCP IP内核任务 
;;;413    	taskEXIT_CRITICAL();  //退出临界区
000024  f7fffffe          BL       vPortExitCritical
;;;414    	return 0;
000028  2000              MOVS     r0,#0
;;;415    } 
00002a  e8bd81fc          POP      {r2-r8,pc}
;;;416    
                          ENDP

00002e  0000              DCW      0x0000
                  |L20.48|
                          DCD      LWIP_ThreadHandler

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  NullMessage
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=2

                  LWIP_ThreadHandler
                          DCD      0x00000000
