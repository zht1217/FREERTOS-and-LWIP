; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\sockets.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\sockets.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\sockets.crf ..\LWIP\lwip-1.4.1\src\api\sockets.c]
                          THUMB

                          AREA ||i.alloc_socket||, CODE, READONLY, ALIGN=2

                  alloc_socket PROC
;;;242    static int
;;;243    alloc_socket(struct netconn *newconn, int accepted)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;244    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;245      int i;
;;;246      SYS_ARCH_DECL_PROTECT(lev);
;;;247    
;;;248      /* allocate a new socket identifier */
;;;249      for (i = 0; i < NUM_SOCKETS; ++i) {
000008  2400              MOVS     r4,#0
00000a  e047              B        |L1.156|
                  |L1.12|
;;;250        /* Protect socket array */
;;;251        SYS_ARCH_PROTECT(lev);
00000c  f7fffffe          BL       sys_arch_protect
000010  4607              MOV      r7,r0
;;;252        if (!sockets[i].conn) {
000012  eb040044          ADD      r0,r4,r4,LSL #1
000016  4924              LDR      r1,|L1.168|
000018  f8510030          LDR      r0,[r1,r0,LSL #3]
00001c  bbc8              CBNZ     r0,|L1.146|
;;;253          sockets[i].conn       = newconn;
00001e  eb040044          ADD      r0,r4,r4,LSL #1
000022  f8415030          STR      r5,[r1,r0,LSL #3]
;;;254          /* The socket is not yet known to anyone, so no need to protect
;;;255             after having marked it as used. */
;;;256          SYS_ARCH_UNPROTECT(lev);
000026  4638              MOV      r0,r7
000028  f7fffffe          BL       sys_arch_unprotect
;;;257          sockets[i].lastdata   = NULL;
00002c  2000              MOVS     r0,#0
00002e  eb040144          ADD      r1,r4,r4,LSL #1
000032  4a1d              LDR      r2,|L1.168|
000034  eb0201c1          ADD      r1,r2,r1,LSL #3
000038  6048              STR      r0,[r1,#4]
;;;258          sockets[i].lastoffset = 0;
00003a  eb040144          ADD      r1,r4,r4,LSL #1
00003e  eb0201c1          ADD      r1,r2,r1,LSL #3
000042  8108              STRH     r0,[r1,#8]
;;;259          sockets[i].rcvevent   = 0;
000044  eb040144          ADD      r1,r4,r4,LSL #1
000048  eb0201c1          ADD      r1,r2,r1,LSL #3
00004c  8148              STRH     r0,[r1,#0xa]
;;;260          /* TCP sendbuf is empty, but the socket is not yet writable until connected
;;;261           * (unless it has been created by accept()). */
;;;262          sockets[i].sendevent  = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
00004e  7828              LDRB     r0,[r5,#0]
000050  2810              CMP      r0,#0x10
000052  d104              BNE      |L1.94|
000054  b10e              CBZ      r6,|L1.90|
000056  2001              MOVS     r0,#1
000058  e002              B        |L1.96|
                  |L1.90|
00005a  2000              MOVS     r0,#0
00005c  e000              B        |L1.96|
                  |L1.94|
00005e  2001              MOVS     r0,#1
                  |L1.96|
000060  eb040144          ADD      r1,r4,r4,LSL #1
000064  4a10              LDR      r2,|L1.168|
000066  eb0201c1          ADD      r1,r2,r1,LSL #3
00006a  8188              STRH     r0,[r1,#0xc]
;;;263          sockets[i].errevent   = 0;
00006c  2000              MOVS     r0,#0
00006e  eb040144          ADD      r1,r4,r4,LSL #1
000072  eb0201c1          ADD      r1,r2,r1,LSL #3
000076  81c8              STRH     r0,[r1,#0xe]
;;;264          sockets[i].err        = 0;
000078  eb040144          ADD      r1,r4,r4,LSL #1
00007c  eb0201c1          ADD      r1,r2,r1,LSL #3
000080  6108              STR      r0,[r1,#0x10]
;;;265          sockets[i].select_waiting = 0;
000082  eb040144          ADD      r1,r4,r4,LSL #1
000086  eb0201c1          ADD      r1,r2,r1,LSL #3
00008a  6148              STR      r0,[r1,#0x14]
;;;266          return i;
00008c  4620              MOV      r0,r4
                  |L1.142|
;;;267        }
;;;268        SYS_ARCH_UNPROTECT(lev);
;;;269      }
;;;270      return -1;
;;;271    }
00008e  e8bd81f0          POP      {r4-r8,pc}
                  |L1.146|
000092  e7ff              B        |L1.148|
                  |L1.148|
000094  4638              MOV      r0,r7                 ;268
000096  f7fffffe          BL       sys_arch_unprotect
00009a  1c64              ADDS     r4,r4,#1              ;249
                  |L1.156|
00009c  2c04              CMP      r4,#4                 ;249
00009e  dbb5              BLT      |L1.12|
0000a0  f04f30ff          MOV      r0,#0xffffffff        ;270
0000a4  e7f3              B        |L1.142|
;;;272    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L1.168|
                          DCD      sockets

                          AREA ||i.event_callback||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  event_callback PROC
;;;1246   static void
;;;1247   event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1248   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;1249     int s;
;;;1250     struct lwip_sock *sock;
;;;1251     struct lwip_select_cb *scb;
;;;1252     int last_select_cb_ctr;
;;;1253     SYS_ARCH_DECL_PROTECT(lev);
;;;1254   
;;;1255     LWIP_UNUSED_ARG(len);
;;;1256   
;;;1257     /* Get socket */
;;;1258     if (conn) {
000008  b1ef              CBZ      r7,|L2.70|
;;;1259       s = conn->socket;
00000a  69bc              LDR      r4,[r7,#0x18]
;;;1260       if (s < 0) {
00000c  2c00              CMP      r4,#0
00000e  da14              BGE      |L2.58|
;;;1261         /* Data comes in right away after an accept, even though
;;;1262          * the server task might not have created a new socket yet.
;;;1263          * Just count down (or up) if that's the case and we
;;;1264          * will use the data later. Note that only receive events
;;;1265          * can happen before the new socket is set up. */
;;;1266         SYS_ARCH_PROTECT(lev);
000010  f7fffffe          BL       sys_arch_protect
000014  4683              MOV      r11,r0
;;;1267         if (conn->socket < 0) {
000016  69b8              LDR      r0,[r7,#0x18]
000018  2800              CMP      r0,#0
00001a  da0a              BGE      |L2.50|
;;;1268           if (evt == NETCONN_EVT_RCVPLUS) {
00001c  f1b80f00          CMP      r8,#0
000020  d102              BNE      |L2.40|
;;;1269             conn->socket--;
000022  69b8              LDR      r0,[r7,#0x18]
000024  1e40              SUBS     r0,r0,#1
000026  61b8              STR      r0,[r7,#0x18]
                  |L2.40|
;;;1270           }
;;;1271           SYS_ARCH_UNPROTECT(lev);
000028  4658              MOV      r0,r11
00002a  f7fffffe          BL       sys_arch_unprotect
                  |L2.46|
;;;1272           return;
;;;1273         }
;;;1274         s = conn->socket;
;;;1275         SYS_ARCH_UNPROTECT(lev);
;;;1276       }
;;;1277   
;;;1278       sock = get_socket(s);
;;;1279       if (!sock) {
;;;1280         return;
;;;1281       }
;;;1282     } else {
;;;1283       return;
;;;1284     }
;;;1285   
;;;1286     SYS_ARCH_PROTECT(lev);
;;;1287     /* Set event as required */
;;;1288     switch (evt) {
;;;1289       case NETCONN_EVT_RCVPLUS:
;;;1290         sock->rcvevent++;
;;;1291         break;
;;;1292       case NETCONN_EVT_RCVMINUS:
;;;1293         sock->rcvevent--;
;;;1294         break;
;;;1295       case NETCONN_EVT_SENDPLUS:
;;;1296         sock->sendevent = 1;
;;;1297         break;
;;;1298       case NETCONN_EVT_SENDMINUS:
;;;1299         sock->sendevent = 0;
;;;1300         break;
;;;1301       case NETCONN_EVT_ERROR:
;;;1302         sock->errevent = 1;
;;;1303         break;
;;;1304       default:
;;;1305         LWIP_ASSERT("unknown event", 0);
;;;1306         break;
;;;1307     }
;;;1308   
;;;1309     if (sock->select_waiting == 0) {
;;;1310       /* noone is waiting for this socket, no need to check select_cb_list */
;;;1311       SYS_ARCH_UNPROTECT(lev);
;;;1312       return;
;;;1313     }
;;;1314   
;;;1315     /* Now decide if anyone is waiting for this socket */
;;;1316     /* NOTE: This code goes through the select_cb_list list multiple times
;;;1317        ONLY IF a select was actually waiting. We go through the list the number
;;;1318        of waiting select calls + 1. This list is expected to be small. */
;;;1319   
;;;1320     /* At this point, SYS_ARCH is still protected! */
;;;1321   again:
;;;1322     for (scb = select_cb_list; scb != NULL; scb = scb->next) {
;;;1323       if (scb->sem_signalled == 0) {
;;;1324         /* semaphore not signalled yet */
;;;1325         int do_signal = 0;
;;;1326         /* Test this select call for our socket */
;;;1327         if (sock->rcvevent > 0) {
;;;1328           if (scb->readset && FD_ISSET(s, scb->readset)) {
;;;1329             do_signal = 1;
;;;1330           }
;;;1331         }
;;;1332         if (sock->sendevent != 0) {
;;;1333           if (!do_signal && scb->writeset && FD_ISSET(s, scb->writeset)) {
;;;1334             do_signal = 1;
;;;1335           }
;;;1336         }
;;;1337         if (sock->errevent != 0) {
;;;1338           if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
;;;1339             do_signal = 1;
;;;1340           }
;;;1341         }
;;;1342         if (do_signal) {
;;;1343           scb->sem_signalled = 1;
;;;1344           /* Don't call SYS_ARCH_UNPROTECT() before signaling the semaphore, as this might
;;;1345              lead to the select thread taking itself off the list, invalidagin the semaphore. */
;;;1346           sys_sem_signal(&scb->sem);
;;;1347         }
;;;1348       }
;;;1349       /* unlock interrupts with each step */
;;;1350       last_select_cb_ctr = select_cb_ctr;
;;;1351       SYS_ARCH_UNPROTECT(lev);
;;;1352       /* this makes sure interrupt protection time is short */
;;;1353       SYS_ARCH_PROTECT(lev);
;;;1354       if (last_select_cb_ctr != select_cb_ctr) {
;;;1355         /* someone has changed select_cb_list, restart at the beginning */
;;;1356         goto again;
;;;1357       }
;;;1358     }
;;;1359     SYS_ARCH_UNPROTECT(lev);
;;;1360   }
00002e  e8bd9ff0          POP      {r4-r12,pc}
                  |L2.50|
000032  69bc              LDR      r4,[r7,#0x18]         ;1274
000034  4658              MOV      r0,r11                ;1275
000036  f7fffffe          BL       sys_arch_unprotect
                  |L2.58|
00003a  4620              MOV      r0,r4                 ;1278
00003c  f7fffffe          BL       get_socket
000040  4605              MOV      r5,r0                 ;1278
000042  b90d              CBNZ     r5,|L2.72|
000044  e7f3              B        |L2.46|
                  |L2.70|
000046  e7f2              B        |L2.46|
                  |L2.72|
000048  f7fffffe          BL       sys_arch_protect
00004c  4683              MOV      r11,r0                ;1286
00004e  f1b80f05          CMP      r8,#5                 ;1288
000052  d217              BCS      |L2.132|
000054  e8dff008          TBB      [pc,r8]               ;1288
000058  03080d10          DCB      0x03,0x08,0x0d,0x10
00005c  1300              DCB      0x13,0x00
00005e  8968              LDRH     r0,[r5,#0xa]          ;1290
000060  1c40              ADDS     r0,r0,#1              ;1290
000062  b200              SXTH     r0,r0                 ;1290
000064  8168              STRH     r0,[r5,#0xa]          ;1290
000066  e019              B        |L2.156|
000068  8968              LDRH     r0,[r5,#0xa]          ;1293
00006a  1e40              SUBS     r0,r0,#1              ;1293
00006c  b200              SXTH     r0,r0                 ;1293
00006e  8168              STRH     r0,[r5,#0xa]          ;1293
000070  e014              B        |L2.156|
000072  2001              MOVS     r0,#1                 ;1296
000074  81a8              STRH     r0,[r5,#0xc]          ;1296
000076  e011              B        |L2.156|
000078  2000              MOVS     r0,#0                 ;1299
00007a  81a8              STRH     r0,[r5,#0xc]          ;1299
00007c  e00e              B        |L2.156|
00007e  2001              MOVS     r0,#1                 ;1302
000080  81e8              STRH     r0,[r5,#0xe]          ;1302
000082  e00b              B        |L2.156|
                  |L2.132|
000084  bf00              NOP                            ;1305
000086  bf00              NOP                            ;1305
000088  a33b              ADR      r3,|L2.376|
00008a  f2405219          MOV      r2,#0x519             ;1305
00008e  a144              ADR      r1,|L2.416|
000090  a047              ADR      r0,|L2.432|
000092  f7fffffe          BL       __2printf
000096  bf00              NOP                            ;1305
000098  bf00              NOP                            ;1305
00009a  bf00              NOP                            ;1306
                  |L2.156|
00009c  bf00              NOP                            ;1291
00009e  6968              LDR      r0,[r5,#0x14]         ;1309
0000a0  b918              CBNZ     r0,|L2.170|
0000a2  4658              MOV      r0,r11                ;1311
0000a4  f7fffffe          BL       sys_arch_unprotect
0000a8  e7c1              B        |L2.46|
                  |L2.170|
0000aa  bf00              NOP                            ;1321
                  |L2.172|
0000ac  484b              LDR      r0,|L2.476|
0000ae  6806              LDR      r6,[r0,#0]            ;1322  ; select_cb_list
0000b0  e05a              B        |L2.360|
                  |L2.178|
0000b2  6970              LDR      r0,[r6,#0x14]         ;1323
0000b4  2800              CMP      r0,#0                 ;1323
0000b6  d148              BNE      |L2.330|
0000b8  4681              MOV      r9,r0                 ;1325
0000ba  f9b5000a          LDRSH    r0,[r5,#0xa]          ;1327
0000be  2800              CMP      r0,#0                 ;1327
0000c0  dd0f              BLE      |L2.226|
0000c2  68b1              LDR      r1,[r6,#8]            ;1328
0000c4  b169              CBZ      r1,|L2.226|
0000c6  17e1              ASRS     r1,r4,#31             ;1328
0000c8  eb047151          ADD      r1,r4,r1,LSR #29      ;1328
0000cc  10c9              ASRS     r1,r1,#3              ;1328
0000ce  68b2              LDR      r2,[r6,#8]            ;1328
0000d0  5c51              LDRB     r1,[r2,r1]            ;1328
0000d2  f0040307          AND      r3,r4,#7              ;1328
0000d6  2201              MOVS     r2,#1                 ;1328
0000d8  409a              LSLS     r2,r2,r3              ;1328
0000da  4011              ANDS     r1,r1,r2              ;1328
0000dc  b109              CBZ      r1,|L2.226|
0000de  f04f0901          MOV      r9,#1                 ;1329
                  |L2.226|
0000e2  89a8              LDRH     r0,[r5,#0xc]          ;1332
0000e4  b190              CBZ      r0,|L2.268|
0000e6  f1b90f00          CMP      r9,#0                 ;1333
0000ea  d10f              BNE      |L2.268|
0000ec  68f1              LDR      r1,[r6,#0xc]          ;1333
0000ee  b169              CBZ      r1,|L2.268|
0000f0  17e1              ASRS     r1,r4,#31             ;1333
0000f2  eb047151          ADD      r1,r4,r1,LSR #29      ;1333
0000f6  10c9              ASRS     r1,r1,#3              ;1333
0000f8  68f2              LDR      r2,[r6,#0xc]          ;1333
0000fa  5c51              LDRB     r1,[r2,r1]            ;1333
0000fc  f0040307          AND      r3,r4,#7              ;1333
000100  2201              MOVS     r2,#1                 ;1333
000102  409a              LSLS     r2,r2,r3              ;1333
000104  4011              ANDS     r1,r1,r2              ;1333
000106  b109              CBZ      r1,|L2.268|
000108  f04f0901          MOV      r9,#1                 ;1334
                  |L2.268|
00010c  89e8              LDRH     r0,[r5,#0xe]          ;1337
00010e  b190              CBZ      r0,|L2.310|
000110  f1b90f00          CMP      r9,#0                 ;1338
000114  d10f              BNE      |L2.310|
000116  6931              LDR      r1,[r6,#0x10]         ;1338
000118  b169              CBZ      r1,|L2.310|
00011a  17e1              ASRS     r1,r4,#31             ;1338
00011c  eb047151          ADD      r1,r4,r1,LSR #29      ;1338
000120  10c9              ASRS     r1,r1,#3              ;1338
000122  6932              LDR      r2,[r6,#0x10]         ;1338
000124  5c51              LDRB     r1,[r2,r1]            ;1338
000126  f0040307          AND      r3,r4,#7              ;1338
00012a  2201              MOVS     r2,#1                 ;1338
00012c  409a              LSLS     r2,r2,r3              ;1338
00012e  4011              ANDS     r1,r1,r2              ;1338
000130  b109              CBZ      r1,|L2.310|
000132  f04f0901          MOV      r9,#1                 ;1339
                  |L2.310|
000136  f1b90f00          CMP      r9,#0                 ;1342
00013a  d005              BEQ      |L2.328|
00013c  2001              MOVS     r0,#1                 ;1343
00013e  6170              STR      r0,[r6,#0x14]         ;1343
000140  f1060018          ADD      r0,r6,#0x18           ;1346
000144  f7fffffe          BL       sys_sem_signal
                  |L2.328|
000148  bf00              NOP                            ;1348
                  |L2.330|
00014a  4825              LDR      r0,|L2.480|
00014c  f8d0a000          LDR      r10,[r0,#0]           ;1350  ; select_cb_ctr
000150  4658              MOV      r0,r11                ;1351
000152  f7fffffe          BL       sys_arch_unprotect
000156  f7fffffe          BL       sys_arch_protect
00015a  4683              MOV      r11,r0                ;1353
00015c  4820              LDR      r0,|L2.480|
00015e  6800              LDR      r0,[r0,#0]            ;1354  ; select_cb_ctr
000160  4582              CMP      r10,r0                ;1354
000162  d000              BEQ      |L2.358|
000164  e7a2              B        |L2.172|
                  |L2.358|
000166  6836              LDR      r6,[r6,#0]            ;1322
                  |L2.360|
000168  2e00              CMP      r6,#0                 ;1322
00016a  d1a2              BNE      |L2.178|
00016c  4658              MOV      r0,r11                ;1359
00016e  f7fffffe          BL       sys_arch_unprotect
000172  bf00              NOP      
000174  e75b              B        |L2.46|
;;;1361   
                          ENDP

000176  0000              DCW      0x0000
                  |L2.376|
000178  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\sockets.c",0
00017c  5749505c
000180  6c776970
000184  2d312e34
000188  2e315c73
00018c  72635c61
000190  70695c73
000194  6f636b65
000198  74732e63
00019c  00      
00019d  00                DCB      0
00019e  00                DCB      0
00019f  00                DCB      0
                  |L2.416|
0001a0  756e6b6e          DCB      "unknown event",0
0001a4  6f776e20
0001a8  6576656e
0001ac  7400    
0001ae  00                DCB      0
0001af  00                DCB      0
                  |L2.432|
0001b0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0001b4  7274696f
0001b8  6e202225
0001bc  73222066
0001c0  61696c65
0001c4  64206174
0001c8  206c696e
0001cc  65202564
0001d0  20696e20
0001d4  25730d0a
0001d8  00      
0001d9  00                DCB      0
0001da  00                DCB      0
0001db  00                DCB      0
                  |L2.476|
                          DCD      select_cb_list
                  |L2.480|
                          DCD      select_cb_ctr

                          AREA ||i.free_socket||, CODE, READONLY, ALIGN=1

                  free_socket PROC
;;;279    static void
;;;280    free_socket(struct lwip_sock *sock, int is_tcp)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;281    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;282      void *lastdata;
;;;283      SYS_ARCH_DECL_PROTECT(lev);
;;;284    
;;;285      lastdata         = sock->lastdata;
000008  6866              LDR      r6,[r4,#4]
;;;286      sock->lastdata   = NULL;
00000a  2000              MOVS     r0,#0
00000c  6060              STR      r0,[r4,#4]
;;;287      sock->lastoffset = 0;
00000e  8120              STRH     r0,[r4,#8]
;;;288      sock->err        = 0;
000010  6120              STR      r0,[r4,#0x10]
;;;289    
;;;290      /* Protect socket array */
;;;291      SYS_ARCH_PROTECT(lev);
000012  f7fffffe          BL       sys_arch_protect
000016  4607              MOV      r7,r0
;;;292      sock->conn       = NULL;
000018  2000              MOVS     r0,#0
00001a  6020              STR      r0,[r4,#0]
;;;293      SYS_ARCH_UNPROTECT(lev);
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       sys_arch_unprotect
;;;294      /* don't use 'sock' after this line, as another task might have allocated it */
;;;295    
;;;296      if (lastdata != NULL) {
000022  b13e              CBZ      r6,|L3.52|
;;;297        if (is_tcp) {
000024  b11d              CBZ      r5,|L3.46|
;;;298          pbuf_free((struct pbuf *)lastdata);
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       pbuf_free
00002c  e002              B        |L3.52|
                  |L3.46|
;;;299        } else {
;;;300          netbuf_delete((struct netbuf *)lastdata);
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       netbuf_delete
                  |L3.52|
;;;301        }
;;;302      }
;;;303    }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;304    
                          ENDP


                          AREA ||i.get_socket||, CODE, READONLY, ALIGN=2

                  get_socket PROC
;;;194    static struct lwip_sock *
;;;195    get_socket(int s)
000000  4601              MOV      r1,r0
;;;196    {
;;;197      struct lwip_sock *sock;
;;;198    
;;;199      if ((s < 0) || (s >= NUM_SOCKETS)) {
000002  2900              CMP      r1,#0
000004  db01              BLT      |L4.10|
000006  2904              CMP      r1,#4
000008  db03              BLT      |L4.18|
                  |L4.10|
;;;200        LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;201        set_errno(EBADF);
;;;202        return NULL;
00000e  2000              MOVS     r0,#0
                  |L4.16|
;;;203      }
;;;204    
;;;205      sock = &sockets[s];
;;;206    
;;;207      if (!sock->conn) {
;;;208        LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
;;;209        set_errno(EBADF);
;;;210        return NULL;
;;;211      }
;;;212    
;;;213      return sock;
;;;214    }
000010  4770              BX       lr
                  |L4.18|
000012  eb010041          ADD      r0,r1,r1,LSL #1       ;205
000016  4b05              LDR      r3,|L4.44|
000018  eb0302c0          ADD      r2,r3,r0,LSL #3       ;205
00001c  6810              LDR      r0,[r2,#0]            ;207
00001e  b918              CBNZ     r0,|L4.40|
000020  bf00              NOP                            ;208
000022  bf00              NOP                            ;208
000024  2000              MOVS     r0,#0                 ;210
000026  e7f3              B        |L4.16|
                  |L4.40|
000028  4610              MOV      r0,r2                 ;213
00002a  e7f1              B        |L4.16|
;;;215    
                          ENDP

                  |L4.44|
                          DCD      sockets

                          AREA ||i.lwip_accept||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  lwip_accept PROC
;;;311    int
;;;312    lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;313    {
000004  b087              SUB      sp,sp,#0x1c
000006  4682              MOV      r10,r0
000008  4688              MOV      r8,r1
00000a  4617              MOV      r7,r2
;;;314      struct lwip_sock *sock, *nsock;
;;;315      struct netconn *newconn;
;;;316      ip_addr_t naddr;
;;;317      u16_t port;
;;;318      int newsock;
;;;319      struct sockaddr_in sin;
;;;320      err_t err;
;;;321      SYS_ARCH_DECL_PROTECT(lev);
;;;322    
;;;323      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
00000c  bf00              NOP      
00000e  bf00              NOP      
;;;324      sock = get_socket(s);
000010  4650              MOV      r0,r10
000012  f7fffffe          BL       get_socket
000016  4604              MOV      r4,r0
;;;325      if (!sock) {
000018  b924              CBNZ     r4,|L5.36|
;;;326        return -1;
00001a  f04f30ff          MOV      r0,#0xffffffff
                  |L5.30|
;;;327      }
;;;328    
;;;329      if (netconn_is_nonblocking(sock->conn) && (sock->rcvevent <= 0)) {
;;;330        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): returning EWOULDBLOCK\n", s));
;;;331        sock_set_errno(sock, EWOULDBLOCK);
;;;332        return -1;
;;;333      }
;;;334    
;;;335      /* wait for a new connection */
;;;336      err = netconn_accept(sock->conn, &newconn);
;;;337      if (err != ERR_OK) {
;;;338        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_acept failed, err=%d\n", s, err));
;;;339        if (netconn_type(sock->conn) != NETCONN_TCP) {
;;;340          sock_set_errno(sock, EOPNOTSUPP);
;;;341          return EOPNOTSUPP;
;;;342        }
;;;343        sock_set_errno(sock, err_to_errno(err));
;;;344        return -1;
;;;345      }
;;;346      LWIP_ASSERT("newconn != NULL", newconn != NULL);
;;;347      /* Prevent automatic window updates, we do this on our own! */
;;;348      netconn_set_noautorecved(newconn, 1);
;;;349    
;;;350      /* get the IP address and port of the remote host */
;;;351      err = netconn_peer(newconn, &naddr, &port);
;;;352      if (err != ERR_OK) {
;;;353        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_peer failed, err=%d\n", s, err));
;;;354        netconn_delete(newconn);
;;;355        sock_set_errno(sock, err_to_errno(err));
;;;356        return -1;
;;;357      }
;;;358    
;;;359      /* Note that POSIX only requires us to check addr is non-NULL. addrlen must
;;;360       * not be NULL if addr is valid.
;;;361       */
;;;362      if (NULL != addr) {
;;;363        LWIP_ASSERT("addr valid but addrlen NULL", addrlen != NULL);
;;;364        memset(&sin, 0, sizeof(sin));
;;;365        sin.sin_len = sizeof(sin);
;;;366        sin.sin_family = AF_INET;
;;;367        sin.sin_port = htons(port);
;;;368        inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
;;;369    
;;;370        if (*addrlen > sizeof(sin))
;;;371          *addrlen = sizeof(sin);
;;;372    
;;;373        MEMCPY(addr, &sin, *addrlen);
;;;374      }
;;;375    
;;;376      newsock = alloc_socket(newconn, 1);
;;;377      if (newsock == -1) {
;;;378        netconn_delete(newconn);
;;;379        sock_set_errno(sock, ENFILE);
;;;380        return -1;
;;;381      }
;;;382      LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
;;;383      LWIP_ASSERT("newconn->callback == event_callback", newconn->callback == event_callback);
;;;384      nsock = &sockets[newsock];
;;;385    
;;;386      /* See event_callback: If data comes in right away after an accept, even
;;;387       * though the server task might not have created a new socket yet.
;;;388       * In that case, newconn->socket is counted down (newconn->socket--),
;;;389       * so nsock->rcvevent is >= 1 here!
;;;390       */
;;;391      SYS_ARCH_PROTECT(lev);
;;;392      nsock->rcvevent += (s16_t)(-1 - newconn->socket);
;;;393      newconn->socket = newsock;
;;;394      SYS_ARCH_UNPROTECT(lev);
;;;395    
;;;396      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
;;;397      ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
;;;398      LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F"\n", port));
;;;399    
;;;400      sock_set_errno(sock, 0);
;;;401      return newsock;
;;;402    }
00001e  b007              ADD      sp,sp,#0x1c
000020  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.36|
000024  6820              LDR      r0,[r4,#0]            ;329
000026  f8900020          LDRB     r0,[r0,#0x20]         ;329
00002a  f0000002          AND      r0,r0,#2              ;329
00002e  b160              CBZ      r0,|L5.74|
000030  f9b4000a          LDRSH    r0,[r4,#0xa]          ;329
000034  2800              CMP      r0,#0                 ;329
000036  dc08              BGT      |L5.74|
000038  bf00              NOP                            ;330
00003a  bf00              NOP                            ;330
00003c  bf00              NOP                            ;331
00003e  200b              MOVS     r0,#0xb               ;331
000040  6120              STR      r0,[r4,#0x10]         ;331
000042  bf00              NOP                            ;331
000044  f04f30ff          MOV      r0,#0xffffffff        ;332
000048  e7e9              B        |L5.30|
                  |L5.74|
00004a  a906              ADD      r1,sp,#0x18           ;336
00004c  6820              LDR      r0,[r4,#0]            ;336
00004e  f7fffffe          BL       netconn_accept
000052  4605              MOV      r5,r0                 ;336
000054  b1cd              CBZ      r5,|L5.138|
000056  bf00              NOP                            ;338
000058  bf00              NOP                            ;338
00005a  6820              LDR      r0,[r4,#0]            ;339
00005c  7800              LDRB     r0,[r0,#0]            ;339
00005e  2810              CMP      r0,#0x10              ;339
000060  d004              BEQ      |L5.108|
000062  bf00              NOP                            ;340
000064  205f              MOVS     r0,#0x5f              ;340
000066  6120              STR      r0,[r4,#0x10]         ;340
000068  bf00              NOP                            ;340
00006a  e7d8              B        |L5.30|
                  |L5.108|
00006c  bf00              NOP                            ;343
00006e  4268              RSBS     r0,r5,#0              ;343
000070  2810              CMP      r0,#0x10              ;343
000072  d204              BCS      |L5.126|
000074  485e              LDR      r0,|L5.496|
000076  4269              RSBS     r1,r5,#0              ;343
000078  f8500021          LDR      r0,[r0,r1,LSL #2]     ;343
00007c  e000              B        |L5.128|
                  |L5.126|
00007e  2005              MOVS     r0,#5                 ;343
                  |L5.128|
000080  6120              STR      r0,[r4,#0x10]         ;343
000082  bf00              NOP                            ;343
000084  f04f30ff          MOV      r0,#0xffffffff        ;344
000088  e7c9              B        |L5.30|
                  |L5.138|
00008a  bf00              NOP                            ;346
00008c  9806              LDR      r0,[sp,#0x18]         ;346
00008e  b940              CBNZ     r0,|L5.162|
000090  bf00              NOP                            ;346
000092  a358              ADR      r3,|L5.500|
000094  f44f72ad          MOV      r2,#0x15a             ;346
000098  a160              ADR      r1,|L5.540|
00009a  a064              ADR      r0,|L5.556|
00009c  f7fffffe          BL       __2printf
0000a0  bf00              NOP                            ;346
                  |L5.162|
0000a2  bf00              NOP                            ;346
0000a4  bf00              NOP                            ;348
0000a6  9806              LDR      r0,[sp,#0x18]         ;348
0000a8  f8900020          LDRB     r0,[r0,#0x20]         ;348
0000ac  f0400008          ORR      r0,r0,#8              ;348
0000b0  9906              LDR      r1,[sp,#0x18]         ;348
0000b2  f8810020          STRB     r0,[r1,#0x20]         ;348
0000b6  bf00              NOP                            ;348
0000b8  2300              MOVS     r3,#0                 ;351
0000ba  aa04              ADD      r2,sp,#0x10           ;351
0000bc  a905              ADD      r1,sp,#0x14           ;351
0000be  9806              LDR      r0,[sp,#0x18]         ;351
0000c0  f7fffffe          BL       netconn_getaddr
0000c4  4605              MOV      r5,r0                 ;351
0000c6  b19d              CBZ      r5,|L5.240|
0000c8  bf00              NOP                            ;353
0000ca  bf00              NOP                            ;353
0000cc  9806              LDR      r0,[sp,#0x18]         ;354
0000ce  f7fffffe          BL       netconn_delete
0000d2  bf00              NOP                            ;355
0000d4  4268              RSBS     r0,r5,#0              ;355
0000d6  2810              CMP      r0,#0x10              ;355
0000d8  d204              BCS      |L5.228|
0000da  4845              LDR      r0,|L5.496|
0000dc  4269              RSBS     r1,r5,#0              ;355
0000de  f8500021          LDR      r0,[r0,r1,LSL #2]     ;355
0000e2  e000              B        |L5.230|
                  |L5.228|
0000e4  2005              MOVS     r0,#5                 ;355
                  |L5.230|
0000e6  6120              STR      r0,[r4,#0x10]         ;355
0000e8  bf00              NOP                            ;355
0000ea  f04f30ff          MOV      r0,#0xffffffff        ;356
0000ee  e796              B        |L5.30|
                  |L5.240|
0000f0  f1b80f00          CMP      r8,#0                 ;362
0000f4  d028              BEQ      |L5.328|
0000f6  bf00              NOP                            ;363
0000f8  b947              CBNZ     r7,|L5.268|
0000fa  bf00              NOP                            ;363
0000fc  a33d              ADR      r3,|L5.500|
0000fe  f240126b          MOV      r2,#0x16b             ;363
000102  a155              ADR      r1,|L5.600|
000104  a049              ADR      r0,|L5.556|
000106  f7fffffe          BL       __2printf
00010a  bf00              NOP                            ;363
                  |L5.268|
00010c  bf00              NOP                            ;363
00010e  2000              MOVS     r0,#0                 ;364
000110  9000              STR      r0,[sp,#0]            ;364
000112  9001              STR      r0,[sp,#4]            ;364
000114  9002              STR      r0,[sp,#8]            ;364
000116  9003              STR      r0,[sp,#0xc]          ;364
000118  2010              MOVS     r0,#0x10              ;365
00011a  f88d0000          STRB     r0,[sp,#0]            ;365
00011e  2002              MOVS     r0,#2                 ;366
000120  f88d0001          STRB     r0,[sp,#1]            ;366
000124  f8bd0010          LDRH     r0,[sp,#0x10]         ;367
000128  f7fffffe          BL       lwip_htons
00012c  f8ad0002          STRH     r0,[sp,#2]            ;367
000130  9805              LDR      r0,[sp,#0x14]         ;368
000132  9001              STR      r0,[sp,#4]            ;368
000134  6838              LDR      r0,[r7,#0]            ;370
000136  2810              CMP      r0,#0x10              ;370
000138  d901              BLS      |L5.318|
00013a  2010              MOVS     r0,#0x10              ;371
00013c  6038              STR      r0,[r7,#0]            ;371
                  |L5.318|
00013e  4669              MOV      r1,sp                 ;373
000140  4640              MOV      r0,r8                 ;373
000142  683a              LDR      r2,[r7,#0]            ;373
000144  f7fffffe          BL       __aeabi_memcpy
                  |L5.328|
000148  2101              MOVS     r1,#1                 ;376
00014a  9806              LDR      r0,[sp,#0x18]         ;376
00014c  f7fffffe          BL       alloc_socket
000150  4606              MOV      r6,r0                 ;376
000152  1c70              ADDS     r0,r6,#1              ;377
000154  b948              CBNZ     r0,|L5.362|
000156  9806              LDR      r0,[sp,#0x18]         ;378
000158  f7fffffe          BL       netconn_delete
00015c  bf00              NOP                            ;379
00015e  2017              MOVS     r0,#0x17              ;379
000160  6120              STR      r0,[r4,#0x10]         ;379
000162  bf00              NOP                            ;379
000164  f04f30ff          MOV      r0,#0xffffffff        ;380
000168  e759              B        |L5.30|
                  |L5.362|
00016a  bf00              NOP                            ;382
00016c  2e00              CMP      r6,#0                 ;382
00016e  db01              BLT      |L5.372|
000170  2e04              CMP      r6,#4                 ;382
000172  db08              BLT      |L5.390|
                  |L5.372|
000174  bf00              NOP                            ;382
000176  a31f              ADR      r3,|L5.500|
000178  f44f72bf          MOV      r2,#0x17e             ;382
00017c  a13d              ADR      r1,|L5.628|
00017e  a02b              ADR      r0,|L5.556|
000180  f7fffffe          BL       __2printf
000184  bf00              NOP                            ;382
                  |L5.390|
000186  bf00              NOP                            ;382
000188  bf00              NOP                            ;383
00018a  9806              LDR      r0,[sp,#0x18]         ;383
00018c  6ac0              LDR      r0,[r0,#0x2c]         ;383
00018e  493f              LDR      r1,|L5.652|
000190  4288              CMP      r0,r1                 ;383
000192  d008              BEQ      |L5.422|
000194  bf00              NOP                            ;383
000196  a317              ADR      r3,|L5.500|
000198  f240127f          MOV      r2,#0x17f             ;383
00019c  a13c              ADR      r1,|L5.656|
00019e  a023              ADR      r0,|L5.556|
0001a0  f7fffffe          BL       __2printf
0001a4  bf00              NOP                            ;383
                  |L5.422|
0001a6  bf00              NOP                            ;383
0001a8  eb060046          ADD      r0,r6,r6,LSL #1       ;384
0001ac  4941              LDR      r1,|L5.692|
0001ae  eb0109c0          ADD      r9,r1,r0,LSL #3       ;384
0001b2  f7fffffe          BL       sys_arch_protect
0001b6  4683              MOV      r11,r0                ;391
0001b8  f8b9100a          LDRH     r1,[r9,#0xa]          ;392
0001bc  9806              LDR      r0,[sp,#0x18]         ;392
0001be  6980              LDR      r0,[r0,#0x18]         ;392
0001c0  f1c030ff          RSB      r0,r0,#0xffffffff     ;392
0001c4  4408              ADD      r0,r0,r1              ;392
0001c6  b200              SXTH     r0,r0                 ;392
0001c8  f8a9000a          STRH     r0,[r9,#0xa]          ;392
0001cc  9806              LDR      r0,[sp,#0x18]         ;393
0001ce  6186              STR      r6,[r0,#0x18]         ;393
0001d0  4658              MOV      r0,r11                ;394
0001d2  f7fffffe          BL       sys_arch_unprotect
0001d6  bf00              NOP                            ;396
0001d8  bf00              NOP                            ;396
0001da  bf00              NOP                            ;397
0001dc  bf00              NOP                            ;397
0001de  bf00              NOP                            ;398
0001e0  bf00              NOP                            ;398
0001e2  bf00              NOP                            ;400
0001e4  2000              MOVS     r0,#0                 ;400
0001e6  6120              STR      r0,[r4,#0x10]         ;400
0001e8  bf00              NOP                            ;400
0001ea  4630              MOV      r0,r6                 ;401
0001ec  e717              B        |L5.30|
;;;403    
                          ENDP

0001ee  0000              DCW      0x0000
                  |L5.496|
                          DCD      err_to_errno_table
                  |L5.500|
0001f4  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\sockets.c",0
0001f8  5749505c
0001fc  6c776970
000200  2d312e34
000204  2e315c73
000208  72635c61
00020c  70695c73
000210  6f636b65
000214  74732e63
000218  00      
000219  00                DCB      0
00021a  00                DCB      0
00021b  00                DCB      0
                  |L5.540|
00021c  6e657763          DCB      "newconn != NULL",0
000220  6f6e6e20
000224  213d204e
000228  554c4c00
                  |L5.556|
00022c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000230  7274696f
000234  6e202225
000238  73222066
00023c  61696c65
000240  64206174
000244  206c696e
000248  65202564
00024c  20696e20
000250  25730d0a
000254  00      
000255  00                DCB      0
000256  00                DCB      0
000257  00                DCB      0
                  |L5.600|
000258  61646472          DCB      "addr valid but addrlen NULL",0
00025c  2076616c
000260  69642062
000264  75742061
000268  6464726c
00026c  656e204e
000270  554c4c00
                  |L5.628|
000274  696e7661          DCB      "invalid socket index",0
000278  6c696420
00027c  736f636b
000280  65742069
000284  6e646578
000288  00      
000289  00                DCB      0
00028a  00                DCB      0
00028b  00                DCB      0
                  |L5.652|
                          DCD      event_callback
                  |L5.656|
000290  6e657763          DCB      "newconn->callback == event_callback",0
000294  6f6e6e2d
000298  3e63616c
00029c  6c626163
0002a0  6b203d3d
0002a4  20657665
0002a8  6e745f63
0002ac  616c6c62
0002b0  61636b00
                  |L5.692|
                          DCD      sockets

                          AREA ||i.lwip_bind||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  lwip_bind PROC
;;;404    int
;;;405    lwip_bind(int s, const struct sockaddr *name, socklen_t namelen)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;406    {
000004  4682              MOV      r10,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;407      struct lwip_sock *sock;
;;;408      ip_addr_t local_addr;
;;;409      u16_t local_port;
;;;410      err_t err;
;;;411      const struct sockaddr_in *name_in;
;;;412    
;;;413      sock = get_socket(s);
00000a  4650              MOV      r0,r10
00000c  f7fffffe          BL       get_socket
000010  4605              MOV      r5,r0
;;;414      if (!sock) {
000012  b91d              CBNZ     r5,|L6.28|
;;;415        return -1;
000014  f04f30ff          MOV      r0,#0xffffffff
                  |L6.24|
;;;416      }
;;;417    
;;;418      /* check size, familiy and alignment of 'name' */
;;;419      LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
;;;420                 ((name->sa_family) == AF_INET) && ((((mem_ptr_t)name) % 4) == 0)),
;;;421                 sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
;;;422      name_in = (const struct sockaddr_in *)(void*)name;
;;;423    
;;;424      inet_addr_to_ipaddr(&local_addr, &name_in->sin_addr);
;;;425      local_port = name_in->sin_port;
;;;426    
;;;427      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
;;;428      ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
;;;429      LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", ntohs(local_port)));
;;;430    
;;;431      err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
;;;432    
;;;433      if (err != ERR_OK) {
;;;434        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
;;;435        sock_set_errno(sock, err_to_errno(err));
;;;436        return -1;
;;;437      }
;;;438    
;;;439      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
;;;440      sock_set_errno(sock, 0);
;;;441      return 0;
;;;442    }
000018  e8bd8ff8          POP      {r3-r11,pc}
                  |L6.28|
00001c  bf00              NOP                            ;419
00001e  f1b80f10          CMP      r8,#0x10              ;419
000022  d106              BNE      |L6.50|
000024  7860              LDRB     r0,[r4,#1]            ;419
000026  2802              CMP      r0,#2                 ;419
000028  d103              BNE      |L6.50|
00002a  f0040003          AND      r0,r4,#3              ;419
00002e  2800              CMP      r0,#0                 ;419
000030  d010              BEQ      |L6.84|
                  |L6.50|
000032  bf00              NOP                            ;419
000034  a320              ADR      r3,|L6.184|
000036  f24012a3          MOV      r2,#0x1a3             ;419
00003a  a129              ADR      r1,|L6.224|
00003c  a02f              ADR      r0,|L6.252|
00003e  f7fffffe          BL       __2printf
000042  bf00              NOP                            ;419
000044  bf00              NOP                            ;419
000046  4838              LDR      r0,|L6.296|
000048  6b80              LDR      r0,[r0,#0x38]         ;419  ; err_to_errno_table
00004a  6128              STR      r0,[r5,#0x10]         ;419
00004c  bf00              NOP                            ;419
00004e  f04f30ff          MOV      r0,#0xffffffff        ;419
000052  e7e1              B        |L6.24|
                  |L6.84|
000054  bf00              NOP                            ;419
000056  4627              MOV      r7,r4                 ;422
000058  463c              MOV      r4,r7                 ;424
00005a  6878              LDR      r0,[r7,#4]            ;424
00005c  9000              STR      r0,[sp,#0]            ;424
00005e  f8b79002          LDRH     r9,[r7,#2]            ;425
000062  bf00              NOP                            ;427
000064  bf00              NOP                            ;427
000066  bf00              NOP                            ;428
000068  bf00              NOP                            ;428
00006a  bf00              NOP                            ;429
00006c  bf00              NOP                            ;429
00006e  4648              MOV      r0,r9                 ;431
000070  f7fffffe          BL       lwip_ntohs
000074  4683              MOV      r11,r0                ;431
000076  465a              MOV      r2,r11                ;431
000078  4669              MOV      r1,sp                 ;431
00007a  6828              LDR      r0,[r5,#0]            ;431
00007c  f7fffffe          BL       netconn_bind
000080  4606              MOV      r6,r0                 ;431
000082  b186              CBZ      r6,|L6.166|
000084  bf00              NOP                            ;434
000086  bf00              NOP                            ;434
000088  bf00              NOP                            ;435
00008a  4270              RSBS     r0,r6,#0              ;435
00008c  2810              CMP      r0,#0x10              ;435
00008e  d204              BCS      |L6.154|
000090  4825              LDR      r0,|L6.296|
000092  4271              RSBS     r1,r6,#0              ;435
000094  f8500021          LDR      r0,[r0,r1,LSL #2]     ;435
000098  e000              B        |L6.156|
                  |L6.154|
00009a  2005              MOVS     r0,#5                 ;435
                  |L6.156|
00009c  6128              STR      r0,[r5,#0x10]         ;435
00009e  bf00              NOP                            ;435
0000a0  f04f30ff          MOV      r0,#0xffffffff        ;436
0000a4  e7b8              B        |L6.24|
                  |L6.166|
0000a6  bf00              NOP                            ;439
0000a8  bf00              NOP                            ;439
0000aa  bf00              NOP                            ;440
0000ac  2000              MOVS     r0,#0                 ;440
0000ae  6128              STR      r0,[r5,#0x10]         ;440
0000b0  bf00              NOP                            ;440
0000b2  bf00              NOP                            ;441
0000b4  e7b0              B        |L6.24|
;;;443    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L6.184|
0000b8  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\sockets.c",0
0000bc  5749505c
0000c0  6c776970
0000c4  2d312e34
0000c8  2e315c73
0000cc  72635c61
0000d0  70695c73
0000d4  6f636b65
0000d8  74732e63
0000dc  00      
0000dd  00                DCB      0
0000de  00                DCB      0
0000df  00                DCB      0
                  |L6.224|
0000e0  6c776970          DCB      "lwip_bind: invalid address",0
0000e4  5f62696e
0000e8  643a2069
0000ec  6e76616c
0000f0  69642061
0000f4  64647265
0000f8  737300  
0000fb  00                DCB      0
                  |L6.252|
0000fc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000100  7274696f
000104  6e202225
000108  73222066
00010c  61696c65
000110  64206174
000114  206c696e
000118  65202564
00011c  20696e20
000120  25730d0a
000124  00      
000125  00                DCB      0
000126  00                DCB      0
000127  00                DCB      0
                  |L6.296|
                          DCD      err_to_errno_table

                          AREA ||i.lwip_close||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  lwip_close PROC
;;;444    int
;;;445    lwip_close(int s)
000000  b570              PUSH     {r4-r6,lr}
;;;446    {
000002  4605              MOV      r5,r0
;;;447      struct lwip_sock *sock;
;;;448      int is_tcp = 0;
000004  2600              MOVS     r6,#0
;;;449    
;;;450      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));
000006  bf00              NOP      
000008  bf00              NOP      
;;;451    
;;;452      sock = get_socket(s);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       get_socket
000010  4604              MOV      r4,r0
;;;453      if (!sock) {
000012  b90c              CBNZ     r4,|L7.24|
;;;454        return -1;
000014  1e70              SUBS     r0,r6,#1
                  |L7.22|
;;;455      }
;;;456    
;;;457      if(sock->conn != NULL) {
;;;458        is_tcp = netconn_type(sock->conn) == NETCONN_TCP;
;;;459      } else {
;;;460        LWIP_ASSERT("sock->lastdata == NULL", sock->lastdata == NULL);
;;;461      }
;;;462    
;;;463      netconn_delete(sock->conn);
;;;464    
;;;465      free_socket(sock, is_tcp);
;;;466      set_errno(0);
;;;467      return 0;
;;;468    }
000016  bd70              POP      {r4-r6,pc}
                  |L7.24|
000018  6820              LDR      r0,[r4,#0]            ;457
00001a  b140              CBZ      r0,|L7.46|
00001c  6820              LDR      r0,[r4,#0]            ;458
00001e  7800              LDRB     r0,[r0,#0]            ;458
000020  2810              CMP      r0,#0x10              ;458
000022  d101              BNE      |L7.40|
000024  2001              MOVS     r0,#1                 ;458
000026  e000              B        |L7.42|
                  |L7.40|
000028  2000              MOVS     r0,#0                 ;458
                  |L7.42|
00002a  4606              MOV      r6,r0                 ;458
00002c  e00c              B        |L7.72|
                  |L7.46|
00002e  bf00              NOP                            ;460
000030  6860              LDR      r0,[r4,#4]            ;460
000032  b140              CBZ      r0,|L7.70|
000034  bf00              NOP                            ;460
000036  a309              ADR      r3,|L7.92|
000038  f44f72e6          MOV      r2,#0x1cc             ;460
00003c  a111              ADR      r1,|L7.132|
00003e  a017              ADR      r0,|L7.156|
000040  f7fffffe          BL       __2printf
000044  bf00              NOP                            ;460
                  |L7.70|
000046  bf00              NOP                            ;460
                  |L7.72|
000048  6820              LDR      r0,[r4,#0]            ;463
00004a  f7fffffe          BL       netconn_delete
00004e  4631              MOV      r1,r6                 ;465
000050  4620              MOV      r0,r4                 ;465
000052  f7fffffe          BL       free_socket
000056  2000              MOVS     r0,#0                 ;467
000058  e7dd              B        |L7.22|
;;;469    
                          ENDP

00005a  0000              DCW      0x0000
                  |L7.92|
00005c  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\sockets.c",0
000060  5749505c
000064  6c776970
000068  2d312e34
00006c  2e315c73
000070  72635c61
000074  70695c73
000078  6f636b65
00007c  74732e63
000080  00      
000081  00                DCB      0
000082  00                DCB      0
000083  00                DCB      0
                  |L7.132|
000084  736f636b          DCB      "sock->lastdata == NULL",0
000088  2d3e6c61
00008c  73746461
000090  7461203d
000094  3d204e55
000098  4c4c00  
00009b  00                DCB      0
                  |L7.156|
00009c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000a0  7274696f
0000a4  6e202225
0000a8  73222066
0000ac  61696c65
0000b0  64206174
0000b4  206c696e
0000b8  65202564
0000bc  20696e20
0000c0  25730d0a
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0

                          AREA ||i.lwip_connect||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  lwip_connect PROC
;;;470    int
;;;471    lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;472    {
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
;;;473      struct lwip_sock *sock;
;;;474      err_t err;
;;;475      const struct sockaddr_in *name_in;
;;;476    
;;;477      sock = get_socket(s);
00000a  4648              MOV      r0,r9
00000c  f7fffffe          BL       get_socket
000010  4604              MOV      r4,r0
;;;478      if (!sock) {
000012  b91c              CBNZ     r4,|L8.28|
;;;479        return -1;
000014  f04f30ff          MOV      r0,#0xffffffff
                  |L8.24|
;;;480      }
;;;481    
;;;482      /* check size, familiy and alignment of 'name' */
;;;483      LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
;;;484                 ((name->sa_family) == AF_INET) && ((((mem_ptr_t)name) % 4) == 0)),
;;;485                 sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
;;;486      name_in = (const struct sockaddr_in *)(void*)name;
;;;487    
;;;488      if (name_in->sin_family == AF_UNSPEC) {
;;;489        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
;;;490        err = netconn_disconnect(sock->conn);
;;;491      } else {
;;;492        ip_addr_t remote_addr;
;;;493        u16_t remote_port;
;;;494    
;;;495        inet_addr_to_ipaddr(&remote_addr, &name_in->sin_addr);
;;;496        remote_port = name_in->sin_port;
;;;497    
;;;498        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
;;;499        ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
;;;500        LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", ntohs(remote_port)));
;;;501    
;;;502        err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
;;;503      }
;;;504    
;;;505      if (err != ERR_OK) {
;;;506        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
;;;507        sock_set_errno(sock, err_to_errno(err));
;;;508        return -1;
;;;509      }
;;;510    
;;;511      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
;;;512      sock_set_errno(sock, 0);
;;;513      return 0;
;;;514    }
000018  e8bd8ff8          POP      {r3-r11,pc}
                  |L8.28|
00001c  bf00              NOP                            ;483
00001e  f1b80f10          CMP      r8,#0x10              ;483
000022  d106              BNE      |L8.50|
000024  7870              LDRB     r0,[r6,#1]            ;483
000026  2802              CMP      r0,#2                 ;483
000028  d103              BNE      |L8.50|
00002a  f0060003          AND      r0,r6,#3              ;483
00002e  2800              CMP      r0,#0                 ;483
000030  d010              BEQ      |L8.84|
                  |L8.50|
000032  bf00              NOP                            ;483
000034  a325              ADR      r3,|L8.204|
000036  f24012e3          MOV      r2,#0x1e3             ;483
00003a  a12e              ADR      r1,|L8.244|
00003c  a035              ADR      r0,|L8.276|
00003e  f7fffffe          BL       __2printf
000042  bf00              NOP                            ;483
000044  bf00              NOP                            ;483
000046  483e              LDR      r0,|L8.320|
000048  6b80              LDR      r0,[r0,#0x38]         ;483  ; err_to_errno_table
00004a  6120              STR      r0,[r4,#0x10]         ;483
00004c  bf00              NOP                            ;483
00004e  f04f30ff          MOV      r0,#0xffffffff        ;483
000052  e7e1              B        |L8.24|
                  |L8.84|
000054  bf00              NOP                            ;483
000056  4637              MOV      r7,r6                 ;486
000058  463e              MOV      r6,r7                 ;488
00005a  7878              LDRB     r0,[r7,#1]            ;488
00005c  b930              CBNZ     r0,|L8.108|
00005e  bf00              NOP                            ;489
000060  bf00              NOP                            ;489
000062  6820              LDR      r0,[r4,#0]            ;490
000064  f7fffffe          BL       netconn_disconnect
000068  4605              MOV      r5,r0                 ;490
00006a  e014              B        |L8.150|
                  |L8.108|
00006c  6878              LDR      r0,[r7,#4]            ;495
00006e  9000              STR      r0,[sp,#0]            ;495
000070  f8b7a002          LDRH     r10,[r7,#2]           ;496
000074  bf00              NOP                            ;498
000076  bf00              NOP                            ;498
000078  bf00              NOP                            ;499
00007a  bf00              NOP                            ;499
00007c  bf00              NOP                            ;500
00007e  bf00              NOP                            ;500
000080  4650              MOV      r0,r10                ;502
000082  f7fffffe          BL       lwip_ntohs
000086  4683              MOV      r11,r0                ;502
000088  465a              MOV      r2,r11                ;502
00008a  4669              MOV      r1,sp                 ;502
00008c  6820              LDR      r0,[r4,#0]            ;502
00008e  f7fffffe          BL       netconn_connect
000092  4605              MOV      r5,r0                 ;502
000094  bf00              NOP                            ;503
                  |L8.150|
000096  b185              CBZ      r5,|L8.186|
000098  bf00              NOP                            ;506
00009a  bf00              NOP                            ;506
00009c  bf00              NOP                            ;507
00009e  4268              RSBS     r0,r5,#0              ;507
0000a0  2810              CMP      r0,#0x10              ;507
0000a2  d204              BCS      |L8.174|
0000a4  4826              LDR      r0,|L8.320|
0000a6  4269              RSBS     r1,r5,#0              ;507
0000a8  f8500021          LDR      r0,[r0,r1,LSL #2]     ;507
0000ac  e000              B        |L8.176|
                  |L8.174|
0000ae  2005              MOVS     r0,#5                 ;507
                  |L8.176|
0000b0  6120              STR      r0,[r4,#0x10]         ;507
0000b2  bf00              NOP                            ;507
0000b4  f04f30ff          MOV      r0,#0xffffffff        ;508
0000b8  e7ae              B        |L8.24|
                  |L8.186|
0000ba  bf00              NOP                            ;511
0000bc  bf00              NOP                            ;511
0000be  bf00              NOP                            ;512
0000c0  2000              MOVS     r0,#0                 ;512
0000c2  6120              STR      r0,[r4,#0x10]         ;512
0000c4  bf00              NOP                            ;512
0000c6  bf00              NOP                            ;513
0000c8  e7a6              B        |L8.24|
;;;515    
                          ENDP

0000ca  0000              DCW      0x0000
                  |L8.204|
0000cc  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\sockets.c",0
0000d0  5749505c
0000d4  6c776970
0000d8  2d312e34
0000dc  2e315c73
0000e0  72635c61
0000e4  70695c73
0000e8  6f636b65
0000ec  74732e63
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L8.244|
0000f4  6c776970          DCB      "lwip_connect: invalid address",0
0000f8  5f636f6e
0000fc  6e656374
000100  3a20696e
000104  76616c69
000108  64206164
00010c  64726573
000110  7300    
000112  00                DCB      0
000113  00                DCB      0
                  |L8.276|
000114  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000118  7274696f
00011c  6e202225
000120  73222066
000124  61696c65
000128  64206174
00012c  206c696e
000130  65202564
000134  20696e20
000138  25730d0a
00013c  00      
00013d  00                DCB      0
00013e  00                DCB      0
00013f  00                DCB      0
                  |L8.320|
                          DCD      err_to_errno_table

                          AREA ||i.lwip_fcntl||, CODE, READONLY, ALIGN=1

                  lwip_fcntl PROC
;;;2346   int
;;;2347   lwip_fcntl(int s, int cmd, int val)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2348   {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;2349     struct lwip_sock *sock = get_socket(s);
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       get_socket
000010  4604              MOV      r4,r0
;;;2350     int ret = -1;
000012  f04f38ff          MOV      r8,#0xffffffff
;;;2351   
;;;2352     if (!sock || !sock->conn) {
000016  b10c              CBZ      r4,|L9.28|
000018  6820              LDR      r0,[r4,#0]
00001a  b918              CBNZ     r0,|L9.36|
                  |L9.28|
;;;2353       return -1;
00001c  f04f30ff          MOV      r0,#0xffffffff
                  |L9.32|
;;;2354     }
;;;2355   
;;;2356     switch (cmd) {
;;;2357     case F_GETFL:
;;;2358       ret = netconn_is_nonblocking(sock->conn) ? O_NONBLOCK : 0;
;;;2359       break;
;;;2360     case F_SETFL:
;;;2361       if ((val & ~O_NONBLOCK) == 0) {
;;;2362         /* only O_NONBLOCK, all other bits are zero */
;;;2363         netconn_set_nonblocking(sock->conn, val & O_NONBLOCK);
;;;2364         ret = 0;
;;;2365       }
;;;2366       break;
;;;2367     default:
;;;2368       LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_fcntl(%d, UNIMPL: %d, %d)\n", s, cmd, val));
;;;2369       break;
;;;2370     }
;;;2371     return ret;
;;;2372   }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L9.36|
000024  2e03              CMP      r6,#3                 ;2356
000026  d002              BEQ      |L9.46|
000028  2e04              CMP      r6,#4                 ;2356
00002a  d122              BNE      |L9.114|
00002c  e005              B        |L9.58|
                  |L9.46|
00002e  6820              LDR      r0,[r4,#0]            ;2358
000030  f8900020          LDRB     r0,[r0,#0x20]         ;2358
000034  f3c00840          UBFX     r8,r0,#1,#1           ;2358
000038  e01e              B        |L9.120|
                  |L9.58|
00003a  f0250001          BIC      r0,r5,#1              ;2361
00003e  b9b8              CBNZ     r0,|L9.112|
000040  bf00              NOP                            ;2363
000042  f0050001          AND      r0,r5,#1              ;2363
000046  b140              CBZ      r0,|L9.90|
000048  6820              LDR      r0,[r4,#0]            ;2363
00004a  f8900020          LDRB     r0,[r0,#0x20]         ;2363
00004e  f0400002          ORR      r0,r0,#2              ;2363
000052  6821              LDR      r1,[r4,#0]            ;2363
000054  f8810020          STRB     r0,[r1,#0x20]         ;2363
000058  e007              B        |L9.106|
                  |L9.90|
00005a  6820              LDR      r0,[r4,#0]            ;2363
00005c  f8900020          LDRB     r0,[r0,#0x20]         ;2363
000060  f0200002          BIC      r0,r0,#2              ;2363
000064  6821              LDR      r1,[r4,#0]            ;2363
000066  f8810020          STRB     r0,[r1,#0x20]         ;2363
                  |L9.106|
00006a  bf00              NOP                            ;2363
00006c  f04f0800          MOV      r8,#0                 ;2364
                  |L9.112|
000070  e002              B        |L9.120|
                  |L9.114|
000072  bf00              NOP                            ;2368
000074  bf00              NOP                            ;2368
000076  bf00              NOP                            ;2369
                  |L9.120|
000078  bf00              NOP                            ;2359
00007a  4640              MOV      r0,r8                 ;2371
00007c  e7d0              B        |L9.32|
;;;2373   
                          ENDP


                          AREA ||i.lwip_getaddrname||, CODE, READONLY, ALIGN=1

                  lwip_getaddrname PROC
;;;1407   static int
;;;1408   lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1409   {
000004  b086              SUB      sp,sp,#0x18
000006  4607              MOV      r7,r0
000008  460e              MOV      r6,r1
00000a  4614              MOV      r4,r2
00000c  4698              MOV      r8,r3
;;;1410     struct lwip_sock *sock;
;;;1411     struct sockaddr_in sin;
;;;1412     ip_addr_t naddr;
;;;1413   
;;;1414     sock = get_socket(s);
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       get_socket
000014  4605              MOV      r5,r0
;;;1415     if (!sock) {
000016  b925              CBNZ     r5,|L10.34|
;;;1416       return -1;
000018  f04f30ff          MOV      r0,#0xffffffff
                  |L10.28|
;;;1417     }
;;;1418   
;;;1419     memset(&sin, 0, sizeof(sin));
;;;1420     sin.sin_len = sizeof(sin);
;;;1421     sin.sin_family = AF_INET;
;;;1422   
;;;1423     /* get the IP address and port */
;;;1424     netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
;;;1425   
;;;1426     LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
;;;1427     ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
;;;1428     LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", sin.sin_port));
;;;1429   
;;;1430     sin.sin_port = htons(sin.sin_port);
;;;1431     inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
;;;1432   
;;;1433     if (*namelen > sizeof(sin)) {
;;;1434       *namelen = sizeof(sin);
;;;1435     }
;;;1436   
;;;1437     MEMCPY(name, &sin, *namelen);
;;;1438     sock_set_errno(sock, 0);
;;;1439     return 0;
;;;1440   }
00001c  b006              ADD      sp,sp,#0x18
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L10.34|
000022  2000              MOVS     r0,#0                 ;1419
000024  9002              STR      r0,[sp,#8]            ;1419
000026  9003              STR      r0,[sp,#0xc]          ;1419
000028  9004              STR      r0,[sp,#0x10]         ;1419
00002a  9005              STR      r0,[sp,#0x14]         ;1419
00002c  2010              MOVS     r0,#0x10              ;1420
00002e  f88d0008          STRB     r0,[sp,#8]            ;1420
000032  2002              MOVS     r0,#2                 ;1421
000034  f88d0009          STRB     r0,[sp,#9]            ;1421
000038  4643              MOV      r3,r8                 ;1424
00003a  f10d020a          ADD      r2,sp,#0xa            ;1424
00003e  a901              ADD      r1,sp,#4              ;1424
000040  6828              LDR      r0,[r5,#0]            ;1424
000042  f7fffffe          BL       netconn_getaddr
000046  bf00              NOP                            ;1426
000048  bf00              NOP                            ;1426
00004a  bf00              NOP                            ;1427
00004c  bf00              NOP                            ;1427
00004e  bf00              NOP                            ;1428
000050  bf00              NOP                            ;1428
000052  f8bd000a          LDRH     r0,[sp,#0xa]          ;1430
000056  f7fffffe          BL       lwip_htons
00005a  f8ad000a          STRH     r0,[sp,#0xa]          ;1430
00005e  9801              LDR      r0,[sp,#4]            ;1431
000060  9003              STR      r0,[sp,#0xc]          ;1431
000062  6820              LDR      r0,[r4,#0]            ;1433
000064  2810              CMP      r0,#0x10              ;1433
000066  d901              BLS      |L10.108|
000068  2010              MOVS     r0,#0x10              ;1434
00006a  6020              STR      r0,[r4,#0]            ;1434
                  |L10.108|
00006c  a902              ADD      r1,sp,#8              ;1437
00006e  4630              MOV      r0,r6                 ;1437
000070  6822              LDR      r2,[r4,#0]            ;1437
000072  f7fffffe          BL       __aeabi_memcpy
000076  bf00              NOP                            ;1438
000078  2000              MOVS     r0,#0                 ;1438
00007a  6128              STR      r0,[r5,#0x10]         ;1438
00007c  bf00              NOP                            ;1438
00007e  bf00              NOP                            ;1439
000080  e7cc              B        |L10.28|
;;;1441   
                          ENDP


                          AREA ||i.lwip_getpeername||, CODE, READONLY, ALIGN=1

                  lwip_getpeername PROC
;;;1442   int
;;;1443   lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
000000  b570              PUSH     {r4-r6,lr}
;;;1444   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1445     return lwip_getaddrname(s, name, namelen, 0);
000008  2300              MOVS     r3,#0
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       lwip_getaddrname
;;;1446   }
000014  bd70              POP      {r4-r6,pc}
;;;1447   
                          ENDP


                          AREA ||i.lwip_getsockname||, CODE, READONLY, ALIGN=1

                  lwip_getsockname PROC
;;;1448   int
;;;1449   lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
000000  b570              PUSH     {r4-r6,lr}
;;;1450   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1451     return lwip_getaddrname(s, name, namelen, 1);
000008  2301              MOVS     r3,#1
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       lwip_getaddrname
;;;1452   }
000014  bd70              POP      {r4-r6,pc}
;;;1453   
                          ENDP


                          AREA ||i.lwip_getsockopt||, CODE, READONLY, ALIGN=2

                  lwip_getsockopt PROC
;;;1454   int
;;;1455   lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1456   {
000004  b088              SUB      sp,sp,#0x20
000006  4682              MOV      r10,r0
000008  4688              MOV      r8,r1
00000a  4616              MOV      r6,r2
00000c  4699              MOV      r9,r3
00000e  9d10              LDR      r5,[sp,#0x40]
;;;1457     err_t err = ERR_OK;
000010  2700              MOVS     r7,#0
;;;1458     struct lwip_sock *sock = get_socket(s);
000012  4650              MOV      r0,r10
000014  f7fffffe          BL       get_socket
000018  4604              MOV      r4,r0
;;;1459     struct lwip_setgetsockopt_data data;
;;;1460   
;;;1461     if (!sock) {
00001a  b91c              CBNZ     r4,|L13.36|
;;;1462       return -1;
00001c  1e78              SUBS     r0,r7,#1
                  |L13.30|
;;;1463     }
;;;1464   
;;;1465     if ((NULL == optval) || (NULL == optlen)) {
;;;1466       sock_set_errno(sock, EFAULT);
;;;1467       return -1;
;;;1468     }
;;;1469   
;;;1470     /* Do length and type checks for the various options first, to keep it readable. */
;;;1471     switch (level) {
;;;1472      
;;;1473   /* Level: SOL_SOCKET */
;;;1474     case SOL_SOCKET:
;;;1475       switch (optname) {
;;;1476          
;;;1477       case SO_ACCEPTCONN:
;;;1478       case SO_BROADCAST:
;;;1479       /* UNIMPL case SO_DEBUG: */
;;;1480       /* UNIMPL case SO_DONTROUTE: */
;;;1481       case SO_ERROR:
;;;1482       case SO_KEEPALIVE:
;;;1483       /* UNIMPL case SO_CONTIMEO: */
;;;1484   #if LWIP_SO_SNDTIMEO
;;;1485       case SO_SNDTIMEO:
;;;1486   #endif /* LWIP_SO_SNDTIMEO */
;;;1487   #if LWIP_SO_RCVTIMEO
;;;1488       case SO_RCVTIMEO:
;;;1489   #endif /* LWIP_SO_RCVTIMEO */
;;;1490   #if LWIP_SO_RCVBUF
;;;1491       case SO_RCVBUF:
;;;1492   #endif /* LWIP_SO_RCVBUF */
;;;1493       /* UNIMPL case SO_OOBINLINE: */
;;;1494       /* UNIMPL case SO_SNDBUF: */
;;;1495       /* UNIMPL case SO_RCVLOWAT: */
;;;1496       /* UNIMPL case SO_SNDLOWAT: */
;;;1497   #if SO_REUSE
;;;1498       case SO_REUSEADDR:
;;;1499       case SO_REUSEPORT:
;;;1500   #endif /* SO_REUSE */
;;;1501       case SO_TYPE:
;;;1502       /* UNIMPL case SO_USELOOPBACK: */
;;;1503         if (*optlen < sizeof(int)) {
;;;1504           err = EINVAL;
;;;1505         }
;;;1506         break;
;;;1507   
;;;1508       case SO_NO_CHECK:
;;;1509         if (*optlen < sizeof(int)) {
;;;1510           err = EINVAL;
;;;1511         }
;;;1512   #if LWIP_UDP
;;;1513         if ((sock->conn->type != NETCONN_UDP) ||
;;;1514             ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
;;;1515           /* this flag is only available for UDP, not for UDP lite */
;;;1516           err = EAFNOSUPPORT;
;;;1517         }
;;;1518   #endif /* LWIP_UDP */
;;;1519         break;
;;;1520   
;;;1521       default:
;;;1522         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
;;;1523                                     s, optname));
;;;1524         err = ENOPROTOOPT;
;;;1525       }  /* switch (optname) */
;;;1526       break;
;;;1527                        
;;;1528   /* Level: IPPROTO_IP */
;;;1529     case IPPROTO_IP:
;;;1530       switch (optname) {
;;;1531       /* UNIMPL case IP_HDRINCL: */
;;;1532       /* UNIMPL case IP_RCVDSTADDR: */
;;;1533       /* UNIMPL case IP_RCVIF: */
;;;1534       case IP_TTL:
;;;1535       case IP_TOS:
;;;1536         if (*optlen < sizeof(int)) {
;;;1537           err = EINVAL;
;;;1538         }
;;;1539         break;
;;;1540   #if LWIP_IGMP
;;;1541       case IP_MULTICAST_TTL:
;;;1542         if (*optlen < sizeof(u8_t)) {
;;;1543           err = EINVAL;
;;;1544         }
;;;1545         break;
;;;1546       case IP_MULTICAST_IF:
;;;1547         if (*optlen < sizeof(struct in_addr)) {
;;;1548           err = EINVAL;
;;;1549         }
;;;1550         break;
;;;1551       case IP_MULTICAST_LOOP:
;;;1552         if (*optlen < sizeof(u8_t)) {
;;;1553           err = EINVAL;
;;;1554         }
;;;1555         if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
;;;1556           err = EAFNOSUPPORT;
;;;1557         }
;;;1558         break;
;;;1559   #endif /* LWIP_IGMP */
;;;1560   
;;;1561       default:
;;;1562         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
;;;1563                                     s, optname));
;;;1564         err = ENOPROTOOPT;
;;;1565       }  /* switch (optname) */
;;;1566       break;
;;;1567            
;;;1568   #if LWIP_TCP
;;;1569   /* Level: IPPROTO_TCP */
;;;1570     case IPPROTO_TCP:
;;;1571       if (*optlen < sizeof(int)) {
;;;1572         err = EINVAL;
;;;1573         break;
;;;1574       }
;;;1575       
;;;1576       /* If this is no TCP socket, ignore any options. */
;;;1577       if (sock->conn->type != NETCONN_TCP)
;;;1578         return 0;
;;;1579   
;;;1580       switch (optname) {
;;;1581       case TCP_NODELAY:
;;;1582       case TCP_KEEPALIVE:
;;;1583   #if LWIP_TCP_KEEPALIVE
;;;1584       case TCP_KEEPIDLE:
;;;1585       case TCP_KEEPINTVL:
;;;1586       case TCP_KEEPCNT:
;;;1587   #endif /* LWIP_TCP_KEEPALIVE */
;;;1588         break;
;;;1589          
;;;1590       default:
;;;1591         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
;;;1592                                     s, optname));
;;;1593         err = ENOPROTOOPT;
;;;1594       }  /* switch (optname) */
;;;1595       break;
;;;1596   #endif /* LWIP_TCP */
;;;1597   #if LWIP_UDP && LWIP_UDPLITE
;;;1598   /* Level: IPPROTO_UDPLITE */
;;;1599     case IPPROTO_UDPLITE:
;;;1600       if (*optlen < sizeof(int)) {
;;;1601         err = EINVAL;
;;;1602         break;
;;;1603       }
;;;1604       
;;;1605       /* If this is no UDP lite socket, ignore any options. */
;;;1606       if (sock->conn->type != NETCONN_UDPLITE) {
;;;1607         return 0;
;;;1608       }
;;;1609   
;;;1610       switch (optname) {
;;;1611       case UDPLITE_SEND_CSCOV:
;;;1612       case UDPLITE_RECV_CSCOV:
;;;1613         break;
;;;1614          
;;;1615       default:
;;;1616         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UNIMPL: optname=0x%x, ..)\n",
;;;1617                                     s, optname));
;;;1618         err = ENOPROTOOPT;
;;;1619       }  /* switch (optname) */
;;;1620       break;
;;;1621   #endif /* LWIP_UDP && LWIP_UDPLITE*/
;;;1622   /* UNDEFINED LEVEL */
;;;1623     default:
;;;1624         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
;;;1625                                     s, level, optname));
;;;1626         err = ENOPROTOOPT;
;;;1627     }  /* switch */
;;;1628   
;;;1629      
;;;1630     if (err != ERR_OK) {
;;;1631       sock_set_errno(sock, err);
;;;1632       return -1;
;;;1633     }
;;;1634   
;;;1635     /* Now do the actual option processing */
;;;1636     data.sock = sock;
;;;1637   #ifdef LWIP_DEBUG
;;;1638     data.s = s;
;;;1639   #endif /* LWIP_DEBUG */
;;;1640     data.level = level;
;;;1641     data.optname = optname;
;;;1642     data.optval = optval;
;;;1643     data.optlen = optlen;
;;;1644     data.err = err;
;;;1645     tcpip_callback(lwip_getsockopt_internal, &data);
;;;1646     sys_arch_sem_wait(&sock->conn->op_completed, 0);
;;;1647     /* maybe lwip_getsockopt_internal has changed err */
;;;1648     err = data.err;
;;;1649   
;;;1650     sock_set_errno(sock, err);
;;;1651     return err ? -1 : 0;
;;;1652   }
00001e  b008              ADD      sp,sp,#0x20
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L13.36|
000024  f1b90f00          CMP      r9,#0                 ;1465
000028  d000              BEQ      |L13.44|
00002a  b935              CBNZ     r5,|L13.58|
                  |L13.44|
00002c  bf00              NOP                            ;1466
00002e  200e              MOVS     r0,#0xe               ;1466
000030  6120              STR      r0,[r4,#0x10]         ;1466
000032  bf00              NOP                            ;1466
000034  f04f30ff          MOV      r0,#0xffffffff        ;1467
000038  e7f1              B        |L13.30|
                  |L13.58|
00003a  f1b80f00          CMP      r8,#0                 ;1471
00003e  d03a              BEQ      |L13.182|
000040  f1b80f06          CMP      r8,#6                 ;1471
000044  d047              BEQ      |L13.214|
000046  f6a870ff          SUB      r0,r8,#0xfff          ;1471
00004a  2800              CMP      r0,#0                 ;1471
00004c  d15b              BNE      |L13.262|
00004e  f2410106          MOV      r1,#0x1006            ;1475
000052  1a70              SUBS     r0,r6,r1              ;1475
000054  428e              CMP      r6,r1                 ;1475
000056  d012              BEQ      |L13.126|
000058  dc06              BGT      |L13.104|
00005a  2e02              CMP      r6,#2                 ;1475
00005c  d00b              BEQ      |L13.118|
00005e  2e08              CMP      r6,#8                 ;1475
000060  d00c              BEQ      |L13.124|
000062  2e20              CMP      r6,#0x20              ;1475
000064  d121              BNE      |L13.170|
000066  e007              B        |L13.120|
                  |L13.104|
000068  2801              CMP      r0,#1                 ;1475
00006a  d006              BEQ      |L13.122|
00006c  2802              CMP      r0,#2                 ;1475
00006e  d007              BEQ      |L13.128|
000070  2804              CMP      r0,#4                 ;1475
000072  d11a              BNE      |L13.170|
000074  e009              B        |L13.138|
                  |L13.118|
000076  bf00              NOP                            ;1478
                  |L13.120|
000078  bf00              NOP                            ;1481
                  |L13.122|
00007a  bf00              NOP                            ;1482
                  |L13.124|
00007c  bf00              NOP                            ;1488
                  |L13.126|
00007e  bf00              NOP                            ;1501
                  |L13.128|
000080  6828              LDR      r0,[r5,#0]            ;1503
000082  2804              CMP      r0,#4                 ;1503
000084  d200              BCS      |L13.136|
000086  2716              MOVS     r7,#0x16              ;1504
                  |L13.136|
000088  e013              B        |L13.178|
                  |L13.138|
00008a  6828              LDR      r0,[r5,#0]            ;1509
00008c  2804              CMP      r0,#4                 ;1509
00008e  d200              BCS      |L13.146|
000090  2716              MOVS     r7,#0x16              ;1510
                  |L13.146|
000092  6820              LDR      r0,[r4,#0]            ;1513
000094  7800              LDRB     r0,[r0,#0]            ;1513
000096  2820              CMP      r0,#0x20              ;1513
000098  d105              BNE      |L13.166|
00009a  6820              LDR      r0,[r4,#0]            ;1514
00009c  6840              LDR      r0,[r0,#4]            ;1514
00009e  7c00              LDRB     r0,[r0,#0x10]         ;1514
0000a0  f0000002          AND      r0,r0,#2              ;1514
0000a4  b100              CBZ      r0,|L13.168|
                  |L13.166|
0000a6  2761              MOVS     r7,#0x61              ;1516
                  |L13.168|
0000a8  e003              B        |L13.178|
                  |L13.170|
0000aa  bf00              NOP                            ;1522
0000ac  bf00              NOP                            ;1522
0000ae  275c              MOVS     r7,#0x5c              ;1524
0000b0  bf00              NOP                            ;1475
                  |L13.178|
0000b2  bf00              NOP                            ;1506
0000b4  e02b              B        |L13.270|
                  |L13.182|
0000b6  2e01              CMP      r6,#1                 ;1530
0000b8  d002              BEQ      |L13.192|
0000ba  2e02              CMP      r6,#2                 ;1530
0000bc  d105              BNE      |L13.202|
0000be  bf00              NOP                            ;1535
                  |L13.192|
0000c0  6828              LDR      r0,[r5,#0]            ;1536
0000c2  2804              CMP      r0,#4                 ;1536
0000c4  d200              BCS      |L13.200|
0000c6  2716              MOVS     r7,#0x16              ;1537
                  |L13.200|
0000c8  e003              B        |L13.210|
                  |L13.202|
0000ca  bf00              NOP                            ;1562
0000cc  bf00              NOP                            ;1562
0000ce  275c              MOVS     r7,#0x5c              ;1564
0000d0  bf00              NOP                            ;1530
                  |L13.210|
0000d2  bf00              NOP                            ;1539
0000d4  e01b              B        |L13.270|
                  |L13.214|
0000d6  6828              LDR      r0,[r5,#0]            ;1571
0000d8  2804              CMP      r0,#4                 ;1571
0000da  d201              BCS      |L13.224|
0000dc  2716              MOVS     r7,#0x16              ;1572
0000de  e016              B        |L13.270|
                  |L13.224|
0000e0  6820              LDR      r0,[r4,#0]            ;1577
0000e2  7800              LDRB     r0,[r0,#0]            ;1577
0000e4  2810              CMP      r0,#0x10              ;1577
0000e6  d001              BEQ      |L13.236|
0000e8  2000              MOVS     r0,#0                 ;1578
0000ea  e798              B        |L13.30|
                  |L13.236|
0000ec  2e01              CMP      r6,#1                 ;1580
0000ee  d002              BEQ      |L13.246|
0000f0  2e02              CMP      r6,#2                 ;1580
0000f2  d102              BNE      |L13.250|
0000f4  e000              B        |L13.248|
                  |L13.246|
0000f6  bf00              NOP                            ;1582
                  |L13.248|
0000f8  e003              B        |L13.258|
                  |L13.250|
0000fa  bf00              NOP                            ;1591
0000fc  bf00              NOP                            ;1591
0000fe  275c              MOVS     r7,#0x5c              ;1593
000100  bf00              NOP                            ;1580
                  |L13.258|
000102  bf00              NOP                            ;1588
000104  e003              B        |L13.270|
                  |L13.262|
000106  bf00              NOP                            ;1624
000108  bf00              NOP                            ;1624
00010a  275c              MOVS     r7,#0x5c              ;1626
00010c  bf00              NOP                            ;1471
                  |L13.270|
00010e  bf00              NOP                            ;1526
000110  b12f              CBZ      r7,|L13.286|
000112  bf00              NOP                            ;1631
000114  6127              STR      r7,[r4,#0x10]         ;1631
000116  bf00              NOP                            ;1631
000118  f04f30ff          MOV      r0,#0xffffffff        ;1632
00011c  e77f              B        |L13.30|
                  |L13.286|
00011e  9401              STR      r4,[sp,#4]            ;1636
000120  f8cda008          STR      r10,[sp,#8]           ;1638
000124  f8cd800c          STR      r8,[sp,#0xc]          ;1640
000128  9604              STR      r6,[sp,#0x10]         ;1641
00012a  f8cd9014          STR      r9,[sp,#0x14]         ;1642
00012e  9506              STR      r5,[sp,#0x18]         ;1643
000130  f88d701c          STRB     r7,[sp,#0x1c]         ;1644
000134  2201              MOVS     r2,#1                 ;1645
000136  a901              ADD      r1,sp,#4              ;1645
000138  4809              LDR      r0,|L13.352|
00013a  f7fffffe          BL       tcpip_callback_with_block
00013e  6821              LDR      r1,[r4,#0]            ;1646
000140  f101000c          ADD      r0,r1,#0xc            ;1646
000144  2100              MOVS     r1,#0                 ;1646
000146  f7fffffe          BL       sys_arch_sem_wait
00014a  f99d701c          LDRSB    r7,[sp,#0x1c]         ;1648
00014e  bf00              NOP                            ;1650
000150  6127              STR      r7,[r4,#0x10]         ;1650
000152  bf00              NOP                            ;1650
000154  b117              CBZ      r7,|L13.348|
000156  f04f30ff          MOV      r0,#0xffffffff        ;1651
00015a  e760              B        |L13.30|
                  |L13.348|
00015c  2000              MOVS     r0,#0                 ;1651
00015e  e75e              B        |L13.30|
;;;1653   
                          ENDP

                  |L13.352|
                          DCD      lwip_getsockopt_internal

                          AREA ||i.lwip_getsockopt_internal||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  lwip_getsockopt_internal PROC
;;;1654   static void
;;;1655   lwip_getsockopt_internal(void *arg)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1656   {
000004  4606              MOV      r6,r0
;;;1657     struct lwip_sock *sock;
;;;1658   #ifdef LWIP_DEBUG
;;;1659     int s;
;;;1660   #endif /* LWIP_DEBUG */
;;;1661     int level, optname;
;;;1662     void *optval;
;;;1663     struct lwip_setgetsockopt_data *data;
;;;1664   
;;;1665     LWIP_ASSERT("arg != NULL", arg != NULL);
000006  bf00              NOP      
000008  b946              CBNZ     r6,|L14.28|
00000a  bf00              NOP      
00000c  a379              ADR      r3,|L14.500|
00000e  f2406281          MOV      r2,#0x681
000012  a182              ADR      r1,|L14.540|
000014  a084              ADR      r0,|L14.552|
000016  f7fffffe          BL       __2printf
00001a  bf00              NOP      
                  |L14.28|
00001c  bf00              NOP      
;;;1666   
;;;1667     data = (struct lwip_setgetsockopt_data*)arg;
00001e  4637              MOV      r7,r6
;;;1668     sock = data->sock;
000020  463e              MOV      r6,r7
000022  683c              LDR      r4,[r7,#0]
;;;1669   #ifdef LWIP_DEBUG
;;;1670     s = data->s;
000024  f8d7a004          LDR      r10,[r7,#4]
;;;1671   #endif /* LWIP_DEBUG */
;;;1672     level = data->level;
000028  f8d79008          LDR      r9,[r7,#8]
;;;1673     optname = data->optname;
00002c  f8d7800c          LDR      r8,[r7,#0xc]
;;;1674     optval = data->optval;
000030  693d              LDR      r5,[r7,#0x10]
;;;1675   
;;;1676     switch (level) {
000032  f1b90f00          CMP      r9,#0
000036  d06f              BEQ      |L14.280|
000038  f1b90f06          CMP      r9,#6
00003c  d06d              BEQ      |L14.282|
00003e  f6a970ff          SUB      r0,r9,#0xfff
000042  2800              CMP      r0,#0
000044  d16a              BNE      |L14.284|
;;;1677   
;;;1678   /* Level: SOL_SOCKET */
;;;1679     case SOL_SOCKET:
;;;1680       switch (optname) {
000046  f2410106          MOV      r1,#0x1006
00004a  eba80001          SUB      r0,r8,r1
00004e  4588              CMP      r8,r1
000050  d057              BEQ      |L14.258|
000052  dc09              BGT      |L14.104|
000054  f1b80f02          CMP      r8,#2
000058  d00d              BEQ      |L14.118|
00005a  f1b80f08          CMP      r8,#8
00005e  d00c              BEQ      |L14.122|
000060  f1b80f20          CMP      r8,#0x20
000064  d15b              BNE      |L14.286|
000066  e007              B        |L14.120|
                  |L14.104|
000068  2801              CMP      r0,#1
00006a  d02c              BEQ      |L14.198|
00006c  2802              CMP      r0,#2
00006e  d00d              BEQ      |L14.140|
000070  2804              CMP      r0,#4
000072  d154              BNE      |L14.286|
000074  e049              B        |L14.266|
                  |L14.118|
;;;1681   
;;;1682       /* The option flags */
;;;1683       case SO_ACCEPTCONN:
;;;1684       case SO_BROADCAST:
000076  bf00              NOP      
                  |L14.120|
;;;1685       /* UNIMPL case SO_DEBUG: */
;;;1686       /* UNIMPL case SO_DONTROUTE: */
;;;1687       case SO_KEEPALIVE:
000078  bf00              NOP      
                  |L14.122|
;;;1688       /* UNIMPL case SO_OOBINCLUDE: */
;;;1689   #if SO_REUSE
;;;1690       case SO_REUSEADDR:
;;;1691       case SO_REUSEPORT:
;;;1692   #endif /* SO_REUSE */
;;;1693       /*case SO_USELOOPBACK: UNIMPL */
;;;1694         *(int*)optval = ip_get_option(sock->conn->pcb.ip, optname);
00007a  6820              LDR      r0,[r4,#0]
00007c  6840              LDR      r0,[r0,#4]
00007e  7a00              LDRB     r0,[r0,#8]
000080  ea000008          AND      r0,r0,r8
000084  6028              STR      r0,[r5,#0]
;;;1695         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
000086  bf00              NOP      
000088  bf00              NOP      
;;;1696                                     s, optname, (*(int*)optval?"on":"off")));
;;;1697         break;
00008a  e054              B        |L14.310|
                  |L14.140|
;;;1698   
;;;1699       case SO_TYPE:
;;;1700         switch (NETCONNTYPE_GROUP(sock->conn->type)) {
00008c  6820              LDR      r0,[r4,#0]
00008e  7800              LDRB     r0,[r0,#0]
000090  f00000f0          AND      r0,r0,#0xf0
000094  2810              CMP      r0,#0x10
000096  d006              BEQ      |L14.166|
000098  2820              CMP      r0,#0x20
00009a  d007              BEQ      |L14.172|
00009c  2840              CMP      r0,#0x40
00009e  d108              BNE      |L14.178|
;;;1701         case NETCONN_RAW:
;;;1702           *(int*)optval = SOCK_RAW;
0000a0  2003              MOVS     r0,#3
0000a2  6028              STR      r0,[r5,#0]
;;;1703           break;
0000a4  e00b              B        |L14.190|
                  |L14.166|
;;;1704         case NETCONN_TCP:
;;;1705           *(int*)optval = SOCK_STREAM;
0000a6  2001              MOVS     r0,#1
0000a8  6028              STR      r0,[r5,#0]
;;;1706           break;
0000aa  e008              B        |L14.190|
                  |L14.172|
;;;1707         case NETCONN_UDP:
;;;1708           *(int*)optval = SOCK_DGRAM;
0000ac  2002              MOVS     r0,#2
0000ae  6028              STR      r0,[r5,#0]
;;;1709           break;
0000b0  e005              B        |L14.190|
                  |L14.178|
;;;1710         default: /* unrecognized socket type */
;;;1711           *(int*)optval = sock->conn->type;
0000b2  6820              LDR      r0,[r4,#0]
0000b4  7800              LDRB     r0,[r0,#0]
0000b6  6028              STR      r0,[r5,#0]
;;;1712           LWIP_DEBUGF(SOCKETS_DEBUG,
0000b8  bf00              NOP      
0000ba  bf00              NOP      
0000bc  bf00              NOP                            ;1700
                  |L14.190|
0000be  bf00              NOP                            ;1703
;;;1713                       ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
;;;1714                       s, *(int *)optval));
;;;1715         }  /* switch (sock->conn->type) */
;;;1716         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
0000c0  bf00              NOP      
0000c2  bf00              NOP      
;;;1717                     s, *(int *)optval));
;;;1718         break;
0000c4  e037              B        |L14.310|
                  |L14.198|
;;;1719   
;;;1720       case SO_ERROR:
;;;1721         /* only overwrite ERR_OK or tempoary errors */
;;;1722         if ((sock->err == 0) || (sock->err == EINPROGRESS)) {
0000c6  6920              LDR      r0,[r4,#0x10]
0000c8  b110              CBZ      r0,|L14.208|
0000ca  6920              LDR      r0,[r4,#0x10]
0000cc  2873              CMP      r0,#0x73
0000ce  d111              BNE      |L14.244|
                  |L14.208|
;;;1723           sock_set_errno(sock, err_to_errno(sock->conn->last_err));
0000d0  bf00              NOP      
0000d2  6820              LDR      r0,[r4,#0]
0000d4  f9900008          LDRSB    r0,[r0,#8]
0000d8  4240              RSBS     r0,r0,#0
0000da  2810              CMP      r0,#0x10
0000dc  d207              BCS      |L14.238|
0000de  6820              LDR      r0,[r4,#0]
0000e0  f9900008          LDRSB    r0,[r0,#8]
0000e4  4240              RSBS     r0,r0,#0
0000e6  495b              LDR      r1,|L14.596|
0000e8  f8510020          LDR      r0,[r1,r0,LSL #2]
0000ec  e000              B        |L14.240|
                  |L14.238|
0000ee  2005              MOVS     r0,#5
                  |L14.240|
0000f0  6120              STR      r0,[r4,#0x10]
0000f2  bf00              NOP      
                  |L14.244|
;;;1724         } 
;;;1725         *(int *)optval = sock->err;
0000f4  6920              LDR      r0,[r4,#0x10]
0000f6  6028              STR      r0,[r5,#0]
;;;1726         sock->err = 0;
0000f8  2000              MOVS     r0,#0
0000fa  6120              STR      r0,[r4,#0x10]
;;;1727         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
0000fc  bf00              NOP      
0000fe  bf00              NOP      
;;;1728                     s, *(int *)optval));
;;;1729         break;
000100  e019              B        |L14.310|
                  |L14.258|
;;;1730   
;;;1731   #if LWIP_SO_SNDTIMEO
;;;1732       case SO_SNDTIMEO:
;;;1733         *(int *)optval = netconn_get_sendtimeout(sock->conn);
;;;1734         break;
;;;1735   #endif /* LWIP_SO_SNDTIMEO */
;;;1736   #if LWIP_SO_RCVTIMEO
;;;1737       case SO_RCVTIMEO:
;;;1738         *(int *)optval = netconn_get_recvtimeout(sock->conn);
000102  6820              LDR      r0,[r4,#0]
000104  69c0              LDR      r0,[r0,#0x1c]
000106  6028              STR      r0,[r5,#0]
;;;1739         break;
000108  e015              B        |L14.310|
                  |L14.266|
;;;1740   #endif /* LWIP_SO_RCVTIMEO */
;;;1741   #if LWIP_SO_RCVBUF
;;;1742       case SO_RCVBUF:
;;;1743         *(int *)optval = netconn_get_recvbufsize(sock->conn);
;;;1744         break;
;;;1745   #endif /* LWIP_SO_RCVBUF */
;;;1746   #if LWIP_UDP
;;;1747       case SO_NO_CHECK:
;;;1748         *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
00010a  6820              LDR      r0,[r4,#0]
00010c  6840              LDR      r0,[r0,#4]
00010e  7c00              LDRB     r0,[r0,#0x10]
000110  f0000001          AND      r0,r0,#1
000114  6028              STR      r0,[r5,#0]
;;;1749         break;
000116  e00e              B        |L14.310|
                  |L14.280|
000118  e00f              B        |L14.314|
                  |L14.282|
00011a  e030              B        |L14.382|
                  |L14.284|
00011c  e055              B        |L14.458|
                  |L14.286|
;;;1750   #endif /* LWIP_UDP*/
;;;1751       default:
;;;1752         LWIP_ASSERT("unhandled optname", 0);
00011e  bf00              NOP      
000120  bf00              NOP      
000122  a334              ADR      r3,|L14.500|
000124  f44f62db          MOV      r2,#0x6d8
000128  a14b              ADR      r1,|L14.600|
00012a  a03f              ADR      r0,|L14.552|
00012c  f7fffffe          BL       __2printf
000130  bf00              NOP      
000132  bf00              NOP      
;;;1753         break;
000134  bf00              NOP      
                  |L14.310|
000136  bf00              NOP                            ;1697
;;;1754       }  /* switch (optname) */
;;;1755       break;
000138  e053              B        |L14.482|
                  |L14.314|
;;;1756   
;;;1757   /* Level: IPPROTO_IP */
;;;1758     case IPPROTO_IP:
;;;1759       switch (optname) {
00013a  f1b80f01          CMP      r8,#1
00013e  d009              BEQ      |L14.340|
000140  f1b80f02          CMP      r8,#2
000144  d10d              BNE      |L14.354|
;;;1760       case IP_TTL:
;;;1761         *(int*)optval = sock->conn->pcb.ip->ttl;
000146  6820              LDR      r0,[r4,#0]
000148  6840              LDR      r0,[r0,#4]
00014a  7a80              LDRB     r0,[r0,#0xa]
00014c  6028              STR      r0,[r5,#0]
;;;1762         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
00014e  bf00              NOP      
000150  bf00              NOP      
;;;1763                     s, *(int *)optval));
;;;1764         break;
000152  e012              B        |L14.378|
                  |L14.340|
;;;1765       case IP_TOS:
;;;1766         *(int*)optval = sock->conn->pcb.ip->tos;
000154  6820              LDR      r0,[r4,#0]
000156  6840              LDR      r0,[r0,#4]
000158  7a40              LDRB     r0,[r0,#9]
00015a  6028              STR      r0,[r5,#0]
;;;1767         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
00015c  bf00              NOP      
00015e  bf00              NOP      
;;;1768                     s, *(int *)optval));
;;;1769         break;
000160  e00b              B        |L14.378|
                  |L14.354|
;;;1770   #if LWIP_IGMP
;;;1771       case IP_MULTICAST_TTL:
;;;1772         *(u8_t*)optval = sock->conn->pcb.ip->ttl;
;;;1773         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_TTL) = %d\n",
;;;1774                     s, *(int *)optval));
;;;1775         break;
;;;1776       case IP_MULTICAST_IF:
;;;1777         inet_addr_from_ipaddr((struct in_addr*)optval, &sock->conn->pcb.udp->multicast_ip);
;;;1778         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%"X32_F"\n",
;;;1779                     s, *(u32_t *)optval));
;;;1780         break;
;;;1781       case IP_MULTICAST_LOOP:
;;;1782         if ((sock->conn->pcb.udp->flags & UDP_FLAGS_MULTICAST_LOOP) != 0) {
;;;1783           *(u8_t*)optval = 1;
;;;1784         } else {
;;;1785           *(u8_t*)optval = 0;
;;;1786         }
;;;1787         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_LOOP) = %d\n",
;;;1788                     s, *(int *)optval));
;;;1789         break;
;;;1790   #endif /* LWIP_IGMP */
;;;1791       default:
;;;1792         LWIP_ASSERT("unhandled optname", 0);
000162  bf00              NOP      
000164  bf00              NOP      
000166  a323              ADR      r3,|L14.500|
000168  f44f62e0          MOV      r2,#0x700
00016c  a13a              ADR      r1,|L14.600|
00016e  a02e              ADR      r0,|L14.552|
000170  f7fffffe          BL       __2printf
000174  bf00              NOP      
000176  bf00              NOP      
;;;1793         break;
000178  bf00              NOP      
                  |L14.378|
00017a  bf00              NOP                            ;1764
;;;1794       }  /* switch (optname) */
;;;1795       break;
00017c  e031              B        |L14.482|
                  |L14.382|
;;;1796   
;;;1797   #if LWIP_TCP
;;;1798   /* Level: IPPROTO_TCP */
;;;1799     case IPPROTO_TCP:
;;;1800       switch (optname) {
00017e  f1b80f01          CMP      r8,#1
000182  d003              BEQ      |L14.396|
000184  f1b80f02          CMP      r8,#2
000188  d111              BNE      |L14.430|
00018a  e008              B        |L14.414|
                  |L14.396|
;;;1801       case TCP_NODELAY:
;;;1802         *(int*)optval = tcp_nagle_disabled(sock->conn->pcb.tcp);
00018c  6820              LDR      r0,[r4,#0]
00018e  6840              LDR      r0,[r0,#4]
000190  7f80              LDRB     r0,[r0,#0x1e]
000192  f3c01080          UBFX     r0,r0,#6,#1
000196  6028              STR      r0,[r5,#0]
;;;1803         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
000198  bf00              NOP      
00019a  bf00              NOP      
;;;1804                     s, (*(int*)optval)?"on":"off") );
;;;1805         break;
00019c  e013              B        |L14.454|
                  |L14.414|
;;;1806       case TCP_KEEPALIVE:
;;;1807         *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
00019e  6820              LDR      r0,[r4,#0]
0001a0  6840              LDR      r0,[r0,#4]
0001a2  f8d00090          LDR      r0,[r0,#0x90]
0001a6  6028              STR      r0,[r5,#0]
;;;1808         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n",
0001a8  bf00              NOP      
0001aa  bf00              NOP      
;;;1809                     s, *(int *)optval));
;;;1810         break;
0001ac  e00b              B        |L14.454|
                  |L14.430|
;;;1811   
;;;1812   #if LWIP_TCP_KEEPALIVE
;;;1813       case TCP_KEEPIDLE:
;;;1814         *(int*)optval = (int)(sock->conn->pcb.tcp->keep_idle/1000);
;;;1815         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPIDLE) = %d\n",
;;;1816                     s, *(int *)optval));
;;;1817         break;
;;;1818       case TCP_KEEPINTVL:
;;;1819         *(int*)optval = (int)(sock->conn->pcb.tcp->keep_intvl/1000);
;;;1820         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPINTVL) = %d\n",
;;;1821                     s, *(int *)optval));
;;;1822         break;
;;;1823       case TCP_KEEPCNT:
;;;1824         *(int*)optval = (int)sock->conn->pcb.tcp->keep_cnt;
;;;1825         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPCNT) = %d\n",
;;;1826                     s, *(int *)optval));
;;;1827         break;
;;;1828   #endif /* LWIP_TCP_KEEPALIVE */
;;;1829       default:
;;;1830         LWIP_ASSERT("unhandled optname", 0);
0001ae  bf00              NOP      
0001b0  bf00              NOP      
0001b2  a310              ADR      r3,|L14.500|
0001b4  f2407226          MOV      r2,#0x726
0001b8  a127              ADR      r1,|L14.600|
0001ba  a01b              ADR      r0,|L14.552|
0001bc  f7fffffe          BL       __2printf
0001c0  bf00              NOP      
0001c2  bf00              NOP      
;;;1831         break;
0001c4  bf00              NOP      
                  |L14.454|
0001c6  bf00              NOP                            ;1805
;;;1832       }  /* switch (optname) */
;;;1833       break;
0001c8  e00b              B        |L14.482|
                  |L14.458|
;;;1834   #endif /* LWIP_TCP */
;;;1835   #if LWIP_UDP && LWIP_UDPLITE
;;;1836     /* Level: IPPROTO_UDPLITE */
;;;1837     case IPPROTO_UDPLITE:
;;;1838       switch (optname) {
;;;1839       case UDPLITE_SEND_CSCOV:
;;;1840         *(int*)optval = sock->conn->pcb.udp->chksum_len_tx;
;;;1841         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV) = %d\n",
;;;1842                     s, (*(int*)optval)) );
;;;1843         break;
;;;1844       case UDPLITE_RECV_CSCOV:
;;;1845         *(int*)optval = sock->conn->pcb.udp->chksum_len_rx;
;;;1846         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV) = %d\n",
;;;1847                     s, (*(int*)optval)) );
;;;1848         break;
;;;1849       default:
;;;1850         LWIP_ASSERT("unhandled optname", 0);
;;;1851         break;
;;;1852       }  /* switch (optname) */
;;;1853       break;
;;;1854   #endif /* LWIP_UDP */
;;;1855     default:
;;;1856       LWIP_ASSERT("unhandled level", 0);
0001ca  bf00              NOP      
0001cc  bf00              NOP      
0001ce  a309              ADR      r3,|L14.500|
0001d0  f44f62e8          MOV      r2,#0x740
0001d4  a125              ADR      r1,|L14.620|
0001d6  a014              ADR      r0,|L14.552|
0001d8  f7fffffe          BL       __2printf
0001dc  bf00              NOP      
0001de  bf00              NOP      
;;;1857       break;
0001e0  bf00              NOP      
                  |L14.482|
0001e2  bf00              NOP                            ;1755
;;;1858     } /* switch (level) */
;;;1859     sys_sem_signal(&sock->conn->op_completed);
0001e4  6821              LDR      r1,[r4,#0]
0001e6  f101000c          ADD      r0,r1,#0xc
0001ea  f7fffffe          BL       sys_sem_signal
;;;1860   }
0001ee  e8bd87f0          POP      {r4-r10,pc}
;;;1861   
                          ENDP

0001f2  0000              DCW      0x0000
                  |L14.500|
0001f4  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\sockets.c",0
0001f8  5749505c
0001fc  6c776970
000200  2d312e34
000204  2e315c73
000208  72635c61
00020c  70695c73
000210  6f636b65
000214  74732e63
000218  00      
000219  00                DCB      0
00021a  00                DCB      0
00021b  00                DCB      0
                  |L14.540|
00021c  61726720          DCB      "arg != NULL",0
000220  213d204e
000224  554c4c00
                  |L14.552|
000228  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
00022c  7274696f
000230  6e202225
000234  73222066
000238  61696c65
00023c  64206174
000240  206c696e
000244  65202564
000248  20696e20
00024c  25730d0a
000250  00      
000251  00                DCB      0
000252  00                DCB      0
000253  00                DCB      0
                  |L14.596|
                          DCD      err_to_errno_table
                  |L14.600|
000258  756e6861          DCB      "unhandled optname",0
00025c  6e646c65
000260  64206f70
000264  746e616d
000268  6500    
00026a  00                DCB      0
00026b  00                DCB      0
                  |L14.620|
00026c  756e6861          DCB      "unhandled level",0
000270  6e646c65
000274  64206c65
000278  76656c00

                          AREA ||i.lwip_ioctl||, CODE, READONLY, ALIGN=2

                  lwip_ioctl PROC
;;;2280   int
;;;2281   lwip_ioctl(int s, long cmd, void *argp)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2282   {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;2283     struct lwip_sock *sock = get_socket(s);
00000a  4640              MOV      r0,r8
00000c  f7fffffe          BL       get_socket
000010  4604              MOV      r4,r0
;;;2284     u8_t val;
;;;2285   #if LWIP_SO_RCVBUF
;;;2286     u16_t buflen = 0;
;;;2287     s16_t recv_avail;
;;;2288   #endif /* LWIP_SO_RCVBUF */
;;;2289   
;;;2290     if (!sock) {
000012  b91c              CBNZ     r4,|L15.28|
;;;2291       return -1;
000014  f04f30ff          MOV      r0,#0xffffffff
                  |L15.24|
;;;2292     }
;;;2293   
;;;2294     switch (cmd) {
;;;2295   #if LWIP_SO_RCVBUF
;;;2296     case FIONREAD:
;;;2297       if (!argp) {
;;;2298         sock_set_errno(sock, EINVAL);
;;;2299         return -1;
;;;2300       }
;;;2301   
;;;2302       SYS_ARCH_GET(sock->conn->recv_avail, recv_avail);
;;;2303       if (recv_avail < 0) {
;;;2304         recv_avail = 0;
;;;2305       }
;;;2306       *((u16_t*)argp) = (u16_t)recv_avail;
;;;2307   
;;;2308       /* Check if there is data left from the last recv operation. /maq 041215 */
;;;2309       if (sock->lastdata) {
;;;2310         struct pbuf *p = (struct pbuf *)sock->lastdata;
;;;2311         if (netconn_type(sock->conn) != NETCONN_TCP) {
;;;2312           p = ((struct netbuf *)p)->p;
;;;2313         }
;;;2314         buflen = p->tot_len;
;;;2315         buflen -= sock->lastoffset;
;;;2316   
;;;2317         *((u16_t*)argp) += buflen;
;;;2318       }
;;;2319   
;;;2320       LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %"U16_F"\n", s, argp, *((u16_t*)argp)));
;;;2321       sock_set_errno(sock, 0);
;;;2322       return 0;
;;;2323   #endif /* LWIP_SO_RCVBUF */
;;;2324   
;;;2325     case FIONBIO:
;;;2326       val = 0;
;;;2327       if (argp && *(u32_t*)argp) {
;;;2328         val = 1;
;;;2329       }
;;;2330       netconn_set_nonblocking(sock->conn, val);
;;;2331       LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, val));
;;;2332       sock_set_errno(sock, 0);
;;;2333       return 0;
;;;2334   
;;;2335     default:
;;;2336       LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
;;;2337       sock_set_errno(sock, ENOSYS); /* not yet implemented */
;;;2338       return -1;
;;;2339     } /* switch (cmd) */
;;;2340   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L15.28|
00001c  4815              LDR      r0,|L15.116|
00001e  4430              ADD      r0,r0,r6              ;2294
000020  b9f8              CBNZ     r0,|L15.98|
000022  2700              MOVS     r7,#0                 ;2326
000024  b115              CBZ      r5,|L15.44|
000026  6828              LDR      r0,[r5,#0]            ;2327
000028  b100              CBZ      r0,|L15.44|
00002a  2701              MOVS     r7,#1                 ;2328
                  |L15.44|
00002c  bf00              NOP                            ;2330
00002e  b147              CBZ      r7,|L15.66|
000030  6820              LDR      r0,[r4,#0]            ;2330
000032  f8900020          LDRB     r0,[r0,#0x20]         ;2330
000036  f0400002          ORR      r0,r0,#2              ;2330
00003a  6821              LDR      r1,[r4,#0]            ;2330
00003c  f8810020          STRB     r0,[r1,#0x20]         ;2330
000040  e007              B        |L15.82|
                  |L15.66|
000042  6820              LDR      r0,[r4,#0]            ;2330
000044  f8900020          LDRB     r0,[r0,#0x20]         ;2330
000048  f0200002          BIC      r0,r0,#2              ;2330
00004c  6821              LDR      r1,[r4,#0]            ;2330
00004e  f8810020          STRB     r0,[r1,#0x20]         ;2330
                  |L15.82|
000052  bf00              NOP                            ;2330
000054  bf00              NOP                            ;2331
000056  bf00              NOP                            ;2331
000058  bf00              NOP                            ;2332
00005a  2000              MOVS     r0,#0                 ;2332
00005c  6120              STR      r0,[r4,#0x10]         ;2332
00005e  bf00              NOP                            ;2332
000060  e7da              B        |L15.24|
                  |L15.98|
000062  bf00              NOP                            ;2336
000064  bf00              NOP                            ;2336
000066  bf00              NOP                            ;2337
000068  2026              MOVS     r0,#0x26              ;2337
00006a  6120              STR      r0,[r4,#0x10]         ;2337
00006c  bf00              NOP                            ;2337
00006e  f04f30ff          MOV      r0,#0xffffffff        ;2338
000072  e7d1              B        |L15.24|
;;;2341   
                          ENDP

                  |L15.116|
                          DCD      0x7ffb9982

                          AREA ||i.lwip_listen||, CODE, READONLY, ALIGN=2

                  lwip_listen PROC
;;;524    int
;;;525    lwip_listen(int s, int backlog)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;526    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
;;;527      struct lwip_sock *sock;
;;;528      err_t err;
;;;529    
;;;530      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));
000008  bf00              NOP      
00000a  bf00              NOP      
;;;531    
;;;532      sock = get_socket(s);
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       get_socket
000012  4604              MOV      r4,r0
;;;533      if (!sock) {
000014  b91c              CBNZ     r4,|L16.30|
;;;534        return -1;
000016  f04f30ff          MOV      r0,#0xffffffff
                  |L16.26|
;;;535      }
;;;536    
;;;537      /* limit the "backlog" parameter to fit in an u8_t */
;;;538      backlog = LWIP_MIN(LWIP_MAX(backlog, 0), 0xff);
;;;539    
;;;540      err = netconn_listen_with_backlog(sock->conn, (u8_t)backlog);
;;;541    
;;;542      if (err != ERR_OK) {
;;;543        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
;;;544        if (netconn_type(sock->conn) != NETCONN_TCP) {
;;;545          sock_set_errno(sock, EOPNOTSUPP);
;;;546          return EOPNOTSUPP;
;;;547        }
;;;548        sock_set_errno(sock, err_to_errno(err));
;;;549        return -1;
;;;550      }
;;;551    
;;;552      sock_set_errno(sock, 0);
;;;553      return 0;
;;;554    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L16.30|
00001e  2e00              CMP      r6,#0                 ;538
000020  dd01              BLE      |L16.38|
000022  4630              MOV      r0,r6                 ;538
000024  e000              B        |L16.40|
                  |L16.38|
000026  2000              MOVS     r0,#0                 ;538
                  |L16.40|
000028  28ff              CMP      r0,#0xff              ;538
00002a  da05              BGE      |L16.56|
00002c  2e00              CMP      r6,#0                 ;538
00002e  dd01              BLE      |L16.52|
000030  4630              MOV      r0,r6                 ;538
000032  e002              B        |L16.58|
                  |L16.52|
000034  2000              MOVS     r0,#0                 ;538
000036  e000              B        |L16.58|
                  |L16.56|
000038  20ff              MOVS     r0,#0xff              ;538
                  |L16.58|
00003a  4606              MOV      r6,r0                 ;538
00003c  b2f1              UXTB     r1,r6                 ;540
00003e  6820              LDR      r0,[r4,#0]            ;540
000040  f7fffffe          BL       netconn_listen_with_backlog
000044  4605              MOV      r5,r0                 ;540
000046  b1cd              CBZ      r5,|L16.124|
000048  bf00              NOP                            ;543
00004a  bf00              NOP                            ;543
00004c  6820              LDR      r0,[r4,#0]            ;544
00004e  7800              LDRB     r0,[r0,#0]            ;544
000050  2810              CMP      r0,#0x10              ;544
000052  d004              BEQ      |L16.94|
000054  bf00              NOP                            ;545
000056  205f              MOVS     r0,#0x5f              ;545
000058  6120              STR      r0,[r4,#0x10]         ;545
00005a  bf00              NOP                            ;545
00005c  e7dd              B        |L16.26|
                  |L16.94|
00005e  bf00              NOP                            ;548
000060  4268              RSBS     r0,r5,#0              ;548
000062  2810              CMP      r0,#0x10              ;548
000064  d204              BCS      |L16.112|
000066  4808              LDR      r0,|L16.136|
000068  4269              RSBS     r1,r5,#0              ;548
00006a  f8500021          LDR      r0,[r0,r1,LSL #2]     ;548
00006e  e000              B        |L16.114|
                  |L16.112|
000070  2005              MOVS     r0,#5                 ;548
                  |L16.114|
000072  6120              STR      r0,[r4,#0x10]         ;548
000074  bf00              NOP                            ;548
000076  f04f30ff          MOV      r0,#0xffffffff        ;549
00007a  e7ce              B        |L16.26|
                  |L16.124|
00007c  bf00              NOP                            ;552
00007e  2000              MOVS     r0,#0                 ;552
000080  6120              STR      r0,[r4,#0x10]         ;552
000082  bf00              NOP                            ;552
000084  bf00              NOP                            ;553
000086  e7c8              B        |L16.26|
;;;555    
                          ENDP

                  |L16.136|
                          DCD      err_to_errno_table

                          AREA ||i.lwip_read||, CODE, READONLY, ALIGN=1

                  lwip_read PROC
;;;741    int
;;;742    lwip_read(int s, void *mem, size_t len)
000000  b57c              PUSH     {r2-r6,lr}
;;;743    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;744      return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
00000c  4603              MOV      r3,r0
00000e  4632              MOV      r2,r6
000010  4629              MOV      r1,r5
000012  9001              STR      r0,[sp,#4]
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       lwip_recvfrom
;;;745    }
00001a  bd7c              POP      {r2-r6,pc}
;;;746    
                          ENDP


                          AREA ||i.lwip_recv||, CODE, READONLY, ALIGN=1

                  lwip_recv PROC
;;;747    int
;;;748    lwip_recv(int s, void *mem, size_t len, int flags)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;749    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;750      return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
000010  463b              MOV      r3,r7
000012  4632              MOV      r2,r6
000014  4629              MOV      r1,r5
000016  9001              STR      r0,[sp,#4]
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       lwip_recvfrom
;;;751    }
00001e  e8bd81fc          POP      {r2-r8,pc}
;;;752    
                          ENDP


                          AREA ||i.lwip_recvfrom||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  lwip_recvfrom PROC
;;;556    int
;;;557    lwip_recvfrom(int s, void *mem, size_t len, int flags,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;558            struct sockaddr *from, socklen_t *fromlen)
;;;559    {
000004  b08b              SUB      sp,sp,#0x2c
000006  4616              MOV      r6,r2
000008  4698              MOV      r8,r3
00000a  f8dd9064          LDR      r9,[sp,#0x64]
;;;560      struct lwip_sock *sock;
;;;561      void             *buf = NULL;
00000e  2000              MOVS     r0,#0
000010  900a              STR      r0,[sp,#0x28]
;;;562      struct pbuf      *p;
;;;563      u16_t            buflen, copylen;
;;;564      int              off = 0;
000012  2500              MOVS     r5,#0
;;;565      ip_addr_t        *addr;
;;;566      u16_t            port;
;;;567      u8_t             done = 0;
000014  9006              STR      r0,[sp,#0x18]
;;;568      err_t            err;
;;;569    
;;;570      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %"SZT_F", 0x%x, ..)\n", s, mem, len, flags));
000016  bf00              NOP      
000018  bf00              NOP      
;;;571      sock = get_socket(s);
00001a  980b              LDR      r0,[sp,#0x2c]
00001c  f7fffffe          BL       get_socket
000020  4604              MOV      r4,r0
;;;572      if (!sock) {
000022  b91c              CBNZ     r4,|L19.44|
;;;573        return -1;
000024  1e68              SUBS     r0,r5,#1
                  |L19.38|
;;;574      }
;;;575    
;;;576      do {
;;;577        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", sock->lastdata));
;;;578        /* Check if there is data left from the last recv operation. */
;;;579        if (sock->lastdata) {
;;;580          buf = sock->lastdata;
;;;581        } else {
;;;582          /* If this is non-blocking call, then check first */
;;;583          if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) && 
;;;584              (sock->rcvevent <= 0)) {
;;;585            if (off > 0) {
;;;586              /* update receive window */
;;;587              netconn_recved(sock->conn, (u32_t)off);
;;;588              /* already received data, return that */
;;;589              sock_set_errno(sock, 0);
;;;590              return off;
;;;591            }
;;;592            LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
;;;593            sock_set_errno(sock, EWOULDBLOCK);
;;;594            return -1;
;;;595          }
;;;596    
;;;597          /* No data was left from the previous operation, so we try to get
;;;598             some from the network. */
;;;599          if (netconn_type(sock->conn) == NETCONN_TCP) {
;;;600            err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
;;;601          } else {
;;;602            err = netconn_recv(sock->conn, (struct netbuf **)&buf);
;;;603          }
;;;604          LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv err=%d, netbuf=%p\n",
;;;605            err, buf));
;;;606    
;;;607          if (err != ERR_OK) {
;;;608            if (off > 0) {
;;;609              /* update receive window */
;;;610              netconn_recved(sock->conn, (u32_t)off);
;;;611              /* already received data, return that */
;;;612              sock_set_errno(sock, 0);
;;;613              return off;
;;;614            }
;;;615            /* We should really do some error checking here. */
;;;616            LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL, error is \"%s\"!\n",
;;;617              s, lwip_strerr(err)));
;;;618            sock_set_errno(sock, err_to_errno(err));
;;;619            if (err == ERR_CLSD) {
;;;620              return 0;
;;;621            } else {
;;;622              return -1;
;;;623            }
;;;624          }
;;;625          LWIP_ASSERT("buf != NULL", buf != NULL);
;;;626          sock->lastdata = buf;
;;;627        }
;;;628    
;;;629        if (netconn_type(sock->conn) == NETCONN_TCP) {
;;;630          p = (struct pbuf *)buf;
;;;631        } else {
;;;632          p = ((struct netbuf *)buf)->p;
;;;633        }
;;;634        buflen = p->tot_len;
;;;635        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%"U16_F" len=%"SZT_F" off=%d sock->lastoffset=%"U16_F"\n",
;;;636          buflen, len, off, sock->lastoffset));
;;;637    
;;;638        buflen -= sock->lastoffset;
;;;639    
;;;640        if (len > buflen) {
;;;641          copylen = buflen;
;;;642        } else {
;;;643          copylen = (u16_t)len;
;;;644        }
;;;645    
;;;646        /* copy the contents of the received buffer into
;;;647        the supplied memory pointer mem */
;;;648        pbuf_copy_partial(p, (u8_t*)mem + off, copylen, sock->lastoffset);
;;;649    
;;;650        off += copylen;
;;;651    
;;;652        if (netconn_type(sock->conn) == NETCONN_TCP) {
;;;653          LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
;;;654          len -= copylen;
;;;655          if ( (len <= 0) || 
;;;656               (p->flags & PBUF_FLAG_PUSH) || 
;;;657               (sock->rcvevent <= 0) || 
;;;658               ((flags & MSG_PEEK)!=0)) {
;;;659            done = 1;
;;;660          }
;;;661        } else {
;;;662          done = 1;
;;;663        }
;;;664    
;;;665        /* Check to see from where the data was.*/
;;;666        if (done) {
;;;667          ip_addr_t fromaddr;
;;;668          if (from && fromlen) {
;;;669            struct sockaddr_in sin;
;;;670    
;;;671            if (netconn_type(sock->conn) == NETCONN_TCP) {
;;;672              addr = &fromaddr;
;;;673              netconn_getaddr(sock->conn, addr, &port, 0);
;;;674            } else {
;;;675              addr = netbuf_fromaddr((struct netbuf *)buf);
;;;676              port = netbuf_fromport((struct netbuf *)buf);
;;;677            }
;;;678    
;;;679            memset(&sin, 0, sizeof(sin));
;;;680            sin.sin_len = sizeof(sin);
;;;681            sin.sin_family = AF_INET;
;;;682            sin.sin_port = htons(port);
;;;683            inet_addr_from_ipaddr(&sin.sin_addr, addr);
;;;684    
;;;685            if (*fromlen > sizeof(sin)) {
;;;686              *fromlen = sizeof(sin);
;;;687            }
;;;688    
;;;689            MEMCPY(from, &sin, *fromlen);
;;;690    
;;;691            LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): addr=", s));
;;;692            ip_addr_debug_print(SOCKETS_DEBUG, addr);
;;;693            LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F" len=%d\n", port, off));
;;;694          } else {
;;;695    #if SOCKETS_DEBUG
;;;696            if (netconn_type(sock->conn) == NETCONN_TCP) {
;;;697              addr = &fromaddr;
;;;698              netconn_getaddr(sock->conn, addr, &port, 0);
;;;699            } else {
;;;700              addr = netbuf_fromaddr((struct netbuf *)buf);
;;;701              port = netbuf_fromport((struct netbuf *)buf);
;;;702            }
;;;703    
;;;704            LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): addr=", s));
;;;705            ip_addr_debug_print(SOCKETS_DEBUG, addr);
;;;706            LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F" len=%d\n", port, off));
;;;707    #endif /*  SOCKETS_DEBUG */
;;;708          }
;;;709        }
;;;710    
;;;711        /* If we don't peek the incoming message... */
;;;712        if ((flags & MSG_PEEK) == 0) {
;;;713          /* If this is a TCP socket, check if there is data left in the
;;;714             buffer. If so, it should be saved in the sock structure for next
;;;715             time around. */
;;;716          if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
;;;717            sock->lastdata = buf;
;;;718            sock->lastoffset += copylen;
;;;719            LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", buf));
;;;720          } else {
;;;721            sock->lastdata = NULL;
;;;722            sock->lastoffset = 0;
;;;723            LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", buf));
;;;724            if (netconn_type(sock->conn) == NETCONN_TCP) {
;;;725              pbuf_free((struct pbuf *)buf);
;;;726            } else {
;;;727              netbuf_delete((struct netbuf *)buf);
;;;728            }
;;;729          }
;;;730        }
;;;731      } while (!done);
;;;732    
;;;733      if (off > 0) {
;;;734        /* update receive window */
;;;735        netconn_recved(sock->conn, (u32_t)off);
;;;736      }
;;;737      sock_set_errno(sock, 0);
;;;738      return off;
;;;739    }
000026  b00f              ADD      sp,sp,#0x3c
000028  e8bd8ff0          POP      {r4-r11,pc}
                  |L19.44|
00002c  bf00              NOP                            ;576
                  |L19.46|
00002e  bf00              NOP                            ;577
000030  bf00              NOP                            ;577
000032  6860              LDR      r0,[r4,#4]            ;579
000034  b110              CBZ      r0,|L19.60|
000036  6860              LDR      r0,[r4,#4]            ;580
000038  900a              STR      r0,[sp,#0x28]         ;580
00003a  e068              B        |L19.270|
                  |L19.60|
00003c  f0080008          AND      r0,r8,#8              ;583
000040  b928              CBNZ     r0,|L19.78|
000042  6820              LDR      r0,[r4,#0]            ;583
000044  f8900020          LDRB     r0,[r0,#0x20]         ;583
000048  f0000002          AND      r0,r0,#2              ;583
00004c  b1c0              CBZ      r0,|L19.128|
                  |L19.78|
00004e  f9b4000a          LDRSH    r0,[r4,#0xa]          ;584
000052  2800              CMP      r0,#0                 ;584
000054  dc14              BGT      |L19.128|
000056  2d00              CMP      r5,#0                 ;585
000058  dd09              BLE      |L19.110|
00005a  4629              MOV      r1,r5                 ;587
00005c  6820              LDR      r0,[r4,#0]            ;587
00005e  f7fffffe          BL       netconn_recved
000062  bf00              NOP                            ;589
000064  2000              MOVS     r0,#0                 ;589
000066  6120              STR      r0,[r4,#0x10]         ;589
000068  bf00              NOP                            ;589
00006a  4628              MOV      r0,r5                 ;590
00006c  e7db              B        |L19.38|
                  |L19.110|
00006e  bf00              NOP                            ;592
000070  bf00              NOP                            ;592
000072  bf00              NOP                            ;593
000074  200b              MOVS     r0,#0xb               ;593
000076  6120              STR      r0,[r4,#0x10]         ;593
000078  bf00              NOP                            ;593
00007a  f04f30ff          MOV      r0,#0xffffffff        ;594
00007e  e7d2              B        |L19.38|
                  |L19.128|
000080  6820              LDR      r0,[r4,#0]            ;599
000082  7800              LDRB     r0,[r0,#0]            ;599
000084  2810              CMP      r0,#0x10              ;599
000086  d105              BNE      |L19.148|
000088  a90a              ADD      r1,sp,#0x28           ;600
00008a  6820              LDR      r0,[r4,#0]            ;600
00008c  f7fffffe          BL       netconn_recv_tcp_pbuf
000090  4683              MOV      r11,r0                ;600
000092  e004              B        |L19.158|
                  |L19.148|
000094  a90a              ADD      r1,sp,#0x28           ;602
000096  6820              LDR      r0,[r4,#0]            ;602
000098  f7fffffe          BL       netconn_recv
00009c  4683              MOV      r11,r0                ;602
                  |L19.158|
00009e  bf00              NOP                            ;604
0000a0  bf00              NOP                            ;604
0000a2  f1bb0f00          CMP      r11,#0                ;607
0000a6  d023              BEQ      |L19.240|
0000a8  2d00              CMP      r5,#0                 ;608
0000aa  dd09              BLE      |L19.192|
0000ac  4629              MOV      r1,r5                 ;610
0000ae  6820              LDR      r0,[r4,#0]            ;610
0000b0  f7fffffe          BL       netconn_recved
0000b4  bf00              NOP                            ;612
0000b6  2000              MOVS     r0,#0                 ;612
0000b8  6120              STR      r0,[r4,#0x10]         ;612
0000ba  bf00              NOP                            ;612
0000bc  4628              MOV      r0,r5                 ;613
0000be  e7b2              B        |L19.38|
                  |L19.192|
0000c0  bf00              NOP                            ;616
0000c2  bf00              NOP                            ;616
0000c4  bf00              NOP                            ;618
0000c6  f1cb0000          RSB      r0,r11,#0             ;618
0000ca  2810              CMP      r0,#0x10              ;618
0000cc  d205              BCS      |L19.218|
0000ce  486e              LDR      r0,|L19.648|
0000d0  f1cb0100          RSB      r1,r11,#0             ;618
0000d4  f8500021          LDR      r0,[r0,r1,LSL #2]     ;618
0000d8  e000              B        |L19.220|
                  |L19.218|
0000da  2005              MOVS     r0,#5                 ;618
                  |L19.220|
0000dc  6120              STR      r0,[r4,#0x10]         ;618
0000de  bf00              NOP                            ;618
0000e0  f10b000c          ADD      r0,r11,#0xc           ;619
0000e4  b908              CBNZ     r0,|L19.234|
0000e6  2000              MOVS     r0,#0                 ;620
0000e8  e79d              B        |L19.38|
                  |L19.234|
0000ea  f04f30ff          MOV      r0,#0xffffffff        ;622
0000ee  e79a              B        |L19.38|
                  |L19.240|
0000f0  bf00              NOP                            ;625
0000f2  980a              LDR      r0,[sp,#0x28]         ;625
0000f4  b940              CBNZ     r0,|L19.264|
0000f6  bf00              NOP                            ;625
0000f8  a364              ADR      r3,|L19.652|
0000fa  f2402271          MOV      r2,#0x271             ;625
0000fe  a16d              ADR      r1,|L19.692|
000100  a06f              ADR      r0,|L19.704|
000102  f7fffffe          BL       __2printf
000106  bf00              NOP                            ;625
                  |L19.264|
000108  bf00              NOP                            ;625
00010a  980a              LDR      r0,[sp,#0x28]         ;626
00010c  6060              STR      r0,[r4,#4]            ;626
                  |L19.270|
00010e  6820              LDR      r0,[r4,#0]            ;629
000110  7800              LDRB     r0,[r0,#0]            ;629
000112  2810              CMP      r0,#0x10              ;629
000114  d102              BNE      |L19.284|
000116  980a              LDR      r0,[sp,#0x28]         ;630
000118  9009              STR      r0,[sp,#0x24]         ;630
00011a  e002              B        |L19.290|
                  |L19.284|
00011c  980a              LDR      r0,[sp,#0x28]         ;632
00011e  6800              LDR      r0,[r0,#0]            ;632
000120  9009              STR      r0,[sp,#0x24]         ;632
                  |L19.290|
000122  9809              LDR      r0,[sp,#0x24]         ;634
000124  f8b0a008          LDRH     r10,[r0,#8]           ;634
000128  bf00              NOP                            ;635
00012a  bf00              NOP                            ;635
00012c  8920              LDRH     r0,[r4,#8]            ;638
00012e  ebaa0000          SUB      r0,r10,r0             ;638
000132  fa1ffa80          UXTH     r10,r0                ;638
000136  4556              CMP      r6,r10                ;640
000138  d901              BLS      |L19.318|
00013a  4657              MOV      r7,r10                ;641
00013c  e000              B        |L19.320|
                  |L19.318|
00013e  b2b7              UXTH     r7,r6                 ;643
                  |L19.320|
000140  8923              LDRH     r3,[r4,#8]            ;648
000142  980c              LDR      r0,[sp,#0x30]         ;648
000144  1941              ADDS     r1,r0,r5              ;648
000146  463a              MOV      r2,r7                 ;648
000148  9809              LDR      r0,[sp,#0x24]         ;648
00014a  f7fffffe          BL       pbuf_copy_partial
00014e  443d              ADD      r5,r5,r7              ;650
000150  6820              LDR      r0,[r4,#0]            ;652
000152  7800              LDRB     r0,[r0,#0]            ;652
000154  2810              CMP      r0,#0x10              ;652
000156  d11d              BNE      |L19.404|
000158  bf00              NOP                            ;653
00015a  42be              CMP      r6,r7                 ;653
00015c  d208              BCS      |L19.368|
00015e  bf00              NOP                            ;653
000160  a34a              ADR      r3,|L19.652|
000162  f240228d          MOV      r2,#0x28d             ;653
000166  a161              ADR      r1,|L19.748|
000168  a055              ADR      r0,|L19.704|
00016a  f7fffffe          BL       __2printf
00016e  bf00              NOP                            ;653
                  |L19.368|
000170  bf00              NOP                            ;653
000172  1bf6              SUBS     r6,r6,r7              ;654
000174  b15e              CBZ      r6,|L19.398|
000176  9809              LDR      r0,[sp,#0x24]         ;656
000178  7b40              LDRB     r0,[r0,#0xd]          ;656
00017a  f0000001          AND      r0,r0,#1              ;656
00017e  b930              CBNZ     r0,|L19.398|
000180  f9b4000a          LDRSH    r0,[r4,#0xa]          ;657
000184  2800              CMP      r0,#0                 ;657
000186  dd02              BLE      |L19.398|
000188  f0080001          AND      r0,r8,#1              ;658
00018c  b120              CBZ      r0,|L19.408|
                  |L19.398|
00018e  2001              MOVS     r0,#1                 ;659
000190  9006              STR      r0,[sp,#0x18]         ;659
000192  e001              B        |L19.408|
                  |L19.404|
000194  2001              MOVS     r0,#1                 ;662
000196  9006              STR      r0,[sp,#0x18]         ;662
                  |L19.408|
000198  9806              LDR      r0,[sp,#0x18]         ;666
00019a  b3e8              CBZ      r0,|L19.536|
00019c  9818              LDR      r0,[sp,#0x60]         ;668
00019e  b3e0              CBZ      r0,|L19.538|
0001a0  f1b90f00          CMP      r9,#0                 ;668
0001a4  d03d              BEQ      |L19.546|
0001a6  6820              LDR      r0,[r4,#0]            ;671
0001a8  7800              LDRB     r0,[r0,#0]            ;671
0001aa  2810              CMP      r0,#0x10              ;671
0001ac  d108              BNE      |L19.448|
0001ae  a805              ADD      r0,sp,#0x14           ;672
0001b0  9008              STR      r0,[sp,#0x20]         ;672
0001b2  2300              MOVS     r3,#0                 ;673
0001b4  aa07              ADD      r2,sp,#0x1c           ;673
0001b6  6820              LDR      r0,[r4,#0]            ;673
0001b8  9908              LDR      r1,[sp,#0x20]         ;673
0001ba  f7fffffe          BL       netconn_getaddr
0001be  e005              B        |L19.460|
                  |L19.448|
0001c0  980a              LDR      r0,[sp,#0x28]         ;675
0001c2  3008              ADDS     r0,r0,#8              ;675
0001c4  9008              STR      r0,[sp,#0x20]         ;675
0001c6  980a              LDR      r0,[sp,#0x28]         ;676
0001c8  8980              LDRH     r0,[r0,#0xc]          ;676
0001ca  9007              STR      r0,[sp,#0x1c]         ;676
                  |L19.460|
0001cc  2000              MOVS     r0,#0                 ;679
0001ce  9001              STR      r0,[sp,#4]            ;679
0001d0  9002              STR      r0,[sp,#8]            ;679
0001d2  9003              STR      r0,[sp,#0xc]          ;679
0001d4  9004              STR      r0,[sp,#0x10]         ;679
0001d6  2010              MOVS     r0,#0x10              ;680
0001d8  f88d0004          STRB     r0,[sp,#4]            ;680
0001dc  2002              MOVS     r0,#2                 ;681
0001de  f88d0005          STRB     r0,[sp,#5]            ;681
0001e2  f8bd001c          LDRH     r0,[sp,#0x1c]         ;682
0001e6  f7fffffe          BL       lwip_htons
0001ea  f8ad0006          STRH     r0,[sp,#6]            ;682
0001ee  9808              LDR      r0,[sp,#0x20]         ;683
0001f0  6800              LDR      r0,[r0,#0]            ;683
0001f2  9002              STR      r0,[sp,#8]            ;683
0001f4  f8d90000          LDR      r0,[r9,#0]            ;685
0001f8  2810              CMP      r0,#0x10              ;685
0001fa  d902              BLS      |L19.514|
0001fc  2010              MOVS     r0,#0x10              ;686
0001fe  f8c90000          STR      r0,[r9,#0]            ;686
                  |L19.514|
000202  a901              ADD      r1,sp,#4              ;689
000204  f8d92000          LDR      r2,[r9,#0]            ;689
000208  9818              LDR      r0,[sp,#0x60]         ;689
00020a  f7fffffe          BL       __aeabi_memcpy
00020e  bf00              NOP                            ;691
000210  bf00              NOP                            ;691
000212  bf00              NOP                            ;692
000214  bf00              NOP                            ;692
000216  e001              B        |L19.540|
                  |L19.536|
000218  e004              B        |L19.548|
                  |L19.538|
00021a  e002              B        |L19.546|
                  |L19.540|
00021c  bf00              NOP                            ;693
00021e  bf00              NOP                            ;693
000220  bf00              NOP                            ;694
                  |L19.546|
000222  bf00              NOP                            ;709
                  |L19.548|
000224  f0080001          AND      r0,r8,#1              ;712
000228  b9f0              CBNZ     r0,|L19.616|
00022a  6820              LDR      r0,[r4,#0]            ;716
00022c  7800              LDRB     r0,[r0,#0]            ;716
00022e  2810              CMP      r0,#0x10              ;716
000230  d10a              BNE      |L19.584|
000232  ebaa0007          SUB      r0,r10,r7             ;716
000236  2800              CMP      r0,#0                 ;716
000238  dd06              BLE      |L19.584|
00023a  980a              LDR      r0,[sp,#0x28]         ;717
00023c  6060              STR      r0,[r4,#4]            ;717
00023e  8920              LDRH     r0,[r4,#8]            ;718
000240  4438              ADD      r0,r0,r7              ;718
000242  8120              STRH     r0,[r4,#8]            ;718
000244  bf00              NOP                            ;719
000246  e00f              B        |L19.616|
                  |L19.584|
000248  2000              MOVS     r0,#0                 ;721
00024a  6060              STR      r0,[r4,#4]            ;721
00024c  8120              STRH     r0,[r4,#8]            ;722
00024e  bf00              NOP                            ;723
000250  bf00              NOP                            ;723
000252  6820              LDR      r0,[r4,#0]            ;724
000254  7800              LDRB     r0,[r0,#0]            ;724
000256  2810              CMP      r0,#0x10              ;724
000258  d103              BNE      |L19.610|
00025a  980a              LDR      r0,[sp,#0x28]         ;725
00025c  f7fffffe          BL       pbuf_free
000260  e002              B        |L19.616|
                  |L19.610|
000262  980a              LDR      r0,[sp,#0x28]         ;727
000264  f7fffffe          BL       netbuf_delete
                  |L19.616|
000268  9806              LDR      r0,[sp,#0x18]         ;731
00026a  2800              CMP      r0,#0                 ;731
00026c  f43faedf          BEQ      |L19.46|
000270  2d00              CMP      r5,#0                 ;733
000272  dd03              BLE      |L19.636|
000274  4629              MOV      r1,r5                 ;735
000276  6820              LDR      r0,[r4,#0]            ;735
000278  f7fffffe          BL       netconn_recved
                  |L19.636|
00027c  bf00              NOP                            ;737
00027e  2000              MOVS     r0,#0                 ;737
000280  6120              STR      r0,[r4,#0x10]         ;737
000282  bf00              NOP                            ;737
000284  4628              MOV      r0,r5                 ;738
000286  e6ce              B        |L19.38|
;;;740    
                          ENDP

                  |L19.648|
                          DCD      err_to_errno_table
                  |L19.652|
00028c  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\sockets.c",0
000290  5749505c
000294  6c776970
000298  2d312e34
00029c  2e315c73
0002a0  72635c61
0002a4  70695c73
0002a8  6f636b65
0002ac  74732e63
0002b0  00      
0002b1  00                DCB      0
0002b2  00                DCB      0
0002b3  00                DCB      0
                  |L19.692|
0002b4  62756620          DCB      "buf != NULL",0
0002b8  213d204e
0002bc  554c4c00
                  |L19.704|
0002c0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0002c4  7274696f
0002c8  6e202225
0002cc  73222066
0002d0  61696c65
0002d4  64206174
0002d8  206c696e
0002dc  65202564
0002e0  20696e20
0002e4  25730d0a
0002e8  00      
0002e9  00                DCB      0
0002ea  00                DCB      0
0002eb  00                DCB      0
                  |L19.748|
0002ec  696e7661          DCB      "invalid copylen, len would underflow",0
0002f0  6c696420
0002f4  636f7079
0002f8  6c656e2c
0002fc  206c656e
000300  20776f75
000304  6c642075
000308  6e646572
00030c  666c6f77
000310  00      
000311  00                DCB      0
000312  00                DCB      0
000313  00                DCB      0

                          AREA ||i.lwip_select||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  lwip_select PROC
;;;1087   int
;;;1088   lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1089               struct timeval *timeout)
;;;1090   {
000004  b091              SUB      sp,sp,#0x44
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8078          LDR      r8,[sp,#0x78]
;;;1091     u32_t waitres = 0;
000010  2000              MOVS     r0,#0
000012  9010              STR      r0,[sp,#0x40]
;;;1092     int nready;
;;;1093     fd_set lreadset, lwriteset, lexceptset;
;;;1094     u32_t msectimeout;
;;;1095     struct lwip_select_cb select_cb;
;;;1096     err_t err;
;;;1097     int i;
;;;1098     SYS_ARCH_DECL_PROTECT(lev);
;;;1099   
;;;1100     LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%"S32_F" tvusec=%"S32_F")\n",
000014  bf00              NOP      
000016  bf00              NOP      
;;;1101                     maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
;;;1102                     timeout ? (s32_t)timeout->tv_sec : (s32_t)-1,
;;;1103                     timeout ? (s32_t)timeout->tv_usec : (s32_t)-1));
;;;1104   
;;;1105     /* Go through each socket in each list to count number of sockets which
;;;1106        currently match */
;;;1107     nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
000018  a80d              ADD      r0,sp,#0x34
00001a  a90e              ADD      r1,sp,#0x38
00001c  aa0f              ADD      r2,sp,#0x3c
00001e  463b              MOV      r3,r7
000020  e9cd2100          STRD     r2,r1,[sp,#0]
000024  9002              STR      r0,[sp,#8]
000026  4632              MOV      r2,r6
000028  4629              MOV      r1,r5
00002a  9811              LDR      r0,[sp,#0x44]
00002c  f7fffffe          BL       lwip_selscan
000030  4681              MOV      r9,r0
;;;1108   
;;;1109     /* If we don't have any current events, then suspend if we are supposed to */
;;;1110     if (!nready) {
000032  f1b90f00          CMP      r9,#0
000036  d171              BNE      |L20.284|
;;;1111       if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
000038  f1b80f00          CMP      r8,#0
00003c  d008              BEQ      |L20.80|
00003e  f8d80000          LDR      r0,[r8,#0]
000042  b928              CBNZ     r0,|L20.80|
000044  f8d80004          LDR      r0,[r8,#4]
000048  b910              CBNZ     r0,|L20.80|
;;;1112         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
00004a  bf00              NOP      
00004c  bf00              NOP      
;;;1113         /* This is OK as the local fdsets are empty and nready is zero,
;;;1114            or we would have returned earlier. */
;;;1115         goto return_copy_fdsets;
00004e  e16f              B        |L20.816|
                  |L20.80|
;;;1116       }
;;;1117   
;;;1118       /* None ready: add our semaphore to list:
;;;1119          We don't actually need any dynamic memory. Our entry on the
;;;1120          list is only valid while we are in this function, so it's ok
;;;1121          to use local variables. */
;;;1122   
;;;1123       select_cb.next = NULL;
000050  2000              MOVS     r0,#0
000052  9006              STR      r0,[sp,#0x18]
;;;1124       select_cb.prev = NULL;
000054  9007              STR      r0,[sp,#0x1c]
;;;1125       select_cb.readset = readset;
000056  9508              STR      r5,[sp,#0x20]
;;;1126       select_cb.writeset = writeset;
000058  9609              STR      r6,[sp,#0x24]
;;;1127       select_cb.exceptset = exceptset;
00005a  970a              STR      r7,[sp,#0x28]
;;;1128       select_cb.sem_signalled = 0;
00005c  900b              STR      r0,[sp,#0x2c]
;;;1129       err = sys_sem_new(&select_cb.sem, 0);
00005e  2100              MOVS     r1,#0
000060  a80c              ADD      r0,sp,#0x30
000062  f7fffffe          BL       sys_sem_new
000066  9005              STR      r0,[sp,#0x14]
;;;1130       if (err != ERR_OK) {
000068  9805              LDR      r0,[sp,#0x14]
00006a  b120              CBZ      r0,|L20.118|
;;;1131         /* failed to create semaphore */
;;;1132         set_errno(ENOMEM);
;;;1133         return -1;
00006c  f04f30ff          MOV      r0,#0xffffffff
                  |L20.112|
;;;1134       }
;;;1135   
;;;1136       /* Protect the select_cb_list */
;;;1137       SYS_ARCH_PROTECT(lev);
;;;1138   
;;;1139       /* Put this select_cb on top of list */
;;;1140       select_cb.next = select_cb_list;
;;;1141       if (select_cb_list != NULL) {
;;;1142         select_cb_list->prev = &select_cb;
;;;1143       }
;;;1144       select_cb_list = &select_cb;
;;;1145       /* Increasing this counter tells even_callback that the list has changed. */
;;;1146       select_cb_ctr++;
;;;1147   
;;;1148       /* Now we can safely unprotect */
;;;1149       SYS_ARCH_UNPROTECT(lev);
;;;1150   
;;;1151       /* Increase select_waiting for each socket we are interested in */
;;;1152       for(i = 0; i < maxfdp1; i++) {
;;;1153         if ((readset && FD_ISSET(i, readset)) ||
;;;1154             (writeset && FD_ISSET(i, writeset)) ||
;;;1155             (exceptset && FD_ISSET(i, exceptset))) {
;;;1156           struct lwip_sock *sock = tryget_socket(i);
;;;1157           LWIP_ASSERT("sock != NULL", sock != NULL);
;;;1158           SYS_ARCH_PROTECT(lev);
;;;1159           sock->select_waiting++;
;;;1160           LWIP_ASSERT("sock->select_waiting > 0", sock->select_waiting > 0);
;;;1161           SYS_ARCH_UNPROTECT(lev);
;;;1162         }
;;;1163       }
;;;1164   
;;;1165       /* Call lwip_selscan again: there could have been events between
;;;1166          the last scan (whithout us on the list) and putting us on the list! */
;;;1167       nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
;;;1168       if (!nready) {
;;;1169         /* Still none ready, just wait to be woken */
;;;1170         if (timeout == 0) {
;;;1171           /* Wait forever */
;;;1172           msectimeout = 0;
;;;1173         } else {
;;;1174           msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
;;;1175           if (msectimeout == 0) {
;;;1176             /* Wait 1ms at least (0 means wait forever) */
;;;1177             msectimeout = 1;
;;;1178           }
;;;1179         }
;;;1180   
;;;1181         waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
;;;1182       }
;;;1183       /* Increase select_waiting for each socket we are interested in */
;;;1184       for(i = 0; i < maxfdp1; i++) {
;;;1185         if ((readset && FD_ISSET(i, readset)) ||
;;;1186             (writeset && FD_ISSET(i, writeset)) ||
;;;1187             (exceptset && FD_ISSET(i, exceptset))) {
;;;1188           struct lwip_sock *sock = tryget_socket(i);
;;;1189           LWIP_ASSERT("sock != NULL", sock != NULL);
;;;1190           SYS_ARCH_PROTECT(lev);
;;;1191           sock->select_waiting--;
;;;1192           LWIP_ASSERT("sock->select_waiting >= 0", sock->select_waiting >= 0);
;;;1193           SYS_ARCH_UNPROTECT(lev);
;;;1194         }
;;;1195       }
;;;1196       /* Take us off the list */
;;;1197       SYS_ARCH_PROTECT(lev);
;;;1198       if (select_cb.next != NULL) {
;;;1199         select_cb.next->prev = select_cb.prev;
;;;1200       }
;;;1201       if (select_cb_list == &select_cb) {
;;;1202         LWIP_ASSERT("select_cb.prev == NULL", select_cb.prev == NULL);
;;;1203         select_cb_list = select_cb.next;
;;;1204       } else {
;;;1205         LWIP_ASSERT("select_cb.prev != NULL", select_cb.prev != NULL);
;;;1206         select_cb.prev->next = select_cb.next;
;;;1207       }
;;;1208       /* Increasing this counter tells even_callback that the list has changed. */
;;;1209       select_cb_ctr++;
;;;1210       SYS_ARCH_UNPROTECT(lev);
;;;1211   
;;;1212       sys_sem_free(&select_cb.sem);
;;;1213       if (waitres == SYS_ARCH_TIMEOUT)  {
;;;1214         /* Timeout */
;;;1215         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
;;;1216         /* This is OK as the local fdsets are empty and nready is zero,
;;;1217            or we would have returned earlier. */
;;;1218         goto return_copy_fdsets;
;;;1219       }
;;;1220   
;;;1221       /* See what's set */
;;;1222       nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
;;;1223     }
;;;1224   
;;;1225     LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
;;;1226   return_copy_fdsets:
;;;1227     set_errno(0);
;;;1228     if (readset) {
;;;1229       *readset = lreadset;
;;;1230     }
;;;1231     if (writeset) {
;;;1232       *writeset = lwriteset;
;;;1233     }
;;;1234     if (exceptset) {
;;;1235       *exceptset = lexceptset;
;;;1236     }
;;;1237   
;;;1238   
;;;1239     return nready;
;;;1240   }
000070  b015              ADD      sp,sp,#0x54
000072  e8bd8ff0          POP      {r4-r11,pc}
                  |L20.118|
000076  f7fffffe          BL       sys_arch_protect
00007a  9004              STR      r0,[sp,#0x10]         ;1137
00007c  48b3              LDR      r0,|L20.844|
00007e  6800              LDR      r0,[r0,#0]            ;1140  ; select_cb_list
000080  9006              STR      r0,[sp,#0x18]         ;1140
000082  48b2              LDR      r0,|L20.844|
000084  6800              LDR      r0,[r0,#0]            ;1141  ; select_cb_list
000086  b118              CBZ      r0,|L20.144|
000088  a806              ADD      r0,sp,#0x18           ;1142
00008a  49b0              LDR      r1,|L20.844|
00008c  6809              LDR      r1,[r1,#0]            ;1142  ; select_cb_list
00008e  6048              STR      r0,[r1,#4]            ;1142
                  |L20.144|
000090  a806              ADD      r0,sp,#0x18           ;1144
000092  49ae              LDR      r1,|L20.844|
000094  6008              STR      r0,[r1,#0]            ;1144  ; select_cb_list
000096  48ae              LDR      r0,|L20.848|
000098  6800              LDR      r0,[r0,#0]            ;1146  ; select_cb_ctr
00009a  1c40              ADDS     r0,r0,#1              ;1146
00009c  49ac              LDR      r1,|L20.848|
00009e  6008              STR      r0,[r1,#0]            ;1146  ; select_cb_ctr
0000a0  9804              LDR      r0,[sp,#0x10]         ;1149
0000a2  f7fffffe          BL       sys_arch_unprotect
0000a6  2400              MOVS     r4,#0                 ;1152
0000a8  e05e              B        |L20.360|
                  |L20.170|
0000aa  b16d              CBZ      r5,|L20.200|
0000ac  17e3              ASRS     r3,r4,#31             ;1153
0000ae  eb047353          ADD      r3,r4,r3,LSR #29      ;1153
0000b2  10db              ASRS     r3,r3,#3              ;1153
0000b4  5ceb              LDRB     r3,[r5,r3]            ;1153
0000b6  f0040b07          AND      r11,r4,#7             ;1153
0000ba  f04f0c01          MOV      r12,#1                ;1153
0000be  fa0cfc0b          LSL      r12,r12,r11           ;1153
0000c2  ea03030c          AND      r3,r3,r12             ;1153
0000c6  b9fb              CBNZ     r3,|L20.264|
                  |L20.200|
0000c8  b16e              CBZ      r6,|L20.230|
0000ca  17e3              ASRS     r3,r4,#31             ;1154
0000cc  eb047353          ADD      r3,r4,r3,LSR #29      ;1154
0000d0  10db              ASRS     r3,r3,#3              ;1154
0000d2  5cf3              LDRB     r3,[r6,r3]            ;1154
0000d4  f0040b07          AND      r11,r4,#7             ;1154
0000d8  f04f0c01          MOV      r12,#1                ;1154
0000dc  fa0cfc0b          LSL      r12,r12,r11           ;1154
0000e0  ea03030c          AND      r3,r3,r12             ;1154
0000e4  b983              CBNZ     r3,|L20.264|
                  |L20.230|
0000e6  2f00              CMP      r7,#0                 ;1155
0000e8  d03d              BEQ      |L20.358|
0000ea  17e3              ASRS     r3,r4,#31             ;1155
0000ec  eb047353          ADD      r3,r4,r3,LSR #29      ;1155
0000f0  10db              ASRS     r3,r3,#3              ;1155
0000f2  5cfb              LDRB     r3,[r7,r3]            ;1155
0000f4  f0040b07          AND      r11,r4,#7             ;1155
0000f8  f04f0c01          MOV      r12,#1                ;1155
0000fc  fa0cfc0b          LSL      r12,r12,r11           ;1155
000100  ea03030c          AND      r3,r3,r12             ;1155
000104  2b00              CMP      r3,#0                 ;1155
000106  d02e              BEQ      |L20.358|
                  |L20.264|
000108  4620              MOV      r0,r4                 ;1156
00010a  f7fffffe          BL       tryget_socket
00010e  4683              MOV      r11,r0                ;1156
000110  bf00              NOP                            ;1157
000112  f1bb0f00          CMP      r11,#0                ;1157
000116  d10a              BNE      |L20.302|
000118  bf00              NOP                            ;1157
00011a  e000              B        |L20.286|
                  |L20.284|
00011c  e105              B        |L20.810|
                  |L20.286|
00011e  a38d              ADR      r3,|L20.852|
000120  f2404285          MOV      r2,#0x485             ;1157
000124  a195              ADR      r1,|L20.892|
000126  a099              ADR      r0,|L20.908|
000128  f7fffffe          BL       __2printf
00012c  bf00              NOP                            ;1157
                  |L20.302|
00012e  bf00              NOP                            ;1157
000130  f7fffffe          BL       sys_arch_protect
000134  9004              STR      r0,[sp,#0x10]         ;1158
000136  f8db0014          LDR      r0,[r11,#0x14]        ;1159
00013a  1c40              ADDS     r0,r0,#1              ;1159
00013c  f8cb0014          STR      r0,[r11,#0x14]        ;1159
000140  bf00              NOP                            ;1160
000142  f8db0014          LDR      r0,[r11,#0x14]        ;1160
000146  2800              CMP      r0,#0                 ;1160
000148  dc08              BGT      |L20.348|
00014a  bf00              NOP                            ;1160
00014c  a381              ADR      r3,|L20.852|
00014e  f44f6291          MOV      r2,#0x488             ;1160
000152  a199              ADR      r1,|L20.952|
000154  a08d              ADR      r0,|L20.908|
000156  f7fffffe          BL       __2printf
00015a  bf00              NOP                            ;1160
                  |L20.348|
00015c  bf00              NOP                            ;1160
00015e  9804              LDR      r0,[sp,#0x10]         ;1161
000160  f7fffffe          BL       sys_arch_unprotect
000164  bf00              NOP                            ;1162
                  |L20.358|
000166  1c64              ADDS     r4,r4,#1              ;1152
                  |L20.360|
000168  9811              LDR      r0,[sp,#0x44]         ;1152
00016a  4284              CMP      r4,r0                 ;1152
00016c  db9d              BLT      |L20.170|
00016e  a80d              ADD      r0,sp,#0x34           ;1167
000170  a90e              ADD      r1,sp,#0x38           ;1167
000172  aa0f              ADD      r2,sp,#0x3c           ;1167
000174  463b              MOV      r3,r7                 ;1167
000176  e9cd2100          STRD     r2,r1,[sp,#0]         ;1167
00017a  9002              STR      r0,[sp,#8]            ;1167
00017c  4632              MOV      r2,r6                 ;1167
00017e  4629              MOV      r1,r5                 ;1167
000180  9811              LDR      r0,[sp,#0x44]         ;1167
000182  f7fffffe          BL       lwip_selscan
000186  4681              MOV      r9,r0                 ;1167
000188  f1b90f00          CMP      r9,#0                 ;1168
00018c  d11f              BNE      |L20.462|
00018e  f1b80f00          CMP      r8,#0                 ;1170
000192  d102              BNE      |L20.410|
000194  f04f0a00          MOV      r10,#0                ;1172
000198  e014              B        |L20.452|
                  |L20.410|
00019a  f8d80004          LDR      r0,[r8,#4]            ;1174
00019e  f50070fa          ADD      r0,r0,#0x1f4          ;1174
0001a2  f44f717a          MOV      r1,#0x3e8             ;1174
0001a6  fb90f0f1          SDIV     r0,r0,r1              ;1174
0001aa  f8d81000          LDR      r1,[r8,#0]            ;1174
0001ae  eb010241          ADD      r2,r1,r1,LSL #1       ;1174
0001b2  ebc211c1          RSB      r1,r2,r1,LSL #7       ;1174
0001b6  eb000ac1          ADD      r10,r0,r1,LSL #3      ;1174
0001ba  f1ba0f00          CMP      r10,#0                ;1175
0001be  d101              BNE      |L20.452|
0001c0  f04f0a01          MOV      r10,#1                ;1177
                  |L20.452|
0001c4  4651              MOV      r1,r10                ;1181
0001c6  a80c              ADD      r0,sp,#0x30           ;1181
0001c8  f7fffffe          BL       sys_arch_sem_wait
0001cc  9010              STR      r0,[sp,#0x40]         ;1181
                  |L20.462|
0001ce  2400              MOVS     r4,#0                 ;1184
0001d0  e05c              B        |L20.652|
                  |L20.466|
0001d2  b16d              CBZ      r5,|L20.496|
0001d4  17e3              ASRS     r3,r4,#31             ;1185
0001d6  eb047353          ADD      r3,r4,r3,LSR #29      ;1185
0001da  10db              ASRS     r3,r3,#3              ;1185
0001dc  5ceb              LDRB     r3,[r5,r3]            ;1185
0001de  f0040b07          AND      r11,r4,#7             ;1185
0001e2  f04f0c01          MOV      r12,#1                ;1185
0001e6  fa0cfc0b          LSL      r12,r12,r11           ;1185
0001ea  ea03030c          AND      r3,r3,r12             ;1185
0001ee  b9fb              CBNZ     r3,|L20.560|
                  |L20.496|
0001f0  b16e              CBZ      r6,|L20.526|
0001f2  17e3              ASRS     r3,r4,#31             ;1186
0001f4  eb047353          ADD      r3,r4,r3,LSR #29      ;1186
0001f8  10db              ASRS     r3,r3,#3              ;1186
0001fa  5cf3              LDRB     r3,[r6,r3]            ;1186
0001fc  f0040b07          AND      r11,r4,#7             ;1186
000200  f04f0c01          MOV      r12,#1                ;1186
000204  fa0cfc0b          LSL      r12,r12,r11           ;1186
000208  ea03030c          AND      r3,r3,r12             ;1186
00020c  b983              CBNZ     r3,|L20.560|
                  |L20.526|
00020e  2f00              CMP      r7,#0                 ;1187
000210  d03b              BEQ      |L20.650|
000212  17e3              ASRS     r3,r4,#31             ;1187
000214  eb047353          ADD      r3,r4,r3,LSR #29      ;1187
000218  10db              ASRS     r3,r3,#3              ;1187
00021a  5cfb              LDRB     r3,[r7,r3]            ;1187
00021c  f0040b07          AND      r11,r4,#7             ;1187
000220  f04f0c01          MOV      r12,#1                ;1187
000224  fa0cfc0b          LSL      r12,r12,r11           ;1187
000228  ea03030c          AND      r3,r3,r12             ;1187
00022c  2b00              CMP      r3,#0                 ;1187
00022e  d02c              BEQ      |L20.650|
                  |L20.560|
000230  4620              MOV      r0,r4                 ;1188
000232  f7fffffe          BL       tryget_socket
000236  4683              MOV      r11,r0                ;1188
000238  bf00              NOP                            ;1189
00023a  f1bb0f00          CMP      r11,#0                ;1189
00023e  d108              BNE      |L20.594|
000240  bf00              NOP                            ;1189
000242  a344              ADR      r3,|L20.852|
000244  f24042a5          MOV      r2,#0x4a5             ;1189
000248  a14c              ADR      r1,|L20.892|
00024a  a050              ADR      r0,|L20.908|
00024c  f7fffffe          BL       __2printf
000250  bf00              NOP                            ;1189
                  |L20.594|
000252  bf00              NOP                            ;1189
000254  f7fffffe          BL       sys_arch_protect
000258  9004              STR      r0,[sp,#0x10]         ;1190
00025a  f8db0014          LDR      r0,[r11,#0x14]        ;1191
00025e  1e40              SUBS     r0,r0,#1              ;1191
000260  f8cb0014          STR      r0,[r11,#0x14]        ;1191
000264  bf00              NOP                            ;1192
000266  f8db0014          LDR      r0,[r11,#0x14]        ;1192
00026a  2800              CMP      r0,#0                 ;1192
00026c  da08              BGE      |L20.640|
00026e  bf00              NOP                            ;1192
000270  a338              ADR      r3,|L20.852|
000272  f44f6295          MOV      r2,#0x4a8             ;1192
000276  a157              ADR      r1,|L20.980|
000278  a044              ADR      r0,|L20.908|
00027a  f7fffffe          BL       __2printf
00027e  bf00              NOP                            ;1192
                  |L20.640|
000280  bf00              NOP                            ;1192
000282  9804              LDR      r0,[sp,#0x10]         ;1193
000284  f7fffffe          BL       sys_arch_unprotect
000288  bf00              NOP                            ;1194
                  |L20.650|
00028a  1c64              ADDS     r4,r4,#1              ;1184
                  |L20.652|
00028c  9811              LDR      r0,[sp,#0x44]         ;1184
00028e  4284              CMP      r4,r0                 ;1184
000290  db9f              BLT      |L20.466|
000292  f7fffffe          BL       sys_arch_protect
000296  9004              STR      r0,[sp,#0x10]         ;1197
000298  9806              LDR      r0,[sp,#0x18]         ;1198
00029a  b110              CBZ      r0,|L20.674|
00029c  e9dd1006          LDRD     r1,r0,[sp,#0x18]      ;1199
0002a0  6048              STR      r0,[r1,#4]            ;1199
                  |L20.674|
0002a2  482a              LDR      r0,|L20.844|
0002a4  6800              LDR      r0,[r0,#0]            ;1201  ; select_cb_list
0002a6  a906              ADD      r1,sp,#0x18           ;1201
0002a8  4288              CMP      r0,r1                 ;1201
0002aa  d110              BNE      |L20.718|
0002ac  bf00              NOP                            ;1202
0002ae  9807              LDR      r0,[sp,#0x1c]         ;1202
0002b0  b140              CBZ      r0,|L20.708|
0002b2  bf00              NOP                            ;1202
0002b4  a327              ADR      r3,|L20.852|
0002b6  f24042b2          MOV      r2,#0x4b2             ;1202
0002ba  a14d              ADR      r1,|L20.1008|
0002bc  a033              ADR      r0,|L20.908|
0002be  f7fffffe          BL       __2printf
0002c2  bf00              NOP                            ;1202
                  |L20.708|
0002c4  bf00              NOP                            ;1202
0002c6  4921              LDR      r1,|L20.844|
0002c8  9806              LDR      r0,[sp,#0x18]         ;1203
0002ca  6008              STR      r0,[r1,#0]            ;1203  ; select_cb_list
0002cc  e00f              B        |L20.750|
                  |L20.718|
0002ce  bf00              NOP                            ;1205
0002d0  9807              LDR      r0,[sp,#0x1c]         ;1205
0002d2  b940              CBNZ     r0,|L20.742|
0002d4  bf00              NOP                            ;1205
0002d6  a31f              ADR      r3,|L20.852|
0002d8  f24042b5          MOV      r2,#0x4b5             ;1205
0002dc  a14a              ADR      r1,|L20.1032|
0002de  a02b              ADR      r0,|L20.908|
0002e0  f7fffffe          BL       __2printf
0002e4  bf00              NOP                            ;1205
                  |L20.742|
0002e6  bf00              NOP                            ;1205
0002e8  e9dd0106          LDRD     r0,r1,[sp,#0x18]      ;1206
0002ec  6008              STR      r0,[r1,#0]            ;1206
                  |L20.750|
0002ee  4818              LDR      r0,|L20.848|
0002f0  6800              LDR      r0,[r0,#0]            ;1209  ; select_cb_ctr
0002f2  1c40              ADDS     r0,r0,#1              ;1209
0002f4  4916              LDR      r1,|L20.848|
0002f6  6008              STR      r0,[r1,#0]            ;1209  ; select_cb_ctr
0002f8  9804              LDR      r0,[sp,#0x10]         ;1210
0002fa  f7fffffe          BL       sys_arch_unprotect
0002fe  a80c              ADD      r0,sp,#0x30           ;1212
000300  f7fffffe          BL       sys_sem_free
000304  9810              LDR      r0,[sp,#0x40]         ;1213
000306  1c40              ADDS     r0,r0,#1              ;1213
000308  b910              CBNZ     r0,|L20.784|
00030a  bf00              NOP                            ;1215
00030c  bf00              NOP                            ;1215
00030e  e00f              B        |L20.816|
                  |L20.784|
000310  a80d              ADD      r0,sp,#0x34           ;1222
000312  a90e              ADD      r1,sp,#0x38           ;1222
000314  aa0f              ADD      r2,sp,#0x3c           ;1222
000316  463b              MOV      r3,r7                 ;1222
000318  e9cd2100          STRD     r2,r1,[sp,#0]         ;1222
00031c  9002              STR      r0,[sp,#8]            ;1222
00031e  4632              MOV      r2,r6                 ;1222
000320  4629              MOV      r1,r5                 ;1222
000322  9811              LDR      r0,[sp,#0x44]         ;1222
000324  f7fffffe          BL       lwip_selscan
000328  4681              MOV      r9,r0                 ;1222
                  |L20.810|
00032a  bf00              NOP                            ;1225
00032c  bf00              NOP                            ;1225
00032e  bf00              NOP                            ;1226
                  |L20.816|
000330  b115              CBZ      r5,|L20.824|
000332  f89d003c          LDRB     r0,[sp,#0x3c]         ;1229
000336  7028              STRB     r0,[r5,#0]            ;1229
                  |L20.824|
000338  b116              CBZ      r6,|L20.832|
00033a  f89d0038          LDRB     r0,[sp,#0x38]         ;1232
00033e  7030              STRB     r0,[r6,#0]            ;1232
                  |L20.832|
000340  b117              CBZ      r7,|L20.840|
000342  f89d0034          LDRB     r0,[sp,#0x34]         ;1235
000346  7038              STRB     r0,[r7,#0]            ;1235
                  |L20.840|
000348  4648              MOV      r0,r9                 ;1239
00034a  e691              B        |L20.112|
;;;1241   
                          ENDP

                  |L20.844|
                          DCD      select_cb_list
                  |L20.848|
                          DCD      select_cb_ctr
                  |L20.852|
000354  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\sockets.c",0
000358  5749505c
00035c  6c776970
000360  2d312e34
000364  2e315c73
000368  72635c61
00036c  70695c73
000370  6f636b65
000374  74732e63
000378  00      
000379  00                DCB      0
00037a  00                DCB      0
00037b  00                DCB      0
                  |L20.892|
00037c  736f636b          DCB      "sock != NULL",0
000380  20213d20
000384  4e554c4c
000388  00      
000389  00                DCB      0
00038a  00                DCB      0
00038b  00                DCB      0
                  |L20.908|
00038c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000390  7274696f
000394  6e202225
000398  73222066
00039c  61696c65
0003a0  64206174
0003a4  206c696e
0003a8  65202564
0003ac  20696e20
0003b0  25730d0a
0003b4  00      
0003b5  00                DCB      0
0003b6  00                DCB      0
0003b7  00                DCB      0
                  |L20.952|
0003b8  736f636b          DCB      "sock->select_waiting > 0",0
0003bc  2d3e7365
0003c0  6c656374
0003c4  5f776169
0003c8  74696e67
0003cc  203e2030
0003d0  00      
0003d1  00                DCB      0
0003d2  00                DCB      0
0003d3  00                DCB      0
                  |L20.980|
0003d4  736f636b          DCB      "sock->select_waiting >= 0",0
0003d8  2d3e7365
0003dc  6c656374
0003e0  5f776169
0003e4  74696e67
0003e8  203e3d20
0003ec  3000    
0003ee  00                DCB      0
0003ef  00                DCB      0
                  |L20.1008|
0003f0  73656c65          DCB      "select_cb.prev == NULL",0
0003f4  63745f63
0003f8  622e7072
0003fc  6576203d
000400  3d204e55
000404  4c4c00  
000407  00                DCB      0
                  |L20.1032|
000408  73656c65          DCB      "select_cb.prev != NULL",0
00040c  63745f63
000410  622e7072
000414  65762021
000418  3d204e55
00041c  4c4c00  
00041f  00                DCB      0

                          AREA ||i.lwip_selscan||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  lwip_selscan PROC
;;;1025   static int
;;;1026   lwip_selscan(int maxfdp1, fd_set *readset_in, fd_set *writeset_in, fd_set *exceptset_in,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1027                fd_set *readset_out, fd_set *writeset_out, fd_set *exceptset_out)
;;;1028   {
000004  b087              SUB      sp,sp,#0x1c
000006  4682              MOV      r10,r0
000008  460f              MOV      r7,r1
00000a  4690              MOV      r8,r2
00000c  4699              MOV      r9,r3
;;;1029     int i, nready = 0;
00000e  2600              MOVS     r6,#0
;;;1030     fd_set lreadset, lwriteset, lexceptset;
;;;1031     struct lwip_sock *sock;
;;;1032     SYS_ARCH_DECL_PROTECT(lev);
;;;1033   
;;;1034     FD_ZERO(&lreadset);
000010  2000              MOVS     r0,#0
000012  9006              STR      r0,[sp,#0x18]
;;;1035     FD_ZERO(&lwriteset);
000014  9005              STR      r0,[sp,#0x14]
;;;1036     FD_ZERO(&lexceptset);
000016  9004              STR      r0,[sp,#0x10]
;;;1037   
;;;1038     /* Go through each socket in each list to count number of sockets which
;;;1039        currently match */
;;;1040     for(i = 0; i < maxfdp1; i++) {
000018  2400              MOVS     r4,#0
00001a  e08d              B        |L21.312|
                  |L21.28|
;;;1041       void* lastdata = NULL;
00001c  f04f0b00          MOV      r11,#0
;;;1042       s16_t rcvevent = 0;
000020  2000              MOVS     r0,#0
000022  9002              STR      r0,[sp,#8]
;;;1043       u16_t sendevent = 0;
000024  9001              STR      r0,[sp,#4]
;;;1044       u16_t errevent = 0;
000026  9000              STR      r0,[sp,#0]
;;;1045       /* First get the socket's status (protected)... */
;;;1046       SYS_ARCH_PROTECT(lev);
000028  f7fffffe          BL       sys_arch_protect
00002c  9003              STR      r0,[sp,#0xc]
;;;1047       sock = tryget_socket(i);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       tryget_socket
000034  4605              MOV      r5,r0
;;;1048       if (sock != NULL) {
000036  b145              CBZ      r5,|L21.74|
;;;1049         lastdata = sock->lastdata;
000038  f8d5b004          LDR      r11,[r5,#4]
;;;1050         rcvevent = sock->rcvevent;
00003c  f9b5000a          LDRSH    r0,[r5,#0xa]
000040  9002              STR      r0,[sp,#8]
;;;1051         sendevent = sock->sendevent;
000042  89a8              LDRH     r0,[r5,#0xc]
000044  9001              STR      r0,[sp,#4]
;;;1052         errevent = sock->errevent;
000046  89e8              LDRH     r0,[r5,#0xe]
000048  9000              STR      r0,[sp,#0]
                  |L21.74|
;;;1053       }
;;;1054       SYS_ARCH_UNPROTECT(lev);
00004a  9803              LDR      r0,[sp,#0xc]
00004c  f7fffffe          BL       sys_arch_unprotect
;;;1055       /* ... then examine it: */
;;;1056       /* See if netconn of this socket is ready for read */
;;;1057       if (readset_in && FD_ISSET(i, readset_in) && ((lastdata != NULL) || (rcvevent > 0))) {
000050  b32f              CBZ      r7,|L21.158|
000052  17e1              ASRS     r1,r4,#31
000054  eb047151          ADD      r1,r4,r1,LSR #29
000058  10c9              ASRS     r1,r1,#3
00005a  5c79              LDRB     r1,[r7,r1]
00005c  f0040307          AND      r3,r4,#7
000060  2201              MOVS     r2,#1
000062  409a              LSLS     r2,r2,r3
000064  4011              ANDS     r1,r1,r2
000066  b1d1              CBZ      r1,|L21.158|
000068  f1bb0f00          CMP      r11,#0
00006c  d102              BNE      |L21.116|
00006e  9902              LDR      r1,[sp,#8]
000070  2900              CMP      r1,#0
000072  dd14              BLE      |L21.158|
                  |L21.116|
;;;1058         FD_SET(i, &lreadset);
000074  17e1              ASRS     r1,r4,#31
000076  eb047151          ADD      r1,r4,r1,LSR #29
00007a  10c9              ASRS     r1,r1,#3
00007c  aa06              ADD      r2,sp,#0x18
00007e  5c51              LDRB     r1,[r2,r1]
000080  f0040307          AND      r3,r4,#7
000084  2201              MOVS     r2,#1
000086  409a              LSLS     r2,r2,r3
000088  4311              ORRS     r1,r1,r2
00008a  4620              MOV      r0,r4
00008c  17e2              ASRS     r2,r4,#31
00008e  eb047252          ADD      r2,r4,r2,LSR #29
000092  10d2              ASRS     r2,r2,#3
000094  ab06              ADD      r3,sp,#0x18
000096  5499              STRB     r1,[r3,r2]
;;;1059         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
000098  bf00              NOP      
00009a  bf00              NOP      
;;;1060         nready++;
00009c  1c76              ADDS     r6,r6,#1
                  |L21.158|
;;;1061       }
;;;1062       /* See if netconn of this socket is ready for write */
;;;1063       if (writeset_in && FD_ISSET(i, writeset_in) && (sendevent != 0)) {
00009e  f1b80f00          CMP      r8,#0
0000a2  d022              BEQ      |L21.234|
0000a4  17e1              ASRS     r1,r4,#31
0000a6  eb047151          ADD      r1,r4,r1,LSR #29
0000aa  10c9              ASRS     r1,r1,#3
0000ac  f8181001          LDRB     r1,[r8,r1]
0000b0  f0040307          AND      r3,r4,#7
0000b4  2201              MOVS     r2,#1
0000b6  409a              LSLS     r2,r2,r3
0000b8  4011              ANDS     r1,r1,r2
0000ba  b1b1              CBZ      r1,|L21.234|
0000bc  9901              LDR      r1,[sp,#4]
0000be  b1a1              CBZ      r1,|L21.234|
;;;1064         FD_SET(i, &lwriteset);
0000c0  17e1              ASRS     r1,r4,#31
0000c2  eb047151          ADD      r1,r4,r1,LSR #29
0000c6  10c9              ASRS     r1,r1,#3
0000c8  aa05              ADD      r2,sp,#0x14
0000ca  5c51              LDRB     r1,[r2,r1]
0000cc  f0040307          AND      r3,r4,#7
0000d0  2201              MOVS     r2,#1
0000d2  409a              LSLS     r2,r2,r3
0000d4  4311              ORRS     r1,r1,r2
0000d6  4620              MOV      r0,r4
0000d8  17e2              ASRS     r2,r4,#31
0000da  eb047252          ADD      r2,r4,r2,LSR #29
0000de  10d2              ASRS     r2,r2,#3
0000e0  ab05              ADD      r3,sp,#0x14
0000e2  5499              STRB     r1,[r3,r2]
;;;1065         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
0000e4  bf00              NOP      
0000e6  bf00              NOP      
;;;1066         nready++;
0000e8  1c76              ADDS     r6,r6,#1
                  |L21.234|
;;;1067       }
;;;1068       /* See if netconn of this socket had an error */
;;;1069       if (exceptset_in && FD_ISSET(i, exceptset_in) && (errevent != 0)) {
0000ea  f1b90f00          CMP      r9,#0
0000ee  d022              BEQ      |L21.310|
0000f0  17e1              ASRS     r1,r4,#31
0000f2  eb047151          ADD      r1,r4,r1,LSR #29
0000f6  10c9              ASRS     r1,r1,#3
0000f8  f8191001          LDRB     r1,[r9,r1]
0000fc  f0040307          AND      r3,r4,#7
000100  2201              MOVS     r2,#1
000102  409a              LSLS     r2,r2,r3
000104  4011              ANDS     r1,r1,r2
000106  b1b1              CBZ      r1,|L21.310|
000108  9900              LDR      r1,[sp,#0]
00010a  b1a1              CBZ      r1,|L21.310|
;;;1070         FD_SET(i, &lexceptset);
00010c  17e1              ASRS     r1,r4,#31
00010e  eb047151          ADD      r1,r4,r1,LSR #29
000112  10c9              ASRS     r1,r1,#3
000114  aa04              ADD      r2,sp,#0x10
000116  5c51              LDRB     r1,[r2,r1]
000118  f0040307          AND      r3,r4,#7
00011c  2201              MOVS     r2,#1
00011e  409a              LSLS     r2,r2,r3
000120  4311              ORRS     r1,r1,r2
000122  4620              MOV      r0,r4
000124  17e2              ASRS     r2,r4,#31
000126  eb047252          ADD      r2,r4,r2,LSR #29
00012a  10d2              ASRS     r2,r2,#3
00012c  ab04              ADD      r3,sp,#0x10
00012e  5499              STRB     r1,[r3,r2]
;;;1071         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
000130  bf00              NOP      
000132  bf00              NOP      
;;;1072         nready++;
000134  1c76              ADDS     r6,r6,#1
                  |L21.310|
000136  1c64              ADDS     r4,r4,#1              ;1040
                  |L21.312|
000138  4554              CMP      r4,r10                ;1040
00013a  f6ffaf6f          BLT      |L21.28|
;;;1073       }
;;;1074     }
;;;1075     /* copy local sets to the ones provided as arguments */
;;;1076     *readset_out = lreadset;
00013e  f89d1018          LDRB     r1,[sp,#0x18]
000142  9810              LDR      r0,[sp,#0x40]
000144  7001              STRB     r1,[r0,#0]
;;;1077     *writeset_out = lwriteset;
000146  f89d1014          LDRB     r1,[sp,#0x14]
00014a  9811              LDR      r0,[sp,#0x44]
00014c  7001              STRB     r1,[r0,#0]
;;;1078     *exceptset_out = lexceptset;
00014e  f89d1010          LDRB     r1,[sp,#0x10]
000152  9812              LDR      r0,[sp,#0x48]
000154  7001              STRB     r1,[r0,#0]
;;;1079   
;;;1080     LWIP_ASSERT("nready >= 0", nready >= 0);
000156  bf00              NOP      
000158  2e00              CMP      r6,#0
00015a  da08              BGE      |L21.366|
00015c  bf00              NOP      
00015e  a306              ADR      r3,|L21.376|
000160  f44f6287          MOV      r2,#0x438
000164  a10e              ADR      r1,|L21.416|
000166  a011              ADR      r0,|L21.428|
000168  f7fffffe          BL       __2printf
00016c  bf00              NOP      
                  |L21.366|
00016e  bf00              NOP      
;;;1081     return nready;
000170  4630              MOV      r0,r6
;;;1082   }
000172  b007              ADD      sp,sp,#0x1c
000174  e8bd8ff0          POP      {r4-r11,pc}
;;;1083   
                          ENDP

                  |L21.376|
000178  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\sockets.c",0
00017c  5749505c
000180  6c776970
000184  2d312e34
000188  2e315c73
00018c  72635c61
000190  70695c73
000194  6f636b65
000198  74732e63
00019c  00      
00019d  00                DCB      0
00019e  00                DCB      0
00019f  00                DCB      0
                  |L21.416|
0001a0  6e726561          DCB      "nready >= 0",0
0001a4  6479203e
0001a8  3d203000
                  |L21.428|
0001ac  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0001b0  7274696f
0001b4  6e202225
0001b8  73222066
0001bc  61696c65
0001c0  64206174
0001c4  206c696e
0001c8  65202564
0001cc  20696e20
0001d0  25730d0a
0001d4  00      
0001d5  00                DCB      0
0001d6  00                DCB      0
0001d7  00                DCB      0

                          AREA ||i.lwip_send||, CODE, READONLY, ALIGN=2

                  lwip_send PROC
;;;753    int
;;;754    lwip_send(int s, const void *data, size_t size, int flags)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;755    {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
00000a  461e              MOV      r6,r3
;;;756      struct lwip_sock *sock;
;;;757      err_t err;
;;;758      u8_t write_flags;
;;;759      size_t written;
;;;760    
;;;761      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%"SZT_F", flags=0x%x)\n",
00000c  bf00              NOP      
00000e  bf00              NOP      
;;;762                                  s, data, size, flags));
;;;763    
;;;764      sock = get_socket(s);
000010  4640              MOV      r0,r8
000012  f7fffffe          BL       get_socket
000016  4604              MOV      r4,r0
;;;765      if (!sock) {
000018  b91c              CBNZ     r4,|L22.34|
;;;766        return -1;
00001a  f04f30ff          MOV      r0,#0xffffffff
                  |L22.30|
;;;767      }
;;;768    
;;;769      if (sock->conn->type != NETCONN_TCP) {
;;;770    #if (LWIP_UDP || LWIP_RAW)
;;;771        return lwip_sendto(s, data, size, flags, NULL, 0);
;;;772    #else /* (LWIP_UDP || LWIP_RAW) */
;;;773        sock_set_errno(sock, err_to_errno(ERR_ARG));
;;;774        return -1;
;;;775    #endif /* (LWIP_UDP || LWIP_RAW) */
;;;776      }
;;;777    
;;;778      write_flags = NETCONN_COPY |
;;;779        ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
;;;780        ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
;;;781      written = 0;
;;;782      err = netconn_write_partly(sock->conn, data, size, write_flags, &written);
;;;783    
;;;784      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d written=%"SZT_F"\n", s, err, written));
;;;785      sock_set_errno(sock, err_to_errno(err));
;;;786      return (err == ERR_OK ? (int)written : -1);
;;;787    }
00001e  e8bd8ffe          POP      {r1-r11,pc}
                  |L22.34|
000022  6820              LDR      r0,[r4,#0]            ;769
000024  7800              LDRB     r0,[r0,#0]            ;769
000026  2810              CMP      r0,#0x10              ;769
000028  d009              BEQ      |L22.62|
00002a  2000              MOVS     r0,#0                 ;771
00002c  9000              STR      r0,[sp,#0]            ;771
00002e  4633              MOV      r3,r6                 ;771
000030  4652              MOV      r2,r10                ;771
000032  4649              MOV      r1,r9                 ;771
000034  9001              STR      r0,[sp,#4]            ;771
000036  4640              MOV      r0,r8                 ;771
000038  f7fffffe          BL       lwip_sendto
00003c  e7ef              B        |L22.30|
                  |L22.62|
00003e  f0060010          AND      r0,r6,#0x10           ;778
000042  b108              CBZ      r0,|L22.72|
000044  2002              MOVS     r0,#2                 ;779
000046  e000              B        |L22.74|
                  |L22.72|
000048  2000              MOVS     r0,#0                 ;779
                  |L22.74|
00004a  f0400001          ORR      r0,r0,#1              ;779
00004e  f0060108          AND      r1,r6,#8              ;779
000052  b109              CBZ      r1,|L22.88|
000054  2104              MOVS     r1,#4                 ;780
000056  e000              B        |L22.90|
                  |L22.88|
000058  2100              MOVS     r1,#0                 ;780
                  |L22.90|
00005a  ea400701          ORR      r7,r0,r1              ;780
00005e  2000              MOVS     r0,#0                 ;781
000060  9002              STR      r0,[sp,#8]            ;781
000062  a802              ADD      r0,sp,#8              ;782
000064  9000              STR      r0,[sp,#0]            ;782
000066  463b              MOV      r3,r7                 ;782
000068  4652              MOV      r2,r10                ;782
00006a  4649              MOV      r1,r9                 ;782
00006c  6820              LDR      r0,[r4,#0]            ;782
00006e  f7fffffe          BL       netconn_write_partly
000072  4605              MOV      r5,r0                 ;782
000074  bf00              NOP                            ;784
000076  bf00              NOP                            ;784
000078  bf00              NOP                            ;785
00007a  4268              RSBS     r0,r5,#0              ;785
00007c  2810              CMP      r0,#0x10              ;785
00007e  d204              BCS      |L22.138|
000080  4806              LDR      r0,|L22.156|
000082  4269              RSBS     r1,r5,#0              ;785
000084  f8500021          LDR      r0,[r0,r1,LSL #2]     ;785
000088  e000              B        |L22.140|
                  |L22.138|
00008a  2005              MOVS     r0,#5                 ;785
                  |L22.140|
00008c  6120              STR      r0,[r4,#0x10]         ;785
00008e  bf00              NOP                            ;785
000090  b90d              CBNZ     r5,|L22.150|
000092  9802              LDR      r0,[sp,#8]            ;786
000094  e7c3              B        |L22.30|
                  |L22.150|
000096  f04f30ff          MOV      r0,#0xffffffff        ;786
00009a  e7c0              B        |L22.30|
;;;788    
                          ENDP

                  |L22.156|
                          DCD      err_to_errno_table

                          AREA ||i.lwip_sendto||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  lwip_sendto PROC
;;;789    int
;;;790    lwip_sendto(int s, const void *data, size_t size, int flags,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;791           const struct sockaddr *to, socklen_t tolen)
;;;792    {
000004  b085              SUB      sp,sp,#0x14
000006  4691              MOV      r9,r2
000008  e9dd5a12          LDRD     r5,r10,[sp,#0x48]
;;;793      struct lwip_sock *sock;
;;;794      err_t err;
;;;795      u16_t short_size;
;;;796      const struct sockaddr_in *to_in;
;;;797      u16_t remote_port;
;;;798    #if !LWIP_TCPIP_CORE_LOCKING
;;;799      struct netbuf buf;
;;;800    #endif
;;;801    
;;;802      sock = get_socket(s);
00000c  9805              LDR      r0,[sp,#0x14]
00000e  f7fffffe          BL       get_socket
000012  4606              MOV      r6,r0
;;;803      if (!sock) {
000014  b926              CBNZ     r6,|L23.32|
;;;804        return -1;
000016  f04f30ff          MOV      r0,#0xffffffff
                  |L23.26|
;;;805      }
;;;806    
;;;807      if (sock->conn->type == NETCONN_TCP) {
;;;808    #if LWIP_TCP
;;;809        return lwip_send(s, data, size, flags);
;;;810    #else /* LWIP_TCP */
;;;811        LWIP_UNUSED_ARG(flags);
;;;812        sock_set_errno(sock, err_to_errno(ERR_ARG));
;;;813        return -1;
;;;814    #endif /* LWIP_TCP */
;;;815      }
;;;816    
;;;817      /* @todo: split into multiple sendto's? */
;;;818      LWIP_ASSERT("lwip_sendto: size must fit in u16_t", size <= 0xffff);
;;;819      short_size = (u16_t)size;
;;;820      LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
;;;821                 ((tolen == sizeof(struct sockaddr_in)) &&
;;;822                 ((to->sa_family) == AF_INET) && ((((mem_ptr_t)to) % 4) == 0))),
;;;823                 sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
;;;824      to_in = (const struct sockaddr_in *)(void*)to;
;;;825    
;;;826    #if LWIP_TCPIP_CORE_LOCKING
;;;827      /* Should only be consider like a sample or a simple way to experiment this option (no check of "to" field...) */
;;;828      {
;;;829        struct pbuf* p;
;;;830        ip_addr_t *remote_addr;
;;;831    
;;;832    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;833        p = pbuf_alloc(PBUF_TRANSPORT, short_size, PBUF_RAM);
;;;834        if (p != NULL) {
;;;835    #if LWIP_CHECKSUM_ON_COPY
;;;836          u16_t chksum = 0;
;;;837          if (sock->conn->type != NETCONN_RAW) {
;;;838            chksum = LWIP_CHKSUM_COPY(p->payload, data, short_size);
;;;839          } else
;;;840    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;841          MEMCPY(p->payload, data, size);
;;;842    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;843        p = pbuf_alloc(PBUF_TRANSPORT, short_size, PBUF_REF);
;;;844        if (p != NULL) {
;;;845          p->payload = (void*)data;
;;;846    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;847    
;;;848          if (to_in != NULL) {
;;;849            inet_addr_to_ipaddr_p(remote_addr, &to_in->sin_addr);
;;;850            remote_port = ntohs(to_in->sin_port);
;;;851          } else {
;;;852            remote_addr = &sock->conn->pcb.ip->remote_ip;
;;;853    #if LWIP_UDP
;;;854            if (NETCONNTYPE_GROUP(sock->conn->type) == NETCONN_UDP) {
;;;855              remote_port = sock->conn->pcb.udp->remote_port;
;;;856            } else
;;;857    #endif /* LWIP_UDP */
;;;858            {
;;;859              remote_port = 0;
;;;860            }
;;;861          }
;;;862    
;;;863          LOCK_TCPIP_CORE();
;;;864          if (netconn_type(sock->conn) == NETCONN_RAW) {
;;;865    #if LWIP_RAW
;;;866            err = sock->conn->last_err = raw_sendto(sock->conn->pcb.raw, p, remote_addr);
;;;867    #else /* LWIP_RAW */
;;;868            err = ERR_ARG;
;;;869    #endif /* LWIP_RAW */
;;;870          }
;;;871    #if LWIP_UDP && LWIP_RAW
;;;872          else
;;;873    #endif /* LWIP_UDP && LWIP_RAW */
;;;874          {
;;;875    #if LWIP_UDP
;;;876    #if LWIP_CHECKSUM_ON_COPY && LWIP_NETIF_TX_SINGLE_PBUF
;;;877            err = sock->conn->last_err = udp_sendto_chksum(sock->conn->pcb.udp, p,
;;;878              remote_addr, remote_port, 1, chksum);
;;;879    #else /* LWIP_CHECKSUM_ON_COPY && LWIP_NETIF_TX_SINGLE_PBUF */
;;;880            err = sock->conn->last_err = udp_sendto(sock->conn->pcb.udp, p,
;;;881              remote_addr, remote_port);
;;;882    #endif /* LWIP_CHECKSUM_ON_COPY && LWIP_NETIF_TX_SINGLE_PBUF */
;;;883    #else /* LWIP_UDP */
;;;884            err = ERR_ARG;
;;;885    #endif /* LWIP_UDP */
;;;886          }
;;;887          UNLOCK_TCPIP_CORE();
;;;888          
;;;889          pbuf_free(p);
;;;890        } else {
;;;891          err = ERR_MEM;
;;;892        }
;;;893      }
;;;894    #else /* LWIP_TCPIP_CORE_LOCKING */
;;;895      /* initialize a buffer */
;;;896      buf.p = buf.ptr = NULL;
;;;897    #if LWIP_CHECKSUM_ON_COPY
;;;898      buf.flags = 0;
;;;899    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;900      if (to) {
;;;901        inet_addr_to_ipaddr(&buf.addr, &to_in->sin_addr);
;;;902        remote_port           = ntohs(to_in->sin_port);
;;;903        netbuf_fromport(&buf) = remote_port;
;;;904      } else {
;;;905        remote_port           = 0;
;;;906        ip_addr_set_any(&buf.addr);
;;;907        netbuf_fromport(&buf) = 0;
;;;908      }
;;;909    
;;;910      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_sendto(%d, data=%p, short_size=%"U16_F", flags=0x%x to=",
;;;911                  s, data, short_size, flags));
;;;912      ip_addr_debug_print(SOCKETS_DEBUG, &buf.addr);
;;;913      LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F"\n", remote_port));
;;;914    
;;;915      /* make the buffer point to the data that should be sent */
;;;916    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;917      /* Allocate a new netbuf and copy the data into it. */
;;;918      if (netbuf_alloc(&buf, short_size) == NULL) {
;;;919        err = ERR_MEM;
;;;920      } else {
;;;921    #if LWIP_CHECKSUM_ON_COPY
;;;922        if (sock->conn->type != NETCONN_RAW) {
;;;923          u16_t chksum = LWIP_CHKSUM_COPY(buf.p->payload, data, short_size);
;;;924          netbuf_set_chksum(&buf, chksum);
;;;925          err = ERR_OK;
;;;926        } else
;;;927    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;928        {
;;;929          err = netbuf_take(&buf, data, short_size);
;;;930        }
;;;931      }
;;;932    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;933      err = netbuf_ref(&buf, data, short_size);
;;;934    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;935      if (err == ERR_OK) {
;;;936        /* send the data */
;;;937        err = netconn_send(sock->conn, &buf);
;;;938      }
;;;939    
;;;940      /* deallocated the buffer */
;;;941      netbuf_free(&buf);
;;;942    #endif /* LWIP_TCPIP_CORE_LOCKING */
;;;943      sock_set_errno(sock, err_to_errno(err));
;;;944      return (err == ERR_OK ? short_size : -1);
;;;945    }
00001a  b009              ADD      sp,sp,#0x24
00001c  e8bd8ff0          POP      {r4-r11,pc}
                  |L23.32|
000020  6830              LDR      r0,[r6,#0]            ;807
000022  7800              LDRB     r0,[r0,#0]            ;807
000024  2810              CMP      r0,#0x10              ;807
000026  d106              BNE      |L23.54|
000028  464a              MOV      r2,r9                 ;809
00002a  9b08              LDR      r3,[sp,#0x20]         ;809
00002c  e9dd0105          LDRD     r0,r1,[sp,#0x14]      ;809
000030  f7fffffe          BL       lwip_send
000034  e7f1              B        |L23.26|
                  |L23.54|
000036  bf00              NOP                            ;818
000038  f5b93f80          CMP      r9,#0x10000           ;818
00003c  d308              BCC      |L23.80|
00003e  bf00              NOP                            ;818
000040  a333              ADR      r3,|L23.272|
000042  f2403232          MOV      r2,#0x332             ;818
000046  a13c              ADR      r1,|L23.312|
000048  a044              ADR      r0,|L23.348|
00004a  f7fffffe          BL       __2printf
00004e  bf00              NOP                            ;818
                  |L23.80|
000050  bf00              NOP                            ;818
000052  fa1ffb89          UXTH     r11,r9                ;819
000056  bf00              NOP                            ;820
000058  b915              CBNZ     r5,|L23.96|
00005a  f1ba0f00          CMP      r10,#0                ;820
00005e  d01a              BEQ      |L23.150|
                  |L23.96|
000060  f1ba0f10          CMP      r10,#0x10             ;820
000064  d106              BNE      |L23.116|
000066  7868              LDRB     r0,[r5,#1]            ;820
000068  2802              CMP      r0,#2                 ;820
00006a  d103              BNE      |L23.116|
00006c  f0050003          AND      r0,r5,#3              ;820
000070  2800              CMP      r0,#0                 ;820
000072  d010              BEQ      |L23.150|
                  |L23.116|
000074  bf00              NOP                            ;820
000076  a326              ADR      r3,|L23.272|
000078  f44f724d          MOV      r2,#0x334             ;820
00007c  a142              ADR      r1,|L23.392|
00007e  a037              ADR      r0,|L23.348|
000080  f7fffffe          BL       __2printf
000084  bf00              NOP                            ;820
000086  bf00              NOP                            ;820
000088  4847              LDR      r0,|L23.424|
00008a  6b80              LDR      r0,[r0,#0x38]         ;820  ; err_to_errno_table
00008c  6130              STR      r0,[r6,#0x10]         ;820
00008e  bf00              NOP                            ;820
000090  f04f30ff          MOV      r0,#0xffffffff        ;820
000094  e7c1              B        |L23.26|
                  |L23.150|
000096  bf00              NOP                            ;820
000098  462f              MOV      r7,r5                 ;824
00009a  2000              MOVS     r0,#0                 ;896
00009c  9002              STR      r0,[sp,#8]            ;896
00009e  9001              STR      r0,[sp,#4]            ;896
0000a0  b145              CBZ      r5,|L23.180|
0000a2  6878              LDR      r0,[r7,#4]            ;901
0000a4  9003              STR      r0,[sp,#0xc]          ;901
0000a6  8878              LDRH     r0,[r7,#2]            ;902
0000a8  f7fffffe          BL       lwip_ntohs
0000ac  4680              MOV      r8,r0                 ;902
0000ae  f8ad8010          STRH     r8,[sp,#0x10]         ;903
0000b2  e005              B        |L23.192|
                  |L23.180|
0000b4  f04f0800          MOV      r8,#0                 ;905
0000b8  2000              MOVS     r0,#0                 ;906
0000ba  9003              STR      r0,[sp,#0xc]          ;906
0000bc  f8ad0010          STRH     r0,[sp,#0x10]         ;907
                  |L23.192|
0000c0  bf00              NOP                            ;910
0000c2  bf00              NOP                            ;910
0000c4  bf00              NOP                            ;912
0000c6  bf00              NOP                            ;912
0000c8  bf00              NOP                            ;913
0000ca  bf00              NOP                            ;913
0000cc  465a              MOV      r2,r11                ;933
0000ce  a801              ADD      r0,sp,#4              ;933
0000d0  9906              LDR      r1,[sp,#0x18]         ;933
0000d2  f7fffffe          BL       netbuf_ref
0000d6  4604              MOV      r4,r0                 ;933
0000d8  b924              CBNZ     r4,|L23.228|
0000da  a901              ADD      r1,sp,#4              ;937
0000dc  6830              LDR      r0,[r6,#0]            ;937
0000de  f7fffffe          BL       netconn_send
0000e2  4604              MOV      r4,r0                 ;937
                  |L23.228|
0000e4  a801              ADD      r0,sp,#4              ;941
0000e6  f7fffffe          BL       netbuf_free
0000ea  bf00              NOP                            ;943
0000ec  4260              RSBS     r0,r4,#0              ;943
0000ee  2810              CMP      r0,#0x10              ;943
0000f0  d204              BCS      |L23.252|
0000f2  482d              LDR      r0,|L23.424|
0000f4  4261              RSBS     r1,r4,#0              ;943
0000f6  f8500021          LDR      r0,[r0,r1,LSL #2]     ;943
0000fa  e000              B        |L23.254|
                  |L23.252|
0000fc  2005              MOVS     r0,#5                 ;943
                  |L23.254|
0000fe  6130              STR      r0,[r6,#0x10]         ;943
000100  bf00              NOP                            ;943
000102  b90c              CBNZ     r4,|L23.264|
000104  4658              MOV      r0,r11                ;944
000106  e788              B        |L23.26|
                  |L23.264|
000108  f04f30ff          MOV      r0,#0xffffffff        ;944
00010c  e785              B        |L23.26|
;;;946    
                          ENDP

00010e  0000              DCW      0x0000
                  |L23.272|
000110  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\sockets.c",0
000114  5749505c
000118  6c776970
00011c  2d312e34
000120  2e315c73
000124  72635c61
000128  70695c73
00012c  6f636b65
000130  74732e63
000134  00      
000135  00                DCB      0
000136  00                DCB      0
000137  00                DCB      0
                  |L23.312|
000138  6c776970          DCB      "lwip_sendto: size must fit in u16_t",0
00013c  5f73656e
000140  64746f3a
000144  2073697a
000148  65206d75
00014c  73742066
000150  69742069
000154  6e207531
000158  365f7400
                  |L23.348|
00015c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000160  7274696f
000164  6e202225
000168  73222066
00016c  61696c65
000170  64206174
000174  206c696e
000178  65202564
00017c  20696e20
000180  25730d0a
000184  00      
000185  00                DCB      0
000186  00                DCB      0
000187  00                DCB      0
                  |L23.392|
000188  6c776970          DCB      "lwip_sendto: invalid address",0
00018c  5f73656e
000190  64746f3a
000194  20696e76
000198  616c6964
00019c  20616464
0001a0  72657373
0001a4  00      
0001a5  00                DCB      0
0001a6  00                DCB      0
0001a7  00                DCB      0
                  |L23.424|
                          DCD      err_to_errno_table

                          AREA ||i.lwip_setsockopt||, CODE, READONLY, ALIGN=2

                  lwip_setsockopt PROC
;;;1862   int
;;;1863   lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1864   {
000004  b087              SUB      sp,sp,#0x1c
000006  4681              MOV      r9,r0
000008  460f              MOV      r7,r1
00000a  4615              MOV      r5,r2
00000c  4698              MOV      r8,r3
;;;1865     struct lwip_sock *sock = get_socket(s);
00000e  4648              MOV      r0,r9
000010  f7fffffe          BL       get_socket
000014  4604              MOV      r4,r0
;;;1866     err_t err = ERR_OK;
000016  2600              MOVS     r6,#0
;;;1867     struct lwip_setgetsockopt_data data;
;;;1868   
;;;1869     if (!sock) {
000018  b91c              CBNZ     r4,|L24.34|
;;;1870       return -1;
00001a  1e70              SUBS     r0,r6,#1
                  |L24.28|
;;;1871     }
;;;1872   
;;;1873     if (NULL == optval) {
;;;1874       sock_set_errno(sock, EFAULT);
;;;1875       return -1;
;;;1876     }
;;;1877   
;;;1878     /* Do length and type checks for the various options first, to keep it readable. */
;;;1879     switch (level) {
;;;1880   
;;;1881   /* Level: SOL_SOCKET */
;;;1882     case SOL_SOCKET:
;;;1883       switch (optname) {
;;;1884   
;;;1885       case SO_BROADCAST:
;;;1886       /* UNIMPL case SO_DEBUG: */
;;;1887       /* UNIMPL case SO_DONTROUTE: */
;;;1888       case SO_KEEPALIVE:
;;;1889       /* UNIMPL case case SO_CONTIMEO: */
;;;1890   #if LWIP_SO_SNDTIMEO
;;;1891       case SO_SNDTIMEO:
;;;1892   #endif /* LWIP_SO_SNDTIMEO */
;;;1893   #if LWIP_SO_RCVTIMEO
;;;1894       case SO_RCVTIMEO:
;;;1895   #endif /* LWIP_SO_RCVTIMEO */
;;;1896   #if LWIP_SO_RCVBUF
;;;1897       case SO_RCVBUF:
;;;1898   #endif /* LWIP_SO_RCVBUF */
;;;1899       /* UNIMPL case SO_OOBINLINE: */
;;;1900       /* UNIMPL case SO_SNDBUF: */
;;;1901       /* UNIMPL case SO_RCVLOWAT: */
;;;1902       /* UNIMPL case SO_SNDLOWAT: */
;;;1903   #if SO_REUSE
;;;1904       case SO_REUSEADDR:
;;;1905       case SO_REUSEPORT:
;;;1906   #endif /* SO_REUSE */
;;;1907       /* UNIMPL case SO_USELOOPBACK: */
;;;1908         if (optlen < sizeof(int)) {
;;;1909           err = EINVAL;
;;;1910         }
;;;1911         break;
;;;1912       case SO_NO_CHECK:
;;;1913         if (optlen < sizeof(int)) {
;;;1914           err = EINVAL;
;;;1915         }
;;;1916   #if LWIP_UDP
;;;1917         if ((sock->conn->type != NETCONN_UDP) ||
;;;1918             ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
;;;1919           /* this flag is only available for UDP, not for UDP lite */
;;;1920           err = EAFNOSUPPORT;
;;;1921         }
;;;1922   #endif /* LWIP_UDP */
;;;1923         break;
;;;1924       default:
;;;1925         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
;;;1926                     s, optname));
;;;1927         err = ENOPROTOOPT;
;;;1928       }  /* switch (optname) */
;;;1929       break;
;;;1930   
;;;1931   /* Level: IPPROTO_IP */
;;;1932     case IPPROTO_IP:
;;;1933       switch (optname) {
;;;1934       /* UNIMPL case IP_HDRINCL: */
;;;1935       /* UNIMPL case IP_RCVDSTADDR: */
;;;1936       /* UNIMPL case IP_RCVIF: */
;;;1937       case IP_TTL:
;;;1938       case IP_TOS:
;;;1939         if (optlen < sizeof(int)) {
;;;1940           err = EINVAL;
;;;1941         }
;;;1942         break;
;;;1943   #if LWIP_IGMP
;;;1944       case IP_MULTICAST_TTL:
;;;1945         if (optlen < sizeof(u8_t)) {
;;;1946           err = EINVAL;
;;;1947         }
;;;1948         if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
;;;1949           err = EAFNOSUPPORT;
;;;1950         }
;;;1951         break;
;;;1952       case IP_MULTICAST_IF:
;;;1953         if (optlen < sizeof(struct in_addr)) {
;;;1954           err = EINVAL;
;;;1955         }
;;;1956         if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
;;;1957           err = EAFNOSUPPORT;
;;;1958         }
;;;1959         break;
;;;1960       case IP_MULTICAST_LOOP:
;;;1961         if (optlen < sizeof(u8_t)) {
;;;1962           err = EINVAL;
;;;1963         }
;;;1964         if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
;;;1965           err = EAFNOSUPPORT;
;;;1966         }
;;;1967         break;
;;;1968       case IP_ADD_MEMBERSHIP:
;;;1969       case IP_DROP_MEMBERSHIP:
;;;1970         if (optlen < sizeof(struct ip_mreq)) {
;;;1971           err = EINVAL;
;;;1972         }
;;;1973         if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
;;;1974           err = EAFNOSUPPORT;
;;;1975         }
;;;1976         break;
;;;1977   #endif /* LWIP_IGMP */
;;;1978         default:
;;;1979           LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
;;;1980                       s, optname));
;;;1981           err = ENOPROTOOPT;
;;;1982       }  /* switch (optname) */
;;;1983       break;
;;;1984   
;;;1985   #if LWIP_TCP
;;;1986   /* Level: IPPROTO_TCP */
;;;1987     case IPPROTO_TCP:
;;;1988       if (optlen < sizeof(int)) {
;;;1989         err = EINVAL;
;;;1990         break;
;;;1991       }
;;;1992   
;;;1993       /* If this is no TCP socket, ignore any options. */
;;;1994       if (sock->conn->type != NETCONN_TCP)
;;;1995         return 0;
;;;1996   
;;;1997       switch (optname) {
;;;1998       case TCP_NODELAY:
;;;1999       case TCP_KEEPALIVE:
;;;2000   #if LWIP_TCP_KEEPALIVE
;;;2001       case TCP_KEEPIDLE:
;;;2002       case TCP_KEEPINTVL:
;;;2003       case TCP_KEEPCNT:
;;;2004   #endif /* LWIP_TCP_KEEPALIVE */
;;;2005         break;
;;;2006   
;;;2007       default:
;;;2008         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
;;;2009                     s, optname));
;;;2010         err = ENOPROTOOPT;
;;;2011       }  /* switch (optname) */
;;;2012       break;
;;;2013   #endif /* LWIP_TCP */
;;;2014   #if LWIP_UDP && LWIP_UDPLITE
;;;2015   /* Level: IPPROTO_UDPLITE */
;;;2016     case IPPROTO_UDPLITE:
;;;2017       if (optlen < sizeof(int)) {
;;;2018         err = EINVAL;
;;;2019         break;
;;;2020       }
;;;2021   
;;;2022       /* If this is no UDP lite socket, ignore any options. */
;;;2023       if (sock->conn->type != NETCONN_UDPLITE)
;;;2024         return 0;
;;;2025   
;;;2026       switch (optname) {
;;;2027       case UDPLITE_SEND_CSCOV:
;;;2028       case UDPLITE_RECV_CSCOV:
;;;2029         break;
;;;2030   
;;;2031       default:
;;;2032         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UNIMPL: optname=0x%x, ..)\n",
;;;2033                     s, optname));
;;;2034         err = ENOPROTOOPT;
;;;2035       }  /* switch (optname) */
;;;2036       break;
;;;2037   #endif /* LWIP_UDP && LWIP_UDPLITE */
;;;2038   /* UNDEFINED LEVEL */
;;;2039     default:
;;;2040       LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
;;;2041                   s, level, optname));
;;;2042       err = ENOPROTOOPT;
;;;2043     }  /* switch (level) */
;;;2044   
;;;2045   
;;;2046     if (err != ERR_OK) {
;;;2047       sock_set_errno(sock, err);
;;;2048       return -1;
;;;2049     }
;;;2050   
;;;2051   
;;;2052     /* Now do the actual option processing */
;;;2053     data.sock = sock;
;;;2054   #ifdef LWIP_DEBUG
;;;2055     data.s = s;
;;;2056   #endif /* LWIP_DEBUG */
;;;2057     data.level = level;
;;;2058     data.optname = optname;
;;;2059     data.optval = (void*)optval;
;;;2060     data.optlen = &optlen;
;;;2061     data.err = err;
;;;2062     tcpip_callback(lwip_setsockopt_internal, &data);
;;;2063     sys_arch_sem_wait(&sock->conn->op_completed, 0);
;;;2064     /* maybe lwip_setsockopt_internal has changed err */
;;;2065     err = data.err;
;;;2066   
;;;2067     sock_set_errno(sock, err);
;;;2068     return err ? -1 : 0;
;;;2069   }
00001c  b007              ADD      sp,sp,#0x1c
00001e  e8bd83f0          POP      {r4-r9,pc}
                  |L24.34|
000022  f1b80f00          CMP      r8,#0                 ;1873
000026  d106              BNE      |L24.54|
000028  bf00              NOP                            ;1874
00002a  200e              MOVS     r0,#0xe               ;1874
00002c  6120              STR      r0,[r4,#0x10]         ;1874
00002e  bf00              NOP                            ;1874
000030  f04f30ff          MOV      r0,#0xffffffff        ;1875
000034  e7f2              B        |L24.28|
                  |L24.54|
000036  b36f              CBZ      r7,|L24.148|
000038  2f06              CMP      r7,#6                 ;1879
00003a  d03b              BEQ      |L24.180|
00003c  f6a770ff          SUB      r0,r7,#0xfff          ;1879
000040  2800              CMP      r0,#0                 ;1879
000042  d14f              BNE      |L24.228|
000044  2d08              CMP      r5,#8                 ;1883
000046  d009              BEQ      |L24.92|
000048  2d20              CMP      r5,#0x20              ;1883
00004a  d006              BEQ      |L24.90|
00004c  f5a55080          SUB      r0,r5,#0x1000         ;1883
000050  3806              SUBS     r0,#6                 ;1883
000052  b120              CBZ      r0,|L24.94|
000054  2804              CMP      r0,#4                 ;1883
000056  d117              BNE      |L24.136|
000058  e006              B        |L24.104|
                  |L24.90|
00005a  bf00              NOP                            ;1888
                  |L24.92|
00005c  bf00              NOP                            ;1894
                  |L24.94|
00005e  980e              LDR      r0,[sp,#0x38]         ;1908
000060  2804              CMP      r0,#4                 ;1908
000062  d200              BCS      |L24.102|
000064  2616              MOVS     r6,#0x16              ;1909
                  |L24.102|
000066  e013              B        |L24.144|
                  |L24.104|
000068  980e              LDR      r0,[sp,#0x38]         ;1913
00006a  2804              CMP      r0,#4                 ;1913
00006c  d200              BCS      |L24.112|
00006e  2616              MOVS     r6,#0x16              ;1914
                  |L24.112|
000070  6820              LDR      r0,[r4,#0]            ;1917
000072  7800              LDRB     r0,[r0,#0]            ;1917
000074  2820              CMP      r0,#0x20              ;1917
000076  d105              BNE      |L24.132|
000078  6820              LDR      r0,[r4,#0]            ;1918
00007a  6840              LDR      r0,[r0,#4]            ;1918
00007c  7c00              LDRB     r0,[r0,#0x10]         ;1918
00007e  f0000002          AND      r0,r0,#2              ;1918
000082  b100              CBZ      r0,|L24.134|
                  |L24.132|
000084  2661              MOVS     r6,#0x61              ;1920
                  |L24.134|
000086  e003              B        |L24.144|
                  |L24.136|
000088  bf00              NOP                            ;1925
00008a  bf00              NOP                            ;1925
00008c  265c              MOVS     r6,#0x5c              ;1927
00008e  bf00              NOP                            ;1883
                  |L24.144|
000090  bf00              NOP                            ;1911
000092  e02b              B        |L24.236|
                  |L24.148|
000094  2d01              CMP      r5,#1                 ;1933
000096  d002              BEQ      |L24.158|
000098  2d02              CMP      r5,#2                 ;1933
00009a  d105              BNE      |L24.168|
00009c  bf00              NOP                            ;1938
                  |L24.158|
00009e  980e              LDR      r0,[sp,#0x38]         ;1939
0000a0  2804              CMP      r0,#4                 ;1939
0000a2  d200              BCS      |L24.166|
0000a4  2616              MOVS     r6,#0x16              ;1940
                  |L24.166|
0000a6  e003              B        |L24.176|
                  |L24.168|
0000a8  bf00              NOP                            ;1979
0000aa  bf00              NOP                            ;1979
0000ac  265c              MOVS     r6,#0x5c              ;1981
0000ae  bf00              NOP                            ;1933
                  |L24.176|
0000b0  bf00              NOP                            ;1942
0000b2  e01b              B        |L24.236|
                  |L24.180|
0000b4  980e              LDR      r0,[sp,#0x38]         ;1988
0000b6  2804              CMP      r0,#4                 ;1988
0000b8  d201              BCS      |L24.190|
0000ba  2616              MOVS     r6,#0x16              ;1989
0000bc  e016              B        |L24.236|
                  |L24.190|
0000be  6820              LDR      r0,[r4,#0]            ;1994
0000c0  7800              LDRB     r0,[r0,#0]            ;1994
0000c2  2810              CMP      r0,#0x10              ;1994
0000c4  d001              BEQ      |L24.202|
0000c6  2000              MOVS     r0,#0                 ;1995
0000c8  e7a8              B        |L24.28|
                  |L24.202|
0000ca  2d01              CMP      r5,#1                 ;1997
0000cc  d002              BEQ      |L24.212|
0000ce  2d02              CMP      r5,#2                 ;1997
0000d0  d102              BNE      |L24.216|
0000d2  e000              B        |L24.214|
                  |L24.212|
0000d4  bf00              NOP                            ;1999
                  |L24.214|
0000d6  e003              B        |L24.224|
                  |L24.216|
0000d8  bf00              NOP                            ;2008
0000da  bf00              NOP                            ;2008
0000dc  265c              MOVS     r6,#0x5c              ;2010
0000de  bf00              NOP                            ;1997
                  |L24.224|
0000e0  bf00              NOP                            ;2005
0000e2  e003              B        |L24.236|
                  |L24.228|
0000e4  bf00              NOP                            ;2040
0000e6  bf00              NOP                            ;2040
0000e8  265c              MOVS     r6,#0x5c              ;2042
0000ea  bf00              NOP                            ;1879
                  |L24.236|
0000ec  bf00              NOP                            ;1929
0000ee  b12e              CBZ      r6,|L24.252|
0000f0  bf00              NOP                            ;2047
0000f2  6126              STR      r6,[r4,#0x10]         ;2047
0000f4  bf00              NOP                            ;2047
0000f6  f04f30ff          MOV      r0,#0xffffffff        ;2048
0000fa  e78f              B        |L24.28|
                  |L24.252|
0000fc  9400              STR      r4,[sp,#0]            ;2053
0000fe  f8cd9004          STR      r9,[sp,#4]            ;2055
000102  9702              STR      r7,[sp,#8]            ;2057
000104  9503              STR      r5,[sp,#0xc]          ;2058
000106  f8cd8010          STR      r8,[sp,#0x10]         ;2059
00010a  a80e              ADD      r0,sp,#0x38           ;2060
00010c  9005              STR      r0,[sp,#0x14]         ;2060
00010e  f88d6018          STRB     r6,[sp,#0x18]         ;2061
000112  2201              MOVS     r2,#1                 ;2062
000114  4669              MOV      r1,sp                 ;2062
000116  480a              LDR      r0,|L24.320|
000118  f7fffffe          BL       tcpip_callback_with_block
00011c  6821              LDR      r1,[r4,#0]            ;2063
00011e  f101000c          ADD      r0,r1,#0xc            ;2063
000122  2100              MOVS     r1,#0                 ;2063
000124  f7fffffe          BL       sys_arch_sem_wait
000128  f99d6018          LDRSB    r6,[sp,#0x18]         ;2065
00012c  bf00              NOP                            ;2067
00012e  6126              STR      r6,[r4,#0x10]         ;2067
000130  bf00              NOP                            ;2067
000132  b116              CBZ      r6,|L24.314|
000134  f04f30ff          MOV      r0,#0xffffffff        ;2068
000138  e770              B        |L24.28|
                  |L24.314|
00013a  2000              MOVS     r0,#0                 ;2068
00013c  e76e              B        |L24.28|
;;;2070   
                          ENDP

00013e  0000              DCW      0x0000
                  |L24.320|
                          DCD      lwip_setsockopt_internal

                          AREA ||i.lwip_setsockopt_internal||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  lwip_setsockopt_internal PROC
;;;2071   static void
;;;2072   lwip_setsockopt_internal(void *arg)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2073   {
000004  4605              MOV      r5,r0
;;;2074     struct lwip_sock *sock;
;;;2075   #ifdef LWIP_DEBUG
;;;2076     int s;
;;;2077   #endif /* LWIP_DEBUG */
;;;2078     int level, optname;
;;;2079     const void *optval;
;;;2080     struct lwip_setgetsockopt_data *data;
;;;2081   
;;;2082     LWIP_ASSERT("arg != NULL", arg != NULL);
000006  bf00              NOP      
000008  b945              CBNZ     r5,|L25.28|
00000a  bf00              NOP      
00000c  a365              ADR      r3,|L25.420|
00000e  f6400222          MOV      r2,#0x822
000012  a16e              ADR      r1,|L25.460|
000014  a070              ADR      r0,|L25.472|
000016  f7fffffe          BL       __2printf
00001a  bf00              NOP      
                  |L25.28|
00001c  bf00              NOP      
;;;2083   
;;;2084     data = (struct lwip_setgetsockopt_data*)arg;
00001e  46a8              MOV      r8,r5
;;;2085     sock = data->sock;
000020  4645              MOV      r5,r8
000022  f8d84000          LDR      r4,[r8,#0]
;;;2086   #ifdef LWIP_DEBUG
;;;2087     s = data->s;
000026  f8d8a004          LDR      r10,[r8,#4]
;;;2088   #endif /* LWIP_DEBUG */
;;;2089     level = data->level;
00002a  f8d89008          LDR      r9,[r8,#8]
;;;2090     optname = data->optname;
00002e  f8d8700c          LDR      r7,[r8,#0xc]
;;;2091     optval = data->optval;
000032  f8d86010          LDR      r6,[r8,#0x10]
;;;2092   
;;;2093     switch (level) {
000036  f1b90f00          CMP      r9,#0
00003a  d04c              BEQ      |L25.214|
00003c  f1b90f06          CMP      r9,#6
000040  d069              BEQ      |L25.278|
000042  f6a970ff          SUB      r0,r9,#0xfff
000046  2800              CMP      r0,#0
000048  d175              BNE      |L25.310|
;;;2094   
;;;2095   /* Level: SOL_SOCKET */
;;;2096     case SOL_SOCKET:
;;;2097       switch (optname) {
00004a  2f08              CMP      r7,#8
00004c  d009              BEQ      |L25.98|
00004e  2f20              CMP      r7,#0x20
000050  d006              BEQ      |L25.96|
000052  f5a75080          SUB      r0,r7,#0x1000
000056  3806              SUBS     r0,#6
000058  b1b8              CBZ      r0,|L25.138|
00005a  2804              CMP      r0,#4
00005c  d12d              BNE      |L25.186|
00005e  e018              B        |L25.146|
                  |L25.96|
;;;2098   
;;;2099       /* The option flags */
;;;2100       case SO_BROADCAST:
;;;2101       /* UNIMPL case SO_DEBUG: */
;;;2102       /* UNIMPL case SO_DONTROUTE: */
;;;2103       case SO_KEEPALIVE:
000060  bf00              NOP      
                  |L25.98|
;;;2104       /* UNIMPL case SO_OOBINCLUDE: */
;;;2105   #if SO_REUSE
;;;2106       case SO_REUSEADDR:
;;;2107       case SO_REUSEPORT:
;;;2108   #endif /* SO_REUSE */
;;;2109       /* UNIMPL case SO_USELOOPBACK: */
;;;2110         if (*(int*)optval) {
000062  6830              LDR      r0,[r6,#0]
000064  b138              CBZ      r0,|L25.118|
;;;2111           ip_set_option(sock->conn->pcb.ip, optname);
000066  6820              LDR      r0,[r4,#0]
000068  6840              LDR      r0,[r0,#4]
00006a  7a00              LDRB     r0,[r0,#8]
00006c  4338              ORRS     r0,r0,r7
00006e  6821              LDR      r1,[r4,#0]
000070  6849              LDR      r1,[r1,#4]
000072  7208              STRB     r0,[r1,#8]
000074  e006              B        |L25.132|
                  |L25.118|
;;;2112         } else {
;;;2113           ip_reset_option(sock->conn->pcb.ip, optname);
000076  6820              LDR      r0,[r4,#0]
000078  6840              LDR      r0,[r0,#4]
00007a  7a00              LDRB     r0,[r0,#8]
00007c  43b8              BICS     r0,r0,r7
00007e  6821              LDR      r1,[r4,#0]
000080  6849              LDR      r1,[r1,#4]
000082  7208              STRB     r0,[r1,#8]
                  |L25.132|
;;;2114         }
;;;2115         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
000084  bf00              NOP      
000086  bf00              NOP      
;;;2116                     s, optname, (*(int*)optval?"on":"off")));
;;;2117         break;
000088  e023              B        |L25.210|
                  |L25.138|
;;;2118   #if LWIP_SO_SNDTIMEO
;;;2119       case SO_SNDTIMEO:
;;;2120         netconn_set_sendtimeout(sock->conn, (s32_t)*(int*)optval);
;;;2121         break;
;;;2122   #endif /* LWIP_SO_SNDTIMEO */
;;;2123   #if LWIP_SO_RCVTIMEO
;;;2124       case SO_RCVTIMEO:
;;;2125         netconn_set_recvtimeout(sock->conn, *(int*)optval);
00008a  6830              LDR      r0,[r6,#0]
00008c  6821              LDR      r1,[r4,#0]
00008e  61c8              STR      r0,[r1,#0x1c]
;;;2126         break;
000090  e01f              B        |L25.210|
                  |L25.146|
;;;2127   #endif /* LWIP_SO_RCVTIMEO */
;;;2128   #if LWIP_SO_RCVBUF
;;;2129       case SO_RCVBUF:
;;;2130         netconn_set_recvbufsize(sock->conn, *(int*)optval);
;;;2131         break;
;;;2132   #endif /* LWIP_SO_RCVBUF */
;;;2133   #if LWIP_UDP
;;;2134       case SO_NO_CHECK:
;;;2135         if (*(int*)optval) {
000092  6830              LDR      r0,[r6,#0]
000094  b140              CBZ      r0,|L25.168|
;;;2136           udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
000096  6820              LDR      r0,[r4,#0]
000098  6840              LDR      r0,[r0,#4]
00009a  7c00              LDRB     r0,[r0,#0x10]
00009c  f0400001          ORR      r0,r0,#1
0000a0  6821              LDR      r1,[r4,#0]
0000a2  6849              LDR      r1,[r1,#4]
0000a4  7408              STRB     r0,[r1,#0x10]
0000a6  e007              B        |L25.184|
                  |L25.168|
;;;2137         } else {
;;;2138           udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6840              LDR      r0,[r0,#4]
0000ac  7c00              LDRB     r0,[r0,#0x10]
0000ae  f0200001          BIC      r0,r0,#1
0000b2  6821              LDR      r1,[r4,#0]
0000b4  6849              LDR      r1,[r1,#4]
0000b6  7408              STRB     r0,[r1,#0x10]
                  |L25.184|
;;;2139         }
;;;2140         break;
0000b8  e00b              B        |L25.210|
                  |L25.186|
;;;2141   #endif /* LWIP_UDP */
;;;2142       default:
;;;2143         LWIP_ASSERT("unhandled optname", 0);
0000ba  bf00              NOP      
0000bc  bf00              NOP      
0000be  a339              ADR      r3,|L25.420|
0000c0  f640025f          MOV      r2,#0x85f
0000c4  a14f              ADR      r1,|L25.516|
0000c6  a044              ADR      r0,|L25.472|
0000c8  f7fffffe          BL       __2printf
0000cc  bf00              NOP      
0000ce  bf00              NOP      
;;;2144         break;
0000d0  bf00              NOP      
                  |L25.210|
0000d2  bf00              NOP                            ;2117
;;;2145       }  /* switch (optname) */
;;;2146       break;
0000d4  e05d              B        |L25.402|
                  |L25.214|
;;;2147   
;;;2148   /* Level: IPPROTO_IP */
;;;2149     case IPPROTO_IP:
;;;2150       switch (optname) {
0000d6  2f01              CMP      r7,#1
0000d8  d008              BEQ      |L25.236|
0000da  2f02              CMP      r7,#2
0000dc  d10d              BNE      |L25.250|
;;;2151       case IP_TTL:
;;;2152         sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
0000de  7830              LDRB     r0,[r6,#0]
0000e0  6821              LDR      r1,[r4,#0]
0000e2  6849              LDR      r1,[r1,#4]
0000e4  7288              STRB     r0,[r1,#0xa]
;;;2153         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %d\n",
0000e6  bf00              NOP      
0000e8  bf00              NOP      
;;;2154                     s, sock->conn->pcb.ip->ttl));
;;;2155         break;
0000ea  e012              B        |L25.274|
                  |L25.236|
;;;2156       case IP_TOS:
;;;2157         sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
0000ec  7830              LDRB     r0,[r6,#0]
0000ee  6821              LDR      r1,[r4,#0]
0000f0  6849              LDR      r1,[r1,#4]
0000f2  7248              STRB     r0,[r1,#9]
;;;2158         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %d\n",
0000f4  bf00              NOP      
0000f6  bf00              NOP      
;;;2159                     s, sock->conn->pcb.ip->tos));
;;;2160         break;
0000f8  e00b              B        |L25.274|
                  |L25.250|
;;;2161   #if LWIP_IGMP
;;;2162       case IP_MULTICAST_TTL:
;;;2163         sock->conn->pcb.udp->ttl = (u8_t)(*(u8_t*)optval);
;;;2164         break;
;;;2165       case IP_MULTICAST_IF:
;;;2166         inet_addr_to_ipaddr(&sock->conn->pcb.udp->multicast_ip, (struct in_addr*)optval);
;;;2167         break;
;;;2168       case IP_MULTICAST_LOOP:
;;;2169         if (*(u8_t*)optval) {
;;;2170           udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_MULTICAST_LOOP);
;;;2171         } else {
;;;2172           udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_MULTICAST_LOOP);
;;;2173         }
;;;2174         break;
;;;2175       case IP_ADD_MEMBERSHIP:
;;;2176       case IP_DROP_MEMBERSHIP:
;;;2177         {
;;;2178           /* If this is a TCP or a RAW socket, ignore these options. */
;;;2179           struct ip_mreq *imr = (struct ip_mreq *)optval;
;;;2180           ip_addr_t if_addr;
;;;2181           ip_addr_t multi_addr;
;;;2182           inet_addr_to_ipaddr(&if_addr, &imr->imr_interface);
;;;2183           inet_addr_to_ipaddr(&multi_addr, &imr->imr_multiaddr);
;;;2184           if(optname == IP_ADD_MEMBERSHIP){
;;;2185             data->err = igmp_joingroup(&if_addr, &multi_addr);
;;;2186           } else {
;;;2187             data->err = igmp_leavegroup(&if_addr, &multi_addr);
;;;2188           }
;;;2189           if(data->err != ERR_OK) {
;;;2190             data->err = EADDRNOTAVAIL;
;;;2191           }
;;;2192         }
;;;2193         break;
;;;2194   #endif /* LWIP_IGMP */
;;;2195       default:
;;;2196         LWIP_ASSERT("unhandled optname", 0);
0000fa  bf00              NOP      
0000fc  bf00              NOP      
0000fe  a329              ADR      r3,|L25.420|
000100  f6400294          MOV      r2,#0x894
000104  a13f              ADR      r1,|L25.516|
000106  a034              ADR      r0,|L25.472|
000108  f7fffffe          BL       __2printf
00010c  bf00              NOP      
00010e  bf00              NOP      
;;;2197         break;
000110  bf00              NOP      
                  |L25.274|
000112  bf00              NOP                            ;2155
;;;2198       }  /* switch (optname) */
;;;2199       break;
000114  e03d              B        |L25.402|
                  |L25.278|
;;;2200   
;;;2201   #if LWIP_TCP
;;;2202   /* Level: IPPROTO_TCP */
;;;2203     case IPPROTO_TCP:
;;;2204       switch (optname) {
000116  2f01              CMP      r7,#1
000118  d002              BEQ      |L25.288|
00011a  2f02              CMP      r7,#2
00011c  d11f              BNE      |L25.350|
00011e  e016              B        |L25.334|
                  |L25.288|
;;;2205       case TCP_NODELAY:
;;;2206         if (*(int*)optval) {
000120  6830              LDR      r0,[r6,#0]
000122  b148              CBZ      r0,|L25.312|
;;;2207           tcp_nagle_disable(sock->conn->pcb.tcp);
000124  6820              LDR      r0,[r4,#0]
000126  6840              LDR      r0,[r0,#4]
000128  7f80              LDRB     r0,[r0,#0x1e]
00012a  f0400040          ORR      r0,r0,#0x40
00012e  6821              LDR      r1,[r4,#0]
000130  6849              LDR      r1,[r1,#4]
000132  7788              STRB     r0,[r1,#0x1e]
000134  e008              B        |L25.328|
                  |L25.310|
000136  e020              B        |L25.378|
                  |L25.312|
;;;2208         } else {
;;;2209           tcp_nagle_enable(sock->conn->pcb.tcp);
000138  6820              LDR      r0,[r4,#0]
00013a  6840              LDR      r0,[r0,#4]
00013c  7f80              LDRB     r0,[r0,#0x1e]
00013e  f0200040          BIC      r0,r0,#0x40
000142  6821              LDR      r1,[r4,#0]
000144  6849              LDR      r1,[r1,#4]
000146  7788              STRB     r0,[r1,#0x1e]
                  |L25.328|
;;;2210         }
;;;2211         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
000148  bf00              NOP      
00014a  bf00              NOP      
;;;2212                     s, (*(int *)optval)?"on":"off") );
;;;2213         break;
00014c  e013              B        |L25.374|
                  |L25.334|
;;;2214       case TCP_KEEPALIVE:
;;;2215         sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
00014e  6830              LDR      r0,[r6,#0]
000150  6821              LDR      r1,[r4,#0]
000152  6849              LDR      r1,[r1,#4]
000154  f8c10090          STR      r0,[r1,#0x90]
;;;2216         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %"U32_F"\n",
000158  bf00              NOP      
00015a  bf00              NOP      
;;;2217                     s, sock->conn->pcb.tcp->keep_idle));
;;;2218         break;
00015c  e00b              B        |L25.374|
                  |L25.350|
;;;2219   
;;;2220   #if LWIP_TCP_KEEPALIVE
;;;2221       case TCP_KEEPIDLE:
;;;2222         sock->conn->pcb.tcp->keep_idle = 1000*(u32_t)(*(int*)optval);
;;;2223         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPIDLE) -> %"U32_F"\n",
;;;2224                     s, sock->conn->pcb.tcp->keep_idle));
;;;2225         break;
;;;2226       case TCP_KEEPINTVL:
;;;2227         sock->conn->pcb.tcp->keep_intvl = 1000*(u32_t)(*(int*)optval);
;;;2228         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPINTVL) -> %"U32_F"\n",
;;;2229                     s, sock->conn->pcb.tcp->keep_intvl));
;;;2230         break;
;;;2231       case TCP_KEEPCNT:
;;;2232         sock->conn->pcb.tcp->keep_cnt = (u32_t)(*(int*)optval);
;;;2233         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPCNT) -> %"U32_F"\n",
;;;2234                     s, sock->conn->pcb.tcp->keep_cnt));
;;;2235         break;
;;;2236   #endif /* LWIP_TCP_KEEPALIVE */
;;;2237       default:
;;;2238         LWIP_ASSERT("unhandled optname", 0);
00015e  bf00              NOP      
000160  bf00              NOP      
000162  a310              ADR      r3,|L25.420|
000164  f64002be          MOV      r2,#0x8be
000168  a126              ADR      r1,|L25.516|
00016a  a01b              ADR      r0,|L25.472|
00016c  f7fffffe          BL       __2printf
000170  bf00              NOP      
000172  bf00              NOP      
;;;2239         break;
000174  bf00              NOP      
                  |L25.374|
000176  bf00              NOP                            ;2213
;;;2240       }  /* switch (optname) */
;;;2241       break;
000178  e00b              B        |L25.402|
                  |L25.378|
;;;2242   #endif /* LWIP_TCP*/
;;;2243   #if LWIP_UDP && LWIP_UDPLITE
;;;2244     /* Level: IPPROTO_UDPLITE */
;;;2245     case IPPROTO_UDPLITE:
;;;2246       switch (optname) {
;;;2247       case UDPLITE_SEND_CSCOV:
;;;2248         if ((*(int*)optval != 0) && ((*(int*)optval < 8) || (*(int*)optval > 0xffff))) {
;;;2249           /* don't allow illegal values! */
;;;2250           sock->conn->pcb.udp->chksum_len_tx = 8;
;;;2251         } else {
;;;2252           sock->conn->pcb.udp->chksum_len_tx = (u16_t)*(int*)optval;
;;;2253         }
;;;2254         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV) -> %d\n",
;;;2255                     s, (*(int*)optval)) );
;;;2256         break;
;;;2257       case UDPLITE_RECV_CSCOV:
;;;2258         if ((*(int*)optval != 0) && ((*(int*)optval < 8) || (*(int*)optval > 0xffff))) {
;;;2259           /* don't allow illegal values! */
;;;2260           sock->conn->pcb.udp->chksum_len_rx = 8;
;;;2261         } else {
;;;2262           sock->conn->pcb.udp->chksum_len_rx = (u16_t)*(int*)optval;
;;;2263         }
;;;2264         LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV) -> %d\n",
;;;2265                     s, (*(int*)optval)) );
;;;2266         break;
;;;2267       default:
;;;2268         LWIP_ASSERT("unhandled optname", 0);
;;;2269         break;
;;;2270       }  /* switch (optname) */
;;;2271       break;
;;;2272   #endif /* LWIP_UDP */
;;;2273     default:
;;;2274       LWIP_ASSERT("unhandled level", 0);
00017a  bf00              NOP      
00017c  bf00              NOP      
00017e  a309              ADR      r3,|L25.420|
000180  f64002e2          MOV      r2,#0x8e2
000184  a124              ADR      r1,|L25.536|
000186  a014              ADR      r0,|L25.472|
000188  f7fffffe          BL       __2printf
00018c  bf00              NOP      
00018e  bf00              NOP      
;;;2275       break;
000190  bf00              NOP      
                  |L25.402|
000192  bf00              NOP                            ;2146
;;;2276     }  /* switch (level) */
;;;2277     sys_sem_signal(&sock->conn->op_completed);
000194  6821              LDR      r1,[r4,#0]
000196  f101000c          ADD      r0,r1,#0xc
00019a  f7fffffe          BL       sys_sem_signal
;;;2278   }
00019e  e8bd87f0          POP      {r4-r10,pc}
;;;2279   
                          ENDP

0001a2  0000              DCW      0x0000
                  |L25.420|
0001a4  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\sockets.c",0
0001a8  5749505c
0001ac  6c776970
0001b0  2d312e34
0001b4  2e315c73
0001b8  72635c61
0001bc  70695c73
0001c0  6f636b65
0001c4  74732e63
0001c8  00      
0001c9  00                DCB      0
0001ca  00                DCB      0
0001cb  00                DCB      0
                  |L25.460|
0001cc  61726720          DCB      "arg != NULL",0
0001d0  213d204e
0001d4  554c4c00
                  |L25.472|
0001d8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0001dc  7274696f
0001e0  6e202225
0001e4  73222066
0001e8  61696c65
0001ec  64206174
0001f0  206c696e
0001f4  65202564
0001f8  20696e20
0001fc  25730d0a
000200  00      
000201  00                DCB      0
000202  00                DCB      0
000203  00                DCB      0
                  |L25.516|
000204  756e6861          DCB      "unhandled optname",0
000208  6e646c65
00020c  64206f70
000210  746e616d
000214  6500    
000216  00                DCB      0
000217  00                DCB      0
                  |L25.536|
000218  756e6861          DCB      "unhandled level",0
00021c  6e646c65
000220  64206c65
000224  76656c00

                          AREA ||i.lwip_shutdown||, CODE, READONLY, ALIGN=2

                  lwip_shutdown PROC
;;;1366   int
;;;1367   lwip_shutdown(int s, int how)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1368   {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
;;;1369     struct lwip_sock *sock;
;;;1370     err_t err;
;;;1371     u8_t shut_rx = 0, shut_tx = 0;
000008  f04f0800          MOV      r8,#0
00000c  46c1              MOV      r9,r8
;;;1372   
;;;1373     LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
00000e  bf00              NOP      
000010  bf00              NOP      
;;;1374   
;;;1375     sock = get_socket(s);
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       get_socket
000018  4604              MOV      r4,r0
;;;1376     if (!sock) {
00001a  b91c              CBNZ     r4,|L26.36|
;;;1377       return -1;
00001c  f04f30ff          MOV      r0,#0xffffffff
                  |L26.32|
;;;1378     }
;;;1379   
;;;1380     if (sock->conn != NULL) {
;;;1381       if (netconn_type(sock->conn) != NETCONN_TCP) {
;;;1382         sock_set_errno(sock, EOPNOTSUPP);
;;;1383         return EOPNOTSUPP;
;;;1384       }
;;;1385     } else {
;;;1386       sock_set_errno(sock, ENOTCONN);
;;;1387       return ENOTCONN;
;;;1388     }
;;;1389   
;;;1390     if (how == SHUT_RD) {
;;;1391       shut_rx = 1;
;;;1392     } else if (how == SHUT_WR) {
;;;1393       shut_tx = 1;
;;;1394     } else if(how == SHUT_RDWR) {
;;;1395       shut_rx = 1;
;;;1396       shut_tx = 1;
;;;1397     } else {
;;;1398       sock_set_errno(sock, EINVAL);
;;;1399       return EINVAL;
;;;1400     }
;;;1401     err = netconn_shutdown(sock->conn, shut_rx, shut_tx);
;;;1402   
;;;1403     sock_set_errno(sock, err_to_errno(err));
;;;1404     return (err == ERR_OK ? 0 : -1);
;;;1405   }
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L26.36|
000024  6820              LDR      r0,[r4,#0]            ;1380
000026  b140              CBZ      r0,|L26.58|
000028  6820              LDR      r0,[r4,#0]            ;1381
00002a  7800              LDRB     r0,[r0,#0]            ;1381
00002c  2810              CMP      r0,#0x10              ;1381
00002e  d009              BEQ      |L26.68|
000030  bf00              NOP                            ;1382
000032  205f              MOVS     r0,#0x5f              ;1382
000034  6120              STR      r0,[r4,#0x10]         ;1382
000036  bf00              NOP                            ;1382
000038  e7f2              B        |L26.32|
                  |L26.58|
00003a  bf00              NOP                            ;1386
00003c  206b              MOVS     r0,#0x6b              ;1386
00003e  6120              STR      r0,[r4,#0x10]         ;1386
000040  bf00              NOP                            ;1386
000042  e7ed              B        |L26.32|
                  |L26.68|
000044  b916              CBNZ     r6,|L26.76|
000046  f04f0801          MOV      r8,#1                 ;1391
00004a  e00f              B        |L26.108|
                  |L26.76|
00004c  2e01              CMP      r6,#1                 ;1392
00004e  d101              BNE      |L26.84|
000050  46b1              MOV      r9,r6                 ;1393
000052  e00b              B        |L26.108|
                  |L26.84|
000054  2e02              CMP      r6,#2                 ;1394
000056  d104              BNE      |L26.98|
000058  f04f0801          MOV      r8,#1                 ;1395
00005c  f04f0901          MOV      r9,#1                 ;1396
000060  e004              B        |L26.108|
                  |L26.98|
000062  bf00              NOP                            ;1398
000064  2016              MOVS     r0,#0x16              ;1398
000066  6120              STR      r0,[r4,#0x10]         ;1398
000068  bf00              NOP                            ;1398
00006a  e7d9              B        |L26.32|
                  |L26.108|
00006c  464a              MOV      r2,r9                 ;1401
00006e  4641              MOV      r1,r8                 ;1401
000070  6820              LDR      r0,[r4,#0]            ;1401
000072  f7fffffe          BL       netconn_shutdown
000076  4605              MOV      r5,r0                 ;1401
000078  bf00              NOP                            ;1403
00007a  4268              RSBS     r0,r5,#0              ;1403
00007c  2810              CMP      r0,#0x10              ;1403
00007e  d204              BCS      |L26.138|
000080  4806              LDR      r0,|L26.156|
000082  4269              RSBS     r1,r5,#0              ;1403
000084  f8500021          LDR      r0,[r0,r1,LSL #2]     ;1403
000088  e000              B        |L26.140|
                  |L26.138|
00008a  2005              MOVS     r0,#5                 ;1403
                  |L26.140|
00008c  6120              STR      r0,[r4,#0x10]         ;1403
00008e  bf00              NOP                            ;1403
000090  b90d              CBNZ     r5,|L26.150|
000092  2000              MOVS     r0,#0                 ;1404
000094  e7c4              B        |L26.32|
                  |L26.150|
000096  f04f30ff          MOV      r0,#0xffffffff        ;1404
00009a  e7c1              B        |L26.32|
;;;1406   
                          ENDP

                  |L26.156|
                          DCD      err_to_errno_table

                          AREA ||i.lwip_socket||, CODE, READONLY, ALIGN=2

                  lwip_socket PROC
;;;947    int
;;;948    lwip_socket(int domain, int type, int protocol)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;949    {
000004  4680              MOV      r8,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;950      struct netconn *conn;
;;;951      int i;
;;;952    
;;;953      LWIP_UNUSED_ARG(domain);
;;;954    
;;;955      /* create a netconn */
;;;956      switch (type) {
00000a  2f01              CMP      r7,#1
00000c  d01a              BEQ      |L27.68|
00000e  2f02              CMP      r7,#2
000010  d00a              BEQ      |L27.40|
000012  2f03              CMP      r7,#3
000014  d128              BNE      |L27.104|
;;;957      case SOCK_RAW:
;;;958        conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
000016  b2f1              UXTB     r1,r6
000018  4a23              LDR      r2,|L27.168|
00001a  2040              MOVS     r0,#0x40
00001c  f7fffffe          BL       netconn_new_with_proto_and_callback
000020  4604              MOV      r4,r0
;;;959        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
000022  bf00              NOP      
000024  bf00              NOP      
;;;960                                     domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
;;;961        break;
000026  e025              B        |L27.116|
                  |L27.40|
;;;962      case SOCK_DGRAM:
;;;963        conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
000028  2e88              CMP      r6,#0x88
00002a  d101              BNE      |L27.48|
00002c  2121              MOVS     r1,#0x21
00002e  e000              B        |L27.50|
                  |L27.48|
000030  2120              MOVS     r1,#0x20
                  |L27.50|
000032  4608              MOV      r0,r1
000034  4a1c              LDR      r2,|L27.168|
000036  2100              MOVS     r1,#0
000038  f7fffffe          BL       netconn_new_with_proto_and_callback
00003c  4604              MOV      r4,r0
;;;964                     NETCONN_UDPLITE : NETCONN_UDP, event_callback);
;;;965        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
00003e  bf00              NOP      
000040  bf00              NOP      
;;;966                                     domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
;;;967        break;
000042  e017              B        |L27.116|
                  |L27.68|
;;;968      case SOCK_STREAM:
;;;969        conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
000044  4a18              LDR      r2,|L27.168|
000046  2100              MOVS     r1,#0
000048  2010              MOVS     r0,#0x10
00004a  f7fffffe          BL       netconn_new_with_proto_and_callback
00004e  4604              MOV      r4,r0
;;;970        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
000050  bf00              NOP      
000052  bf00              NOP      
;;;971                                     domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
;;;972        if (conn != NULL) {
000054  b13c              CBZ      r4,|L27.102|
;;;973          /* Prevent automatic window updates, we do this on our own! */
;;;974          netconn_set_noautorecved(conn, 1);
000056  bf00              NOP      
000058  f8940020          LDRB     r0,[r4,#0x20]
00005c  f0400008          ORR      r0,r0,#8
000060  f8840020          STRB     r0,[r4,#0x20]
000064  bf00              NOP      
                  |L27.102|
;;;975        }
;;;976        break;
000066  e005              B        |L27.116|
                  |L27.104|
;;;977      default:
;;;978        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
000068  bf00              NOP      
00006a  bf00              NOP      
;;;979                                     domain, type, protocol));
;;;980        set_errno(EINVAL);
;;;981        return -1;
00006c  f04f30ff          MOV      r0,#0xffffffff
                  |L27.112|
;;;982      }
;;;983    
;;;984      if (!conn) {
;;;985        LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
;;;986        set_errno(ENOBUFS);
;;;987        return -1;
;;;988      }
;;;989    
;;;990      i = alloc_socket(conn, 0);
;;;991    
;;;992      if (i == -1) {
;;;993        netconn_delete(conn);
;;;994        set_errno(ENFILE);
;;;995        return -1;
;;;996      }
;;;997      conn->socket = i;
;;;998      LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
;;;999      set_errno(0);
;;;1000     return i;
;;;1001   }
000070  e8bd81f0          POP      {r4-r8,pc}
                  |L27.116|
000074  bf00              NOP                            ;961
000076  b924              CBNZ     r4,|L27.130|
000078  bf00              NOP                            ;985
00007a  bf00              NOP                            ;985
00007c  f04f30ff          MOV      r0,#0xffffffff        ;987
000080  e7f6              B        |L27.112|
                  |L27.130|
000082  2100              MOVS     r1,#0                 ;990
000084  4620              MOV      r0,r4                 ;990
000086  f7fffffe          BL       alloc_socket
00008a  4605              MOV      r5,r0                 ;990
00008c  1c68              ADDS     r0,r5,#1              ;992
00008e  b928              CBNZ     r0,|L27.156|
000090  4620              MOV      r0,r4                 ;993
000092  f7fffffe          BL       netconn_delete
000096  f04f30ff          MOV      r0,#0xffffffff        ;995
00009a  e7e9              B        |L27.112|
                  |L27.156|
00009c  61a5              STR      r5,[r4,#0x18]         ;997
00009e  bf00              NOP                            ;998
0000a0  bf00              NOP                            ;998
0000a2  4628              MOV      r0,r5                 ;1000
0000a4  e7e4              B        |L27.112|
;;;1002   
                          ENDP

0000a6  0000              DCW      0x0000
                  |L27.168|
                          DCD      event_callback

                          AREA ||i.lwip_socket_init||, CODE, READONLY, ALIGN=1

                  lwip_socket_init PROC
;;;183    void
;;;184    lwip_socket_init(void)
000000  4770              BX       lr
;;;185    {
;;;186    }
;;;187    
                          ENDP


                          AREA ||i.lwip_write||, CODE, READONLY, ALIGN=1

                  lwip_write PROC
;;;1003   int
;;;1004   lwip_write(int s, const void *data, size_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;1005   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1006     return lwip_send(s, data, size, 0);
000008  2300              MOVS     r3,#0
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       lwip_send
;;;1007   }
000014  bd70              POP      {r4-r6,pc}
;;;1008   
                          ENDP


                          AREA ||i.tryget_socket||, CODE, READONLY, ALIGN=2

                  tryget_socket PROC
;;;222    static struct lwip_sock *
;;;223    tryget_socket(int s)
000000  4601              MOV      r1,r0
;;;224    {
;;;225      if ((s < 0) || (s >= NUM_SOCKETS)) {
000002  2900              CMP      r1,#0
000004  db01              BLT      |L30.10|
000006  2904              CMP      r1,#4
000008  db01              BLT      |L30.14|
                  |L30.10|
;;;226        return NULL;
00000a  2000              MOVS     r0,#0
                  |L30.12|
;;;227      }
;;;228      if (!sockets[s].conn) {
;;;229        return NULL;
;;;230      }
;;;231      return &sockets[s];
;;;232    }
00000c  4770              BX       lr
                  |L30.14|
00000e  eb010041          ADD      r0,r1,r1,LSL #1       ;228
000012  4a06              LDR      r2,|L30.44|
000014  f8520030          LDR      r0,[r2,r0,LSL #3]     ;228
000018  b908              CBNZ     r0,|L30.30|
00001a  2000              MOVS     r0,#0                 ;229
00001c  e7f6              B        |L30.12|
                  |L30.30|
00001e  eb010041          ADD      r0,r1,r1,LSL #1       ;231
000022  4a02              LDR      r2,|L30.44|
000024  eb0200c0          ADD      r0,r2,r0,LSL #3       ;231
000028  e7f0              B        |L30.12|
;;;233    
                          ENDP

00002a  0000              DCW      0x0000
                  |L30.44|
                          DCD      sockets

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  sockets
                          %        96

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  err_to_errno_table
                          DCD      0x00000000
                          DCD      0x0000000c
                          DCD      0x00000069
                          DCD      0x0000000b
                          DCD      0x00000071
                          DCD      0x00000073
                          DCD      0x00000016
                          DCD      0x0000000b
                          DCD      0x00000062
                          DCD      0x00000072
                          DCD      0x00000067
                          DCD      0x00000068
                          DCD      0x0000006b
                          DCD      0x0000006b
                          DCD      0x00000005
                          DCD      0xffffffff

                          AREA ||.data||, DATA, ALIGN=2

                  select_cb_list
                          DCD      0x00000000
                  select_cb_ctr
                          DCD      0x00000000
