; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\etharp.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\etharp.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\etharp.crf ..\LWIP\lwip-1.4.1\src\netif\etharp.c]
                          THUMB

                          AREA ||i.etharp_arp_input||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  etharp_arp_input PROC
;;;687    static void
;;;688    etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;689    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;690      struct etharp_hdr *hdr;
;;;691      struct eth_hdr *ethhdr;
;;;692      /* these are aligned properly, whereas the ARP header fields might not be */
;;;693      ip_addr_t sipaddr, dipaddr;
;;;694      u8_t for_us;
;;;695    #if LWIP_AUTOIP
;;;696      const u8_t * ethdst_hwaddr;
;;;697    #endif /* LWIP_AUTOIP */
;;;698    
;;;699      LWIP_ERROR("netif != NULL", (netif != NULL), return;);
00000a  bf00              NOP      
00000c  b955              CBNZ     r5,|L1.36|
00000e  bf00              NOP      
000010  a353              ADR      r3,|L1.352|
000012  f24022bb          MOV      r2,#0x2bb
000016  a15c              ADR      r1,|L1.392|
000018  a05f              ADR      r0,|L1.408|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
                  |L1.32|
;;;700    
;;;701      /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
;;;702         since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
;;;703      if (p->len < SIZEOF_ETHARP_PACKET) {
;;;704        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;705          ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
;;;706          (s16_t)SIZEOF_ETHARP_PACKET));
;;;707        ETHARP_STATS_INC(etharp.lenerr);
;;;708        ETHARP_STATS_INC(etharp.drop);
;;;709        pbuf_free(p);
;;;710        return;
;;;711      }
;;;712    
;;;713      ethhdr = (struct eth_hdr *)p->payload;
;;;714      hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
;;;715    #if ETHARP_SUPPORT_VLAN
;;;716      if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
;;;717        hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
;;;718      }
;;;719    #endif /* ETHARP_SUPPORT_VLAN */
;;;720    
;;;721      /* RFC 826 "Packet Reception": */
;;;722      if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
;;;723          (hdr->hwlen != ETHARP_HWADDR_LEN) ||
;;;724          (hdr->protolen != sizeof(ip_addr_t)) ||
;;;725          (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
;;;726        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;727          ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
;;;728          hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
;;;729        ETHARP_STATS_INC(etharp.proterr);
;;;730        ETHARP_STATS_INC(etharp.drop);
;;;731        pbuf_free(p);
;;;732        return;
;;;733      }
;;;734      ETHARP_STATS_INC(etharp.recv);
;;;735    
;;;736    #if LWIP_AUTOIP
;;;737      /* We have to check if a host already has configured our random
;;;738       * created link local address and continously check if there is
;;;739       * a host with this IP-address so we can detect collisions */
;;;740      autoip_arp_reply(netif, hdr);
;;;741    #endif /* LWIP_AUTOIP */
;;;742    
;;;743      /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
;;;744       * structure packing (not using structure copy which breaks strict-aliasing rules). */
;;;745      IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
;;;746      IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
;;;747    
;;;748      /* this interface is not configured? */
;;;749      if (ip_addr_isany(&netif->ip_addr)) {
;;;750        for_us = 0;
;;;751      } else {
;;;752        /* ARP packet directed to us? */
;;;753        for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
;;;754      }
;;;755    
;;;756      /* ARP message directed to us?
;;;757          -> add IP address in ARP cache; assume requester wants to talk to us,
;;;758             can result in directly sending the queued packets for this host.
;;;759         ARP message not directed to us?
;;;760          ->  update the source IP address in the cache, if present */
;;;761      etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
;;;762                       for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
;;;763    
;;;764      /* now act on the message itself */
;;;765      switch (hdr->opcode) {
;;;766      /* ARP request? */
;;;767      case PP_HTONS(ARP_REQUEST):
;;;768        /* ARP request. If it asked for our address, we send out a
;;;769         * reply. In any case, we time-stamp any existing ARP entry,
;;;770         * and possiby send out an IP packet that was queued on it. */
;;;771    
;;;772        LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
;;;773        /* ARP request for our address? */
;;;774        if (for_us) {
;;;775    
;;;776          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
;;;777          /* Re-use pbuf to send ARP reply.
;;;778             Since we are re-using an existing pbuf, we can't call etharp_raw since
;;;779             that would allocate a new pbuf. */
;;;780          hdr->opcode = htons(ARP_REPLY);
;;;781    
;;;782          IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
;;;783          IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
;;;784    
;;;785          LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
;;;786                      (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;787    #if LWIP_AUTOIP
;;;788          /* If we are using Link-Local, all ARP packets that contain a Link-Local
;;;789           * 'sender IP address' MUST be sent using link-layer broadcast instead of
;;;790           * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
;;;791          ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
;;;792    #endif /* LWIP_AUTOIP */
;;;793    
;;;794          ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
;;;795    #if LWIP_AUTOIP
;;;796          ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
;;;797    #else  /* LWIP_AUTOIP */
;;;798          ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
;;;799    #endif /* LWIP_AUTOIP */
;;;800          ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
;;;801          ETHADDR16_COPY(&ethhdr->src, ethaddr);
;;;802    
;;;803          /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
;;;804             are already correct, we tested that before */
;;;805    
;;;806          /* return ARP reply */
;;;807          netif->linkoutput(netif, p);
;;;808        /* we are not configured? */
;;;809        } else if (ip_addr_isany(&netif->ip_addr)) {
;;;810          /* { for_us == 0 and netif->ip_addr.addr == 0 } */
;;;811          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: we are unconfigured, ARP request ignored.\n"));
;;;812        /* request was not directed to us */
;;;813        } else {
;;;814          /* { for_us == 0 and netif->ip_addr.addr != 0 } */
;;;815          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
;;;816        }
;;;817        break;
;;;818      case PP_HTONS(ARP_REPLY):
;;;819        /* ARP reply. We already updated the ARP cache earlier. */
;;;820        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP reply\n"));
;;;821    #if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
;;;822        /* DHCP wants to know about ARP replies from any host with an
;;;823         * IP address also offered to us by the DHCP server. We do not
;;;824         * want to take a duplicate IP address on a single network.
;;;825         * @todo How should we handle redundant (fail-over) interfaces? */
;;;826        dhcp_arp_reply(netif, &sipaddr);
;;;827    #endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
;;;828        break;
;;;829      default:
;;;830        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
;;;831        ETHARP_STATS_INC(etharp.err);
;;;832        break;
;;;833      }
;;;834      /* free ARP packet */
;;;835      pbuf_free(p);
;;;836    }
000020  e8bd87fc          POP      {r2-r10,pc}
                  |L1.36|
000024  bf00              NOP                            ;699
000026  8970              LDRH     r0,[r6,#0xa]          ;703
000028  282a              CMP      r0,#0x2a              ;703
00002a  da05              BGE      |L1.56|
00002c  bf00              NOP                            ;704
00002e  bf00              NOP                            ;704
000030  4630              MOV      r0,r6                 ;709
000032  f7fffffe          BL       pbuf_free
000036  e7f3              B        |L1.32|
                  |L1.56|
000038  6877              LDR      r7,[r6,#4]            ;713
00003a  f107040e          ADD      r4,r7,#0xe            ;714
00003e  8820              LDRH     r0,[r4,#0]            ;722
000040  f5b07f80          CMP      r0,#0x100             ;722
000044  d108              BNE      |L1.88|
000046  7920              LDRB     r0,[r4,#4]            ;723
000048  2806              CMP      r0,#6                 ;723
00004a  d105              BNE      |L1.88|
00004c  7960              LDRB     r0,[r4,#5]            ;724
00004e  2804              CMP      r0,#4                 ;724
000050  d102              BNE      |L1.88|
000052  8860              LDRH     r0,[r4,#2]            ;725
000054  2808              CMP      r0,#8                 ;725
000056  d005              BEQ      |L1.100|
                  |L1.88|
000058  bf00              NOP                            ;726
00005a  bf00              NOP                            ;726
00005c  4630              MOV      r0,r6                 ;731
00005e  f7fffffe          BL       pbuf_free
000062  e7dd              B        |L1.32|
                  |L1.100|
000064  f8d4000e          LDR      r0,[r4,#0xe]          ;745
000068  9001              STR      r0,[sp,#4]            ;745
00006a  69a0              LDR      r0,[r4,#0x18]         ;746
00006c  9000              STR      r0,[sp,#0]            ;746
00006e  1d28              ADDS     r0,r5,#4              ;749
000070  b108              CBZ      r0,|L1.118|
000072  6868              LDR      r0,[r5,#4]            ;749
000074  b910              CBNZ     r0,|L1.124|
                  |L1.118|
000076  f04f0900          MOV      r9,#0                 ;750
00007a  e007              B        |L1.140|
                  |L1.124|
00007c  9800              LDR      r0,[sp,#0]            ;753
00007e  6869              LDR      r1,[r5,#4]            ;753
000080  4288              CMP      r0,r1                 ;753
000082  d101              BNE      |L1.136|
000084  2001              MOVS     r0,#1                 ;753
000086  e000              B        |L1.138|
                  |L1.136|
000088  2000              MOVS     r0,#0                 ;753
                  |L1.138|
00008a  4681              MOV      r9,r0                 ;753
                  |L1.140|
00008c  f1b90f00          CMP      r9,#0                 ;761
000090  d001              BEQ      |L1.150|
000092  2001              MOVS     r0,#1                 ;762
000094  e000              B        |L1.152|
                  |L1.150|
000096  2002              MOVS     r0,#2                 ;762
                  |L1.152|
000098  4603              MOV      r3,r0                 ;762
00009a  f1040208          ADD      r2,r4,#8              ;762
00009e  a901              ADD      r1,sp,#4              ;762
0000a0  4628              MOV      r0,r5                 ;762
0000a2  f7fffffe          BL       etharp_update_arp_entry
0000a6  88e0              LDRH     r0,[r4,#6]            ;765
0000a8  f5b07f80          CMP      r0,#0x100             ;765
0000ac  d003              BEQ      |L1.182|
0000ae  f5b07f00          CMP      r0,#0x200             ;765
0000b2  d14b              BNE      |L1.332|
0000b4  e043              B        |L1.318|
                  |L1.182|
0000b6  bf00              NOP                            ;772
0000b8  bf00              NOP                            ;772
0000ba  f1b90f00          CMP      r9,#0                 ;774
0000be  d035              BEQ      |L1.300|
0000c0  bf00              NOP                            ;776
0000c2  bf00              NOP                            ;776
0000c4  2002              MOVS     r0,#2                 ;780
0000c6  f7fffffe          BL       lwip_htons
0000ca  80e0              STRH     r0,[r4,#6]            ;780
0000cc  f8d4000e          LDR      r0,[r4,#0xe]          ;782
0000d0  61a0              STR      r0,[r4,#0x18]         ;782
0000d2  6868              LDR      r0,[r5,#4]            ;783
0000d4  f8c4000e          STR      r0,[r4,#0xe]          ;783
0000d8  bf00              NOP                            ;785
0000da  f8950026          LDRB     r0,[r5,#0x26]         ;785
0000de  2806              CMP      r0,#6                 ;785
0000e0  d008              BEQ      |L1.244|
0000e2  bf00              NOP                            ;785
0000e4  a31e              ADR      r3,|L1.352|
0000e6  f2403211          MOV      r2,#0x311             ;785
0000ea  4936              LDR      r1,|L1.452|
0000ec  a02a              ADR      r0,|L1.408|
0000ee  f7fffffe          BL       __2printf
0000f2  bf00              NOP                            ;785
                  |L1.244|
0000f4  bf00              NOP                            ;785
0000f6  68a0              LDR      r0,[r4,#8]            ;794
0000f8  f8c40012          STR      r0,[r4,#0x12]         ;794
0000fc  89a0              LDRH     r0,[r4,#0xc]          ;794
0000fe  82e0              STRH     r0,[r4,#0x16]         ;794
000100  68a0              LDR      r0,[r4,#8]            ;798
000102  6038              STR      r0,[r7,#0]            ;798
000104  89a0              LDRH     r0,[r4,#0xc]          ;798
000106  80b8              STRH     r0,[r7,#4]            ;798
000108  f8d80000          LDR      r0,[r8,#0]            ;800
00010c  60a0              STR      r0,[r4,#8]            ;800
00010e  f8b80004          LDRH     r0,[r8,#4]            ;800
000112  81a0              STRH     r0,[r4,#0xc]          ;800
000114  f8d80000          LDR      r0,[r8,#0]            ;801
000118  f8c70006          STR      r0,[r7,#6]            ;801
00011c  f8b80004          LDRH     r0,[r8,#4]            ;801
000120  8178              STRH     r0,[r7,#0xa]          ;801
000122  4631              MOV      r1,r6                 ;807
000124  4628              MOV      r0,r5                 ;807
000126  69aa              LDR      r2,[r5,#0x18]         ;807
000128  4790              BLX      r2                    ;807
00012a  e007              B        |L1.316|
                  |L1.300|
00012c  1d28              ADDS     r0,r5,#4              ;809
00012e  b108              CBZ      r0,|L1.308|
000130  6868              LDR      r0,[r5,#4]            ;809
000132  b908              CBNZ     r0,|L1.312|
                  |L1.308|
000134  bf00              NOP                            ;811
000136  e001              B        |L1.316|
                  |L1.312|
000138  bf00              NOP                            ;815
00013a  bf00              NOP                            ;815
                  |L1.316|
00013c  e009              B        |L1.338|
                  |L1.318|
00013e  bf00              NOP                            ;820
000140  bf00              NOP                            ;820
000142  a901              ADD      r1,sp,#4              ;826
000144  4628              MOV      r0,r5                 ;826
000146  f7fffffe          BL       dhcp_arp_reply
00014a  e002              B        |L1.338|
                  |L1.332|
00014c  bf00              NOP                            ;830
00014e  bf00              NOP                            ;830
000150  bf00              NOP                            ;832
                  |L1.338|
000152  bf00              NOP                            ;817
000154  4630              MOV      r0,r6                 ;835
000156  f7fffffe          BL       pbuf_free
00015a  bf00              NOP      
00015c  e760              B        |L1.32|
;;;837    
                          ENDP

00015e  0000              DCW      0x0000
                  |L1.352|
000160  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\netif\\etharp.c",0
000164  5749505c
000168  6c776970
00016c  2d312e34
000170  2e315c73
000174  72635c6e
000178  65746966
00017c  5c657468
000180  6172702e
000184  6300    
000186  00                DCB      0
000187  00                DCB      0
                  |L1.392|
000188  6e657469          DCB      "netif != NULL",0
00018c  6620213d
000190  204e554c
000194  4c00    
000196  00                DCB      0
000197  00                DCB      0
                  |L1.408|
000198  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
00019c  7274696f
0001a0  6e202225
0001a4  73222066
0001a8  61696c65
0001ac  64206174
0001b0  206c696e
0001b4  65202564
0001b8  20696e20
0001bc  25730d0a
0001c0  00      
0001c1  00                DCB      0
0001c2  00                DCB      0
0001c3  00                DCB      0
                  |L1.452|
                          DCD      ||.conststring||

                          AREA ||i.etharp_cleanup_netif||, CODE, READONLY, ALIGN=2

                  etharp_cleanup_netif PROC
;;;578     */
;;;579    void etharp_cleanup_netif(struct netif *netif)
000000  b570              PUSH     {r4-r6,lr}
;;;580    {
000002  4605              MOV      r5,r0
;;;581      u8_t i;
;;;582    
;;;583      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
000004  2400              MOVS     r4,#0
000006  e012              B        |L2.46|
                  |L2.8|
;;;584        u8_t state = arp_table[i].state;
000008  eb040084          ADD      r0,r4,r4,LSL #2
00000c  4909              LDR      r1,|L2.52|
00000e  eb010080          ADD      r0,r1,r0,LSL #2
000012  7c86              LDRB     r6,[r0,#0x12]
;;;585        if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
000014  b14e              CBZ      r6,|L2.42|
000016  eb040084          ADD      r0,r4,r4,LSL #2
00001a  eb010080          ADD      r0,r1,r0,LSL #2
00001e  6880              LDR      r0,[r0,#8]
000020  42a8              CMP      r0,r5
000022  d102              BNE      |L2.42|
;;;586          etharp_free_entry(i);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       etharp_free_entry
                  |L2.42|
00002a  1c60              ADDS     r0,r4,#1              ;583
00002c  b2c4              UXTB     r4,r0                 ;583
                  |L2.46|
00002e  2c0a              CMP      r4,#0xa               ;583
000030  dbea              BLT      |L2.8|
;;;587        }
;;;588      }
;;;589    }
000032  bd70              POP      {r4-r6,pc}
;;;590    
                          ENDP

                  |L2.52|
                          DCD      arp_table

                          AREA ||i.etharp_find_addr||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  etharp_find_addr PROC
;;;602    s8_t
;;;603    etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;604             struct eth_addr **eth_ret, ip_addr_t **ip_ret)
;;;605    {
000004  4680              MOV      r8,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;606      s8_t i;
;;;607    
;;;608      LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
00000c  bf00              NOP      
00000e  b10d              CBZ      r5,|L3.20|
000010  2e00              CMP      r6,#0
000012  d108              BNE      |L3.38|
                  |L3.20|
000014  bf00              NOP      
000016  a315              ADR      r3,|L3.108|
000018  f44f7218          MOV      r2,#0x260
00001c  a11d              ADR      r1,|L3.148|
00001e  a026              ADR      r0,|L3.184|
000020  f7fffffe          BL       __2printf
000024  bf00              NOP      
                  |L3.38|
000026  bf00              NOP      
;;;609        eth_ret != NULL && ip_ret != NULL);
;;;610    
;;;611      LWIP_UNUSED_ARG(netif);
;;;612    
;;;613      i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
000028  2102              MOVS     r1,#2
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       etharp_find_entry
000030  4604              MOV      r4,r0
;;;614      if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
000032  2c00              CMP      r4,#0
000034  db16              BLT      |L3.100|
000036  eb040084          ADD      r0,r4,r4,LSL #2
00003a  492a              LDR      r1,|L3.228|
00003c  eb010080          ADD      r0,r1,r0,LSL #2
000040  7c80              LDRB     r0,[r0,#0x12]
000042  2802              CMP      r0,#2
000044  db0e              BLT      |L3.100|
;;;615          *eth_ret = &arp_table[i].ethaddr;
000046  eb040084          ADD      r0,r4,r4,LSL #2
00004a  eb010080          ADD      r0,r1,r0,LSL #2
00004e  300c              ADDS     r0,r0,#0xc
000050  6028              STR      r0,[r5,#0]
;;;616          *ip_ret = &arp_table[i].ipaddr;
000052  eb040084          ADD      r0,r4,r4,LSL #2
000056  eb010080          ADD      r0,r1,r0,LSL #2
00005a  1d00              ADDS     r0,r0,#4
00005c  6030              STR      r0,[r6,#0]
;;;617          return i;
00005e  4620              MOV      r0,r4
                  |L3.96|
;;;618      }
;;;619      return -1;
;;;620    }
000060  e8bd81f0          POP      {r4-r8,pc}
                  |L3.100|
000064  f04f30ff          MOV      r0,#0xffffffff        ;619
000068  e7fa              B        |L3.96|
;;;621    
                          ENDP

00006a  0000              DCW      0x0000
                  |L3.108|
00006c  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\netif\\etharp.c",0
000070  5749505c
000074  6c776970
000078  2d312e34
00007c  2e315c73
000080  72635c6e
000084  65746966
000088  5c657468
00008c  6172702e
000090  6300    
000092  00                DCB      0
000093  00                DCB      0
                  |L3.148|
000094  6574685f          DCB      "eth_ret != NULL && ip_ret != NULL",0
000098  72657420
00009c  213d204e
0000a0  554c4c20
0000a4  26262069
0000a8  705f7265
0000ac  7420213d
0000b0  204e554c
0000b4  4c00    
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L3.184|
0000b8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000bc  7274696f
0000c0  6e202225
0000c4  73222066
0000c8  61696c65
0000cc  64206174
0000d0  206c696e
0000d4  65202564
0000d8  20696e20
0000dc  25730d0a
0000e0  00      
0000e1  00                DCB      0
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L3.228|
                          DCD      arp_table

                          AREA ||i.etharp_find_entry||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  etharp_find_entry PROC
;;;265    static s8_t
;;;266    etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;267    {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
;;;268      s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
000008  f04f090a          MOV      r9,#0xa
00000c  46ca              MOV      r10,r9
;;;269      s8_t empty = ARP_TABLE_SIZE;
00000e  270a              MOVS     r7,#0xa
;;;270      u8_t i = 0, age_pending = 0, age_stable = 0;
000010  2400              MOVS     r4,#0
000012  2000              MOVS     r0,#0
000014  9002              STR      r0,[sp,#8]
000016  9001              STR      r0,[sp,#4]
;;;271      /* oldest entry with packets on queue */
;;;272      s8_t old_queue = ARP_TABLE_SIZE;
000018  46bb              MOV      r11,r7
;;;273      /* its age */
;;;274      u8_t age_queue = 0;
00001a  9000              STR      r0,[sp,#0]
;;;275    
;;;276      /**
;;;277       * a) do a search through the cache, remember candidates
;;;278       * b) select candidate entry
;;;279       * c) create new entry
;;;280       */
;;;281    
;;;282      /* a) in a single search sweep, do all of this
;;;283       * 1) remember the first empty entry (if any)
;;;284       * 2) remember the oldest stable entry (if any)
;;;285       * 3) remember the oldest pending entry without queued packets (if any)
;;;286       * 4) remember the oldest pending entry with queued packets (if any)
;;;287       * 5) search for a matching IP entry, either pending or stable
;;;288       *    until 5 matches, or all entries are searched for.
;;;289       */
;;;290    
;;;291      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
00001c  bf00              NOP      
00001e  e06f              B        |L4.256|
                  |L4.32|
;;;292        u8_t state = arp_table[i].state;
000020  eb040084          ADD      r0,r4,r4,LSL #2
000024  4976              LDR      r1,|L4.512|
000026  eb010080          ADD      r0,r1,r0,LSL #2
00002a  7c85              LDRB     r5,[r0,#0x12]
;;;293        /* no empty entry found yet and now we do find one? */
;;;294        if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
00002c  2f0a              CMP      r7,#0xa
00002e  d104              BNE      |L4.58|
000030  b91d              CBNZ     r5,|L4.58|
;;;295          LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
000032  bf00              NOP      
000034  bf00              NOP      
;;;296          /* remember first empty entry */
;;;297          empty = i;
000036  b267              SXTB     r7,r4
000038  e060              B        |L4.252|
                  |L4.58|
;;;298        } else if (state != ETHARP_STATE_EMPTY) {
00003a  2d00              CMP      r5,#0
00003c  d05e              BEQ      |L4.252|
;;;299          LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
00003e  bf00              NOP      
000040  2d01              CMP      r5,#1
000042  d00a              BEQ      |L4.90|
000044  2d02              CMP      r5,#2
000046  da08              BGE      |L4.90|
000048  bf00              NOP      
00004a  a36e              ADR      r3,|L4.516|
00004c  f240122b          MOV      r2,#0x12b
000050  a176              ADR      r1,|L4.556|
000052  a086              ADR      r0,|L4.620|
000054  f7fffffe          BL       __2printf
000058  bf00              NOP      
                  |L4.90|
00005a  bf00              NOP      
;;;300            state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
;;;301          /* if given, does IP address match IP address in ARP entry? */
;;;302          if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
00005c  b16e              CBZ      r6,|L4.122|
00005e  eb040184          ADD      r1,r4,r4,LSL #2
000062  4a67              LDR      r2,|L4.512|
000064  eb020181          ADD      r1,r2,r1,LSL #2
000068  6830              LDR      r0,[r6,#0]
00006a  6849              LDR      r1,[r1,#4]
00006c  4288              CMP      r0,r1
00006e  d104              BNE      |L4.122|
;;;303            LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
000070  bf00              NOP      
000072  bf00              NOP      
;;;304            /* found exact IP address match, simply bail out */
;;;305            return i;
000074  b260              SXTB     r0,r4
                  |L4.118|
;;;306          }
;;;307          /* pending entry? */
;;;308          if (state == ETHARP_STATE_PENDING) {
;;;309            /* pending with queued packets? */
;;;310            if (arp_table[i].q != NULL) {
;;;311              if (arp_table[i].ctime >= age_queue) {
;;;312                old_queue = i;
;;;313                age_queue = arp_table[i].ctime;
;;;314              }
;;;315            } else
;;;316            /* pending without queued packets? */
;;;317            {
;;;318              if (arp_table[i].ctime >= age_pending) {
;;;319                old_pending = i;
;;;320                age_pending = arp_table[i].ctime;
;;;321              }
;;;322            }
;;;323          /* stable entry? */
;;;324          } else if (state >= ETHARP_STATE_STABLE) {
;;;325    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;326            /* don't record old_stable for static entries since they never expire */
;;;327            if (state < ETHARP_STATE_STATIC)
;;;328    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;329            {
;;;330              /* remember entry with oldest stable entry in oldest, its age in maxtime */
;;;331              if (arp_table[i].ctime >= age_stable) {
;;;332                old_stable = i;
;;;333                age_stable = arp_table[i].ctime;
;;;334              }
;;;335            }
;;;336          }
;;;337        }
;;;338      }
;;;339      /* { we have no match } => try to create a new entry */
;;;340       
;;;341      /* don't create new entry, only search? */
;;;342      if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
;;;343          /* or no empty entry found and not allowed to recycle? */
;;;344          ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
;;;345        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
;;;346        return (s8_t)ERR_MEM;
;;;347      }
;;;348      
;;;349      /* b) choose the least destructive entry to recycle:
;;;350       * 1) empty entry
;;;351       * 2) oldest stable entry
;;;352       * 3) oldest pending entry without queued packets
;;;353       * 4) oldest pending entry with queued packets
;;;354       * 
;;;355       * { ETHARP_FLAG_TRY_HARD is set at this point }
;;;356       */ 
;;;357    
;;;358      /* 1) empty entry available? */
;;;359      if (empty < ARP_TABLE_SIZE) {
;;;360        i = empty;
;;;361        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
;;;362      } else {
;;;363        /* 2) found recyclable stable entry? */
;;;364        if (old_stable < ARP_TABLE_SIZE) {
;;;365          /* recycle oldest stable*/
;;;366          i = old_stable;
;;;367          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
;;;368          /* no queued packets should exist on stable entries */
;;;369          LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
;;;370        /* 3) found recyclable pending entry without queued packets? */
;;;371        } else if (old_pending < ARP_TABLE_SIZE) {
;;;372          /* recycle oldest pending */
;;;373          i = old_pending;
;;;374          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
;;;375        /* 4) found recyclable pending entry with queued packets? */
;;;376        } else if (old_queue < ARP_TABLE_SIZE) {
;;;377          /* recycle oldest pending (queued packets are free in etharp_free_entry) */
;;;378          i = old_queue;
;;;379          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
;;;380          /* no empty or recyclable entries found */
;;;381        } else {
;;;382          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
;;;383          return (s8_t)ERR_MEM;
;;;384        }
;;;385    
;;;386        /* { empty or recyclable entry found } */
;;;387        LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
;;;388        etharp_free_entry(i);
;;;389      }
;;;390    
;;;391      LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
;;;392      LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
;;;393        arp_table[i].state == ETHARP_STATE_EMPTY);
;;;394    
;;;395      /* IP address given? */
;;;396      if (ipaddr != NULL) {
;;;397        /* set IP address */
;;;398        ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
;;;399      }
;;;400      arp_table[i].ctime = 0;
;;;401      return (err_t)i;
;;;402    }
000076  e8bd8ffe          POP      {r1-r11,pc}
                  |L4.122|
00007a  2d01              CMP      r5,#1                 ;308
00007c  d12a              BNE      |L4.212|
00007e  eb040084          ADD      r0,r4,r4,LSL #2       ;310
000082  495f              LDR      r1,|L4.512|
000084  f8510020          LDR      r0,[r1,r0,LSL #2]     ;310
000088  b188              CBZ      r0,|L4.174|
00008a  eb040084          ADD      r0,r4,r4,LSL #2       ;311
00008e  eb010080          ADD      r0,r1,r0,LSL #2       ;311
000092  7cc1              LDRB     r1,[r0,#0x13]         ;311
000094  9800              LDR      r0,[sp,#0]            ;311
000096  4281              CMP      r1,r0                 ;311
000098  db30              BLT      |L4.252|
00009a  fa4ffb84          SXTB     r11,r4                ;312
00009e  eb040084          ADD      r0,r4,r4,LSL #2       ;313
0000a2  4957              LDR      r1,|L4.512|
0000a4  eb010080          ADD      r0,r1,r0,LSL #2       ;313
0000a8  7cc0              LDRB     r0,[r0,#0x13]         ;313
0000aa  9000              STR      r0,[sp,#0]            ;313
0000ac  e026              B        |L4.252|
                  |L4.174|
0000ae  eb040084          ADD      r0,r4,r4,LSL #2       ;318
0000b2  4953              LDR      r1,|L4.512|
0000b4  eb010080          ADD      r0,r1,r0,LSL #2       ;318
0000b8  7cc1              LDRB     r1,[r0,#0x13]         ;318
0000ba  9802              LDR      r0,[sp,#8]            ;318
0000bc  4281              CMP      r1,r0                 ;318
0000be  db1d              BLT      |L4.252|
0000c0  fa4ff984          SXTB     r9,r4                 ;319
0000c4  eb040084          ADD      r0,r4,r4,LSL #2       ;320
0000c8  494d              LDR      r1,|L4.512|
0000ca  eb010080          ADD      r0,r1,r0,LSL #2       ;320
0000ce  7cc0              LDRB     r0,[r0,#0x13]         ;320
0000d0  9002              STR      r0,[sp,#8]            ;320
0000d2  e013              B        |L4.252|
                  |L4.212|
0000d4  2d02              CMP      r5,#2                 ;324
0000d6  db11              BLT      |L4.252|
0000d8  eb040084          ADD      r0,r4,r4,LSL #2       ;331
0000dc  4948              LDR      r1,|L4.512|
0000de  eb010080          ADD      r0,r1,r0,LSL #2       ;331
0000e2  7cc1              LDRB     r1,[r0,#0x13]         ;331
0000e4  9801              LDR      r0,[sp,#4]            ;331
0000e6  4281              CMP      r1,r0                 ;331
0000e8  db08              BLT      |L4.252|
0000ea  fa4ffa84          SXTB     r10,r4                ;332
0000ee  eb040084          ADD      r0,r4,r4,LSL #2       ;333
0000f2  4943              LDR      r1,|L4.512|
0000f4  eb010080          ADD      r0,r1,r0,LSL #2       ;333
0000f8  7cc0              LDRB     r0,[r0,#0x13]         ;333
0000fa  9001              STR      r0,[sp,#4]            ;333
                  |L4.252|
0000fc  1c60              ADDS     r0,r4,#1              ;291
0000fe  b2c4              UXTB     r4,r0                 ;291
                  |L4.256|
000100  2c0a              CMP      r4,#0xa               ;291
000102  db8d              BLT      |L4.32|
000104  f0080002          AND      r0,r8,#2              ;342
000108  b920              CBNZ     r0,|L4.276|
00010a  2f0a              CMP      r7,#0xa               ;344
00010c  d107              BNE      |L4.286|
00010e  f0080001          AND      r0,r8,#1              ;344
000112  b920              CBNZ     r0,|L4.286|
                  |L4.276|
000114  bf00              NOP                            ;345
000116  bf00              NOP                            ;345
000118  f04f30ff          MOV      r0,#0xffffffff        ;346
00011c  e7ab              B        |L4.118|
                  |L4.286|
00011e  2f0a              CMP      r7,#0xa               ;359
000120  da02              BGE      |L4.296|
000122  b2fc              UXTB     r4,r7                 ;360
000124  bf00              NOP                            ;361
000126  e03a              B        |L4.414|
                  |L4.296|
000128  f1ba0f0a          CMP      r10,#0xa              ;364
00012c  da14              BGE      |L4.344|
00012e  f00a04ff          AND      r4,r10,#0xff          ;366
000132  bf00              NOP                            ;367
000134  bf00              NOP                            ;367
000136  bf00              NOP                            ;369
000138  eb040084          ADD      r0,r4,r4,LSL #2       ;369
00013c  4930              LDR      r1,|L4.512|
00013e  f8510020          LDR      r0,[r1,r0,LSL #2]     ;369
000142  b140              CBZ      r0,|L4.342|
000144  bf00              NOP                            ;369
000146  a32f              ADR      r3,|L4.516|
000148  f2401271          MOV      r2,#0x171             ;369
00014c  a152              ADR      r1,|L4.664|
00014e  a047              ADR      r0,|L4.620|
000150  f7fffffe          BL       __2printf
000154  bf00              NOP                            ;369
                  |L4.342|
000156  e012              B        |L4.382|
                  |L4.344|
000158  f1b90f0a          CMP      r9,#0xa               ;371
00015c  da03              BGE      |L4.358|
00015e  f00904ff          AND      r4,r9,#0xff           ;373
000162  bf00              NOP                            ;374
000164  e00b              B        |L4.382|
                  |L4.358|
000166  f1bb0f0a          CMP      r11,#0xa              ;376
00016a  da03              BGE      |L4.372|
00016c  f00b04ff          AND      r4,r11,#0xff          ;378
000170  bf00              NOP                            ;379
000172  e004              B        |L4.382|
                  |L4.372|
000174  bf00              NOP                            ;382
000176  bf00              NOP                            ;382
000178  f04f30ff          MOV      r0,#0xffffffff        ;383
00017c  e77b              B        |L4.118|
                  |L4.382|
00017e  bf00              NOP                            ;387
000180  2c0a              CMP      r4,#0xa               ;387
000182  db08              BLT      |L4.406|
000184  bf00              NOP                            ;387
000186  a31f              ADR      r3,|L4.516|
000188  f2401283          MOV      r2,#0x183             ;387
00018c  a148              ADR      r1,|L4.688|
00018e  a037              ADR      r0,|L4.620|
000190  f7fffffe          BL       __2printf
000194  bf00              NOP                            ;387
                  |L4.406|
000196  bf00              NOP                            ;387
000198  4620              MOV      r0,r4                 ;388
00019a  f7fffffe          BL       etharp_free_entry
                  |L4.414|
00019e  bf00              NOP                            ;391
0001a0  2c0a              CMP      r4,#0xa               ;391
0001a2  db08              BLT      |L4.438|
0001a4  bf00              NOP                            ;391
0001a6  a317              ADR      r3,|L4.516|
0001a8  f2401287          MOV      r2,#0x187             ;391
0001ac  a140              ADR      r1,|L4.688|
0001ae  a02f              ADR      r0,|L4.620|
0001b0  f7fffffe          BL       __2printf
0001b4  bf00              NOP                            ;391
                  |L4.438|
0001b6  bf00              NOP                            ;391
0001b8  bf00              NOP                            ;392
0001ba  eb040084          ADD      r0,r4,r4,LSL #2       ;392
0001be  4910              LDR      r1,|L4.512|
0001c0  eb010080          ADD      r0,r1,r0,LSL #2       ;392
0001c4  7c80              LDRB     r0,[r0,#0x12]         ;392
0001c6  b140              CBZ      r0,|L4.474|
0001c8  bf00              NOP                            ;392
0001ca  a30e              ADR      r3,|L4.516|
0001cc  f44f72c4          MOV      r2,#0x188             ;392
0001d0  a13c              ADR      r1,|L4.708|
0001d2  a026              ADR      r0,|L4.620|
0001d4  f7fffffe          BL       __2printf
0001d8  bf00              NOP                            ;392
                  |L4.474|
0001da  bf00              NOP                            ;392
0001dc  b136              CBZ      r6,|L4.492|
0001de  eb040184          ADD      r1,r4,r4,LSL #2       ;398
0001e2  4a07              LDR      r2,|L4.512|
0001e4  eb020181          ADD      r1,r2,r1,LSL #2       ;398
0001e8  6830              LDR      r0,[r6,#0]            ;398
0001ea  6048              STR      r0,[r1,#4]            ;398
                  |L4.492|
0001ec  2000              MOVS     r0,#0                 ;400
0001ee  eb040184          ADD      r1,r4,r4,LSL #2       ;400
0001f2  4a03              LDR      r2,|L4.512|
0001f4  eb020181          ADD      r1,r2,r1,LSL #2       ;400
0001f8  74c8              STRB     r0,[r1,#0x13]         ;400
0001fa  b260              SXTB     r0,r4                 ;401
0001fc  e73b              B        |L4.118|
;;;403    
                          ENDP

0001fe  0000              DCW      0x0000
                  |L4.512|
                          DCD      arp_table
                  |L4.516|
000204  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\netif\\etharp.c",0
000208  5749505c
00020c  6c776970
000210  2d312e34
000214  2e315c73
000218  72635c6e
00021c  65746966
000220  5c657468
000224  6172702e
000228  6300    
00022a  00                DCB      0
00022b  00                DCB      0
                  |L4.556|
00022c  73746174          DCB      "state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_"
000230  65203d3d
000234  20455448
000238  4152505f
00023c  53544154
000240  455f5045
000244  4e44494e
000248  47207c7c
00024c  20737461
000250  7465203e
000254  3d204554
000258  48415250
00025c  5f535441
000260  54455f  
000263  53544142          DCB      "STABLE",0
000267  4c4500  
00026a  00                DCB      0
00026b  00                DCB      0
                  |L4.620|
00026c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000270  7274696f
000274  6e202225
000278  73222066
00027c  61696c65
000280  64206174
000284  206c696e
000288  65202564
00028c  20696e20
000290  25730d0a
000294  00      
000295  00                DCB      0
000296  00                DCB      0
000297  00                DCB      0
                  |L4.664|
000298  6172705f          DCB      "arp_table[i].q == NULL",0
00029c  7461626c
0002a0  655b695d
0002a4  2e71203d
0002a8  3d204e55
0002ac  4c4c00  
0002af  00                DCB      0
                  |L4.688|
0002b0  69203c20          DCB      "i < ARP_TABLE_SIZE",0
0002b4  4152505f
0002b8  5441424c
0002bc  455f5349
0002c0  5a4500  
0002c3  00                DCB      0
                  |L4.708|
0002c4  6172705f          DCB      "arp_table[i].state == ETHARP_STATE_EMPTY",0
0002c8  7461626c
0002cc  655b695d
0002d0  2e737461
0002d4  7465203d
0002d8  3d204554
0002dc  48415250
0002e0  5f535441
0002e4  54455f45
0002e8  4d505459
0002ec  00      
0002ed  00                DCB      0
0002ee  00                DCB      0
0002ef  00                DCB      0

                          AREA ||i.etharp_free_entry||, CODE, READONLY, ALIGN=2

                  etharp_free_entry PROC
;;;176    static void
;;;177    etharp_free_entry(int i)
000000  b510              PUSH     {r4,lr}
;;;178    {
000002  4604              MOV      r4,r0
;;;179      /* remove from SNMP ARP index tree */
;;;180      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
;;;181      /* and empty packet queue */
;;;182      if (arp_table[i].q != NULL) {
000004  eb040084          ADD      r0,r4,r4,LSL #2
000008  4919              LDR      r1,|L5.112|
00000a  f8510020          LDR      r0,[r1,r0,LSL #2]
00000e  b170              CBZ      r0,|L5.46|
;;;183        /* remove all queued packets */
;;;184        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
000010  bf00              NOP      
000012  bf00              NOP      
;;;185        free_etharp_q(arp_table[i].q);
000014  eb040184          ADD      r1,r4,r4,LSL #2
000018  4a15              LDR      r2,|L5.112|
00001a  f8520021          LDR      r0,[r2,r1,LSL #2]
00001e  f7fffffe          BL       pbuf_free
;;;186        arp_table[i].q = NULL;
000022  2000              MOVS     r0,#0
000024  eb040184          ADD      r1,r4,r4,LSL #2
000028  4a11              LDR      r2,|L5.112|
00002a  f8420021          STR      r0,[r2,r1,LSL #2]
                  |L5.46|
;;;187      }
;;;188      /* recycle entry for re-use */
;;;189      arp_table[i].state = ETHARP_STATE_EMPTY;
00002e  2000              MOVS     r0,#0
000030  eb040184          ADD      r1,r4,r4,LSL #2
000034  4a0e              LDR      r2,|L5.112|
000036  eb020181          ADD      r1,r2,r1,LSL #2
00003a  7488              STRB     r0,[r1,#0x12]
;;;190    #ifdef LWIP_DEBUG
;;;191      /* for debugging, clean out the complete entry */
;;;192      arp_table[i].ctime = 0;
00003c  eb040184          ADD      r1,r4,r4,LSL #2
000040  eb020181          ADD      r1,r2,r1,LSL #2
000044  74c8              STRB     r0,[r1,#0x13]
;;;193      arp_table[i].netif = NULL;
000046  eb040184          ADD      r1,r4,r4,LSL #2
00004a  eb020181          ADD      r1,r2,r1,LSL #2
00004e  6088              STR      r0,[r1,#8]
;;;194      ip_addr_set_zero(&arp_table[i].ipaddr);
000050  eb040184          ADD      r1,r4,r4,LSL #2
000054  eb020181          ADD      r1,r2,r1,LSL #2
000058  6048              STR      r0,[r1,#4]
;;;195      arp_table[i].ethaddr = ethzero;
00005a  eb040084          ADD      r0,r4,r4,LSL #2
00005e  4611              MOV      r1,r2
000060  eb010080          ADD      r0,r1,r0,LSL #2
000064  4903              LDR      r1,|L5.116|
000066  680a              LDR      r2,[r1,#0]  ; ethzero
000068  60c2              STR      r2,[r0,#0xc]
00006a  8889              LDRH     r1,[r1,#4]  ; ethzero
00006c  8201              STRH     r1,[r0,#0x10]
;;;196    #endif /* LWIP_DEBUG */
;;;197    }
00006e  bd10              POP      {r4,pc}
;;;198    
                          ENDP

                  |L5.112|
                          DCD      arp_table
                  |L5.116|
                          DCD      ethzero

                          AREA ||i.etharp_output||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  etharp_output PROC
;;;878    err_t
;;;879    etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;880    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;881      struct eth_addr *dest;
;;;882      struct eth_addr mcastaddr;
;;;883      ip_addr_t *dst_addr = ipaddr;
00000a  46a9              MOV      r9,r5
;;;884    
;;;885      LWIP_ASSERT("netif != NULL", netif != NULL);
00000c  bf00              NOP      
00000e  b944              CBNZ     r4,|L6.34|
000010  bf00              NOP      
000012  a35a              ADR      r3,|L6.380|
000014  f2403275          MOV      r2,#0x375
000018  a162              ADR      r1,|L6.420|
00001a  a066              ADR      r0,|L6.436|
00001c  f7fffffe          BL       __2printf
000020  bf00              NOP      
                  |L6.34|
000022  bf00              NOP      
;;;886      LWIP_ASSERT("q != NULL", q != NULL);
000024  bf00              NOP      
000026  b947              CBNZ     r7,|L6.58|
000028  bf00              NOP      
00002a  a354              ADR      r3,|L6.380|
00002c  f2403276          MOV      r2,#0x376
000030  a16b              ADR      r1,|L6.480|
000032  a060              ADR      r0,|L6.436|
000034  f7fffffe          BL       __2printf
000038  bf00              NOP      
                  |L6.58|
00003a  bf00              NOP      
;;;887      LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
00003c  bf00              NOP      
00003e  b945              CBNZ     r5,|L6.82|
000040  bf00              NOP      
000042  a34e              ADR      r3,|L6.380|
000044  f2403277          MOV      r2,#0x377
000048  a168              ADR      r1,|L6.492|
00004a  a05a              ADR      r0,|L6.436|
00004c  f7fffffe          BL       __2printf
000050  bf00              NOP      
                  |L6.82|
000052  bf00              NOP      
;;;888    
;;;889      /* make room for Ethernet header - should not fail */
;;;890      if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
000054  210e              MOVS     r1,#0xe
000056  4638              MOV      r0,r7
000058  f7fffffe          BL       pbuf_header
00005c  b128              CBZ      r0,|L6.106|
;;;891        /* bail out */
;;;892        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
00005e  bf00              NOP      
000060  bf00              NOP      
;;;893          ("etharp_output: could not allocate room for header.\n"));
;;;894        LINK_STATS_INC(link.lenerr);
;;;895        return ERR_BUF;
000062  f06f0001          MVN      r0,#1
                  |L6.102|
;;;896      }
;;;897    
;;;898      /* Determine on destination hardware address. Broadcasts and multicasts
;;;899       * are special, other IP addresses are looked up in the ARP table. */
;;;900    
;;;901      /* broadcast destination IP address? */
;;;902      if (ip_addr_isbroadcast(ipaddr, netif)) {
;;;903        /* broadcast on Ethernet also */
;;;904        dest = (struct eth_addr *)&ethbroadcast;
;;;905      /* multicast destination IP address? */
;;;906      } else if (ip_addr_ismulticast(ipaddr)) {
;;;907        /* Hash IP multicast address to MAC address.*/
;;;908        mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
;;;909        mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
;;;910        mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
;;;911        mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
;;;912        mcastaddr.addr[4] = ip4_addr3(ipaddr);
;;;913        mcastaddr.addr[5] = ip4_addr4(ipaddr);
;;;914        /* destination Ethernet address is multicast */
;;;915        dest = &mcastaddr;
;;;916      /* unicast destination IP address? */
;;;917      } else {
;;;918        s8_t i;
;;;919        /* outside local network? if so, this can neither be a global broadcast nor
;;;920           a subnet broadcast. */
;;;921        if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
;;;922            !ip_addr_islinklocal(ipaddr)) {
;;;923    #if LWIP_AUTOIP
;;;924          struct ip_hdr *iphdr = (struct ip_hdr*)((u8_t*)q->payload +
;;;925            sizeof(struct eth_hdr));
;;;926          /* According to RFC 3297, chapter 2.6.2 (Forwarding Rules), a packet with
;;;927             a link-local source address must always be "directly to its destination
;;;928             on the same physical link. The host MUST NOT send the packet to any
;;;929             router for forwarding". */
;;;930          if (!ip_addr_islinklocal(&iphdr->src))
;;;931    #endif /* LWIP_AUTOIP */
;;;932          {
;;;933            /* interface has default gateway? */
;;;934            if (!ip_addr_isany(&netif->gw)) {
;;;935              /* send to hardware address of default gateway IP address */
;;;936              dst_addr = &(netif->gw);
;;;937            /* no default gateway available */
;;;938            } else {
;;;939              /* no route to destination error (default gateway missing) */
;;;940              return ERR_RTE;
;;;941            }
;;;942          }
;;;943        }
;;;944    #if LWIP_NETIF_HWADDRHINT
;;;945        if (netif->addr_hint != NULL) {
;;;946          /* per-pcb cached entry was given */
;;;947          u8_t etharp_cached_entry = *(netif->addr_hint);
;;;948          if (etharp_cached_entry < ARP_TABLE_SIZE) {
;;;949    #endif /* LWIP_NETIF_HWADDRHINT */
;;;950            if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
;;;951                (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
;;;952              /* the per-pcb-cached entry is stable and the right one! */
;;;953              ETHARP_STATS_INC(etharp.cachehit);
;;;954              return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
;;;955            }
;;;956    #if LWIP_NETIF_HWADDRHINT
;;;957          }
;;;958        }
;;;959    #endif /* LWIP_NETIF_HWADDRHINT */
;;;960    
;;;961        /* find stable entry: do this here since this is a critical path for
;;;962           throughput and etharp_find_entry() is kind of slow */
;;;963        for (i = 0; i < ARP_TABLE_SIZE; i++) {
;;;964          if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
;;;965              (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
;;;966            /* found an existing, stable entry */
;;;967            ETHARP_SET_HINT(netif, i);
;;;968            return etharp_output_to_arp_index(netif, q, i);
;;;969          }
;;;970        }
;;;971        /* no stable entry found, use the (slower) query function:
;;;972           queue on destination Ethernet address belonging to ipaddr */
;;;973        return etharp_query(netif, dst_addr, q);
;;;974      }
;;;975    
;;;976      /* continuation for multicast/broadcast destinations */
;;;977      /* obtain source Ethernet address of the given interface */
;;;978      /* send packet directly on the link */
;;;979      return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
;;;980    }
000066  e8bd87fc          POP      {r2-r10,pc}
                  |L6.106|
00006a  4621              MOV      r1,r4                 ;902
00006c  6828              LDR      r0,[r5,#0]            ;902
00006e  f7fffffe          BL       ip4_addr_isbroadcast
000072  b110              CBZ      r0,|L6.122|
000074  f8df8184          LDR      r8,|L6.508|
000078  e077              B        |L6.362|
                  |L6.122|
00007a  7828              LDRB     r0,[r5,#0]            ;906
00007c  f00000f0          AND      r0,r0,#0xf0           ;906
000080  28e0              CMP      r0,#0xe0              ;906
000082  d115              BNE      |L6.176|
000084  2001              MOVS     r0,#1                 ;908
000086  f88d0000          STRB     r0,[sp,#0]            ;908
00008a  2000              MOVS     r0,#0                 ;909
00008c  f88d0001          STRB     r0,[sp,#1]            ;909
000090  205e              MOVS     r0,#0x5e              ;910
000092  f88d0002          STRB     r0,[sp,#2]            ;910
000096  7868              LDRB     r0,[r5,#1]            ;911
000098  f000007f          AND      r0,r0,#0x7f           ;911
00009c  f88d0003          STRB     r0,[sp,#3]            ;911
0000a0  78a8              LDRB     r0,[r5,#2]            ;912
0000a2  f88d0004          STRB     r0,[sp,#4]            ;912
0000a6  78e8              LDRB     r0,[r5,#3]            ;913
0000a8  f88d0005          STRB     r0,[sp,#5]            ;913
0000ac  46e8              MOV      r8,sp                 ;915
0000ae  e05b              B        |L6.360|
                  |L6.176|
0000b0  6828              LDR      r0,[r5,#0]            ;921
0000b2  68a1              LDR      r1,[r4,#8]            ;921
0000b4  4008              ANDS     r0,r0,r1              ;921
0000b6  e9d41201          LDRD     r1,r2,[r4,#4]         ;921
0000ba  4011              ANDS     r1,r1,r2              ;921
0000bc  4288              CMP      r0,r1                 ;921
0000be  d010              BEQ      |L6.226|
0000c0  8828              LDRH     r0,[r5,#0]            ;922
0000c2  b280              UXTH     r0,r0                 ;922
0000c4  f64f61a9          MOV      r1,#0xfea9            ;922
0000c8  4288              CMP      r0,r1                 ;922
0000ca  d00a              BEQ      |L6.226|
0000cc  f104000c          ADD      r0,r4,#0xc            ;934
0000d0  b120              CBZ      r0,|L6.220|
0000d2  68e0              LDR      r0,[r4,#0xc]          ;934
0000d4  b110              CBZ      r0,|L6.220|
0000d6  f104090c          ADD      r9,r4,#0xc            ;936
0000da  e002              B        |L6.226|
                  |L6.220|
0000dc  f06f0003          MVN      r0,#3                 ;940
0000e0  e7c1              B        |L6.102|
                  |L6.226|
0000e2  4847              LDR      r0,|L6.512|
0000e4  7800              LDRB     r0,[r0,#0]            ;950  ; etharp_cached_entry
0000e6  eb000080          ADD      r0,r0,r0,LSL #2       ;950
0000ea  4946              LDR      r1,|L6.516|
0000ec  eb010080          ADD      r0,r1,r0,LSL #2       ;950
0000f0  7c80              LDRB     r0,[r0,#0x12]         ;950
0000f2  2802              CMP      r0,#2                 ;950
0000f4  db12              BLT      |L6.284|
0000f6  4942              LDR      r1,|L6.512|
0000f8  7809              LDRB     r1,[r1,#0]            ;951  ; etharp_cached_entry
0000fa  eb010181          ADD      r1,r1,r1,LSL #2       ;951
0000fe  4a41              LDR      r2,|L6.516|
000100  eb020181          ADD      r1,r2,r1,LSL #2       ;951
000104  f8d90000          LDR      r0,[r9,#0]            ;951
000108  6849              LDR      r1,[r1,#4]            ;951
00010a  4288              CMP      r0,r1                 ;951
00010c  d106              BNE      |L6.284|
00010e  483c              LDR      r0,|L6.512|
000110  7802              LDRB     r2,[r0,#0]            ;954  ; etharp_cached_entry
000112  4639              MOV      r1,r7                 ;954
000114  4620              MOV      r0,r4                 ;954
000116  f7fffffe          BL       etharp_output_to_arp_index
00011a  e7a4              B        |L6.102|
                  |L6.284|
00011c  2600              MOVS     r6,#0                 ;963
00011e  e01b              B        |L6.344|
                  |L6.288|
000120  eb060086          ADD      r0,r6,r6,LSL #2       ;964
000124  4937              LDR      r1,|L6.516|
000126  eb010080          ADD      r0,r1,r0,LSL #2       ;964
00012a  7c80              LDRB     r0,[r0,#0x12]         ;964
00012c  2802              CMP      r0,#2                 ;964
00012e  db11              BLT      |L6.340|
000130  eb060186          ADD      r1,r6,r6,LSL #2       ;965
000134  4a33              LDR      r2,|L6.516|
000136  eb020181          ADD      r1,r2,r1,LSL #2       ;965
00013a  f8d90000          LDR      r0,[r9,#0]            ;965
00013e  6849              LDR      r1,[r1,#4]            ;965
000140  4288              CMP      r0,r1                 ;965
000142  d107              BNE      |L6.340|
000144  492e              LDR      r1,|L6.512|
000146  700e              STRB     r6,[r1,#0]            ;967
000148  b2f2              UXTB     r2,r6                 ;968
00014a  4639              MOV      r1,r7                 ;968
00014c  4620              MOV      r0,r4                 ;968
00014e  f7fffffe          BL       etharp_output_to_arp_index
000152  e788              B        |L6.102|
                  |L6.340|
000154  1c70              ADDS     r0,r6,#1              ;963
000156  b246              SXTB     r6,r0                 ;963
                  |L6.344|
000158  2e0a              CMP      r6,#0xa               ;963
00015a  dbe1              BLT      |L6.288|
00015c  463a              MOV      r2,r7                 ;973
00015e  4649              MOV      r1,r9                 ;973
000160  4620              MOV      r0,r4                 ;973
000162  f7fffffe          BL       etharp_query
000166  e77e              B        |L6.102|
                  |L6.360|
000168  bf00              NOP                            ;974
                  |L6.362|
00016a  4643              MOV      r3,r8                 ;979
00016c  f1040227          ADD      r2,r4,#0x27           ;979
000170  4639              MOV      r1,r7                 ;979
000172  4620              MOV      r0,r4                 ;979
000174  f7fffffe          BL       etharp_send_ip
000178  e775              B        |L6.102|
;;;981    
                          ENDP

00017a  0000              DCW      0x0000
                  |L6.380|
00017c  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\netif\\etharp.c",0
000180  5749505c
000184  6c776970
000188  2d312e34
00018c  2e315c73
000190  72635c6e
000194  65746966
000198  5c657468
00019c  6172702e
0001a0  6300    
0001a2  00                DCB      0
0001a3  00                DCB      0
                  |L6.420|
0001a4  6e657469          DCB      "netif != NULL",0
0001a8  6620213d
0001ac  204e554c
0001b0  4c00    
0001b2  00                DCB      0
0001b3  00                DCB      0
                  |L6.436|
0001b4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0001b8  7274696f
0001bc  6e202225
0001c0  73222066
0001c4  61696c65
0001c8  64206174
0001cc  206c696e
0001d0  65202564
0001d4  20696e20
0001d8  25730d0a
0001dc  00      
0001dd  00                DCB      0
0001de  00                DCB      0
0001df  00                DCB      0
                  |L6.480|
0001e0  7120213d          DCB      "q != NULL",0
0001e4  204e554c
0001e8  4c00    
0001ea  00                DCB      0
0001eb  00                DCB      0
                  |L6.492|
0001ec  69706164          DCB      "ipaddr != NULL",0
0001f0  64722021
0001f4  3d204e55
0001f8  4c4c00  
0001fb  00                DCB      0
                  |L6.508|
                          DCD      ethbroadcast
                  |L6.512|
                          DCD      etharp_cached_entry
                  |L6.516|
                          DCD      arp_table

                          AREA ||i.etharp_output_to_arp_index||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  etharp_output_to_arp_index PROC
;;;841    static err_t
;;;842    etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
000000  b570              PUSH     {r4-r6,lr}
;;;843    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;844      LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
000008  bf00              NOP      
00000a  eb040084          ADD      r0,r4,r4,LSL #2
00000e  491f              LDR      r1,|L7.140|
000010  eb010080          ADD      r0,r1,r0,LSL #2
000014  7c80              LDRB     r0,[r0,#0x12]
000016  2802              CMP      r0,#2
000018  da08              BGE      |L7.44|
00001a  bf00              NOP      
00001c  a31c              ADR      r3,|L7.144|
00001e  f44f7253          MOV      r2,#0x34c
000022  a125              ADR      r1,|L7.184|
000024  a030              ADR      r0,|L7.232|
000026  f7fffffe          BL       __2printf
00002a  bf00              NOP      
                  |L7.44|
00002c  bf00              NOP      
;;;845                  arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
;;;846      /* if arp table entry is about to expire: re-request it,
;;;847         but only if its state is ETHARP_STATE_STABLE to prevent flooding the
;;;848         network with ARP requests if this address is used frequently. */
;;;849      if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
00002e  eb040084          ADD      r0,r4,r4,LSL #2
000032  4916              LDR      r1,|L7.140|
000034  eb010080          ADD      r0,r1,r0,LSL #2
000038  7c80              LDRB     r0,[r0,#0x12]
00003a  2802              CMP      r0,#2
00003c  d117              BNE      |L7.110|
;;;850          (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
00003e  eb040084          ADD      r0,r4,r4,LSL #2
000042  eb010080          ADD      r0,r1,r0,LSL #2
000046  7cc0              LDRB     r0,[r0,#0x13]
000048  28e4              CMP      r0,#0xe4
00004a  db10              BLT      |L7.110|
;;;851        if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
00004c  eb040084          ADD      r0,r4,r4,LSL #2
000050  460a              MOV      r2,r1
000052  eb020080          ADD      r0,r2,r0,LSL #2
000056  1d01              ADDS     r1,r0,#4
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       etharp_request
00005e  b930              CBNZ     r0,|L7.110|
;;;852          arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
000060  2003              MOVS     r0,#3
000062  eb040184          ADD      r1,r4,r4,LSL #2
000066  4a09              LDR      r2,|L7.140|
000068  eb020181          ADD      r1,r2,r1,LSL #2
00006c  7488              STRB     r0,[r1,#0x12]
                  |L7.110|
;;;853        }
;;;854      }
;;;855      
;;;856      return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
00006e  eb040084          ADD      r0,r4,r4,LSL #2
000072  4906              LDR      r1,|L7.140|
000074  eb010080          ADD      r0,r1,r0,LSL #2
000078  f100030c          ADD      r3,r0,#0xc
00007c  f1050227          ADD      r2,r5,#0x27
000080  4631              MOV      r1,r6
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       etharp_send_ip
;;;857        &arp_table[arp_idx].ethaddr);
;;;858    }
000088  bd70              POP      {r4-r6,pc}
;;;859    
                          ENDP

00008a  0000              DCW      0x0000
                  |L7.140|
                          DCD      arp_table
                  |L7.144|
000090  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\netif\\etharp.c",0
000094  5749505c
000098  6c776970
00009c  2d312e34
0000a0  2e315c73
0000a4  72635c6e
0000a8  65746966
0000ac  5c657468
0000b0  6172702e
0000b4  6300    
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L7.184|
0000b8  6172705f          DCB      "arp_table[arp_idx].state >= ETHARP_STATE_STABLE",0
0000bc  7461626c
0000c0  655b6172
0000c4  705f6964
0000c8  785d2e73
0000cc  74617465
0000d0  203e3d20
0000d4  45544841
0000d8  52505f53
0000dc  54415445
0000e0  5f535441
0000e4  424c4500
                  |L7.232|
0000e8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000ec  7274696f
0000f0  6e202225
0000f4  73222066
0000f8  61696c65
0000fc  64206174
000100  206c696e
000104  65202564
000108  20696e20
00010c  25730d0a
000110  00      
000111  00                DCB      0
000112  00                DCB      0
000113  00                DCB      0

                          AREA ||i.etharp_query||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  etharp_query PROC
;;;1015   err_t
;;;1016   etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1017   {
000004  4680              MOV      r8,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;1018     struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
00000a  f1080927          ADD      r9,r8,#0x27
;;;1019     err_t result = ERR_MEM;
00000e  f04f3aff          MOV      r10,#0xffffffff
;;;1020     s8_t i; /* ARP entry index */
;;;1021   
;;;1022     /* non-unicast address? */
;;;1023     if (ip_addr_isbroadcast(ipaddr, netif) ||
000012  4641              MOV      r1,r8
000014  6838              LDR      r0,[r7,#0]
000016  f7fffffe          BL       ip4_addr_isbroadcast
00001a  b938              CBNZ     r0,|L8.44|
;;;1024         ip_addr_ismulticast(ipaddr) ||
00001c  7838              LDRB     r0,[r7,#0]
00001e  f00000f0          AND      r0,r0,#0xf0
000022  28e0              CMP      r0,#0xe0
000024  d002              BEQ      |L8.44|
;;;1025         ip_addr_isany(ipaddr)) {
000026  b10f              CBZ      r7,|L8.44|
000028  6838              LDR      r0,[r7,#0]
00002a  b928              CBNZ     r0,|L8.56|
                  |L8.44|
;;;1026       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
00002c  bf00              NOP      
00002e  bf00              NOP      
;;;1027       return ERR_ARG;
000030  f06f000d          MVN      r0,#0xd
                  |L8.52|
;;;1028     }
;;;1029   
;;;1030     /* find entry in ARP cache, ask to create entry if queueing packet */
;;;1031     i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
;;;1032   
;;;1033     /* could not find or create entry? */
;;;1034     if (i < 0) {
;;;1035       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
;;;1036       if (q) {
;;;1037         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
;;;1038         ETHARP_STATS_INC(etharp.memerr);
;;;1039       }
;;;1040       return (err_t)i;
;;;1041     }
;;;1042   
;;;1043     /* mark a fresh entry as pending (we just sent a request) */
;;;1044     if (arp_table[i].state == ETHARP_STATE_EMPTY) {
;;;1045       arp_table[i].state = ETHARP_STATE_PENDING;
;;;1046     }
;;;1047   
;;;1048     /* { i is either a STABLE or (new or existing) PENDING entry } */
;;;1049     LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
;;;1050     ((arp_table[i].state == ETHARP_STATE_PENDING) ||
;;;1051      (arp_table[i].state >= ETHARP_STATE_STABLE)));
;;;1052   
;;;1053     /* do we have a pending entry? or an implicit query request? */
;;;1054     if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
;;;1055       /* try to resolve it; send out ARP request */
;;;1056       result = etharp_request(netif, ipaddr);
;;;1057       if (result != ERR_OK) {
;;;1058         /* ARP request couldn't be sent */
;;;1059         /* We don't re-send arp request in etharp_tmr, but we still queue packets,
;;;1060            since this failure could be temporary, and the next packet calling
;;;1061            etharp_query again could lead to sending the queued packets. */
;;;1062       }
;;;1063       if (q == NULL) {
;;;1064         return result;
;;;1065       }
;;;1066     }
;;;1067   
;;;1068     /* packet given? */
;;;1069     LWIP_ASSERT("q != NULL", q != NULL);
;;;1070     /* stable entry? */
;;;1071     if (arp_table[i].state >= ETHARP_STATE_STABLE) {
;;;1072       /* we have a valid IP->Ethernet address mapping */
;;;1073       ETHARP_SET_HINT(netif, i);
;;;1074       /* send the packet */
;;;1075       result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
;;;1076     /* pending entry? (either just created or already pending */
;;;1077     } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;1078       /* entry is still pending, queue the given packet 'q' */
;;;1079       struct pbuf *p;
;;;1080       int copy_needed = 0;
;;;1081       /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
;;;1082        * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
;;;1083        * PBUF_ROMs can be left as they are, since ROM must not get changed. */
;;;1084       p = q;
;;;1085       while (p) {
;;;1086         LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
;;;1087         if(p->type != PBUF_ROM) {
;;;1088           copy_needed = 1;
;;;1089           break;
;;;1090         }
;;;1091         p = p->next;
;;;1092       }
;;;1093       if(copy_needed) {
;;;1094         /* copy the whole packet into new pbufs */
;;;1095         p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
;;;1096         if(p != NULL) {
;;;1097           if (pbuf_copy(p, q) != ERR_OK) {
;;;1098             pbuf_free(p);
;;;1099             p = NULL;
;;;1100           }
;;;1101         }
;;;1102       } else {
;;;1103         /* referencing the old pbuf is enough */
;;;1104         p = q;
;;;1105         pbuf_ref(p);
;;;1106       }
;;;1107       /* packet could be taken over? */
;;;1108       if (p != NULL) {
;;;1109         /* queue packet ... */
;;;1110   #if ARP_QUEUEING
;;;1111         struct etharp_q_entry *new_entry;
;;;1112         /* allocate a new arp queue entry */
;;;1113         new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
;;;1114         if (new_entry != NULL) {
;;;1115           new_entry->next = 0;
;;;1116           new_entry->p = p;
;;;1117           if(arp_table[i].q != NULL) {
;;;1118             /* queue was already existent, append the new entry to the end */
;;;1119             struct etharp_q_entry *r;
;;;1120             r = arp_table[i].q;
;;;1121             while (r->next != NULL) {
;;;1122               r = r->next;
;;;1123             }
;;;1124             r->next = new_entry;
;;;1125           } else {
;;;1126             /* queue did not exist, first item in queue */
;;;1127             arp_table[i].q = new_entry;
;;;1128           }
;;;1129           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1130           result = ERR_OK;
;;;1131         } else {
;;;1132           /* the pool MEMP_ARP_QUEUE is empty */
;;;1133           pbuf_free(p);
;;;1134           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
;;;1135           result = ERR_MEM;
;;;1136         }
;;;1137   #else /* ARP_QUEUEING */
;;;1138         /* always queue one packet per ARP request only, freeing a previously queued packet */
;;;1139         if (arp_table[i].q != NULL) {
;;;1140           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet %p for ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1141           pbuf_free(arp_table[i].q);
;;;1142         }
;;;1143         arp_table[i].q = p;
;;;1144         result = ERR_OK;
;;;1145         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1146   #endif /* ARP_QUEUEING */
;;;1147       } else {
;;;1148         ETHARP_STATS_INC(etharp.memerr);
;;;1149         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
;;;1150         result = ERR_MEM;
;;;1151       }
;;;1152     }
;;;1153     return result;
;;;1154   }
000034  e8bd9ff0          POP      {r4-r12,pc}
                  |L8.56|
000038  2101              MOVS     r1,#1                 ;1031
00003a  4638              MOV      r0,r7                 ;1031
00003c  f7fffffe          BL       etharp_find_entry
000040  4604              MOV      r4,r0                 ;1031
000042  2c00              CMP      r4,#0                 ;1034
000044  da06              BGE      |L8.84|
000046  bf00              NOP                            ;1035
000048  bf00              NOP                            ;1035
00004a  b10e              CBZ      r6,|L8.80|
00004c  bf00              NOP                            ;1037
00004e  bf00              NOP                            ;1037
                  |L8.80|
000050  4620              MOV      r0,r4                 ;1040
000052  e7ef              B        |L8.52|
                  |L8.84|
000054  eb040084          ADD      r0,r4,r4,LSL #2       ;1044
000058  495c              LDR      r1,|L8.460|
00005a  eb010080          ADD      r0,r1,r0,LSL #2       ;1044
00005e  7c80              LDRB     r0,[r0,#0x12]         ;1044
000060  b930              CBNZ     r0,|L8.112|
000062  2001              MOVS     r0,#1                 ;1045
000064  eb040184          ADD      r1,r4,r4,LSL #2       ;1045
000068  4a58              LDR      r2,|L8.460|
00006a  eb020181          ADD      r1,r2,r1,LSL #2       ;1045
00006e  7488              STRB     r0,[r1,#0x12]         ;1045
                  |L8.112|
000070  bf00              NOP                            ;1049
000072  eb040084          ADD      r0,r4,r4,LSL #2       ;1049
000076  4955              LDR      r1,|L8.460|
000078  eb010080          ADD      r0,r1,r0,LSL #2       ;1049
00007c  7c80              LDRB     r0,[r0,#0x12]         ;1049
00007e  2801              CMP      r0,#1                 ;1049
000080  d00f              BEQ      |L8.162|
000082  eb040084          ADD      r0,r4,r4,LSL #2       ;1049
000086  eb010080          ADD      r0,r1,r0,LSL #2       ;1049
00008a  7c80              LDRB     r0,[r0,#0x12]         ;1049
00008c  2802              CMP      r0,#2                 ;1049
00008e  da08              BGE      |L8.162|
000090  bf00              NOP                            ;1049
000092  a34f              ADR      r3,|L8.464|
000094  f2404219          MOV      r2,#0x419             ;1049
000098  a157              ADR      r1,|L8.504|
00009a  a061              ADR      r0,|L8.544|
00009c  f7fffffe          BL       __2printf
0000a0  bf00              NOP                            ;1049
                  |L8.162|
0000a2  bf00              NOP                            ;1049
0000a4  eb040084          ADD      r0,r4,r4,LSL #2       ;1054
0000a8  4948              LDR      r1,|L8.460|
0000aa  eb010080          ADD      r0,r1,r0,LSL #2       ;1054
0000ae  7c80              LDRB     r0,[r0,#0x12]         ;1054
0000b0  2801              CMP      r0,#1                 ;1054
0000b2  d000              BEQ      |L8.182|
0000b4  b93e              CBNZ     r6,|L8.198|
                  |L8.182|
0000b6  4639              MOV      r1,r7                 ;1056
0000b8  4640              MOV      r0,r8                 ;1056
0000ba  f7fffffe          BL       etharp_request
0000be  4682              MOV      r10,r0                ;1056
0000c0  b90e              CBNZ     r6,|L8.198|
0000c2  4650              MOV      r0,r10                ;1064
0000c4  e7b6              B        |L8.52|
                  |L8.198|
0000c6  bf00              NOP                            ;1069
0000c8  b946              CBNZ     r6,|L8.220|
0000ca  bf00              NOP                            ;1069
0000cc  a340              ADR      r3,|L8.464|
0000ce  f240422d          MOV      r2,#0x42d             ;1069
0000d2  a15e              ADR      r1,|L8.588|
0000d4  a052              ADR      r0,|L8.544|
0000d6  f7fffffe          BL       __2printf
0000da  bf00              NOP                            ;1069
                  |L8.220|
0000dc  bf00              NOP                            ;1069
0000de  eb040084          ADD      r0,r4,r4,LSL #2       ;1071
0000e2  493a              LDR      r1,|L8.460|
0000e4  eb010080          ADD      r0,r1,r0,LSL #2       ;1071
0000e8  7c80              LDRB     r0,[r0,#0x12]         ;1071
0000ea  2802              CMP      r0,#2                 ;1071
0000ec  db0f              BLT      |L8.270|
0000ee  495a              LDR      r1,|L8.600|
0000f0  700c              STRB     r4,[r1,#0]            ;1073
0000f2  eb040084          ADD      r0,r4,r4,LSL #2       ;1075
0000f6  4935              LDR      r1,|L8.460|
0000f8  eb010080          ADD      r0,r1,r0,LSL #2       ;1075
0000fc  f100030c          ADD      r3,r0,#0xc            ;1075
000100  464a              MOV      r2,r9                 ;1075
000102  4631              MOV      r1,r6                 ;1075
000104  4640              MOV      r0,r8                 ;1075
000106  f7fffffe          BL       etharp_send_ip
00010a  4682              MOV      r10,r0                ;1075
00010c  e05c              B        |L8.456|
                  |L8.270|
00010e  eb040084          ADD      r0,r4,r4,LSL #2       ;1077
000112  492e              LDR      r1,|L8.460|
000114  eb010080          ADD      r0,r1,r0,LSL #2       ;1077
000118  7c80              LDRB     r0,[r0,#0x12]         ;1077
00011a  2801              CMP      r0,#1                 ;1077
00011c  d154              BNE      |L8.456|
00011e  f04f0b00          MOV      r11,#0                ;1080
000122  4635              MOV      r5,r6                 ;1084
000124  e017              B        |L8.342|
                  |L8.294|
000126  bf00              NOP                            ;1086
000128  8968              LDRH     r0,[r5,#0xa]          ;1086
00012a  8929              LDRH     r1,[r5,#8]            ;1086
00012c  4288              CMP      r0,r1                 ;1086
00012e  d10a              BNE      |L8.326|
000130  6828              LDR      r0,[r5,#0]            ;1086
000132  b140              CBZ      r0,|L8.326|
000134  bf00              NOP                            ;1086
000136  a326              ADR      r3,|L8.464|
000138  f240423e          MOV      r2,#0x43e             ;1086
00013c  a147              ADR      r1,|L8.604|
00013e  a038              ADR      r0,|L8.544|
000140  f7fffffe          BL       __2printf
000144  bf00              NOP                            ;1086
                  |L8.326|
000146  bf00              NOP                            ;1086
000148  7b28              LDRB     r0,[r5,#0xc]          ;1087
00014a  2801              CMP      r0,#1                 ;1087
00014c  d002              BEQ      |L8.340|
00014e  f04f0b01          MOV      r11,#1                ;1088
000152  e002              B        |L8.346|
                  |L8.340|
000154  682d              LDR      r5,[r5,#0]            ;1091
                  |L8.342|
000156  2d00              CMP      r5,#0                 ;1085
000158  d1e5              BNE      |L8.294|
                  |L8.346|
00015a  bf00              NOP                            ;1089
00015c  f1bb0f00          CMP      r11,#0                ;1093
000160  d010              BEQ      |L8.388|
000162  8929              LDRH     r1,[r5,#8]            ;1095
000164  2200              MOVS     r2,#0                 ;1095
000166  2003              MOVS     r0,#3                 ;1095
000168  f7fffffe          BL       pbuf_alloc
00016c  4605              MOV      r5,r0                 ;1095
00016e  b16d              CBZ      r5,|L8.396|
000170  4631              MOV      r1,r6                 ;1097
000172  4628              MOV      r0,r5                 ;1097
000174  f7fffffe          BL       pbuf_copy
000178  b140              CBZ      r0,|L8.396|
00017a  4628              MOV      r0,r5                 ;1098
00017c  f7fffffe          BL       pbuf_free
000180  2500              MOVS     r5,#0                 ;1099
000182  e003              B        |L8.396|
                  |L8.388|
000184  4635              MOV      r5,r6                 ;1104
000186  4628              MOV      r0,r5                 ;1105
000188  f7fffffe          BL       pbuf_ref
                  |L8.396|
00018c  b1bd              CBZ      r5,|L8.446|
00018e  eb040084          ADD      r0,r4,r4,LSL #2       ;1139
000192  490e              LDR      r1,|L8.460|
000194  f8510020          LDR      r0,[r1,r0,LSL #2]     ;1139
000198  b140              CBZ      r0,|L8.428|
00019a  bf00              NOP                            ;1140
00019c  bf00              NOP                            ;1140
00019e  eb040184          ADD      r1,r4,r4,LSL #2       ;1141
0001a2  4a0a              LDR      r2,|L8.460|
0001a4  f8520021          LDR      r0,[r2,r1,LSL #2]     ;1141
0001a8  f7fffffe          BL       pbuf_free
                  |L8.428|
0001ac  eb040084          ADD      r0,r4,r4,LSL #2       ;1143
0001b0  4906              LDR      r1,|L8.460|
0001b2  f8415020          STR      r5,[r1,r0,LSL #2]     ;1143
0001b6  f04f0a00          MOV      r10,#0                ;1144
0001ba  bf00              NOP                            ;1145
0001bc  e003              B        |L8.454|
                  |L8.446|
0001be  bf00              NOP                            ;1149
0001c0  bf00              NOP                            ;1149
0001c2  f04f3aff          MOV      r10,#0xffffffff       ;1150
                  |L8.454|
0001c6  bf00              NOP                            ;1152
                  |L8.456|
0001c8  4650              MOV      r0,r10                ;1153
0001ca  e733              B        |L8.52|
;;;1155   
                          ENDP

                  |L8.460|
                          DCD      arp_table
                  |L8.464|
0001d0  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\netif\\etharp.c",0
0001d4  5749505c
0001d8  6c776970
0001dc  2d312e34
0001e0  2e315c73
0001e4  72635c6e
0001e8  65746966
0001ec  5c657468
0001f0  6172702e
0001f4  6300    
0001f6  00                DCB      0
0001f7  00                DCB      0
                  |L8.504|
0001f8  6172705f          DCB      "arp_table[i].state == PENDING or STABLE",0
0001fc  7461626c
000200  655b695d
000204  2e737461
000208  7465203d
00020c  3d205045
000210  4e44494e
000214  47206f72
000218  20535441
00021c  424c4500
                  |L8.544|
000220  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000224  7274696f
000228  6e202225
00022c  73222066
000230  61696c65
000234  64206174
000238  206c696e
00023c  65202564
000240  20696e20
000244  25730d0a
000248  00      
000249  00                DCB      0
00024a  00                DCB      0
00024b  00                DCB      0
                  |L8.588|
00024c  7120213d          DCB      "q != NULL",0
000250  204e554c
000254  4c00    
000256  00                DCB      0
000257  00                DCB      0
                  |L8.600|
                          DCD      etharp_cached_entry
                  |L8.604|
00025c  6e6f2070          DCB      "no packet queues allowed!",0
000260  61636b65
000264  74207175
000268  65756573
00026c  20616c6c
000270  6f776564
000274  2100    
000276  00                DCB      0
000277  00                DCB      0

                          AREA ||i.etharp_raw||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  etharp_raw PROC
;;;1174   err_t
;;;1175   etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1176              const struct eth_addr *ethdst_addr,
;;;1177              const struct eth_addr *hwsrc_addr, const ip_addr_t *ipsrc_addr,
;;;1178              const struct eth_addr *hwdst_addr, const ip_addr_t *ipdst_addr,
;;;1179              const u16_t opcode)
;;;1180   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  469a              MOV      r10,r3
00000c  f8ddb028          LDR      r11,[sp,#0x28]
;;;1181     struct pbuf *p;
;;;1182     err_t result = ERR_OK;
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
;;;1183     struct eth_hdr *ethhdr;
;;;1184     struct etharp_hdr *hdr;
;;;1185   #if LWIP_AUTOIP
;;;1186     const u8_t * ethdst_hwaddr;
;;;1187   #endif /* LWIP_AUTOIP */
;;;1188   
;;;1189     LWIP_ASSERT("netif != NULL", netif != NULL);
000014  bf00              NOP      
000016  b947              CBNZ     r7,|L9.42|
000018  bf00              NOP      
00001a  a339              ADR      r3,|L9.256|
00001c  f24042a5          MOV      r2,#0x4a5
000020  a141              ADR      r1,|L9.296|
000022  a045              ADR      r0,|L9.312|
000024  f7fffffe          BL       __2printf
000028  bf00              NOP      
                  |L9.42|
00002a  bf00              NOP      
;;;1190   
;;;1191     /* allocate a pbuf for the outgoing ARP request packet */
;;;1192     p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
00002c  2200              MOVS     r2,#0
00002e  212a              MOVS     r1,#0x2a
000030  2003              MOVS     r0,#3
000032  f7fffffe          BL       pbuf_alloc
000036  4605              MOV      r5,r0
;;;1193     /* could allocate a pbuf for an ARP request? */
;;;1194     if (p == NULL) {
000038  b92d              CBNZ     r5,|L9.70|
;;;1195       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
00003a  bf00              NOP      
00003c  bf00              NOP      
;;;1196         ("etharp_raw: could not allocate pbuf for ARP request.\n"));
;;;1197       ETHARP_STATS_INC(etharp.memerr);
;;;1198       return ERR_MEM;
00003e  f04f30ff          MOV      r0,#0xffffffff
                  |L9.66|
;;;1199     }
;;;1200     LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
;;;1201                 (p->len >= SIZEOF_ETHARP_PACKET));
;;;1202   
;;;1203     ethhdr = (struct eth_hdr *)p->payload;
;;;1204     hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
;;;1205     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
;;;1206     hdr->opcode = htons(opcode);
;;;1207   
;;;1208     LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
;;;1209                 (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;1210   #if LWIP_AUTOIP
;;;1211     /* If we are using Link-Local, all ARP packets that contain a Link-Local
;;;1212      * 'sender IP address' MUST be sent using link-layer broadcast instead of
;;;1213      * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
;;;1214     ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
;;;1215   #endif /* LWIP_AUTOIP */
;;;1216     /* Write the ARP MAC-Addresses */
;;;1217     ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
;;;1218     ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
;;;1219     /* Write the Ethernet MAC-Addresses */
;;;1220   #if LWIP_AUTOIP
;;;1221     ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
;;;1222   #else  /* LWIP_AUTOIP */
;;;1223     ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
;;;1224   #endif /* LWIP_AUTOIP */
;;;1225     ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
;;;1226     /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
;;;1227      * structure packing. */ 
;;;1228     IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
;;;1229     IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
;;;1230   
;;;1231     hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
;;;1232     hdr->proto = PP_HTONS(ETHTYPE_IP);
;;;1233     /* set hwlen and protolen */
;;;1234     hdr->hwlen = ETHARP_HWADDR_LEN;
;;;1235     hdr->protolen = sizeof(ip_addr_t);
;;;1236   
;;;1237     ethhdr->type = PP_HTONS(ETHTYPE_ARP);
;;;1238     /* send ARP query */
;;;1239     result = netif->linkoutput(netif, p);
;;;1240     ETHARP_STATS_INC(etharp.xmit);
;;;1241     /* free ARP query packet */
;;;1242     pbuf_free(p);
;;;1243     p = NULL;
;;;1244     /* could not allocate pbuf for ARP request */
;;;1245   
;;;1246     return result;
;;;1247   }
000042  e8bd8ff8          POP      {r3-r11,pc}
                  |L9.70|
000046  bf00              NOP                            ;1200
000048  8968              LDRH     r0,[r5,#0xa]          ;1200
00004a  282a              CMP      r0,#0x2a              ;1200
00004c  da08              BGE      |L9.96|
00004e  bf00              NOP                            ;1200
000050  a32b              ADR      r3,|L9.256|
000052  f44f6296          MOV      r2,#0x4b0             ;1200
000056  a143              ADR      r1,|L9.356|
000058  a037              ADR      r0,|L9.312|
00005a  f7fffffe          BL       __2printf
00005e  bf00              NOP                            ;1200
                  |L9.96|
000060  bf00              NOP                            ;1200
000062  686e              LDR      r6,[r5,#4]            ;1203
000064  f106040e          ADD      r4,r6,#0xe            ;1204
000068  bf00              NOP                            ;1205
00006a  bf00              NOP                            ;1205
00006c  980d              LDR      r0,[sp,#0x34]         ;1206
00006e  f7fffffe          BL       lwip_htons
000072  80e0              STRH     r0,[r4,#6]            ;1206
000074  bf00              NOP                            ;1208
000076  f8970026          LDRB     r0,[r7,#0x26]         ;1208
00007a  2806              CMP      r0,#6                 ;1208
00007c  d008              BEQ      |L9.144|
00007e  bf00              NOP                            ;1208
000080  a31f              ADR      r3,|L9.256|
000082  f44f6297          MOV      r2,#0x4b8             ;1208
000086  4944              LDR      r1,|L9.408|
000088  a02b              ADR      r0,|L9.312|
00008a  f7fffffe          BL       __2printf
00008e  bf00              NOP                            ;1208
                  |L9.144|
000090  bf00              NOP                            ;1208
000092  f8da0000          LDR      r0,[r10,#0]           ;1217
000096  60a0              STR      r0,[r4,#8]            ;1217
000098  f8ba0004          LDRH     r0,[r10,#4]           ;1217
00009c  81a0              STRH     r0,[r4,#0xc]          ;1217
00009e  980b              LDR      r0,[sp,#0x2c]         ;1218
0000a0  6801              LDR      r1,[r0,#0]            ;1218
0000a2  f8c41012          STR      r1,[r4,#0x12]         ;1218
0000a6  8880              LDRH     r0,[r0,#4]            ;1218
0000a8  82e0              STRH     r0,[r4,#0x16]         ;1218
0000aa  f8d90000          LDR      r0,[r9,#0]            ;1223
0000ae  6030              STR      r0,[r6,#0]            ;1223
0000b0  f8b90004          LDRH     r0,[r9,#4]            ;1223
0000b4  80b0              STRH     r0,[r6,#4]            ;1223
0000b6  f8d80000          LDR      r0,[r8,#0]            ;1225
0000ba  f8c60006          STR      r0,[r6,#6]            ;1225
0000be  f8b80004          LDRH     r0,[r8,#4]            ;1225
0000c2  8170              STRH     r0,[r6,#0xa]          ;1225
0000c4  f8db0000          LDR      r0,[r11,#0]           ;1228
0000c8  f8c4000e          STR      r0,[r4,#0xe]          ;1228
0000cc  980c              LDR      r0,[sp,#0x30]         ;1229
0000ce  6800              LDR      r0,[r0,#0]            ;1229
0000d0  61a0              STR      r0,[r4,#0x18]         ;1229
0000d2  f44f7080          MOV      r0,#0x100             ;1231
0000d6  8020              STRH     r0,[r4,#0]            ;1231
0000d8  2008              MOVS     r0,#8                 ;1232
0000da  8060              STRH     r0,[r4,#2]            ;1232
0000dc  2006              MOVS     r0,#6                 ;1234
0000de  7120              STRB     r0,[r4,#4]            ;1234
0000e0  2004              MOVS     r0,#4                 ;1235
0000e2  7160              STRB     r0,[r4,#5]            ;1235
0000e4  f44f60c1          MOV      r0,#0x608             ;1237
0000e8  81b0              STRH     r0,[r6,#0xc]          ;1237
0000ea  4629              MOV      r1,r5                 ;1239
0000ec  4638              MOV      r0,r7                 ;1239
0000ee  69ba              LDR      r2,[r7,#0x18]         ;1239
0000f0  4790              BLX      r2                    ;1239
0000f2  9000              STR      r0,[sp,#0]            ;1239
0000f4  4628              MOV      r0,r5                 ;1242
0000f6  f7fffffe          BL       pbuf_free
0000fa  2500              MOVS     r5,#0                 ;1243
0000fc  9800              LDR      r0,[sp,#0]            ;1246
0000fe  e7a0              B        |L9.66|
;;;1248   
                          ENDP

                  |L9.256|
000100  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\netif\\etharp.c",0
000104  5749505c
000108  6c776970
00010c  2d312e34
000110  2e315c73
000114  72635c6e
000118  65746966
00011c  5c657468
000120  6172702e
000124  6300    
000126  00                DCB      0
000127  00                DCB      0
                  |L9.296|
000128  6e657469          DCB      "netif != NULL",0
00012c  6620213d
000130  204e554c
000134  4c00    
000136  00                DCB      0
000137  00                DCB      0
                  |L9.312|
000138  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
00013c  7274696f
000140  6e202225
000144  73222066
000148  61696c65
00014c  64206174
000150  206c696e
000154  65202564
000158  20696e20
00015c  25730d0a
000160  00      
000161  00                DCB      0
000162  00                DCB      0
000163  00                DCB      0
                  |L9.356|
000164  63686563          DCB      "check that first pbuf can hold struct etharp_hdr",0
000168  6b207468
00016c  61742066
000170  69727374
000174  20706275
000178  66206361
00017c  6e20686f
000180  6c642073
000184  74727563
000188  74206574
00018c  68617270
000190  5f686472
000194  00      
000195  00                DCB      0
000196  00                DCB      0
000197  00                DCB      0
                  |L9.408|
                          DCD      ||.conststring||

                          AREA ||i.etharp_request||, CODE, READONLY, ALIGN=2

                  etharp_request PROC
;;;1258   err_t
;;;1259   etharp_request(struct netif *netif, ip_addr_t *ipaddr)
000000  b57f              PUSH     {r0-r6,lr}
;;;1260   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1261     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
000006  bf00              NOP      
000008  bf00              NOP      
;;;1262     return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
00000a  2101              MOVS     r1,#1
00000c  4a06              LDR      r2,|L10.40|
00000e  1d20              ADDS     r0,r4,#4
000010  f1040327          ADD      r3,r4,#0x27
000014  e88d0025          STM      sp,{r0,r2,r5}
000018  9103              STR      r1,[sp,#0xc]
00001a  4a04              LDR      r2,|L10.44|
00001c  4619              MOV      r1,r3
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       etharp_raw
;;;1263                       (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
;;;1264                       ipaddr, ARP_REQUEST);
;;;1265   }
000024  b004              ADD      sp,sp,#0x10
000026  bd70              POP      {r4-r6,pc}
;;;1266   #endif /* LWIP_ARP */
                          ENDP

                  |L10.40|
                          DCD      ethzero
                  |L10.44|
                          DCD      ethbroadcast

                          AREA ||i.etharp_send_ip||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  etharp_send_ip PROC
;;;414    static err_t
;;;415    etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;416    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;417      struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
00000c  6875              LDR      r5,[r6,#4]
;;;418    
;;;419      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
00000e  bf00              NOP      
000010  f8940026          LDRB     r0,[r4,#0x26]
000014  2806              CMP      r0,#6
000016  d008              BEQ      |L11.42|
000018  bf00              NOP      
00001a  a30f              ADR      r3,|L11.88|
00001c  f24012a3          MOV      r2,#0x1a3
000020  4917              LDR      r1,|L11.128|
000022  a018              ADR      r0,|L11.132|
000024  f7fffffe          BL       __2printf
000028  bf00              NOP      
                  |L11.42|
00002a  bf00              NOP      
;;;420                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;421      ETHADDR32_COPY(&ethhdr->dest, dst);
00002c  f8d80000          LDR      r0,[r8,#0]
000030  6028              STR      r0,[r5,#0]
000032  f8b80004          LDRH     r0,[r8,#4]
000036  80a8              STRH     r0,[r5,#4]
;;;422      ETHADDR16_COPY(&ethhdr->src, src);
000038  6838              LDR      r0,[r7,#0]
00003a  f8c50006          STR      r0,[r5,#6]
00003e  88b8              LDRH     r0,[r7,#4]
000040  8168              STRH     r0,[r5,#0xa]
;;;423      ethhdr->type = PP_HTONS(ETHTYPE_IP);
000042  2008              MOVS     r0,#8
000044  81a8              STRH     r0,[r5,#0xc]
;;;424      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
000046  bf00              NOP      
000048  bf00              NOP      
;;;425      /* send the packet */
;;;426      return netif->linkoutput(netif, p);
00004a  4631              MOV      r1,r6
00004c  4620              MOV      r0,r4
00004e  69a2              LDR      r2,[r4,#0x18]
000050  4790              BLX      r2
;;;427    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;428    
                          ENDP

000056  0000              DCW      0x0000
                  |L11.88|
000058  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\netif\\etharp.c",0
00005c  5749505c
000060  6c776970
000064  2d312e34
000068  2e315c73
00006c  72635c6e
000070  65746966
000074  5c657468
000078  6172702e
00007c  6300    
00007e  00                DCB      0
00007f  00                DCB      0
                  |L11.128|
                          DCD      ||.conststring||
                  |L11.132|
000084  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000088  7274696f
00008c  6e202225
000090  73222066
000094  61696c65
000098  64206174
00009c  206c696e
0000a0  65202564
0000a4  20696e20
0000a8  25730d0a
0000ac  00      
0000ad  00                DCB      0
0000ae  00                DCB      0
0000af  00                DCB      0

                          AREA ||i.etharp_tmr||, CODE, READONLY, ALIGN=2

                  etharp_tmr PROC
;;;205    void
;;;206    etharp_tmr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;207    {
;;;208      u8_t i;
;;;209    
;;;210      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
000002  bf00              NOP      
000004  bf00              NOP      
;;;211      /* remove expired entries from the ARP table */
;;;212      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
000006  2400              MOVS     r4,#0
000008  e03f              B        |L12.138|
                  |L12.10|
;;;213        u8_t state = arp_table[i].state;
00000a  eb040084          ADD      r0,r4,r4,LSL #2
00000e  4920              LDR      r1,|L12.144|
000010  eb010080          ADD      r0,r1,r0,LSL #2
000014  7c85              LDRB     r5,[r0,#0x12]
;;;214        if (state != ETHARP_STATE_EMPTY
000016  b335              CBZ      r5,|L12.102|
;;;215    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;216          && (state != ETHARP_STATE_STATIC)
;;;217    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;218          ) {
;;;219          arp_table[i].ctime++;
000018  eb040084          ADD      r0,r4,r4,LSL #2
00001c  eb010080          ADD      r0,r1,r0,LSL #2
000020  7cc0              LDRB     r0,[r0,#0x13]
000022  1c40              ADDS     r0,r0,#1
000024  eb040184          ADD      r1,r4,r4,LSL #2
000028  4a19              LDR      r2,|L12.144|
00002a  eb020181          ADD      r1,r2,r1,LSL #2
00002e  74c8              STRB     r0,[r1,#0x13]
;;;220          if ((arp_table[i].ctime >= ARP_MAXAGE) ||
000030  eb040084          ADD      r0,r4,r4,LSL #2
000034  4611              MOV      r1,r2
000036  eb010080          ADD      r0,r1,r0,LSL #2
00003a  7cc0              LDRB     r0,[r0,#0x13]
00003c  28f0              CMP      r0,#0xf0
00003e  da0d              BGE      |L12.92|
;;;221              ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
000040  eb040084          ADD      r0,r4,r4,LSL #2
000044  eb010080          ADD      r0,r1,r0,LSL #2
000048  7c80              LDRB     r0,[r0,#0x12]
00004a  2801              CMP      r0,#1
00004c  d10c              BNE      |L12.104|
;;;222               (arp_table[i].ctime >= ARP_MAXPENDING))) {
00004e  eb040084          ADD      r0,r4,r4,LSL #2
000052  eb010080          ADD      r0,r1,r0,LSL #2
000056  7cc0              LDRB     r0,[r0,#0x13]
000058  2802              CMP      r0,#2
00005a  db05              BLT      |L12.104|
                  |L12.92|
;;;223            /* pending or stable entry has become old! */
;;;224            LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
00005c  bf00              NOP      
00005e  bf00              NOP      
;;;225                 arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
;;;226            /* clean up entries that have just been expired */
;;;227            etharp_free_entry(i);
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       etharp_free_entry
                  |L12.102|
000066  e00e              B        |L12.134|
                  |L12.104|
;;;228          }
;;;229          else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
000068  eb040084          ADD      r0,r4,r4,LSL #2
00006c  4908              LDR      r1,|L12.144|
00006e  eb010080          ADD      r0,r1,r0,LSL #2
000072  7c80              LDRB     r0,[r0,#0x12]
000074  2803              CMP      r0,#3
000076  d106              BNE      |L12.134|
;;;230            /* Reset state to stable, so that the next transmitted packet will
;;;231               re-send an ARP request. */
;;;232            arp_table[i].state = ETHARP_STATE_STABLE;
000078  2002              MOVS     r0,#2
00007a  eb040184          ADD      r1,r4,r4,LSL #2
00007e  4a04              LDR      r2,|L12.144|
000080  eb020181          ADD      r1,r2,r1,LSL #2
000084  7488              STRB     r0,[r1,#0x12]
                  |L12.134|
000086  1c60              ADDS     r0,r4,#1              ;212
000088  b2c4              UXTB     r4,r0                 ;212
                  |L12.138|
00008a  2c0a              CMP      r4,#0xa               ;212
00008c  dbbd              BLT      |L12.10|
;;;233          }
;;;234    #if ARP_QUEUEING
;;;235          /* still pending entry? (not expired) */
;;;236          if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;237            /* resend an ARP query here? */
;;;238          }
;;;239    #endif /* ARP_QUEUEING */
;;;240        }
;;;241      }
;;;242    }
00008e  bd70              POP      {r4-r6,pc}
;;;243    
                          ENDP

                  |L12.144|
                          DCD      arp_table

                          AREA ||i.etharp_update_arp_entry||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  etharp_update_arp_entry PROC
;;;447    static err_t
;;;448    etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;449    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;450      s8_t i;
;;;451      LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
00000c  bf00              NOP      
00000e  f8960026          LDRB     r0,[r6,#0x26]
000012  2806              CMP      r0,#6
000014  d008              BEQ      |L13.40|
000016  bf00              NOP      
000018  a32f              ADR      r3,|L13.216|
00001a  f24012c3          MOV      r2,#0x1c3
00001e  a138              ADR      r1,|L13.256|
000020  a041              ADR      r0,|L13.296|
000022  f7fffffe          BL       __2printf
000026  bf00              NOP      
                  |L13.40|
000028  bf00              NOP      
;;;452      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
00002a  bf00              NOP      
00002c  bf00              NOP      
;;;453        ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
;;;454        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
;;;455        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
;;;456      /* non-unicast address? */
;;;457      if (ip_addr_isany(ipaddr) ||
00002e  b15d              CBZ      r5,|L13.72|
000030  6828              LDR      r0,[r5,#0]
000032  b148              CBZ      r0,|L13.72|
;;;458          ip_addr_isbroadcast(ipaddr, netif) ||
000034  4631              MOV      r1,r6
000036  6828              LDR      r0,[r5,#0]
000038  f7fffffe          BL       ip4_addr_isbroadcast
00003c  b920              CBNZ     r0,|L13.72|
;;;459          ip_addr_ismulticast(ipaddr)) {
00003e  7828              LDRB     r0,[r5,#0]
000040  f00000f0          AND      r0,r0,#0xf0
000044  28e0              CMP      r0,#0xe0
000046  d105              BNE      |L13.84|
                  |L13.72|
;;;460        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
000048  bf00              NOP      
00004a  bf00              NOP      
;;;461        return ERR_ARG;
00004c  f06f000d          MVN      r0,#0xd
                  |L13.80|
;;;462      }
;;;463      /* find or create ARP entry */
;;;464      i = etharp_find_entry(ipaddr, flags);
;;;465      /* bail out if no entry could be found */
;;;466      if (i < 0) {
;;;467        return (err_t)i;
;;;468      }
;;;469    
;;;470    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;471      if (flags & ETHARP_FLAG_STATIC_ENTRY) {
;;;472        /* record static type */
;;;473        arp_table[i].state = ETHARP_STATE_STATIC;
;;;474      } else
;;;475    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;476      {
;;;477        /* mark it stable */
;;;478        arp_table[i].state = ETHARP_STATE_STABLE;
;;;479      }
;;;480    
;;;481      /* record network interface */
;;;482      arp_table[i].netif = netif;
;;;483      /* insert in SNMP ARP index tree */
;;;484      snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);
;;;485    
;;;486      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
;;;487      /* update address */
;;;488      ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
;;;489      /* reset time stamp */
;;;490      arp_table[i].ctime = 0;
;;;491      /* this is where we will send out queued packets! */
;;;492    #if ARP_QUEUEING
;;;493      while (arp_table[i].q != NULL) {
;;;494        struct pbuf *p;
;;;495        /* remember remainder of queue */
;;;496        struct etharp_q_entry *q = arp_table[i].q;
;;;497        /* pop first item off the queue */
;;;498        arp_table[i].q = q->next;
;;;499        /* get the packet pointer */
;;;500        p = q->p;
;;;501        /* now queue entry can be freed */
;;;502        memp_free(MEMP_ARP_QUEUE, q);
;;;503    #else /* ARP_QUEUEING */
;;;504      if (arp_table[i].q != NULL) {
;;;505        struct pbuf *p = arp_table[i].q;
;;;506        arp_table[i].q = NULL;
;;;507    #endif /* ARP_QUEUEING */
;;;508        /* send the queued IP packet */
;;;509        etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
;;;510        /* free the queued IP packet */
;;;511        pbuf_free(p);
;;;512      }
;;;513      return ERR_OK;
;;;514    }
000050  e8bd87f0          POP      {r4-r10,pc}
                  |L13.84|
000054  4641              MOV      r1,r8                 ;464
000056  4628              MOV      r0,r5                 ;464
000058  f7fffffe          BL       etharp_find_entry
00005c  4604              MOV      r4,r0                 ;464
00005e  2c00              CMP      r4,#0                 ;466
000060  da01              BGE      |L13.102|
000062  4620              MOV      r0,r4                 ;467
000064  e7f4              B        |L13.80|
                  |L13.102|
000066  2002              MOVS     r0,#2                 ;478
000068  eb040184          ADD      r1,r4,r4,LSL #2       ;478
00006c  4a39              LDR      r2,|L13.340|
00006e  eb020181          ADD      r1,r2,r1,LSL #2       ;478
000072  7488              STRB     r0,[r1,#0x12]         ;478
000074  eb040084          ADD      r0,r4,r4,LSL #2       ;482
000078  4611              MOV      r1,r2                 ;482
00007a  eb010080          ADD      r0,r1,r0,LSL #2       ;482
00007e  6086              STR      r6,[r0,#8]            ;482
000080  bf00              NOP                            ;486
000082  bf00              NOP                            ;486
000084  eb040084          ADD      r0,r4,r4,LSL #2       ;488
000088  eb010080          ADD      r0,r1,r0,LSL #2       ;488
00008c  6839              LDR      r1,[r7,#0]            ;488
00008e  60c1              STR      r1,[r0,#0xc]          ;488
000090  88b9              LDRH     r1,[r7,#4]            ;488
000092  8201              STRH     r1,[r0,#0x10]         ;488
000094  2000              MOVS     r0,#0                 ;490
000096  eb040184          ADD      r1,r4,r4,LSL #2       ;490
00009a  eb020181          ADD      r1,r2,r1,LSL #2       ;490
00009e  74c8              STRB     r0,[r1,#0x13]         ;490
0000a0  eb040084          ADD      r0,r4,r4,LSL #2       ;504
0000a4  4611              MOV      r1,r2                 ;504
0000a6  f8510020          LDR      r0,[r1,r0,LSL #2]     ;504
0000aa  b198              CBZ      r0,|L13.212|
0000ac  eb040084          ADD      r0,r4,r4,LSL #2       ;505
0000b0  f8519020          LDR      r9,[r1,r0,LSL #2]     ;505
0000b4  2000              MOVS     r0,#0                 ;506
0000b6  eb040184          ADD      r1,r4,r4,LSL #2       ;506
0000ba  f8420021          STR      r0,[r2,r1,LSL #2]     ;506
0000be  463b              MOV      r3,r7                 ;509
0000c0  f1060227          ADD      r2,r6,#0x27           ;509
0000c4  4649              MOV      r1,r9                 ;509
0000c6  4630              MOV      r0,r6                 ;509
0000c8  f7fffffe          BL       etharp_send_ip
0000cc  4648              MOV      r0,r9                 ;511
0000ce  f7fffffe          BL       pbuf_free
0000d2  bf00              NOP                            ;512
                  |L13.212|
0000d4  2000              MOVS     r0,#0                 ;513
0000d6  e7bb              B        |L13.80|
;;;515    
                          ENDP

                  |L13.216|
0000d8  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\netif\\etharp.c",0
0000dc  5749505c
0000e0  6c776970
0000e4  2d312e34
0000e8  2e315c73
0000ec  72635c6e
0000f0  65746966
0000f4  5c657468
0000f8  6172702e
0000fc  6300    
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L13.256|
000100  6e657469          DCB      "netif->hwaddr_len == ETHARP_HWADDR_LEN",0
000104  662d3e68
000108  77616464
00010c  725f6c65
000110  6e203d3d
000114  20455448
000118  4152505f
00011c  48574144
000120  44525f4c
000124  454e00  
000127  00                DCB      0
                  |L13.296|
000128  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
00012c  7274696f
000130  6e202225
000134  73222066
000138  61696c65
00013c  64206174
000140  206c696e
000144  65202564
000148  20696e20
00014c  25730d0a
000150  00      
000151  00                DCB      0
000152  00                DCB      0
000153  00                DCB      0
                  |L13.340|
                          DCD      arp_table

                          AREA ||i.ethernet_input||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  ethernet_input PROC
;;;1276   err_t
;;;1277   ethernet_input(struct pbuf *p, struct netif *netif)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1278   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;1279     struct eth_hdr* ethhdr;
;;;1280     u16_t type;
;;;1281   #if LWIP_ARP || ETHARP_SUPPORT_VLAN
;;;1282     s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
000008  f04f080e          MOV      r8,#0xe
;;;1283   #endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */
;;;1284   
;;;1285     if (p->len <= SIZEOF_ETH_HDR) {
00000c  8960              LDRH     r0,[r4,#0xa]
00000e  280e              CMP      r0,#0xe
000010  dc00              BGT      |L14.20|
;;;1286       /* a packet with only an ethernet header (or less) is not valid for us */
;;;1287       ETHARP_STATS_INC(etharp.proterr);
;;;1288       ETHARP_STATS_INC(etharp.drop);
;;;1289       goto free_and_return;
000012  e054              B        |L14.190|
                  |L14.20|
;;;1290     }
;;;1291   
;;;1292     /* points to packet payload, which starts with an Ethernet header */
;;;1293     ethhdr = (struct eth_hdr *)p->payload;
000014  6865              LDR      r5,[r4,#4]
;;;1294     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
000016  bf00              NOP      
000018  bf00              NOP      
;;;1295       ("ethernet_input: dest:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", src:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", type:%"X16_F"\n",
;;;1296        (unsigned)ethhdr->dest.addr[0], (unsigned)ethhdr->dest.addr[1], (unsigned)ethhdr->dest.addr[2],
;;;1297        (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
;;;1298        (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
;;;1299        (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
;;;1300        (unsigned)htons(ethhdr->type)));
;;;1301   
;;;1302     type = ethhdr->type;
00001a  89af              LDRH     r7,[r5,#0xc]
;;;1303   #if ETHARP_SUPPORT_VLAN
;;;1304     if (type == PP_HTONS(ETHTYPE_VLAN)) {
;;;1305       struct eth_vlan_hdr *vlan = (struct eth_vlan_hdr*)(((char*)ethhdr) + SIZEOF_ETH_HDR);
;;;1306       if (p->len <= SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR) {
;;;1307         /* a packet with only an ethernet/vlan header (or less) is not valid for us */
;;;1308         ETHARP_STATS_INC(etharp.proterr);
;;;1309         ETHARP_STATS_INC(etharp.drop);
;;;1310         goto free_and_return;
;;;1311       }
;;;1312   #if defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) /* if not, allow all VLANs */
;;;1313   #ifdef ETHARP_VLAN_CHECK_FN
;;;1314       if (!ETHARP_VLAN_CHECK_FN(ethhdr, vlan)) {
;;;1315   #elif defined(ETHARP_VLAN_CHECK)
;;;1316       if (VLAN_ID(vlan) != ETHARP_VLAN_CHECK) {
;;;1317   #endif
;;;1318         /* silently ignore this packet: not for our VLAN */
;;;1319         pbuf_free(p);
;;;1320         return ERR_OK;
;;;1321       }
;;;1322   #endif /* defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) */
;;;1323       type = vlan->tpid;
;;;1324       ip_hdr_offset = SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR;
;;;1325     }
;;;1326   #endif /* ETHARP_SUPPORT_VLAN */
;;;1327   
;;;1328   #if LWIP_ARP_FILTER_NETIF
;;;1329     netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
;;;1330   #endif /* LWIP_ARP_FILTER_NETIF*/
;;;1331   
;;;1332     if (ethhdr->dest.addr[0] & 1) {
00001c  7828              LDRB     r0,[r5,#0]
00001e  f0000001          AND      r0,r0,#1
000022  b1b0              CBZ      r0,|L14.82|
;;;1333       /* this might be a multicast or broadcast packet */
;;;1334       if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
000024  7828              LDRB     r0,[r5,#0]
000026  2801              CMP      r0,#1
000028  d109              BNE      |L14.62|
;;;1335         if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
00002a  7868              LDRB     r0,[r5,#1]
00002c  b988              CBNZ     r0,|L14.82|
;;;1336             (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
00002e  78a8              LDRB     r0,[r5,#2]
000030  285e              CMP      r0,#0x5e
000032  d10e              BNE      |L14.82|
;;;1337           /* mark the pbuf as link-layer multicast */
;;;1338           p->flags |= PBUF_FLAG_LLMCAST;
000034  7b60              LDRB     r0,[r4,#0xd]
000036  f0400010          ORR      r0,r0,#0x10
00003a  7360              STRB     r0,[r4,#0xd]
00003c  e009              B        |L14.82|
                  |L14.62|
;;;1339         }
;;;1340       } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
00003e  2206              MOVS     r2,#6
000040  4921              LDR      r1,|L14.200|
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       memcmp
000048  b918              CBNZ     r0,|L14.82|
;;;1341         /* mark the pbuf as link-layer broadcast */
;;;1342         p->flags |= PBUF_FLAG_LLBCAST;
00004a  7b60              LDRB     r0,[r4,#0xd]
00004c  f0400008          ORR      r0,r0,#8
000050  7360              STRB     r0,[r4,#0xd]
                  |L14.82|
;;;1343       }
;;;1344     }
;;;1345   
;;;1346     switch (type) {
000052  2f08              CMP      r7,#8
000054  d003              BEQ      |L14.94|
000056  f5b76fc1          CMP      r7,#0x608
00005a  d12b              BNE      |L14.180|
00005c  e01d              B        |L14.154|
                  |L14.94|
;;;1347   #if LWIP_ARP
;;;1348       /* IP packet? */
;;;1349       case PP_HTONS(ETHTYPE_IP):
;;;1350         if (!(netif->flags & NETIF_FLAG_ETHARP)) {
00005e  f896002d          LDRB     r0,[r6,#0x2d]
000062  f0000020          AND      r0,r0,#0x20
000066  b900              CBNZ     r0,|L14.106|
;;;1351           goto free_and_return;
000068  e029              B        |L14.190|
                  |L14.106|
;;;1352         }
;;;1353   #if ETHARP_TRUST_IP_MAC
;;;1354         /* update ARP table */
;;;1355         etharp_ip_input(netif, p);
;;;1356   #endif /* ETHARP_TRUST_IP_MAC */
;;;1357         /* skip Ethernet header */
;;;1358         if(pbuf_header(p, -ip_hdr_offset)) {
00006a  f1c80000          RSB      r0,r8,#0
00006e  b201              SXTH     r1,r0
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       pbuf_header
000076  b158              CBZ      r0,|L14.144|
;;;1359           LWIP_ASSERT("Can't move over header in packet", 0);
000078  bf00              NOP      
00007a  bf00              NOP      
00007c  a313              ADR      r3,|L14.204|
00007e  f240524f          MOV      r2,#0x54f
000082  a11c              ADR      r1,|L14.244|
000084  a024              ADR      r0,|L14.280|
000086  f7fffffe          BL       __2printf
00008a  bf00              NOP      
00008c  bf00              NOP      
;;;1360           goto free_and_return;
00008e  e016              B        |L14.190|
                  |L14.144|
;;;1361         } else {
;;;1362           /* pass to IP layer */
;;;1363           ip_input(p, netif);
000090  4631              MOV      r1,r6
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       ip_input
;;;1364         }
;;;1365         break;
000098  e00d              B        |L14.182|
                  |L14.154|
;;;1366         
;;;1367       case PP_HTONS(ETHTYPE_ARP):
;;;1368         if (!(netif->flags & NETIF_FLAG_ETHARP)) {
00009a  f896002d          LDRB     r0,[r6,#0x2d]
00009e  f0000020          AND      r0,r0,#0x20
0000a2  b900              CBNZ     r0,|L14.166|
;;;1369           goto free_and_return;
0000a4  e00b              B        |L14.190|
                  |L14.166|
;;;1370         }
;;;1371         /* pass p to ARP module */
;;;1372         etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
0000a6  4622              MOV      r2,r4
0000a8  f1060127          ADD      r1,r6,#0x27
0000ac  4630              MOV      r0,r6
0000ae  f7fffffe          BL       etharp_arp_input
;;;1373         break;
0000b2  e000              B        |L14.182|
                  |L14.180|
;;;1374   #endif /* LWIP_ARP */
;;;1375   #if PPPOE_SUPPORT
;;;1376       case PP_HTONS(ETHTYPE_PPPOEDISC): /* PPP Over Ethernet Discovery Stage */
;;;1377         pppoe_disc_input(netif, p);
;;;1378         break;
;;;1379   
;;;1380       case PP_HTONS(ETHTYPE_PPPOE): /* PPP Over Ethernet Session Stage */
;;;1381         pppoe_data_input(netif, p);
;;;1382         break;
;;;1383   #endif /* PPPOE_SUPPORT */
;;;1384   
;;;1385       default:
;;;1386         ETHARP_STATS_INC(etharp.proterr);
;;;1387         ETHARP_STATS_INC(etharp.drop);
;;;1388         goto free_and_return;
0000b4  e003              B        |L14.190|
                  |L14.182|
0000b6  bf00              NOP                            ;1365
;;;1389     }
;;;1390   
;;;1391     /* This means the pbuf is freed or consumed,
;;;1392        so the caller doesn't have to free it again */
;;;1393     return ERR_OK;
0000b8  2000              MOVS     r0,#0
                  |L14.186|
;;;1394   
;;;1395   free_and_return:
;;;1396     pbuf_free(p);
;;;1397     return ERR_OK;
;;;1398   }
0000ba  e8bd81f0          POP      {r4-r8,pc}
                  |L14.190|
0000be  4620              MOV      r0,r4                 ;1396
0000c0  f7fffffe          BL       pbuf_free
0000c4  2000              MOVS     r0,#0                 ;1397
0000c6  e7f8              B        |L14.186|
;;;1399   #endif /* LWIP_ARP || LWIP_ETHERNET */
                          ENDP

                  |L14.200|
                          DCD      ethbroadcast
                  |L14.204|
0000cc  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\netif\\etharp.c",0
0000d0  5749505c
0000d4  6c776970
0000d8  2d312e34
0000dc  2e315c73
0000e0  72635c6e
0000e4  65746966
0000e8  5c657468
0000ec  6172702e
0000f0  6300    
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L14.244|
0000f4  43616e27          DCB      "Can't move over header in packet",0
0000f8  74206d6f
0000fc  7665206f
000100  76657220
000104  68656164
000108  65722069
00010c  6e207061
000110  636b6574
000114  00      
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0
                  |L14.280|
000118  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
00011c  7274696f
000120  6e202225
000124  73222066
000128  61696c65
00012c  64206174
000130  206c696e
000134  65202564
000138  20696e20
00013c  25730d0a
000140  00      
000141  00                DCB      0
000142  00                DCB      0
000143  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  arp_table
                          %        200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ethbroadcast
000000  ffffffff          DCB      0xff,0xff,0xff,0xff
000004  ffff              DCB      0xff,0xff
                  ethzero
000006  0000              DCB      0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  6e657469          DCB      "netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN"
000004  662d3e68
000008  77616464
00000c  725f6c65
000010  6e206d75
000014  73742062
000018  65207468
00001c  65207361
000020  6d652061
000024  73204554
000028  48415250
00002c  5f485741
000030  4444525f
000034  4c454e  
000037  20666f72          DCB      " for etharp!",0
00003b  20657468
00003f  61727021
000043  00      

                          AREA ||.data||, DATA, ALIGN=0

                  etharp_cached_entry
000000  00                DCB      0x00
