; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\tcpip.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\tcpip.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\tcpip.crf ..\LWIP\lwip-1.4.1\src\api\tcpip.c]
                          THUMB

                          AREA ||i.mem_free_callback||, CODE, READONLY, ALIGN=2

                  mem_free_callback PROC
;;;505    err_t
;;;506    mem_free_callback(void *m)
000000  b510              PUSH     {r4,lr}
;;;507    {
000002  4604              MOV      r4,r0
;;;508      return tcpip_callback_with_block(mem_free, m, 0);
000004  2200              MOVS     r2,#0
000006  4621              MOV      r1,r4
000008  4801              LDR      r0,|L1.16|
00000a  f7fffffe          BL       tcpip_callback_with_block
;;;509    }
00000e  bd10              POP      {r4,pc}
;;;510    
                          ENDP

                  |L1.16|
                          DCD      mem_free

                          AREA ||i.pbuf_free_callback||, CODE, READONLY, ALIGN=2

                  pbuf_free_callback PROC
;;;492    err_t
;;;493    pbuf_free_callback(struct pbuf *p)
000000  b510              PUSH     {r4,lr}
;;;494    {
000002  4604              MOV      r4,r0
;;;495      return tcpip_callback_with_block(pbuf_free_int, p, 0);
000004  2200              MOVS     r2,#0
000006  4621              MOV      r1,r4
000008  4801              LDR      r0,|L2.16|
00000a  f7fffffe          BL       tcpip_callback_with_block
;;;496    }
00000e  bd10              POP      {r4,pc}
;;;497    
                          ENDP

                  |L2.16|
                          DCD      pbuf_free_int

                          AREA ||i.pbuf_free_int||, CODE, READONLY, ALIGN=1

                  pbuf_free_int PROC
;;;479    static void
;;;480    pbuf_free_int(void *p)
000000  b570              PUSH     {r4-r6,lr}
;;;481    {
000002  4604              MOV      r4,r0
;;;482      struct pbuf *q = (struct pbuf *)p;
000004  4625              MOV      r5,r4
;;;483      pbuf_free(q);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       pbuf_free
;;;484    }
00000c  bd70              POP      {r4-r6,pc}
;;;485    
                          ENDP


                          AREA ||i.tcpip_apimsg||, CODE, READONLY, ALIGN=2

                  tcpip_apimsg PROC
;;;305    err_t
;;;306    tcpip_apimsg(struct api_msg *apimsg)
000000  b510              PUSH     {r4,lr}
;;;307    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;308      struct tcpip_msg msg;
;;;309    #ifdef LWIP_DEBUG
;;;310      /* catch functions that don't set err */
;;;311      apimsg->msg.err = ERR_VAL;
000006  21fa              MOVS     r1,#0xfa
000008  7221              STRB     r1,[r4,#8]
;;;312    #endif
;;;313      
;;;314      if (sys_mbox_valid(&mbox)) {
00000a  480c              LDR      r0,|L4.60|
00000c  f7fffffe          BL       sys_mbox_valid
000010  b188              CBZ      r0,|L4.54|
;;;315        msg.type = TCPIP_MSG_API;
000012  2000              MOVS     r0,#0
000014  f88d0004          STRB     r0,[sp,#4]
;;;316        msg.msg.apimsg = apimsg;
000018  9403              STR      r4,[sp,#0xc]
;;;317        sys_mbox_post(&mbox, &msg);
00001a  a901              ADD      r1,sp,#4
00001c  4807              LDR      r0,|L4.60|
00001e  f7fffffe          BL       sys_mbox_post
;;;318        sys_arch_sem_wait(&apimsg->msg.conn->op_completed, 0);
000022  6861              LDR      r1,[r4,#4]
000024  f101000c          ADD      r0,r1,#0xc
000028  2100              MOVS     r1,#0
00002a  f7fffffe          BL       sys_arch_sem_wait
;;;319        return apimsg->msg.err;
00002e  f9940008          LDRSB    r0,[r4,#8]
                  |L4.50|
;;;320      }
;;;321      return ERR_VAL;
;;;322    }
000032  b006              ADD      sp,sp,#0x18
000034  bd10              POP      {r4,pc}
                  |L4.54|
000036  f06f0005          MVN      r0,#5                 ;321
00003a  e7fa              B        |L4.50|
;;;323    
                          ENDP

                  |L4.60|
                          DCD      mbox

                          AREA ||i.tcpip_callback_with_block||, CODE, READONLY, ALIGN=2

                  tcpip_callback_with_block PROC
;;;210    err_t
;;;211    tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;212    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;213      struct tcpip_msg *msg;
;;;214    
;;;215      if (sys_mbox_valid(&mbox)) {
00000a  4814              LDR      r0,|L5.92|
00000c  f7fffffe          BL       sys_mbox_valid
000010  b300              CBZ      r0,|L5.84|
;;;216        msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
000012  2009              MOVS     r0,#9
000014  f7fffffe          BL       memp_malloc
000018  4604              MOV      r4,r0
;;;217        if (msg == NULL) {
00001a  b91c              CBNZ     r4,|L5.36|
;;;218          return ERR_MEM;
00001c  f04f30ff          MOV      r0,#0xffffffff
                  |L5.32|
;;;219        }
;;;220    
;;;221        msg->type = TCPIP_MSG_CALLBACK;
;;;222        msg->msg.cb.function = function;
;;;223        msg->msg.cb.ctx = ctx;
;;;224        if (block) {
;;;225          sys_mbox_post(&mbox, msg);
;;;226        } else {
;;;227          if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
;;;228            memp_free(MEMP_TCPIP_MSG_API, msg);
;;;229            return ERR_MEM;
;;;230          }
;;;231        }
;;;232        return ERR_OK;
;;;233      }
;;;234      return ERR_VAL;
;;;235    }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L5.36|
000024  2004              MOVS     r0,#4                 ;221
000026  7020              STRB     r0,[r4,#0]            ;221
000028  60a5              STR      r5,[r4,#8]            ;222
00002a  60e6              STR      r6,[r4,#0xc]          ;223
00002c  b127              CBZ      r7,|L5.56|
00002e  4621              MOV      r1,r4                 ;225
000030  480a              LDR      r0,|L5.92|
000032  f7fffffe          BL       sys_mbox_post
000036  e00b              B        |L5.80|
                  |L5.56|
000038  4621              MOV      r1,r4                 ;227
00003a  4808              LDR      r0,|L5.92|
00003c  f7fffffe          BL       sys_mbox_trypost
000040  b130              CBZ      r0,|L5.80|
000042  4621              MOV      r1,r4                 ;228
000044  2009              MOVS     r0,#9                 ;228
000046  f7fffffe          BL       memp_free
00004a  f04f30ff          MOV      r0,#0xffffffff        ;229
00004e  e7e7              B        |L5.32|
                  |L5.80|
000050  2000              MOVS     r0,#0                 ;232
000052  e7e5              B        |L5.32|
                  |L5.84|
000054  f06f0005          MVN      r0,#5                 ;234
000058  e7e2              B        |L5.32|
;;;236    
                          ENDP

00005a  0000              DCW      0x0000
                  |L5.92|
                          DCD      mbox

                          AREA ||i.tcpip_callbackmsg_delete||, CODE, READONLY, ALIGN=1

                  tcpip_callbackmsg_delete PROC
;;;424     */
;;;425    void tcpip_callbackmsg_delete(struct tcpip_callback_msg* msg)
000000  b510              PUSH     {r4,lr}
;;;426    {
000002  4604              MOV      r4,r0
;;;427      memp_free(MEMP_TCPIP_MSG_API, msg);
000004  4621              MOV      r1,r4
000006  2009              MOVS     r0,#9
000008  f7fffffe          BL       memp_free
;;;428    }
00000c  bd10              POP      {r4,pc}
;;;429    
                          ENDP


                          AREA ||i.tcpip_callbackmsg_new||, CODE, READONLY, ALIGN=1

                  tcpip_callbackmsg_new PROC
;;;407     */
;;;408    struct tcpip_callback_msg* tcpip_callbackmsg_new(tcpip_callback_fn function, void *ctx)
000000  b570              PUSH     {r4-r6,lr}
;;;409    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;410      struct tcpip_msg *msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
000006  2009              MOVS     r0,#9
000008  f7fffffe          BL       memp_malloc
00000c  4604              MOV      r4,r0
;;;411      if (msg == NULL) {
00000e  b90c              CBNZ     r4,|L7.20|
;;;412        return NULL;
000010  2000              MOVS     r0,#0
                  |L7.18|
;;;413      }
;;;414      msg->type = TCPIP_MSG_CALLBACK_STATIC;
;;;415      msg->msg.cb.function = function;
;;;416      msg->msg.cb.ctx = ctx;
;;;417      return (struct tcpip_callback_msg*)msg;
;;;418    }
000012  bd70              POP      {r4-r6,pc}
                  |L7.20|
000014  2005              MOVS     r0,#5                 ;414
000016  7020              STRB     r0,[r4,#0]            ;414
000018  60a5              STR      r5,[r4,#8]            ;415
00001a  60e6              STR      r6,[r4,#0xc]          ;416
00001c  4620              MOV      r0,r4                 ;417
00001e  e7f8              B        |L7.18|
;;;419    
                          ENDP


                          AREA ||i.tcpip_init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcpip_init PROC
;;;454    void
;;;455    tcpip_init(tcpip_init_done_fn initfunc, void *arg)
000000  b538              PUSH     {r3-r5,lr}
;;;456    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;457      lwip_init();
000006  f7fffffe          BL       lwip_init
;;;458    
;;;459      tcpip_init_done = initfunc;
00000a  480f              LDR      r0,|L8.72|
00000c  6004              STR      r4,[r0,#0]  ; tcpip_init_done
;;;460      tcpip_init_done_arg = arg;
00000e  480f              LDR      r0,|L8.76|
000010  6005              STR      r5,[r0,#0]  ; tcpip_init_done_arg
;;;461      if(sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
000012  2114              MOVS     r1,#0x14
000014  480e              LDR      r0,|L8.80|
000016  f7fffffe          BL       sys_mbox_new
00001a  2800              CMP      r0,#0
00001c  d00a              BEQ      |L8.52|
;;;462        LWIP_ASSERT("failed to create tcpip_thread mbox", 0);
00001e  bf00              NOP      
000020  bf00              NOP      
000022  a30c              ADR      r3,|L8.84|
000024  f44f72e7          MOV      r2,#0x1ce
000028  a113              ADR      r1,|L8.120|
00002a  a01c              ADR      r0,|L8.156|
00002c  f7fffffe          BL       __2printf
000030  bf00              NOP      
000032  bf00              NOP      
                  |L8.52|
;;;463      }
;;;464    #if LWIP_TCPIP_CORE_LOCKING
;;;465      if(sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
;;;466        LWIP_ASSERT("failed to create lock_tcpip_core", 0);
;;;467      }
;;;468    #endif /* LWIP_TCPIP_CORE_LOCKING */
;;;469    
;;;470      sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
000034  201f              MOVS     r0,#0x1f
000036  f44f737a          MOV      r3,#0x3e8
00003a  2200              MOVS     r2,#0
00003c  4922              LDR      r1,|L8.200|
00003e  9000              STR      r0,[sp,#0]
000040  a022              ADR      r0,|L8.204|
000042  f7fffffe          BL       sys_thread_new
;;;471    }
000046  bd38              POP      {r3-r5,pc}
;;;472    
                          ENDP

                  |L8.72|
                          DCD      tcpip_init_done
                  |L8.76|
                          DCD      tcpip_init_done_arg
                  |L8.80|
                          DCD      mbox
                  |L8.84|
000054  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\tcpip.c",0
000058  5749505c
00005c  6c776970
000060  2d312e34
000064  2e315c73
000068  72635c61
00006c  70695c74
000070  63706970
000074  2e6300  
000077  00                DCB      0
                  |L8.120|
000078  6661696c          DCB      "failed to create tcpip_thread mbox",0
00007c  65642074
000080  6f206372
000084  65617465
000088  20746370
00008c  69705f74
000090  68726561
000094  64206d62
000098  6f7800  
00009b  00                DCB      0
                  |L8.156|
00009c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000a0  7274696f
0000a4  6e202225
0000a8  73222066
0000ac  61696c65
0000b0  64206174
0000b4  206c696e
0000b8  65202564
0000bc  20696e20
0000c0  25730d0a
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L8.200|
                          DCD      tcpip_thread
                  |L8.204|
0000cc  74637069          DCB      "tcpip_thread",0
0000d0  705f7468
0000d4  72656164
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0

                          AREA ||i.tcpip_input||, CODE, READONLY, ALIGN=2

                  tcpip_input PROC
;;;160    err_t
;;;161    tcpip_input(struct pbuf *p, struct netif *inp)
000000  b570              PUSH     {r4-r6,lr}
;;;162    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;163    #if LWIP_TCPIP_CORE_LOCKING_INPUT
;;;164      err_t ret;
;;;165      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_input: PACKET %p/%p\n", (void *)p, (void *)inp));
;;;166      LOCK_TCPIP_CORE();
;;;167    #if LWIP_ETHERNET
;;;168      if (inp->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
;;;169        ret = ethernet_input(p, inp);
;;;170      } else
;;;171    #endif /* LWIP_ETHERNET */
;;;172      {
;;;173        ret = ip_input(p, inp);
;;;174      }
;;;175      UNLOCK_TCPIP_CORE();
;;;176      return ret;
;;;177    #else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
;;;178      struct tcpip_msg *msg;
;;;179    
;;;180      if (!sys_mbox_valid(&mbox)) {
000006  4810              LDR      r0,|L9.72|
000008  f7fffffe          BL       sys_mbox_valid
00000c  b910              CBNZ     r0,|L9.20|
;;;181        return ERR_VAL;
00000e  f06f0005          MVN      r0,#5
                  |L9.18|
;;;182      }
;;;183      msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
;;;184      if (msg == NULL) {
;;;185        return ERR_MEM;
;;;186      }
;;;187    
;;;188      msg->type = TCPIP_MSG_INPKT;
;;;189      msg->msg.inp.p = p;
;;;190      msg->msg.inp.netif = inp;
;;;191      if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
;;;192        memp_free(MEMP_TCPIP_MSG_INPKT, msg);
;;;193        return ERR_MEM;
;;;194      }
;;;195      return ERR_OK;
;;;196    #endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
;;;197    }
000012  bd70              POP      {r4-r6,pc}
                  |L9.20|
000014  200a              MOVS     r0,#0xa               ;183
000016  f7fffffe          BL       memp_malloc
00001a  4604              MOV      r4,r0                 ;183
00001c  b914              CBNZ     r4,|L9.36|
00001e  f04f30ff          MOV      r0,#0xffffffff        ;185
000022  e7f6              B        |L9.18|
                  |L9.36|
000024  2001              MOVS     r0,#1                 ;188
000026  7020              STRB     r0,[r4,#0]            ;188
000028  60a5              STR      r5,[r4,#8]            ;189
00002a  60e6              STR      r6,[r4,#0xc]          ;190
00002c  4621              MOV      r1,r4                 ;191
00002e  4806              LDR      r0,|L9.72|
000030  f7fffffe          BL       sys_mbox_trypost
000034  b130              CBZ      r0,|L9.68|
000036  4621              MOV      r1,r4                 ;192
000038  200a              MOVS     r0,#0xa               ;192
00003a  f7fffffe          BL       memp_free
00003e  f04f30ff          MOV      r0,#0xffffffff        ;193
000042  e7e6              B        |L9.18|
                  |L9.68|
000044  2000              MOVS     r0,#0                 ;195
000046  e7e4              B        |L9.18|
;;;198    
                          ENDP

                  |L9.72|
                          DCD      mbox

                          AREA ||i.tcpip_thread||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcpip_thread PROC
;;;73     static void
;;;74     tcpip_thread(void *arg)
000000  b508              PUSH     {r3,lr}
;;;75     {
;;;76       struct tcpip_msg *msg;
;;;77       LWIP_UNUSED_ARG(arg);
;;;78     
;;;79       if (tcpip_init_done != NULL) {
000002  4839              LDR      r0,|L10.232|
000004  6800              LDR      r0,[r0,#0]  ; tcpip_init_done
000006  b120              CBZ      r0,|L10.18|
;;;80         tcpip_init_done(tcpip_init_done_arg);
000008  4838              LDR      r0,|L10.236|
00000a  6800              LDR      r0,[r0,#0]  ; tcpip_init_done_arg
00000c  4936              LDR      r1,|L10.232|
00000e  6809              LDR      r1,[r1,#0]  ; tcpip_init_done
000010  4788              BLX      r1
                  |L10.18|
;;;81       }
;;;82     
;;;83       LOCK_TCPIP_CORE();
;;;84       while (1) {                          /* MAIN Loop */
000012  e067              B        |L10.228|
                  |L10.20|
;;;85         UNLOCK_TCPIP_CORE();
;;;86         LWIP_TCPIP_THREAD_ALIVE();
;;;87         /* wait for a message, timeouts are processed while waiting */
;;;88         sys_timeouts_mbox_fetch(&mbox, (void **)&msg);
000014  4669              MOV      r1,sp
000016  4836              LDR      r0,|L10.240|
000018  f7fffffe          BL       sys_timeouts_mbox_fetch
;;;89         LOCK_TCPIP_CORE();
;;;90         switch (msg->type) {
00001c  9800              LDR      r0,[sp,#0]
00001e  7800              LDRB     r0,[r0,#0]
000020  2806              CMP      r0,#6
000022  d251              BCS      |L10.200|
000024  e8dff000          TBB      [pc,r0]
000028  030d2632          DCB      0x03,0x0d,0x26,0x32
00002c  3e49              DCB      0x3e,0x49
;;;91     #if LWIP_NETCONN
;;;92         case TCPIP_MSG_API:
;;;93           LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
00002e  bf00              NOP      
000030  bf00              NOP      
;;;94           msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
000032  9a00              LDR      r2,[sp,#0]
000034  6892              LDR      r2,[r2,#8]
000036  1d10              ADDS     r0,r2,#4
000038  9a00              LDR      r2,[sp,#0]
00003a  6892              LDR      r2,[r2,#8]
00003c  6811              LDR      r1,[r2,#0]
00003e  4788              BLX      r1
;;;95           break;
000040  e04f              B        |L10.226|
;;;96     #endif /* LWIP_NETCONN */
;;;97     
;;;98     #if !LWIP_TCPIP_CORE_LOCKING_INPUT
;;;99         case TCPIP_MSG_INPKT:
;;;100          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
000042  bf00              NOP      
000044  bf00              NOP      
;;;101    #if LWIP_ETHERNET
;;;102          if (msg->msg.inp.netif->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
000046  9800              LDR      r0,[sp,#0]
000048  68c0              LDR      r0,[r0,#0xc]
00004a  f890002d          LDRB     r0,[r0,#0x2d]
00004e  f0000060          AND      r0,r0,#0x60
000052  b128              CBZ      r0,|L10.96|
;;;103            ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
000054  9a00              LDR      r2,[sp,#0]
000056  e9d20102          LDRD     r0,r1,[r2,#8]
00005a  f7fffffe          BL       ethernet_input
00005e  e004              B        |L10.106|
                  |L10.96|
;;;104          } else
;;;105    #endif /* LWIP_ETHERNET */
;;;106          {
;;;107            ip_input(msg->msg.inp.p, msg->msg.inp.netif);
000060  9a00              LDR      r2,[sp,#0]
000062  e9d20102          LDRD     r0,r1,[r2,#8]
000066  f7fffffe          BL       ip_input
                  |L10.106|
;;;108          }
;;;109          memp_free(MEMP_TCPIP_MSG_INPKT, msg);
00006a  200a              MOVS     r0,#0xa
00006c  9900              LDR      r1,[sp,#0]
00006e  f7fffffe          BL       memp_free
;;;110          break;
000072  e036              B        |L10.226|
;;;111    #endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
;;;112    
;;;113    #if LWIP_NETIF_API
;;;114        case TCPIP_MSG_NETIFAPI:
;;;115          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: Netif API message %p\n", (void *)msg));
;;;116          msg->msg.netifapimsg->function(&(msg->msg.netifapimsg->msg));
;;;117          break;
;;;118    #endif /* LWIP_NETIF_API */
;;;119    
;;;120    #if LWIP_TCPIP_TIMEOUT
;;;121        case TCPIP_MSG_TIMEOUT:
;;;122          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));
000074  bf00              NOP      
000076  bf00              NOP      
;;;123          sys_timeout(msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
000078  9b00              LDR      r3,[sp,#0]
00007a  3308              ADDS     r3,r3,#8
00007c  cb07              LDM      r3!,{r0-r2}
00007e  f7fffffe          BL       sys_timeout
;;;124          memp_free(MEMP_TCPIP_MSG_API, msg);
000082  2009              MOVS     r0,#9
000084  9900              LDR      r1,[sp,#0]
000086  f7fffffe          BL       memp_free
;;;125          break;
00008a  e02a              B        |L10.226|
;;;126        case TCPIP_MSG_UNTIMEOUT:
;;;127          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: UNTIMEOUT %p\n", (void *)msg));
00008c  bf00              NOP      
00008e  bf00              NOP      
;;;128          sys_untimeout(msg->msg.tmo.h, msg->msg.tmo.arg);
000090  9a00              LDR      r2,[sp,#0]
000092  e9d20103          LDRD     r0,r1,[r2,#0xc]
000096  f7fffffe          BL       sys_untimeout
;;;129          memp_free(MEMP_TCPIP_MSG_API, msg);
00009a  2009              MOVS     r0,#9
00009c  9900              LDR      r1,[sp,#0]
00009e  f7fffffe          BL       memp_free
;;;130          break;
0000a2  e01e              B        |L10.226|
;;;131    #endif /* LWIP_TCPIP_TIMEOUT */
;;;132    
;;;133        case TCPIP_MSG_CALLBACK:
;;;134          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
0000a4  bf00              NOP      
0000a6  bf00              NOP      
;;;135          msg->msg.cb.function(msg->msg.cb.ctx);
0000a8  9a00              LDR      r2,[sp,#0]
0000aa  e9d21002          LDRD     r1,r0,[r2,#8]
0000ae  4788              BLX      r1
;;;136          memp_free(MEMP_TCPIP_MSG_API, msg);
0000b0  2009              MOVS     r0,#9
0000b2  9900              LDR      r1,[sp,#0]
0000b4  f7fffffe          BL       memp_free
;;;137          break;
0000b8  e013              B        |L10.226|
;;;138    
;;;139        case TCPIP_MSG_CALLBACK_STATIC:
;;;140          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK_STATIC %p\n", (void *)msg));
0000ba  bf00              NOP      
0000bc  bf00              NOP      
;;;141          msg->msg.cb.function(msg->msg.cb.ctx);
0000be  9a00              LDR      r2,[sp,#0]
0000c0  e9d21002          LDRD     r1,r0,[r2,#8]
0000c4  4788              BLX      r1
;;;142          break;
0000c6  e00c              B        |L10.226|
                  |L10.200|
;;;143    
;;;144        default:
;;;145          LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: %d\n", msg->type));
0000c8  bf00              NOP      
0000ca  bf00              NOP      
;;;146          LWIP_ASSERT("tcpip_thread: invalid message", 0);
0000cc  bf00              NOP      
0000ce  bf00              NOP      
0000d0  a308              ADR      r3,|L10.244|
0000d2  2292              MOVS     r2,#0x92
0000d4  a110              ADR      r1,|L10.280|
0000d6  a018              ADR      r0,|L10.312|
0000d8  f7fffffe          BL       __2printf
0000dc  bf00              NOP      
0000de  bf00              NOP      
;;;147          break;
0000e0  bf00              NOP      
                  |L10.226|
0000e2  bf00              NOP                            ;95
                  |L10.228|
0000e4  e796              B        |L10.20|
;;;148        }
;;;149      }
;;;150    }
;;;151    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L10.232|
                          DCD      tcpip_init_done
                  |L10.236|
                          DCD      tcpip_init_done_arg
                  |L10.240|
                          DCD      mbox
                  |L10.244|
0000f4  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\api\\tcpip.c",0
0000f8  5749505c
0000fc  6c776970
000100  2d312e34
000104  2e315c73
000108  72635c61
00010c  70695c74
000110  63706970
000114  2e6300  
000117  00                DCB      0
                  |L10.280|
000118  74637069          DCB      "tcpip_thread: invalid message",0
00011c  705f7468
000120  72656164
000124  3a20696e
000128  76616c69
00012c  64206d65
000130  73736167
000134  6500    
000136  00                DCB      0
000137  00                DCB      0
                  |L10.312|
000138  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
00013c  7274696f
000140  6e202225
000144  73222066
000148  61696c65
00014c  64206174
000150  206c696e
000154  65202564
000158  20696e20
00015c  25730d0a
000160  00      
000161  00                DCB      0
000162  00                DCB      0
000163  00                DCB      0

                          AREA ||i.tcpip_timeout||, CODE, READONLY, ALIGN=2

                  tcpip_timeout PROC
;;;246    err_t
;;;247    tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;248    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;249      struct tcpip_msg *msg;
;;;250    
;;;251      if (sys_mbox_valid(&mbox)) {
00000a  480d              LDR      r0,|L11.64|
00000c  f7fffffe          BL       sys_mbox_valid
000010  b198              CBZ      r0,|L11.58|
;;;252        msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
000012  2009              MOVS     r0,#9
000014  f7fffffe          BL       memp_malloc
000018  4604              MOV      r4,r0
;;;253        if (msg == NULL) {
00001a  b91c              CBNZ     r4,|L11.36|
;;;254          return ERR_MEM;
00001c  f04f30ff          MOV      r0,#0xffffffff
                  |L11.32|
;;;255        }
;;;256    
;;;257        msg->type = TCPIP_MSG_TIMEOUT;
;;;258        msg->msg.tmo.msecs = msecs;
;;;259        msg->msg.tmo.h = h;
;;;260        msg->msg.tmo.arg = arg;
;;;261        sys_mbox_post(&mbox, msg);
;;;262        return ERR_OK;
;;;263      }
;;;264      return ERR_VAL;
;;;265    }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L11.36|
000024  2002              MOVS     r0,#2                 ;257
000026  7020              STRB     r0,[r4,#0]            ;257
000028  60a5              STR      r5,[r4,#8]            ;258
00002a  60e6              STR      r6,[r4,#0xc]          ;259
00002c  6127              STR      r7,[r4,#0x10]         ;260
00002e  4621              MOV      r1,r4                 ;261
000030  4803              LDR      r0,|L11.64|
000032  f7fffffe          BL       sys_mbox_post
000036  2000              MOVS     r0,#0                 ;262
000038  e7f2              B        |L11.32|
                  |L11.58|
00003a  f06f0005          MVN      r0,#5                 ;264
00003e  e7ef              B        |L11.32|
;;;266    
                          ENDP

                  |L11.64|
                          DCD      mbox

                          AREA ||i.tcpip_trycallback||, CODE, READONLY, ALIGN=2

                  tcpip_trycallback PROC
;;;437    err_t
;;;438    tcpip_trycallback(struct tcpip_callback_msg* msg)
000000  b510              PUSH     {r4,lr}
;;;439    {
000002  4604              MOV      r4,r0
;;;440      if (!sys_mbox_valid(&mbox)) {
000004  4805              LDR      r0,|L12.28|
000006  f7fffffe          BL       sys_mbox_valid
00000a  b910              CBNZ     r0,|L12.18|
;;;441        return ERR_VAL;
00000c  f06f0005          MVN      r0,#5
                  |L12.16|
;;;442      }
;;;443      return sys_mbox_trypost(&mbox, msg);
;;;444    }
000010  bd10              POP      {r4,pc}
                  |L12.18|
000012  4621              MOV      r1,r4                 ;443
000014  4801              LDR      r0,|L12.28|
000016  f7fffffe          BL       sys_mbox_trypost
00001a  e7f9              B        |L12.16|
;;;445    
                          ENDP

                  |L12.28|
                          DCD      mbox

                          AREA ||i.tcpip_untimeout||, CODE, READONLY, ALIGN=2

                  tcpip_untimeout PROC
;;;275    err_t
;;;276    tcpip_untimeout(sys_timeout_handler h, void *arg)
000000  b570              PUSH     {r4-r6,lr}
;;;277    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;278      struct tcpip_msg *msg;
;;;279    
;;;280      if (sys_mbox_valid(&mbox)) {
000006  480c              LDR      r0,|L13.56|
000008  f7fffffe          BL       sys_mbox_valid
00000c  b188              CBZ      r0,|L13.50|
;;;281        msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
00000e  2009              MOVS     r0,#9
000010  f7fffffe          BL       memp_malloc
000014  4604              MOV      r4,r0
;;;282        if (msg == NULL) {
000016  b914              CBNZ     r4,|L13.30|
;;;283          return ERR_MEM;
000018  f04f30ff          MOV      r0,#0xffffffff
                  |L13.28|
;;;284        }
;;;285    
;;;286        msg->type = TCPIP_MSG_UNTIMEOUT;
;;;287        msg->msg.tmo.h = h;
;;;288        msg->msg.tmo.arg = arg;
;;;289        sys_mbox_post(&mbox, msg);
;;;290        return ERR_OK;
;;;291      }
;;;292      return ERR_VAL;
;;;293    }
00001c  bd70              POP      {r4-r6,pc}
                  |L13.30|
00001e  2003              MOVS     r0,#3                 ;286
000020  7020              STRB     r0,[r4,#0]            ;286
000022  60e5              STR      r5,[r4,#0xc]          ;287
000024  6126              STR      r6,[r4,#0x10]         ;288
000026  4621              MOV      r1,r4                 ;289
000028  4803              LDR      r0,|L13.56|
00002a  f7fffffe          BL       sys_mbox_post
00002e  2000              MOVS     r0,#0                 ;290
000030  e7f4              B        |L13.28|
                  |L13.50|
000032  f06f0005          MVN      r0,#5                 ;292
000036  e7f1              B        |L13.28|
;;;294    #endif /* LWIP_TCPIP_TIMEOUT */
                          ENDP

                  |L13.56|
                          DCD      mbox

                          AREA ||.data||, DATA, ALIGN=2

                  tcpip_init_done
                          DCD      0x00000000
                  tcpip_init_done_arg
                          DCD      0x00000000
                  mbox
                          DCD      0x00000000
