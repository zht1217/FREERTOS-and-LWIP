; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\mem.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\mem.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\mem.crf ..\LWIP\lwip-1.4.1\src\core\mem.c]
                          THUMB

                          AREA ||i.mem_calloc||, CODE, READONLY, ALIGN=1

                  mem_calloc PROC
;;;647     */
;;;648    void *mem_calloc(mem_size_t count, mem_size_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;649    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;650      void *p;
;;;651    
;;;652      /* allocate 'count' objects of size 'size' */
;;;653      p = mem_malloc(count * size);
000006  fb04f105          MUL      r1,r4,r5
00000a  b288              UXTH     r0,r1
00000c  f7fffffe          BL       mem_malloc
000010  4606              MOV      r6,r0
;;;654      if (p) {
000012  b126              CBZ      r6,|L1.30|
;;;655        /* zero the memory */
;;;656        memset(p, 0, count * size);
000014  fb04f105          MUL      r1,r4,r5
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       __aeabi_memclr
                  |L1.30|
;;;657      }
;;;658      return p;
00001e  4630              MOV      r0,r6
;;;659    }
000020  bd70              POP      {r4-r6,pc}
;;;660    
                          ENDP


                          AREA ||i.mem_free||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  mem_free PROC
;;;312    void
;;;313    mem_free(void *rmem)
000000  b570              PUSH     {r4-r6,lr}
;;;314    {
000002  4604              MOV      r4,r0
;;;315      struct mem *mem;
;;;316      LWIP_MEM_FREE_DECL_PROTECT();
;;;317    
;;;318      if (rmem == NULL) {
000004  b914              CBNZ     r4,|L2.12|
;;;319        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
000006  bf00              NOP      
000008  bf00              NOP      
                  |L2.10|
;;;320        return;
;;;321      }
;;;322      LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
;;;323    
;;;324      LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
;;;325        (u8_t *)rmem < (u8_t *)ram_end);
;;;326    
;;;327      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
;;;328        SYS_ARCH_DECL_PROTECT(lev);
;;;329        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
;;;330        /* protect mem stats from concurrent access */
;;;331        SYS_ARCH_PROTECT(lev);
;;;332        MEM_STATS_INC(illegal);
;;;333        SYS_ARCH_UNPROTECT(lev);
;;;334        return;
;;;335      }
;;;336      /* protect the heap from concurrent access */
;;;337      LWIP_MEM_FREE_PROTECT();
;;;338      /* Get the corresponding struct mem ... */
;;;339      mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;340      /* ... which has to be in a used state ... */
;;;341      LWIP_ASSERT("mem_free: mem->used", mem->used);
;;;342      /* ... and is now unused. */
;;;343      mem->used = 0;
;;;344    
;;;345      if (mem < lfree) {
;;;346        /* the newly freed struct is now the lowest */
;;;347        lfree = mem;
;;;348      }
;;;349    
;;;350      MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
;;;351    
;;;352      /* finally, see if prev or next are free also */
;;;353      plug_holes(mem);
;;;354    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;355      mem_free_count = 1;
;;;356    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;357      LWIP_MEM_FREE_UNPROTECT();
;;;358    }
00000a  bd70              POP      {r4-r6,pc}
                  |L2.12|
00000c  bf00              NOP                            ;322
00000e  f0040003          AND      r0,r4,#3              ;322
000012  b140              CBZ      r0,|L2.38|
000014  bf00              NOP                            ;322
000016  a328              ADR      r3,|L2.184|
000018  f44f72a1          MOV      r2,#0x142             ;322
00001c  a12f              ADR      r1,|L2.220|
00001e  a038              ADR      r0,|L2.256|
000020  f7fffffe          BL       __2printf
000024  bf00              NOP                            ;322
                  |L2.38|
000026  bf00              NOP                            ;322
000028  bf00              NOP                            ;324
00002a  4840              LDR      r0,|L2.300|
00002c  6800              LDR      r0,[r0,#0]            ;324  ; ram
00002e  4284              CMP      r4,r0                 ;324
000030  d303              BCC      |L2.58|
000032  483f              LDR      r0,|L2.304|
000034  6800              LDR      r0,[r0,#0]            ;324  ; ram_end
000036  4284              CMP      r4,r0                 ;324
000038  d308              BCC      |L2.76|
                  |L2.58|
00003a  bf00              NOP                            ;324
00003c  a31e              ADR      r3,|L2.184|
00003e  f44f72a2          MOV      r2,#0x144             ;324
000042  a13c              ADR      r1,|L2.308|
000044  a02e              ADR      r0,|L2.256|
000046  f7fffffe          BL       __2printf
00004a  bf00              NOP                            ;324
                  |L2.76|
00004c  bf00              NOP                            ;324
00004e  4837              LDR      r0,|L2.300|
000050  6800              LDR      r0,[r0,#0]            ;327  ; ram
000052  4284              CMP      r4,r0                 ;327
000054  d303              BCC      |L2.94|
000056  4836              LDR      r0,|L2.304|
000058  6800              LDR      r0,[r0,#0]            ;327  ; ram_end
00005a  4284              CMP      r4,r0                 ;327
00005c  d308              BCC      |L2.112|
                  |L2.94|
00005e  bf00              NOP                            ;329
000060  bf00              NOP                            ;329
000062  f7fffffe          BL       sys_arch_protect
000066  4606              MOV      r6,r0                 ;331
000068  4630              MOV      r0,r6                 ;333
00006a  f7fffffe          BL       sys_arch_unprotect
00006e  e7cc              B        |L2.10|
                  |L2.112|
000070  2100              MOVS     r1,#0                 ;337
000072  4836              LDR      r0,|L2.332|
000074  f7fffffe          BL       sys_arch_sem_wait
000078  f1a40508          SUB      r5,r4,#8              ;339
00007c  bf00              NOP                            ;341
00007e  7928              LDRB     r0,[r5,#4]            ;341
000080  b940              CBNZ     r0,|L2.148|
000082  bf00              NOP                            ;341
000084  a30c              ADR      r3,|L2.184|
000086  f2401255          MOV      r2,#0x155             ;341
00008a  a131              ADR      r1,|L2.336|
00008c  a01c              ADR      r0,|L2.256|
00008e  f7fffffe          BL       __2printf
000092  bf00              NOP                            ;341
                  |L2.148|
000094  bf00              NOP                            ;341
000096  2000              MOVS     r0,#0                 ;343
000098  7128              STRB     r0,[r5,#4]            ;343
00009a  4832              LDR      r0,|L2.356|
00009c  6800              LDR      r0,[r0,#0]            ;345  ; lfree
00009e  4285              CMP      r5,r0                 ;345
0000a0  d201              BCS      |L2.166|
0000a2  4830              LDR      r0,|L2.356|
0000a4  6005              STR      r5,[r0,#0]            ;347  ; lfree
                  |L2.166|
0000a6  4628              MOV      r0,r5                 ;353
0000a8  f7fffffe          BL       plug_holes
0000ac  4827              LDR      r0,|L2.332|
0000ae  f7fffffe          BL       sys_sem_signal
0000b2  bf00              NOP      
0000b4  e7a9              B        |L2.10|
;;;359    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L2.184|
0000b8  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\mem.c",0
0000bc  5749505c
0000c0  6c776970
0000c4  2d312e34
0000c8  2e315c73
0000cc  72635c63
0000d0  6f72655c
0000d4  6d656d2e
0000d8  6300    
0000da  00                DCB      0
0000db  00                DCB      0
                  |L2.220|
0000dc  6d656d5f          DCB      "mem_free: sanity check alignment",0
0000e0  66726565
0000e4  3a207361
0000e8  6e697479
0000ec  20636865
0000f0  636b2061
0000f4  6c69676e
0000f8  6d656e74
0000fc  00      
0000fd  00                DCB      0
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L2.256|
000100  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000104  7274696f
000108  6e202225
00010c  73222066
000110  61696c65
000114  64206174
000118  206c696e
00011c  65202564
000120  20696e20
000124  25730d0a
000128  00      
000129  00                DCB      0
00012a  00                DCB      0
00012b  00                DCB      0
                  |L2.300|
                          DCD      ||ram||
                  |L2.304|
                          DCD      ram_end
                  |L2.308|
000134  6d656d5f          DCB      "mem_free: legal memory",0
000138  66726565
00013c  3a206c65
000140  67616c20
000144  6d656d6f
000148  727900  
00014b  00                DCB      0
                  |L2.332|
                          DCD      mem_mutex
                  |L2.336|
000150  6d656d5f          DCB      "mem_free: mem->used",0
000154  66726565
000158  3a206d65
00015c  6d2d3e75
000160  73656400
                  |L2.356|
                          DCD      lfree

                          AREA ||i.mem_init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  mem_init PROC
;;;275    void
;;;276    mem_init(void)
000000  b510              PUSH     {r4,lr}
;;;277    {
;;;278      struct mem *mem;
;;;279    
;;;280      LWIP_ASSERT("Sanity check alignment",
000002  bf00              NOP      
000004  bf00              NOP      
;;;281        (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);
;;;282    
;;;283      /* align the heap */
;;;284      ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
000006  481b              LDR      r0,|L3.116|
000008  6800              LDR      r0,[r0,#0]  ; ram_heap
00000a  1cc0              ADDS     r0,r0,#3
00000c  f0200003          BIC      r0,r0,#3
000010  4919              LDR      r1,|L3.120|
000012  6008              STR      r0,[r1,#0]  ; ram
;;;285      /* initialize the start of the heap */
;;;286      mem = (struct mem *)(void *)ram;
000014  4608              MOV      r0,r1
000016  6804              LDR      r4,[r0,#0]  ; ram
;;;287      mem->next = MEM_SIZE_ALIGNED;
000018  f44f50c0          MOV      r0,#0x1800
00001c  8020              STRH     r0,[r4,#0]
;;;288      mem->prev = 0;
00001e  2000              MOVS     r0,#0
000020  8060              STRH     r0,[r4,#2]
;;;289      mem->used = 0;
000022  7120              STRB     r0,[r4,#4]
;;;290      /* initialize the end of the heap */
;;;291      ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
000024  4608              MOV      r0,r1
000026  6800              LDR      r0,[r0,#0]  ; ram
000028  f50050c0          ADD      r0,r0,#0x1800
00002c  4913              LDR      r1,|L3.124|
00002e  6008              STR      r0,[r1,#0]  ; ram_end
;;;292      ram_end->used = 1;
000030  2001              MOVS     r0,#1
000032  6809              LDR      r1,[r1,#0]  ; ram_end
000034  7108              STRB     r0,[r1,#4]
;;;293      ram_end->next = MEM_SIZE_ALIGNED;
000036  f44f50c0          MOV      r0,#0x1800
00003a  4910              LDR      r1,|L3.124|
00003c  6809              LDR      r1,[r1,#0]  ; ram_end
00003e  8008              STRH     r0,[r1,#0]
;;;294      ram_end->prev = MEM_SIZE_ALIGNED;
000040  490e              LDR      r1,|L3.124|
000042  6809              LDR      r1,[r1,#0]  ; ram_end
000044  8048              STRH     r0,[r1,#2]
;;;295    
;;;296      /* initialize the lowest-free pointer to the start of the heap */
;;;297      lfree = (struct mem *)(void *)ram;
000046  480c              LDR      r0,|L3.120|
000048  6800              LDR      r0,[r0,#0]  ; ram
00004a  490d              LDR      r1,|L3.128|
00004c  6008              STR      r0,[r1,#0]  ; lfree
;;;298    
;;;299      MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
;;;300    
;;;301      if(sys_mutex_new(&mem_mutex) != ERR_OK) {
00004e  2101              MOVS     r1,#1
000050  480c              LDR      r0,|L3.132|
000052  f7fffffe          BL       sys_sem_new
000056  2800              CMP      r0,#0
000058  d00a              BEQ      |L3.112|
;;;302        LWIP_ASSERT("failed to create mem_mutex", 0);
00005a  bf00              NOP      
00005c  bf00              NOP      
00005e  a30a              ADR      r3,|L3.136|
000060  f44f7297          MOV      r2,#0x12e
000064  a111              ADR      r1,|L3.172|
000066  a018              ADR      r0,|L3.200|
000068  f7fffffe          BL       __2printf
00006c  bf00              NOP      
00006e  bf00              NOP      
                  |L3.112|
;;;303      }
;;;304    }
000070  bd10              POP      {r4,pc}
;;;305    
                          ENDP

000072  0000              DCW      0x0000
                  |L3.116|
                          DCD      ram_heap
                  |L3.120|
                          DCD      ||ram||
                  |L3.124|
                          DCD      ram_end
                  |L3.128|
                          DCD      lfree
                  |L3.132|
                          DCD      mem_mutex
                  |L3.136|
000088  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\mem.c",0
00008c  5749505c
000090  6c776970
000094  2d312e34
000098  2e315c73
00009c  72635c63
0000a0  6f72655c
0000a4  6d656d2e
0000a8  6300    
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L3.172|
0000ac  6661696c          DCB      "failed to create mem_mutex",0
0000b0  65642074
0000b4  6f206372
0000b8  65617465
0000bc  206d656d
0000c0  5f6d7574
0000c4  657800  
0000c7  00                DCB      0
                  |L3.200|
0000c8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000cc  7274696f
0000d0  6e202225
0000d4  73222066
0000d8  61696c65
0000dc  64206174
0000e0  206c696e
0000e4  65202564
0000e8  20696e20
0000ec  25730d0a
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0

                          AREA ||i.mem_malloc||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  mem_malloc PROC
;;;495    void *
;;;496    mem_malloc(mem_size_t size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;497    {
000004  4605              MOV      r5,r0
;;;498      mem_size_t ptr, ptr2;
;;;499      struct mem *mem, *mem2;
;;;500    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;501      u8_t local_mem_free_count = 0;
;;;502    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;503      LWIP_MEM_ALLOC_DECL_PROTECT();
;;;504    
;;;505      if (size == 0) {
000006  b915              CBNZ     r5,|L4.14|
;;;506        return NULL;
000008  2000              MOVS     r0,#0
                  |L4.10|
;;;507      }
;;;508    
;;;509      /* Expand the size of the allocated memory region so that we can
;;;510         adjust for alignment. */
;;;511      size = LWIP_MEM_ALIGN_SIZE(size);
;;;512    
;;;513      if(size < MIN_SIZE_ALIGNED) {
;;;514        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;515        size = MIN_SIZE_ALIGNED;
;;;516      }
;;;517    
;;;518      if (size > MEM_SIZE_ALIGNED) {
;;;519        return NULL;
;;;520      }
;;;521    
;;;522      /* protect the heap from concurrent access */
;;;523      sys_mutex_lock(&mem_mutex);
;;;524      LWIP_MEM_ALLOC_PROTECT();
;;;525    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;526      /* run as long as a mem_free disturbed mem_malloc or mem_trim */
;;;527      do {
;;;528        local_mem_free_count = 0;
;;;529    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;530    
;;;531        /* Scan through the heap searching for a free block that is big enough,
;;;532         * beginning with the lowest free block.
;;;533         */
;;;534        for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
;;;535             ptr = ((struct mem *)(void *)&ram[ptr])->next) {
;;;536          mem = (struct mem *)(void *)&ram[ptr];
;;;537    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;538          mem_free_count = 0;
;;;539          LWIP_MEM_ALLOC_UNPROTECT();
;;;540          /* allow mem_free or mem_trim to run */
;;;541          LWIP_MEM_ALLOC_PROTECT();
;;;542          if (mem_free_count != 0) {
;;;543            /* If mem_free or mem_trim have run, we have to restart since they
;;;544               could have altered our current struct mem. */
;;;545            local_mem_free_count = 1;
;;;546            break;
;;;547          }
;;;548    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;549    
;;;550          if ((!mem->used) &&
;;;551              (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
;;;552            /* mem is not used and at least perfect fit is possible:
;;;553             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
;;;554    
;;;555            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
;;;556              /* (in addition to the above, we test if another struct mem (SIZEOF_STRUCT_MEM) containing
;;;557               * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')
;;;558               * -> split large block, create empty remainder,
;;;559               * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if
;;;560               * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
;;;561               * struct mem would fit in but no data between mem2 and mem2->next
;;;562               * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;563               *       region that couldn't hold data, but when mem->next gets freed,
;;;564               *       the 2 regions would be combined, resulting in more free memory
;;;565               */
;;;566              ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
;;;567              /* create mem2 struct */
;;;568              mem2 = (struct mem *)(void *)&ram[ptr2];
;;;569              mem2->used = 0;
;;;570              mem2->next = mem->next;
;;;571              mem2->prev = ptr;
;;;572              /* and insert it between mem and mem->next */
;;;573              mem->next = ptr2;
;;;574              mem->used = 1;
;;;575    
;;;576              if (mem2->next != MEM_SIZE_ALIGNED) {
;;;577                ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;578              }
;;;579              MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
;;;580            } else {
;;;581              /* (a mem2 struct does no fit into the user data space of mem and mem->next will always
;;;582               * be used at this point: if not we have 2 unused structs in a row, plug_holes should have
;;;583               * take care of this).
;;;584               * -> near fit or excact fit: do not split, no mem2 creation
;;;585               * also can't move mem->next directly behind mem, since mem->next
;;;586               * will always be used at this point!
;;;587               */
;;;588              mem->used = 1;
;;;589              MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
;;;590            }
;;;591    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;592    mem_malloc_adjust_lfree:
;;;593    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;594            if (mem == lfree) {
;;;595              struct mem *cur = lfree;
;;;596              /* Find next free block after mem and update lowest free pointer */
;;;597              while (cur->used && cur != ram_end) {
;;;598    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;599                mem_free_count = 0;
;;;600                LWIP_MEM_ALLOC_UNPROTECT();
;;;601                /* prevent high interrupt latency... */
;;;602                LWIP_MEM_ALLOC_PROTECT();
;;;603                if (mem_free_count != 0) {
;;;604                  /* If mem_free or mem_trim have run, we have to restart since they
;;;605                     could have altered our current struct mem or lfree. */
;;;606                  goto mem_malloc_adjust_lfree;
;;;607                }
;;;608    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;609                cur = (struct mem *)(void *)&ram[cur->next];
;;;610              }
;;;611              lfree = cur;
;;;612              LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
;;;613            }
;;;614            LWIP_MEM_ALLOC_UNPROTECT();
;;;615            sys_mutex_unlock(&mem_mutex);
;;;616            LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
;;;617             (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
;;;618            LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
;;;619             ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
;;;620            LWIP_ASSERT("mem_malloc: sanity check alignment",
;;;621              (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);
;;;622    
;;;623            return (u8_t *)mem + SIZEOF_STRUCT_MEM;
;;;624          }
;;;625        }
;;;626    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;627        /* if we got interrupted by a mem_free, try again */
;;;628      } while(local_mem_free_count != 0);
;;;629    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;630      LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
;;;631      MEM_STATS_INC(err);
;;;632      LWIP_MEM_ALLOC_UNPROTECT();
;;;633      sys_mutex_unlock(&mem_mutex);
;;;634      return NULL;
;;;635    }
00000a  e8bd87f0          POP      {r4-r10,pc}
                  |L4.14|
00000e  1ce8              ADDS     r0,r5,#3              ;511
000010  f0200003          BIC      r0,r0,#3              ;511
000014  b285              UXTH     r5,r0                 ;511
000016  2d0c              CMP      r5,#0xc               ;513
000018  da00              BGE      |L4.28|
00001a  250c              MOVS     r5,#0xc               ;515
                  |L4.28|
00001c  f5b55fc0          CMP      r5,#0x1800            ;518
000020  dd01              BLE      |L4.38|
000022  2000              MOVS     r0,#0                 ;519
000024  e7f1              B        |L4.10|
                  |L4.38|
000026  2100              MOVS     r1,#0                 ;523
000028  4857              LDR      r0,|L4.392|
00002a  f7fffffe          BL       sys_arch_sem_wait
00002e  4857              LDR      r0,|L4.396|
000030  8800              LDRH     r0,[r0,#0]            ;534  ; lfree
000032  4957              LDR      r1,|L4.400|
000034  8809              LDRH     r1,[r1,#0]            ;534  ; ram
000036  1a40              SUBS     r0,r0,r1              ;534
000038  b286              UXTH     r6,r0                 ;534
00003a  e098              B        |L4.366|
                  |L4.60|
00003c  4854              LDR      r0,|L4.400|
00003e  6800              LDR      r0,[r0,#0]            ;536  ; ram
000040  1984              ADDS     r4,r0,r6              ;536
000042  7920              LDRB     r0,[r4,#4]            ;550
000044  2800              CMP      r0,#0                 ;550
000046  d17d              BNE      |L4.324|
000048  8821              LDRH     r1,[r4,#0]            ;551
00004a  f1060008          ADD      r0,r6,#8              ;551
00004e  1a08              SUBS     r0,r1,r0              ;551
000050  42a8              CMP      r0,r5                 ;551
000052  d377              BCC      |L4.324|
000054  8821              LDRH     r1,[r4,#0]            ;555
000056  f1060008          ADD      r0,r6,#8              ;555
00005a  1a09              SUBS     r1,r1,r0              ;555
00005c  f1050014          ADD      r0,r5,#0x14           ;555
000060  4281              CMP      r1,r0                 ;555
000062  d31c              BCC      |L4.158|
000064  f1060008          ADD      r0,r6,#8              ;566
000068  4428              ADD      r0,r0,r5              ;566
00006a  fa1ff880          UXTH     r8,r0                 ;566
00006e  4848              LDR      r0,|L4.400|
000070  6800              LDR      r0,[r0,#0]            ;568  ; ram
000072  eb000708          ADD      r7,r0,r8              ;568
000076  2000              MOVS     r0,#0                 ;569
000078  7138              STRB     r0,[r7,#4]            ;569
00007a  8820              LDRH     r0,[r4,#0]            ;570
00007c  8038              STRH     r0,[r7,#0]            ;570
00007e  807e              STRH     r6,[r7,#2]            ;571
000080  f8a48000          STRH     r8,[r4,#0]            ;573
000084  2001              MOVS     r0,#1                 ;574
000086  7120              STRB     r0,[r4,#4]            ;574
000088  8838              LDRH     r0,[r7,#0]            ;576
00008a  f5b05fc0          CMP      r0,#0x1800            ;576
00008e  d008              BEQ      |L4.162|
000090  8838              LDRH     r0,[r7,#0]            ;577
000092  493f              LDR      r1,|L4.400|
000094  6809              LDR      r1,[r1,#0]            ;577  ; ram
000096  4408              ADD      r0,r0,r1              ;577
000098  f8a08002          STRH     r8,[r0,#2]            ;577
00009c  e001              B        |L4.162|
                  |L4.158|
00009e  2001              MOVS     r0,#1                 ;588
0000a0  7120              STRB     r0,[r4,#4]            ;588
                  |L4.162|
0000a2  483a              LDR      r0,|L4.396|
0000a4  6800              LDR      r0,[r0,#0]            ;594  ; lfree
0000a6  4284              CMP      r4,r0                 ;594
0000a8  d128              BNE      |L4.252|
0000aa  4838              LDR      r0,|L4.396|
0000ac  f8d09000          LDR      r9,[r0,#0]            ;595  ; lfree
0000b0  e005              B        |L4.190|
                  |L4.178|
0000b2  f8b90000          LDRH     r0,[r9,#0]            ;609
0000b6  4936              LDR      r1,|L4.400|
0000b8  6809              LDR      r1,[r1,#0]            ;609  ; ram
0000ba  eb000901          ADD      r9,r0,r1              ;609
                  |L4.190|
0000be  f8990004          LDRB     r0,[r9,#4]            ;597
0000c2  b118              CBZ      r0,|L4.204|
0000c4  4833              LDR      r0,|L4.404|
0000c6  6800              LDR      r0,[r0,#0]            ;597  ; ram_end
0000c8  4581              CMP      r9,r0                 ;597
0000ca  d1f2              BNE      |L4.178|
                  |L4.204|
0000cc  482f              LDR      r0,|L4.396|
0000ce  f8c09000          STR      r9,[r0,#0]            ;611  ; lfree
0000d2  bf00              NOP                            ;612
0000d4  6800              LDR      r0,[r0,#0]            ;612  ; lfree
0000d6  492f              LDR      r1,|L4.404|
0000d8  6809              LDR      r1,[r1,#0]            ;612  ; ram_end
0000da  4288              CMP      r0,r1                 ;612
0000dc  d00c              BEQ      |L4.248|
0000de  482b              LDR      r0,|L4.396|
0000e0  6800              LDR      r0,[r0,#0]            ;612  ; lfree
0000e2  7900              LDRB     r0,[r0,#4]            ;612
0000e4  b140              CBZ      r0,|L4.248|
0000e6  bf00              NOP                            ;612
0000e8  a32b              ADR      r3,|L4.408|
0000ea  f44f7219          MOV      r2,#0x264             ;612
0000ee  a133              ADR      r1,|L4.444|
0000f0  a039              ADR      r0,|L4.472|
0000f2  f7fffffe          BL       __2printf
0000f6  bf00              NOP                            ;612
                  |L4.248|
0000f8  bf00              NOP                            ;612
0000fa  bf00              NOP                            ;613
                  |L4.252|
0000fc  4822              LDR      r0,|L4.392|
0000fe  f7fffffe          BL       sys_sem_signal
000102  bf00              NOP                            ;616
000104  f1040008          ADD      r0,r4,#8              ;616
000108  4428              ADD      r0,r0,r5              ;616
00010a  4922              LDR      r1,|L4.404|
00010c  6809              LDR      r1,[r1,#0]            ;616  ; ram_end
00010e  4288              CMP      r0,r1                 ;616
000110  d908              BLS      |L4.292|
000112  bf00              NOP                            ;616
000114  a320              ADR      r3,|L4.408|
000116  f44f721a          MOV      r2,#0x268             ;616
00011a  a13a              ADR      r1,|L4.516|
00011c  a02e              ADR      r0,|L4.472|
00011e  f7fffffe          BL       __2printf
000122  bf00              NOP                            ;616
                  |L4.292|
000124  bf00              NOP                            ;616
000126  bf00              NOP                            ;618
000128  f0040003          AND      r0,r4,#3              ;618
00012c  b140              CBZ      r0,|L4.320|
00012e  bf00              NOP                            ;618
000130  a319              ADR      r3,|L4.408|
000132  f240226a          MOV      r2,#0x26a             ;618
000136  a13f              ADR      r1,|L4.564|
000138  a027              ADR      r0,|L4.472|
00013a  f7fffffe          BL       __2printf
00013e  bf00              NOP                            ;618
                  |L4.320|
000140  bf00              NOP                            ;618
000142  e000              B        |L4.326|
                  |L4.324|
000144  e010              B        |L4.360|
                  |L4.326|
000146  bf00              NOP                            ;620
000148  f0040003          AND      r0,r4,#3              ;620
00014c  b140              CBZ      r0,|L4.352|
00014e  bf00              NOP                            ;620
000150  a311              ADR      r3,|L4.408|
000152  f44f721b          MOV      r2,#0x26c             ;620
000156  a143              ADR      r1,|L4.612|
000158  a01f              ADR      r0,|L4.472|
00015a  f7fffffe          BL       __2printf
00015e  bf00              NOP                            ;620
                  |L4.352|
000160  bf00              NOP                            ;620
000162  f1040008          ADD      r0,r4,#8              ;623
000166  e750              B        |L4.10|
                  |L4.360|
000168  4809              LDR      r0,|L4.400|
00016a  6800              LDR      r0,[r0,#0]            ;535  ; ram
00016c  5b86              LDRH     r6,[r0,r6]            ;535
                  |L4.366|
00016e  f5c550c0          RSB      r0,r5,#0x1800         ;534
000172  42b0              CMP      r0,r6                 ;534
000174  f73faf62          BGT      |L4.60|
000178  bf00              NOP                            ;630
00017a  bf00              NOP                            ;630
00017c  4802              LDR      r0,|L4.392|
00017e  f7fffffe          BL       sys_sem_signal
000182  2000              MOVS     r0,#0                 ;634
000184  e741              B        |L4.10|
;;;636    
                          ENDP

000186  0000              DCW      0x0000
                  |L4.392|
                          DCD      mem_mutex
                  |L4.396|
                          DCD      lfree
                  |L4.400|
                          DCD      ||ram||
                  |L4.404|
                          DCD      ram_end
                  |L4.408|
000198  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\mem.c",0
00019c  5749505c
0001a0  6c776970
0001a4  2d312e34
0001a8  2e315c73
0001ac  72635c63
0001b0  6f72655c
0001b4  6d656d2e
0001b8  6300    
0001ba  00                DCB      0
0001bb  00                DCB      0
                  |L4.444|
0001bc  6d656d5f          DCB      "mem_malloc: !lfree->used",0
0001c0  6d616c6c
0001c4  6f633a20
0001c8  216c6672
0001cc  65652d3e
0001d0  75736564
0001d4  00      
0001d5  00                DCB      0
0001d6  00                DCB      0
0001d7  00                DCB      0
                  |L4.472|
0001d8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0001dc  7274696f
0001e0  6e202225
0001e4  73222066
0001e8  61696c65
0001ec  64206174
0001f0  206c696e
0001f4  65202564
0001f8  20696e20
0001fc  25730d0a
000200  00      
000201  00                DCB      0
000202  00                DCB      0
000203  00                DCB      0
                  |L4.516|
000204  6d656d5f          DCB      "mem_malloc: allocated memory not above ram_end.",0
000208  6d616c6c
00020c  6f633a20
000210  616c6c6f
000214  63617465
000218  64206d65
00021c  6d6f7279
000220  206e6f74
000224  2061626f
000228  76652072
00022c  616d5f65
000230  6e642e00
                  |L4.564|
000234  6d656d5f          DCB      "mem_malloc: allocated memory properly aligned.",0
000238  6d616c6c
00023c  6f633a20
000240  616c6c6f
000244  63617465
000248  64206d65
00024c  6d6f7279
000250  2070726f
000254  7065726c
000258  7920616c
00025c  69676e65
000260  642e00  
000263  00                DCB      0
                  |L4.612|
000264  6d656d5f          DCB      "mem_malloc: sanity check alignment",0
000268  6d616c6c
00026c  6f633a20
000270  73616e69
000274  74792063
000278  6865636b
00027c  20616c69
000280  676e6d65
000284  6e7400  
000287  00                DCB      0

                          AREA ||i.mem_trim||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  mem_trim PROC
;;;370    void *
;;;371    mem_trim(void *rmem, mem_size_t newsize)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;372    {
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
;;;373      mem_size_t size;
;;;374      mem_size_t ptr, ptr2;
;;;375      struct mem *mem, *mem2;
;;;376      /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
;;;377      LWIP_MEM_FREE_DECL_PROTECT();
;;;378    
;;;379      /* Expand the size of the allocated memory region so that we can
;;;380         adjust for alignment. */
;;;381      newsize = LWIP_MEM_ALIGN_SIZE(newsize);
000008  1ce8              ADDS     r0,r5,#3
00000a  f0200003          BIC      r0,r0,#3
00000e  b285              UXTH     r5,r0
;;;382    
;;;383      if(newsize < MIN_SIZE_ALIGNED) {
000010  2d0c              CMP      r5,#0xc
000012  da00              BGE      |L5.22|
;;;384        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;385        newsize = MIN_SIZE_ALIGNED;
000014  250c              MOVS     r5,#0xc
                  |L5.22|
;;;386      }
;;;387    
;;;388      if (newsize > MEM_SIZE_ALIGNED) {
000016  f5b55fc0          CMP      r5,#0x1800
00001a  dd02              BLE      |L5.34|
;;;389        return NULL;
00001c  2000              MOVS     r0,#0
                  |L5.30|
;;;390      }
;;;391    
;;;392      LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
;;;393       (u8_t *)rmem < (u8_t *)ram_end);
;;;394    
;;;395      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
;;;396        SYS_ARCH_DECL_PROTECT(lev);
;;;397        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
;;;398        /* protect mem stats from concurrent access */
;;;399        SYS_ARCH_PROTECT(lev);
;;;400        MEM_STATS_INC(illegal);
;;;401        SYS_ARCH_UNPROTECT(lev);
;;;402        return rmem;
;;;403      }
;;;404      /* Get the corresponding struct mem ... */
;;;405      mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;406      /* ... and its offset pointer */
;;;407      ptr = (mem_size_t)((u8_t *)mem - ram);
;;;408    
;;;409      size = mem->next - ptr - SIZEOF_STRUCT_MEM;
;;;410      LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
;;;411      if (newsize > size) {
;;;412        /* not supported */
;;;413        return NULL;
;;;414      }
;;;415      if (newsize == size) {
;;;416        /* No change in size, simply return */
;;;417        return rmem;
;;;418      }
;;;419    
;;;420      /* protect the heap from concurrent access */
;;;421      LWIP_MEM_FREE_PROTECT();
;;;422    
;;;423      mem2 = (struct mem *)(void *)&ram[mem->next];
;;;424      if(mem2->used == 0) {
;;;425        /* The next struct is unused, we can simply move it at little */
;;;426        mem_size_t next;
;;;427        /* remember the old next pointer */
;;;428        next = mem2->next;
;;;429        /* create new struct mem which is moved directly after the shrinked mem */
;;;430        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;431        if (lfree == mem2) {
;;;432          lfree = (struct mem *)(void *)&ram[ptr2];
;;;433        }
;;;434        mem2 = (struct mem *)(void *)&ram[ptr2];
;;;435        mem2->used = 0;
;;;436        /* restore the next pointer */
;;;437        mem2->next = next;
;;;438        /* link it back to mem */
;;;439        mem2->prev = ptr;
;;;440        /* link mem to it */
;;;441        mem->next = ptr2;
;;;442        /* last thing to restore linked list: as we have moved mem2,
;;;443         * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
;;;444         * the end of the heap */
;;;445        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;446          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;447        }
;;;448        MEM_STATS_DEC_USED(used, (size - newsize));
;;;449        /* no need to plug holes, we've already done that */
;;;450      } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
;;;451        /* Next struct is used but there's room for another struct mem with
;;;452         * at least MIN_SIZE_ALIGNED of data.
;;;453         * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
;;;454         * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
;;;455         * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;456         *       region that couldn't hold data, but when mem->next gets freed,
;;;457         *       the 2 regions would be combined, resulting in more free memory */
;;;458        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;459        mem2 = (struct mem *)(void *)&ram[ptr2];
;;;460        if (mem2 < lfree) {
;;;461          lfree = mem2;
;;;462        }
;;;463        mem2->used = 0;
;;;464        mem2->next = mem->next;
;;;465        mem2->prev = ptr;
;;;466        mem->next = ptr2;
;;;467        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;468          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;469        }
;;;470        MEM_STATS_DEC_USED(used, (size - newsize));
;;;471        /* the original mem->next is used, so no need to plug holes! */
;;;472      }
;;;473      /* else {
;;;474        next struct mem is used but size between mem and mem2 is not big enough
;;;475        to create another struct mem
;;;476        -> don't do anyhting. 
;;;477        -> the remaining space stays unused since it is too small
;;;478      } */
;;;479    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;480      mem_free_count = 1;
;;;481    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;482      LWIP_MEM_FREE_UNPROTECT();
;;;483      return rmem;
;;;484    }
00001e  e8bd9ff0          POP      {r4-r12,pc}
                  |L5.34|
000022  bf00              NOP                            ;392
000024  484b              LDR      r0,|L5.340|
000026  6800              LDR      r0,[r0,#0]            ;392  ; ram
000028  4580              CMP      r8,r0                 ;392
00002a  d303              BCC      |L5.52|
00002c  484a              LDR      r0,|L5.344|
00002e  6800              LDR      r0,[r0,#0]            ;392  ; ram_end
000030  4580              CMP      r8,r0                 ;392
000032  d308              BCC      |L5.70|
                  |L5.52|
000034  bf00              NOP                            ;392
000036  a349              ADR      r3,|L5.348|
000038  f44f72c4          MOV      r2,#0x188             ;392
00003c  a150              ADR      r1,|L5.384|
00003e  a056              ADR      r0,|L5.408|
000040  f7fffffe          BL       __2printf
000044  bf00              NOP                            ;392
                  |L5.70|
000046  bf00              NOP                            ;392
000048  4842              LDR      r0,|L5.340|
00004a  6800              LDR      r0,[r0,#0]            ;395  ; ram
00004c  4580              CMP      r8,r0                 ;395
00004e  d303              BCC      |L5.88|
000050  4841              LDR      r0,|L5.344|
000052  6800              LDR      r0,[r0,#0]            ;395  ; ram_end
000054  4580              CMP      r8,r0                 ;395
000056  d309              BCC      |L5.108|
                  |L5.88|
000058  bf00              NOP                            ;397
00005a  bf00              NOP                            ;397
00005c  f7fffffe          BL       sys_arch_protect
000060  4683              MOV      r11,r0                ;399
000062  4658              MOV      r0,r11                ;401
000064  f7fffffe          BL       sys_arch_unprotect
000068  4640              MOV      r0,r8                 ;402
00006a  e7d8              B        |L5.30|
                  |L5.108|
00006c  f1a80708          SUB      r7,r8,#8              ;405
000070  4838              LDR      r0,|L5.340|
000072  8800              LDRH     r0,[r0,#0]            ;407  ; ram
000074  1a38              SUBS     r0,r7,r0              ;407
000076  fa1ff980          UXTH     r9,r0                 ;407
00007a  8838              LDRH     r0,[r7,#0]            ;409
00007c  eba00009          SUB      r0,r0,r9              ;409
000080  3808              SUBS     r0,r0,#8              ;409
000082  fa1ffa80          UXTH     r10,r0                ;409
000086  bf00              NOP                            ;410
000088  4555              CMP      r5,r10                ;410
00008a  dd08              BLE      |L5.158|
00008c  bf00              NOP                            ;410
00008e  a333              ADR      r3,|L5.348|
000090  f44f72cd          MOV      r2,#0x19a             ;410
000094  a14b              ADR      r1,|L5.452|
000096  a040              ADR      r0,|L5.408|
000098  f7fffffe          BL       __2printf
00009c  bf00              NOP                            ;410
                  |L5.158|
00009e  bf00              NOP                            ;410
0000a0  4555              CMP      r5,r10                ;411
0000a2  dd01              BLE      |L5.168|
0000a4  2000              MOVS     r0,#0                 ;413
0000a6  e7ba              B        |L5.30|
                  |L5.168|
0000a8  4555              CMP      r5,r10                ;415
0000aa  d101              BNE      |L5.176|
0000ac  4640              MOV      r0,r8                 ;417
0000ae  e7b6              B        |L5.30|
                  |L5.176|
0000b0  2100              MOVS     r1,#0                 ;421
0000b2  484c              LDR      r0,|L5.484|
0000b4  f7fffffe          BL       sys_arch_sem_wait
0000b8  8838              LDRH     r0,[r7,#0]            ;423
0000ba  4926              LDR      r1,|L5.340|
0000bc  6809              LDR      r1,[r1,#0]            ;423  ; ram
0000be  1844              ADDS     r4,r0,r1              ;423
0000c0  7920              LDRB     r0,[r4,#4]            ;424
0000c2  bb00              CBNZ     r0,|L5.262|
0000c4  8820              LDRH     r0,[r4,#0]            ;428
0000c6  f1090108          ADD      r1,r9,#8              ;430
0000ca  4429              ADD      r1,r1,r5              ;430
0000cc  b28e              UXTH     r6,r1                 ;430
0000ce  4946              LDR      r1,|L5.488|
0000d0  6809              LDR      r1,[r1,#0]            ;431  ; lfree
0000d2  42a1              CMP      r1,r4                 ;431
0000d4  d104              BNE      |L5.224|
0000d6  491f              LDR      r1,|L5.340|
0000d8  6809              LDR      r1,[r1,#0]            ;432  ; ram
0000da  4431              ADD      r1,r1,r6              ;432
0000dc  4a42              LDR      r2,|L5.488|
0000de  6011              STR      r1,[r2,#0]            ;432  ; lfree
                  |L5.224|
0000e0  491c              LDR      r1,|L5.340|
0000e2  6809              LDR      r1,[r1,#0]            ;434  ; ram
0000e4  198c              ADDS     r4,r1,r6              ;434
0000e6  2100              MOVS     r1,#0                 ;435
0000e8  7121              STRB     r1,[r4,#4]            ;435
0000ea  8020              STRH     r0,[r4,#0]            ;437
0000ec  f8a49002          STRH     r9,[r4,#2]            ;439
0000f0  803e              STRH     r6,[r7,#0]            ;441
0000f2  8821              LDRH     r1,[r4,#0]            ;445
0000f4  f5b15fc0          CMP      r1,#0x1800            ;445
0000f8  d004              BEQ      |L5.260|
0000fa  8821              LDRH     r1,[r4,#0]            ;446
0000fc  4a15              LDR      r2,|L5.340|
0000fe  6812              LDR      r2,[r2,#0]            ;446  ; ram
000100  4411              ADD      r1,r1,r2              ;446
000102  804e              STRH     r6,[r1,#2]            ;446
                  |L5.260|
000104  e020              B        |L5.328|
                  |L5.262|
000106  f1050014          ADD      r0,r5,#0x14           ;450
00010a  4550              CMP      r0,r10                ;450
00010c  d81c              BHI      |L5.328|
00010e  f1090008          ADD      r0,r9,#8              ;458
000112  4428              ADD      r0,r0,r5              ;458
000114  b286              UXTH     r6,r0                 ;458
000116  480f              LDR      r0,|L5.340|
000118  6800              LDR      r0,[r0,#0]            ;459  ; ram
00011a  1984              ADDS     r4,r0,r6              ;459
00011c  4832              LDR      r0,|L5.488|
00011e  6800              LDR      r0,[r0,#0]            ;460  ; lfree
000120  4284              CMP      r4,r0                 ;460
000122  d201              BCS      |L5.296|
000124  4830              LDR      r0,|L5.488|
000126  6004              STR      r4,[r0,#0]            ;461  ; lfree
                  |L5.296|
000128  2000              MOVS     r0,#0                 ;463
00012a  7120              STRB     r0,[r4,#4]            ;463
00012c  8838              LDRH     r0,[r7,#0]            ;464
00012e  8020              STRH     r0,[r4,#0]            ;464
000130  f8a49002          STRH     r9,[r4,#2]            ;465
000134  803e              STRH     r6,[r7,#0]            ;466
000136  8820              LDRH     r0,[r4,#0]            ;467
000138  f5b05fc0          CMP      r0,#0x1800            ;467
00013c  d004              BEQ      |L5.328|
00013e  8820              LDRH     r0,[r4,#0]            ;468
000140  4904              LDR      r1,|L5.340|
000142  6809              LDR      r1,[r1,#0]            ;468  ; ram
000144  4408              ADD      r0,r0,r1              ;468
000146  8046              STRH     r6,[r0,#2]            ;468
                  |L5.328|
000148  4826              LDR      r0,|L5.484|
00014a  f7fffffe          BL       sys_sem_signal
00014e  4640              MOV      r0,r8                 ;483
000150  e765              B        |L5.30|
;;;485    
                          ENDP

000152  0000              DCW      0x0000
                  |L5.340|
                          DCD      ||ram||
                  |L5.344|
                          DCD      ram_end
                  |L5.348|
00015c  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\mem.c",0
000160  5749505c
000164  6c776970
000168  2d312e34
00016c  2e315c73
000170  72635c63
000174  6f72655c
000178  6d656d2e
00017c  6300    
00017e  00                DCB      0
00017f  00                DCB      0
                  |L5.384|
000180  6d656d5f          DCB      "mem_trim: legal memory",0
000184  7472696d
000188  3a206c65
00018c  67616c20
000190  6d656d6f
000194  727900  
000197  00                DCB      0
                  |L5.408|
000198  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
00019c  7274696f
0001a0  6e202225
0001a4  73222066
0001a8  61696c65
0001ac  64206174
0001b0  206c696e
0001b4  65202564
0001b8  20696e20
0001bc  25730d0a
0001c0  00      
0001c1  00                DCB      0
0001c2  00                DCB      0
0001c3  00                DCB      0
                  |L5.452|
0001c4  6d656d5f          DCB      "mem_trim can only shrink memory",0
0001c8  7472696d
0001cc  2063616e
0001d0  206f6e6c
0001d4  79207368
0001d8  72696e6b
0001dc  206d656d
0001e0  6f727900
                  |L5.484|
                          DCD      mem_mutex
                  |L5.488|
                          DCD      lfree

                          AREA ||i.plug_holes||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  plug_holes PROC
;;;237    static void
;;;238    plug_holes(struct mem *mem)
000000  b570              PUSH     {r4-r6,lr}
;;;239    {
000002  4604              MOV      r4,r0
;;;240      struct mem *nmem;
;;;241      struct mem *pmem;
;;;242    
;;;243      LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
000004  bf00              NOP      
000006  4835              LDR      r0,|L6.220|
000008  6800              LDR      r0,[r0,#0]  ; ram
00000a  4284              CMP      r4,r0
00000c  d207              BCS      |L6.30|
00000e  bf00              NOP      
000010  a333              ADR      r3,|L6.224|
000012  22f3              MOVS     r2,#0xf3
000014  a13b              ADR      r1,|L6.260|
000016  a041              ADR      r0,|L6.284|
000018  f7fffffe          BL       __2printf
00001c  bf00              NOP      
                  |L6.30|
00001e  bf00              NOP      
;;;244      LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
000020  bf00              NOP      
000022  4849              LDR      r0,|L6.328|
000024  6800              LDR      r0,[r0,#0]  ; ram_end
000026  4284              CMP      r4,r0
000028  d307              BCC      |L6.58|
00002a  bf00              NOP      
00002c  a32c              ADR      r3,|L6.224|
00002e  22f4              MOVS     r2,#0xf4
000030  a146              ADR      r1,|L6.332|
000032  a03a              ADR      r0,|L6.284|
000034  f7fffffe          BL       __2printf
000038  bf00              NOP      
                  |L6.58|
00003a  bf00              NOP      
;;;245      LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
00003c  bf00              NOP      
00003e  7920              LDRB     r0,[r4,#4]
000040  b138              CBZ      r0,|L6.82|
000042  bf00              NOP      
000044  a326              ADR      r3,|L6.224|
000046  22f5              MOVS     r2,#0xf5
000048  a147              ADR      r1,|L6.360|
00004a  a034              ADR      r0,|L6.284|
00004c  f7fffffe          BL       __2printf
000050  bf00              NOP      
                  |L6.82|
000052  bf00              NOP      
;;;246    
;;;247      /* plug hole forward */
;;;248      LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
000054  bf00              NOP      
000056  8820              LDRH     r0,[r4,#0]
000058  f5b05fc0          CMP      r0,#0x1800
00005c  dd07              BLE      |L6.110|
00005e  bf00              NOP      
000060  a31f              ADR      r3,|L6.224|
000062  22f8              MOVS     r2,#0xf8
000064  a147              ADR      r1,|L6.388|
000066  a02d              ADR      r0,|L6.284|
000068  f7fffffe          BL       __2printf
00006c  bf00              NOP      
                  |L6.110|
00006e  bf00              NOP      
;;;249    
;;;250      nmem = (struct mem *)(void *)&ram[mem->next];
000070  8820              LDRH     r0,[r4,#0]
000072  491a              LDR      r1,|L6.220|
000074  6809              LDR      r1,[r1,#0]  ; ram
000076  1845              ADDS     r5,r0,r1
;;;251      if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
000078  42ac              CMP      r4,r5
00007a  d015              BEQ      |L6.168|
00007c  7928              LDRB     r0,[r5,#4]
00007e  b998              CBNZ     r0,|L6.168|
000080  4831              LDR      r0,|L6.328|
000082  6800              LDR      r0,[r0,#0]  ; ram_end
000084  4285              CMP      r5,r0
000086  d00f              BEQ      |L6.168|
;;;252        /* if mem->next is unused and not end of ram, combine mem and mem->next */
;;;253        if (lfree == nmem) {
000088  4849              LDR      r0,|L6.432|
00008a  6800              LDR      r0,[r0,#0]  ; lfree
00008c  42a8              CMP      r0,r5
00008e  d101              BNE      |L6.148|
;;;254          lfree = mem;
000090  4847              LDR      r0,|L6.432|
000092  6004              STR      r4,[r0,#0]  ; lfree
                  |L6.148|
;;;255        }
;;;256        mem->next = nmem->next;
000094  8828              LDRH     r0,[r5,#0]
000096  8020              STRH     r0,[r4,#0]
;;;257        ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
000098  4810              LDR      r0,|L6.220|
00009a  8800              LDRH     r0,[r0,#0]  ; ram
00009c  1a20              SUBS     r0,r4,r0
00009e  8829              LDRH     r1,[r5,#0]
0000a0  4a0e              LDR      r2,|L6.220|
0000a2  6812              LDR      r2,[r2,#0]  ; ram
0000a4  4411              ADD      r1,r1,r2
0000a6  8048              STRH     r0,[r1,#2]
                  |L6.168|
;;;258      }
;;;259    
;;;260      /* plug hole backward */
;;;261      pmem = (struct mem *)(void *)&ram[mem->prev];
0000a8  8860              LDRH     r0,[r4,#2]
0000aa  490c              LDR      r1,|L6.220|
0000ac  6809              LDR      r1,[r1,#0]  ; ram
0000ae  1846              ADDS     r6,r0,r1
;;;262      if (pmem != mem && pmem->used == 0) {
0000b0  42a6              CMP      r6,r4
0000b2  d011              BEQ      |L6.216|
0000b4  7930              LDRB     r0,[r6,#4]
0000b6  b978              CBNZ     r0,|L6.216|
;;;263        /* if mem->prev is unused, combine mem and mem->prev */
;;;264        if (lfree == mem) {
0000b8  483d              LDR      r0,|L6.432|
0000ba  6800              LDR      r0,[r0,#0]  ; lfree
0000bc  42a0              CMP      r0,r4
0000be  d101              BNE      |L6.196|
;;;265          lfree = pmem;
0000c0  483b              LDR      r0,|L6.432|
0000c2  6006              STR      r6,[r0,#0]  ; lfree
                  |L6.196|
;;;266        }
;;;267        pmem->next = mem->next;
0000c4  8820              LDRH     r0,[r4,#0]
0000c6  8030              STRH     r0,[r6,#0]
;;;268        ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
0000c8  4804              LDR      r0,|L6.220|
0000ca  8800              LDRH     r0,[r0,#0]  ; ram
0000cc  1a30              SUBS     r0,r6,r0
0000ce  8821              LDRH     r1,[r4,#0]
0000d0  4a02              LDR      r2,|L6.220|
0000d2  6812              LDR      r2,[r2,#0]  ; ram
0000d4  4411              ADD      r1,r1,r2
0000d6  8048              STRH     r0,[r1,#2]
                  |L6.216|
;;;269      }
;;;270    }
0000d8  bd70              POP      {r4-r6,pc}
;;;271    
                          ENDP

0000da  0000              DCW      0x0000
                  |L6.220|
                          DCD      ||ram||
                  |L6.224|
0000e0  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\mem.c",0
0000e4  5749505c
0000e8  6c776970
0000ec  2d312e34
0000f0  2e315c73
0000f4  72635c63
0000f8  6f72655c
0000fc  6d656d2e
000100  6300    
000102  00                DCB      0
000103  00                DCB      0
                  |L6.260|
000104  706c7567          DCB      "plug_holes: mem >= ram",0
000108  5f686f6c
00010c  65733a20
000110  6d656d20
000114  3e3d2072
000118  616d00  
00011b  00                DCB      0
                  |L6.284|
00011c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000120  7274696f
000124  6e202225
000128  73222066
00012c  61696c65
000130  64206174
000134  206c696e
000138  65202564
00013c  20696e20
000140  25730d0a
000144  00      
000145  00                DCB      0
000146  00                DCB      0
000147  00                DCB      0
                  |L6.328|
                          DCD      ram_end
                  |L6.332|
00014c  706c7567          DCB      "plug_holes: mem < ram_end",0
000150  5f686f6c
000154  65733a20
000158  6d656d20
00015c  3c207261
000160  6d5f656e
000164  6400    
000166  00                DCB      0
000167  00                DCB      0
                  |L6.360|
000168  706c7567          DCB      "plug_holes: mem->used == 0",0
00016c  5f686f6c
000170  65733a20
000174  6d656d2d
000178  3e757365
00017c  64203d3d
000180  203000  
000183  00                DCB      0
                  |L6.388|
000184  706c7567          DCB      "plug_holes: mem->next <= MEM_SIZE_ALIGNED",0
000188  5f686f6c
00018c  65733a20
000190  6d656d2d
000194  3e6e6578
000198  74203c3d
00019c  204d454d
0001a0  5f53495a
0001a4  455f414c
0001a8  49474e45
0001ac  4400    
0001ae  00                DCB      0
0001af  00                DCB      0
                  |L6.432|
                          DCD      lfree

                          AREA ||.data||, DATA, ALIGN=2

                  ram_heap
                          DCD      0x00000000
                  ||ram||
                          DCD      0x00000000
                  ram_end
                          DCD      0x00000000
                  lfree
                          DCD      0x00000000
                  mem_mutex
                          DCD      0x00000000
