; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\timers.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\timers.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\timers.crf ..\FreeRTOS\timers.c]
                          THUMB

                          AREA ||i.pcTimerGetName||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  pcTimerGetName PROC
;;;488    
;;;489    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  b570              PUSH     {r4-r6,lr}
;;;490    {
000002  4604              MOV      r4,r0
;;;491    Timer_t *pxTimer = ( Timer_t * ) xTimer;
000004  4625              MOV      r5,r4
;;;492    
;;;493    	configASSERT( xTimer );
000006  b92c              CBNZ     r4,|L1.20|
000008  f24012ed          MOV      r2,#0x1ed
00000c  a102              ADR      r1,|L1.24|
00000e  a008              ADR      r0,|L1.48|
000010  f7fffffe          BL       __2printf
                  |L1.20|
;;;494    	return pxTimer->pcTimerName;
000014  6828              LDR      r0,[r5,#0]
;;;495    }
000016  bd70              POP      {r4-r6,pc}
;;;496    /*-----------------------------------------------------------*/
                          ENDP

                  |L1.24|
000018  2e2e5c46          DCB      "..\\FreeRTOS\\timers.c",0
00001c  72656552
000020  544f535c
000024  74696d65
000028  72732e63
00002c  00      
00002d  00                DCB      0
00002e  00                DCB      0
00002f  00                DCB      0
                  |L1.48|
000030  4572726f          DCB      "Error:%s,%d\r\n",0
000034  723a2573
000038  2c25640d
00003c  0a00    
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.prvCheckForValidListAndQueue||, CODE, READONLY, ALIGN=2

                  prvCheckForValidListAndQueue PROC
;;;929    
;;;930    static void prvCheckForValidListAndQueue( void )
000000  b510              PUSH     {r4,lr}
;;;931    {
;;;932    	/* Check that the list from which active timers are referenced, and the
;;;933    	queue used to communicate with the timer service, have been
;;;934    	initialised. */
;;;935    	taskENTER_CRITICAL();
000002  f7fffffe          BL       vPortEnterCritical
;;;936    	{
;;;937    		if( xTimerQueue == NULL )
000006  4810              LDR      r0,|L2.72|
000008  6800              LDR      r0,[r0,#0]  ; xTimerQueue
00000a  b9d0              CBNZ     r0,|L2.66|
;;;938    		{
;;;939    			vListInitialise( &xActiveTimerList1 );
00000c  480f              LDR      r0,|L2.76|
00000e  f7fffffe          BL       vListInitialise
;;;940    			vListInitialise( &xActiveTimerList2 );
000012  480f              LDR      r0,|L2.80|
000014  f7fffffe          BL       vListInitialise
;;;941    			pxCurrentTimerList = &xActiveTimerList1;
000018  480c              LDR      r0,|L2.76|
00001a  490e              LDR      r1,|L2.84|
00001c  6008              STR      r0,[r1,#0]  ; pxCurrentTimerList
;;;942    			pxOverflowTimerList = &xActiveTimerList2;
00001e  480c              LDR      r0,|L2.80|
000020  490d              LDR      r1,|L2.88|
000022  6008              STR      r0,[r1,#0]  ; pxOverflowTimerList
;;;943    
;;;944    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;945    			{
;;;946    				/* The timer queue is allocated statically in case
;;;947    				configSUPPORT_DYNAMIC_ALLOCATION is 0. */
;;;948    				static StaticQueue_t xStaticTimerQueue;
;;;949    				static uint8_t ucStaticTimerQueueStorage[ configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ];
;;;950    
;;;951    				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
;;;952    			}
;;;953    			#else
;;;954    			{
;;;955    				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
000024  2200              MOVS     r2,#0
000026  2110              MOVS     r1,#0x10
000028  2005              MOVS     r0,#5
00002a  f7fffffe          BL       xQueueGenericCreate
00002e  4906              LDR      r1,|L2.72|
000030  6008              STR      r0,[r1,#0]  ; xTimerQueue
;;;956    			}
;;;957    			#endif
;;;958    
;;;959    			#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;960    			{
;;;961    				if( xTimerQueue != NULL )
000032  4608              MOV      r0,r1
000034  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000036  b120              CBZ      r0,|L2.66|
;;;962    				{
;;;963    					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
000038  a108              ADR      r1,|L2.92|
00003a  4803              LDR      r0,|L2.72|
00003c  6800              LDR      r0,[r0,#0]  ; xTimerQueue
00003e  f7fffffe          BL       vQueueAddToRegistry
                  |L2.66|
;;;964    				}
;;;965    				else
;;;966    				{
;;;967    					mtCOVERAGE_TEST_MARKER();
;;;968    				}
;;;969    			}
;;;970    			#endif /* configQUEUE_REGISTRY_SIZE */
;;;971    		}
;;;972    		else
;;;973    		{
;;;974    			mtCOVERAGE_TEST_MARKER();
;;;975    		}
;;;976    	}
;;;977    	taskEXIT_CRITICAL();
000042  f7fffffe          BL       vPortExitCritical
;;;978    }
000046  bd10              POP      {r4,pc}
;;;979    /*-----------------------------------------------------------*/
                          ENDP

                  |L2.72|
                          DCD      xTimerQueue
                  |L2.76|
                          DCD      xActiveTimerList1
                  |L2.80|
                          DCD      xActiveTimerList2
                  |L2.84|
                          DCD      pxCurrentTimerList
                  |L2.88|
                          DCD      pxOverflowTimerList
                  |L2.92|
00005c  546d7251          DCB      "TmrQ",0
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.prvGetNextExpireTime||, CODE, READONLY, ALIGN=2

                  prvGetNextExpireTime PROC
;;;633    
;;;634    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
000000  4601              MOV      r1,r0
;;;635    {
;;;636    TickType_t xNextExpireTime;
;;;637    
;;;638    	/* Timers are listed in expiry time order, with the head of the list
;;;639    	referencing the task that will expire first.  Obtain the time at which
;;;640    	the timer with the nearest expiry time will expire.  If there are no
;;;641    	active timers then just set the next expire time to 0.  That will cause
;;;642    	this task to unblock when the tick count overflows, at which point the
;;;643    	timer lists will be switched and the next expiry time can be
;;;644    	re-assessed.  */
;;;645    	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
000002  4a08              LDR      r2,|L3.36|
000004  6812              LDR      r2,[r2,#0]  ; pxCurrentTimerList
000006  6812              LDR      r2,[r2,#0]
000008  b90a              CBNZ     r2,|L3.14|
00000a  2201              MOVS     r2,#1
00000c  e000              B        |L3.16|
                  |L3.14|
00000e  2200              MOVS     r2,#0
                  |L3.16|
000010  600a              STR      r2,[r1,#0]
;;;646    	if( *pxListWasEmpty == pdFALSE )
000012  680a              LDR      r2,[r1,#0]
000014  b922              CBNZ     r2,|L3.32|
;;;647    	{
;;;648    		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
000016  4a03              LDR      r2,|L3.36|
000018  6812              LDR      r2,[r2,#0]  ; pxCurrentTimerList
00001a  68d2              LDR      r2,[r2,#0xc]
00001c  6810              LDR      r0,[r2,#0]
00001e  e000              B        |L3.34|
                  |L3.32|
;;;649    	}
;;;650    	else
;;;651    	{
;;;652    		/* Ensure the task unblocks when the tick count rolls over. */
;;;653    		xNextExpireTime = ( TickType_t ) 0U;
000020  2000              MOVS     r0,#0
                  |L3.34|
;;;654    	}
;;;655    
;;;656    	return xNextExpireTime;
;;;657    }
000022  4770              BX       lr
;;;658    /*-----------------------------------------------------------*/
                          ENDP

                  |L3.36|
                          DCD      pxCurrentTimerList

                          AREA ||i.prvInitialiseNewTimer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  prvInitialiseNewTimer PROC
;;;387    
;;;388    static void prvInitialiseNewTimer(	const char * const pcTimerName,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;389    									const TickType_t xTimerPeriodInTicks,
;;;390    									const UBaseType_t uxAutoReload,
;;;391    									void * const pvTimerID,
;;;392    									TimerCallbackFunction_t pxCallbackFunction,
;;;393    									Timer_t *pxNewTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;394    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9dd9408          LDRD     r9,r4,[sp,#0x20]
;;;395    	/* 0 is not a valid value for xTimerPeriodInTicks. */
;;;396    	configASSERT( ( xTimerPeriodInTicks > 0 ) );
000010  b10d              CBZ      r5,|L4.22|
000012  2001              MOVS     r0,#1
000014  e000              B        |L4.24|
                  |L4.22|
000016  2000              MOVS     r0,#0
                  |L4.24|
000018  b928              CBNZ     r0,|L4.38|
00001a  f44f72c6          MOV      r2,#0x18c
00001e  a109              ADR      r1,|L4.68|
000020  a00e              ADR      r0,|L4.92|
000022  f7fffffe          BL       __2printf
                  |L4.38|
;;;397    
;;;398    	if( pxNewTimer != NULL )
000026  b15c              CBZ      r4,|L4.64|
;;;399    	{
;;;400    		/* Ensure the infrastructure used by the timer service task has been
;;;401    		created/initialised. */
;;;402    		prvCheckForValidListAndQueue();
000028  f7fffffe          BL       prvCheckForValidListAndQueue
;;;403    
;;;404    		/* Initialise the timer structure members using the function
;;;405    		parameters. */
;;;406    		pxNewTimer->pcTimerName = pcTimerName;
00002c  6026              STR      r6,[r4,#0]
;;;407    		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
00002e  61a5              STR      r5,[r4,#0x18]
;;;408    		pxNewTimer->uxAutoReload = uxAutoReload;
000030  61e7              STR      r7,[r4,#0x1c]
;;;409    		pxNewTimer->pvTimerID = pvTimerID;
000032  f8c48020          STR      r8,[r4,#0x20]
;;;410    		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
000036  f8c49024          STR      r9,[r4,#0x24]
;;;411    		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
00003a  1d20              ADDS     r0,r4,#4
00003c  f7fffffe          BL       vListInitialiseItem
                  |L4.64|
;;;412    		traceTIMER_CREATE( pxNewTimer );
;;;413    	}
;;;414    }
000040  e8bd87f0          POP      {r4-r10,pc}
;;;415    /*-----------------------------------------------------------*/
                          ENDP

                  |L4.68|
000044  2e2e5c46          DCB      "..\\FreeRTOS\\timers.c",0
000048  72656552
00004c  544f535c
000050  74696d65
000054  72732e63
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L4.92|
00005c  4572726f          DCB      "Error:%s,%d\r\n",0
000060  723a2573
000064  2c25640d
000068  0a00    
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.prvInsertTimerInActiveList||, CODE, READONLY, ALIGN=2

                  prvInsertTimerInActiveList PROC
;;;682    
;;;683    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;684    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;685    BaseType_t xProcessTimerNow = pdFALSE;
00000c  f04f0800          MOV      r8,#0
;;;686    
;;;687    	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
000010  6065              STR      r5,[r4,#4]
;;;688    	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
000012  6124              STR      r4,[r4,#0x10]
;;;689    
;;;690    	if( xNextExpiryTime <= xTimeNow )
000014  42b5              CMP      r5,r6
000016  d80c              BHI      |L5.50|
;;;691    	{
;;;692    		/* Has the expiry time elapsed between the command to start/reset a
;;;693    		timer was issued, and the time the command was processed? */
;;;694    		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000018  1bf0              SUBS     r0,r6,r7
00001a  69a1              LDR      r1,[r4,#0x18]
00001c  4288              CMP      r0,r1
00001e  d302              BCC      |L5.38|
;;;695    		{
;;;696    			/* The time between a command being issued and the command being
;;;697    			processed actually exceeds the timers period.  */
;;;698    			xProcessTimerNow = pdTRUE;
000020  f04f0801          MOV      r8,#1
000024  e011              B        |L5.74|
                  |L5.38|
;;;699    		}
;;;700    		else
;;;701    		{
;;;702    			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
000026  1d21              ADDS     r1,r4,#4
000028  4809              LDR      r0,|L5.80|
00002a  6800              LDR      r0,[r0,#0]  ; pxOverflowTimerList
00002c  f7fffffe          BL       vListInsert
000030  e00b              B        |L5.74|
                  |L5.50|
;;;703    		}
;;;704    	}
;;;705    	else
;;;706    	{
;;;707    		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
000032  42be              CMP      r6,r7
000034  d204              BCS      |L5.64|
000036  42bd              CMP      r5,r7
000038  d302              BCC      |L5.64|
;;;708    		{
;;;709    			/* If, since the command was issued, the tick count has overflowed
;;;710    			but the expiry time has not, then the timer must have already passed
;;;711    			its expiry time and should be processed immediately. */
;;;712    			xProcessTimerNow = pdTRUE;
00003a  f04f0801          MOV      r8,#1
00003e  e004              B        |L5.74|
                  |L5.64|
;;;713    		}
;;;714    		else
;;;715    		{
;;;716    			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
000040  1d21              ADDS     r1,r4,#4
000042  4804              LDR      r0,|L5.84|
000044  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
000046  f7fffffe          BL       vListInsert
                  |L5.74|
;;;717    		}
;;;718    	}
;;;719    
;;;720    	return xProcessTimerNow;
00004a  4640              MOV      r0,r8
;;;721    }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;722    /*-----------------------------------------------------------*/
                          ENDP

                  |L5.80|
                          DCD      pxOverflowTimerList
                  |L5.84|
                          DCD      pxCurrentTimerList

                          AREA ||i.prvProcessExpiredTimer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  prvProcessExpiredTimer PROC
;;;497    
;;;498    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
000000  b5f8              PUSH     {r3-r7,lr}
;;;499    {
000002  4605              MOV      r5,r0
000004  460f              MOV      r7,r1
;;;500    BaseType_t xResult;
;;;501    Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
000006  4813              LDR      r0,|L6.84|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  68c4              LDR      r4,[r0,#0xc]
;;;502    
;;;503    	/* Remove the timer from the list of active timers.  A check has already
;;;504    	been performed to ensure the list is not empty. */
;;;505    	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       uxListRemove
;;;506    	traceTIMER_EXPIRED( pxTimer );
;;;507    
;;;508    	/* If the timer is an auto reload timer then calculate the next
;;;509    	expiry time and re-insert the timer in the list of active timers. */
;;;510    	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
000014  69e0              LDR      r0,[r4,#0x1c]
000016  2801              CMP      r0,#1
000018  d118              BNE      |L6.76|
;;;511    	{
;;;512    		/* The timer is inserted into a list using a time relative to anything
;;;513    		other than the current time.  It will therefore be inserted into the
;;;514    		correct list relative to the time this task thinks it is now. */
;;;515    		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
00001a  69a0              LDR      r0,[r4,#0x18]
00001c  1941              ADDS     r1,r0,r5
00001e  462b              MOV      r3,r5
000020  463a              MOV      r2,r7
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       prvInsertTimerInActiveList
000028  b180              CBZ      r0,|L6.76|
;;;516    		{
;;;517    			/* The timer expired before it was added to the active timer
;;;518    			list.  Reload it now.  */
;;;519    			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
00002a  2000              MOVS     r0,#0
00002c  4603              MOV      r3,r0
00002e  462a              MOV      r2,r5
000030  4601              MOV      r1,r0
000032  9000              STR      r0,[sp,#0]
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       xTimerGenericCommand
00003a  4606              MOV      r6,r0
;;;520    			configASSERT( xResult );
00003c  b92e              CBNZ     r6,|L6.74|
00003e  f44f7202          MOV      r2,#0x208
000042  a105              ADR      r1,|L6.88|
000044  a00a              ADR      r0,|L6.112|
000046  f7fffffe          BL       __2printf
                  |L6.74|
;;;521    			( void ) xResult;
00004a  bf00              NOP      
                  |L6.76|
;;;522    		}
;;;523    		else
;;;524    		{
;;;525    			mtCOVERAGE_TEST_MARKER();
;;;526    		}
;;;527    	}
;;;528    	else
;;;529    	{
;;;530    		mtCOVERAGE_TEST_MARKER();
;;;531    	}
;;;532    
;;;533    	/* Call the timer callback. */
;;;534    	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
00004c  4620              MOV      r0,r4
00004e  6a61              LDR      r1,[r4,#0x24]
000050  4788              BLX      r1
;;;535    }
000052  bdf8              POP      {r3-r7,pc}
;;;536    /*-----------------------------------------------------------*/
                          ENDP

                  |L6.84|
                          DCD      pxCurrentTimerList
                  |L6.88|
000058  2e2e5c46          DCB      "..\\FreeRTOS\\timers.c",0
00005c  72656552
000060  544f535c
000064  74696d65
000068  72732e63
00006c  00      
00006d  00                DCB      0
00006e  00                DCB      0
00006f  00                DCB      0
                  |L6.112|
000070  4572726f          DCB      "Error:%s,%d\r\n",0
000074  723a2573
000078  2c25640d
00007c  0a00    
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.prvProcessReceivedCommands||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  prvProcessReceivedCommands PROC
;;;723    
;;;724    static void	prvProcessReceivedCommands( void )
000000  b5f0              PUSH     {r4-r7,lr}
;;;725    {
000002  b087              SUB      sp,sp,#0x1c
;;;726    DaemonTaskMessage_t xMessage;
;;;727    Timer_t *pxTimer;
;;;728    BaseType_t xTimerListsWereSwitched, xResult;
;;;729    TickType_t xTimeNow;
;;;730    
;;;731    	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
000004  e070              B        |L7.232|
                  |L7.6|
;;;732    	{
;;;733    		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
;;;734    		{
;;;735    			/* Negative commands are pended function calls rather than timer
;;;736    			commands. */
;;;737    			if( xMessage.xMessageID < ( BaseType_t ) 0 )
000006  9803              LDR      r0,[sp,#0xc]
000008  2800              CMP      r0,#0
00000a  da0c              BGE      |L7.38|
;;;738    			{
;;;739    				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
00000c  ae04              ADD      r6,sp,#0x10
;;;740    
;;;741    				/* The timer uses the xCallbackParameters member to request a
;;;742    				callback be executed.  Check the callback is not NULL. */
;;;743    				configASSERT( pxCallback );
00000e  b92e              CBNZ     r6,|L7.28|
000010  f24022e7          MOV      r2,#0x2e7
000014  a13a              ADR      r1,|L7.256|
000016  a040              ADR      r0,|L7.280|
000018  f7fffffe          BL       __2printf
                  |L7.28|
;;;744    
;;;745    				/* Call the function. */
;;;746    				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
00001c  e9d62000          LDRD     r2,r0,[r6,#0]
000020  68b1              LDR      r1,[r6,#8]
000022  4790              BLX      r2
;;;747    			}
000024  bf00              NOP      
                  |L7.38|
;;;748    			else
;;;749    			{
;;;750    				mtCOVERAGE_TEST_MARKER();
;;;751    			}
;;;752    		}
;;;753    		#endif /* INCLUDE_xTimerPendFunctionCall */
;;;754    
;;;755    		/* Commands that are positive are timer commands rather than pended
;;;756    		function calls. */
;;;757    		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
000026  9803              LDR      r0,[sp,#0xc]
000028  2800              CMP      r0,#0
00002a  db5d              BLT      |L7.232|
;;;758    		{
;;;759    			/* The messages uses the xTimerParameters member to work on a
;;;760    			software timer. */
;;;761    			pxTimer = xMessage.u.xTimerParameters.pxTimer;
00002c  9c05              LDR      r4,[sp,#0x14]
;;;762    
;;;763    			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
00002e  6960              LDR      r0,[r4,#0x14]
000030  b908              CBNZ     r0,|L7.54|
000032  2001              MOVS     r0,#1
000034  e000              B        |L7.56|
                  |L7.54|
000036  2000              MOVS     r0,#0
                  |L7.56|
000038  b910              CBNZ     r0,|L7.64|
;;;764    			{
;;;765    				/* The timer is in a list, remove it. */
;;;766    				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
00003a  1d20              ADDS     r0,r4,#4
00003c  f7fffffe          BL       uxListRemove
                  |L7.64|
;;;767    			}
;;;768    			else
;;;769    			{
;;;770    				mtCOVERAGE_TEST_MARKER();
;;;771    			}
;;;772    
;;;773    			traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );
;;;774    
;;;775    			/* In this case the xTimerListsWereSwitched parameter is not used, but
;;;776    			it must be present in the function call.  prvSampleTimeNow() must be
;;;777    			called after the message is received from xTimerQueue so there is no
;;;778    			possibility of a higher priority task adding a message to the message
;;;779    			queue with a time that is ahead of the timer daemon task (because it
;;;780    			pre-empted the timer daemon task after the xTimeNow value was set). */
;;;781    			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
000040  a802              ADD      r0,sp,#8
000042  f7fffffe          BL       prvSampleTimeNow
000046  4605              MOV      r5,r0
;;;782    
;;;783    			switch( xMessage.xMessageID )
000048  9803              LDR      r0,[sp,#0xc]
00004a  280a              CMP      r0,#0xa
00004c  d24a              BCS      |L7.228|
00004e  e8dff000          TBB      [pc,r0]
000052  0905              DCB      0x09,0x05
000054  072c2e45          DCB      0x07,0x2c,0x2e,0x45
000058  06082d2f          DCB      0x06,0x08,0x2d,0x2f
;;;784    			{
;;;785    				case tmrCOMMAND_START :
;;;786    			    case tmrCOMMAND_START_FROM_ISR :
00005c  bf00              NOP      
;;;787    			    case tmrCOMMAND_RESET :
00005e  bf00              NOP      
;;;788    			    case tmrCOMMAND_RESET_FROM_ISR :
000060  bf00              NOP      
;;;789    				case tmrCOMMAND_START_DONT_TRACE :
000062  bf00              NOP      
;;;790    					/* Start or restart a timer. */
;;;791    					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
000064  9804              LDR      r0,[sp,#0x10]
000066  69a2              LDR      r2,[r4,#0x18]
000068  1881              ADDS     r1,r0,r2
00006a  4603              MOV      r3,r0
00006c  462a              MOV      r2,r5
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       prvInsertTimerInActiveList
000074  b1c0              CBZ      r0,|L7.168|
;;;792    					{
;;;793    						/* The timer expired before it was added to the active
;;;794    						timer list.  Process it now. */
;;;795    						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
000076  4620              MOV      r0,r4
000078  6a61              LDR      r1,[r4,#0x24]
00007a  4788              BLX      r1
;;;796    						traceTIMER_EXPIRED( pxTimer );
;;;797    
;;;798    						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
00007c  69e0              LDR      r0,[r4,#0x1c]
00007e  2801              CMP      r0,#1
000080  d112              BNE      |L7.168|
;;;799    						{
;;;800    							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
000082  2000              MOVS     r0,#0
000084  9000              STR      r0,[sp,#0]
000086  9804              LDR      r0,[sp,#0x10]
000088  69a1              LDR      r1,[r4,#0x18]
00008a  1842              ADDS     r2,r0,r1
00008c  2300              MOVS     r3,#0
00008e  4619              MOV      r1,r3
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       xTimerGenericCommand
000096  4607              MOV      r7,r0
;;;801    							configASSERT( xResult );
000098  b92f              CBNZ     r7,|L7.166|
00009a  f2403221          MOV      r2,#0x321
00009e  a118              ADR      r1,|L7.256|
0000a0  a01d              ADR      r0,|L7.280|
0000a2  f7fffffe          BL       __2printf
                  |L7.166|
;;;802    							( void ) xResult;
0000a6  bf00              NOP      
                  |L7.168|
;;;803    						}
;;;804    						else
;;;805    						{
;;;806    							mtCOVERAGE_TEST_MARKER();
;;;807    						}
;;;808    					}
;;;809    					else
;;;810    					{
;;;811    						mtCOVERAGE_TEST_MARKER();
;;;812    					}
;;;813    					break;
0000a8  e01d              B        |L7.230|
;;;814    
;;;815    				case tmrCOMMAND_STOP :
;;;816    				case tmrCOMMAND_STOP_FROM_ISR :
0000aa  bf00              NOP      
;;;817    					/* The timer has already been removed from the active list.
;;;818    					There is nothing to do here. */
;;;819    					break;
0000ac  e01b              B        |L7.230|
;;;820    
;;;821    				case tmrCOMMAND_CHANGE_PERIOD :
;;;822    				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
0000ae  bf00              NOP      
;;;823    					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
0000b0  9804              LDR      r0,[sp,#0x10]
0000b2  61a0              STR      r0,[r4,#0x18]
;;;824    					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
0000b4  69a0              LDR      r0,[r4,#0x18]
0000b6  b108              CBZ      r0,|L7.188|
0000b8  2001              MOVS     r0,#1
0000ba  e000              B        |L7.190|
                  |L7.188|
0000bc  2000              MOVS     r0,#0
                  |L7.190|
0000be  b928              CBNZ     r0,|L7.204|
0000c0  f44f724e          MOV      r2,#0x338
0000c4  a10e              ADR      r1,|L7.256|
0000c6  a014              ADR      r0,|L7.280|
0000c8  f7fffffe          BL       __2printf
                  |L7.204|
;;;825    
;;;826    					/* The new period does not really have a reference, and can
;;;827    					be longer or shorter than the old one.  The command time is
;;;828    					therefore set to the current time, and as the period cannot
;;;829    					be zero the next expiry time can only be in the future,
;;;830    					meaning (unlike for the xTimerStart() case above) there is
;;;831    					no fail case that needs to be handled here. */
;;;832    					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
0000cc  69a0              LDR      r0,[r4,#0x18]
0000ce  1941              ADDS     r1,r0,r5
0000d0  462b              MOV      r3,r5
0000d2  462a              MOV      r2,r5
0000d4  4620              MOV      r0,r4
0000d6  f7fffffe          BL       prvInsertTimerInActiveList
;;;833    					break;
0000da  e004              B        |L7.230|
;;;834    
;;;835    				case tmrCOMMAND_DELETE :
;;;836    					/* The timer has already been removed from the active list,
;;;837    					just free up the memory if the memory was dynamically
;;;838    					allocated. */
;;;839    					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
;;;840    					{
;;;841    						/* The timer can only have been allocated dynamically -
;;;842    						free it again. */
;;;843    						vPortFree( pxTimer );
0000dc  4620              MOV      r0,r4
0000de  f7fffffe          BL       vPortFree
;;;844    					}
;;;845    					#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;;;846    					{
;;;847    						/* The timer could have been allocated statically or
;;;848    						dynamically, so check before attempting to free the
;;;849    						memory. */
;;;850    						if( pxTimer->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
;;;851    						{
;;;852    							vPortFree( pxTimer );
;;;853    						}
;;;854    						else
;;;855    						{
;;;856    							mtCOVERAGE_TEST_MARKER();
;;;857    						}
;;;858    					}
;;;859    					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;860    					break;
0000e2  e000              B        |L7.230|
                  |L7.228|
;;;861    
;;;862    				default	:
;;;863    					/* Don't expect to get here. */
;;;864    					break;
0000e4  bf00              NOP      
                  |L7.230|
0000e6  bf00              NOP                            ;813
                  |L7.232|
0000e8  2300              MOVS     r3,#0                 ;731
0000ea  461a              MOV      r2,r3                 ;731
0000ec  a903              ADD      r1,sp,#0xc            ;731
0000ee  480e              LDR      r0,|L7.296|
0000f0  6800              LDR      r0,[r0,#0]            ;731  ; xTimerQueue
0000f2  f7fffffe          BL       xQueueGenericReceive
0000f6  2800              CMP      r0,#0                 ;731
0000f8  d185              BNE      |L7.6|
;;;865    			}
;;;866    		}
;;;867    	}
;;;868    }
0000fa  b007              ADD      sp,sp,#0x1c
0000fc  bdf0              POP      {r4-r7,pc}
;;;869    /*-----------------------------------------------------------*/
                          ENDP

0000fe  0000              DCW      0x0000
                  |L7.256|
000100  2e2e5c46          DCB      "..\\FreeRTOS\\timers.c",0
000104  72656552
000108  544f535c
00010c  74696d65
000110  72732e63
000114  00      
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0
                  |L7.280|
000118  4572726f          DCB      "Error:%s,%d\r\n",0
00011c  723a2573
000120  2c25640d
000124  0a00    
000126  00                DCB      0
000127  00                DCB      0
                  |L7.296|
                          DCD      xTimerQueue

                          AREA ||i.prvProcessTimerOrBlockTask||, CODE, READONLY, ALIGN=2

                  prvProcessTimerOrBlockTask PROC
;;;573    
;;;574    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
000000  b5f8              PUSH     {r3-r7,lr}
;;;575    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;576    TickType_t xTimeNow;
;;;577    BaseType_t xTimerListsWereSwitched;
;;;578    
;;;579    	vTaskSuspendAll();
000006  f7fffffe          BL       vTaskSuspendAll
;;;580    	{
;;;581    		/* Obtain the time now to make an assessment as to whether the timer
;;;582    		has expired or not.  If obtaining the time causes the lists to switch
;;;583    		then don't process this timer as any timers that remained in the list
;;;584    		when the lists were switched will have been processed within the
;;;585    		prvSampleTimeNow() function. */
;;;586    		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       prvSampleTimeNow
000010  4606              MOV      r6,r0
;;;587    		if( xTimerListsWereSwitched == pdFALSE )
000012  9800              LDR      r0,[sp,#0]
000014  bb20              CBNZ     r0,|L8.96|
;;;588    		{
;;;589    			/* The tick count has not overflowed, has the timer expired? */
;;;590    			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
000016  b944              CBNZ     r4,|L8.42|
000018  42b5              CMP      r5,r6
00001a  d806              BHI      |L8.42|
;;;591    			{
;;;592    				( void ) xTaskResumeAll();
00001c  f7fffffe          BL       xTaskResumeAll
;;;593    				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
000020  4631              MOV      r1,r6
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       prvProcessExpiredTimer
000028  e01c              B        |L8.100|
                  |L8.42|
;;;594    			}
;;;595    			else
;;;596    			{
;;;597    				/* The tick count has not overflowed, and the next expire
;;;598    				time has not been reached yet.  This task should therefore
;;;599    				block to wait for the next expire time or a command to be
;;;600    				received - whichever comes first.  The following line cannot
;;;601    				be reached unless xNextExpireTime > xTimeNow, except in the
;;;602    				case when the current timer list is empty. */
;;;603    				if( xListWasEmpty != pdFALSE )
00002a  b13c              CBZ      r4,|L8.60|
;;;604    				{
;;;605    					/* The current timer list is empty - is the overflow list
;;;606    					also empty? */
;;;607    					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
00002c  480e              LDR      r0,|L8.104|
00002e  6800              LDR      r0,[r0,#0]  ; pxOverflowTimerList
000030  6800              LDR      r0,[r0,#0]
000032  b908              CBNZ     r0,|L8.56|
000034  2001              MOVS     r0,#1
000036  e000              B        |L8.58|
                  |L8.56|
000038  2000              MOVS     r0,#0
                  |L8.58|
00003a  4604              MOV      r4,r0
                  |L8.60|
;;;608    				}
;;;609    
;;;610    				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
00003c  1ba9              SUBS     r1,r5,r6
00003e  4622              MOV      r2,r4
000040  480a              LDR      r0,|L8.108|
000042  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000044  f7fffffe          BL       vQueueWaitForMessageRestricted
;;;611    
;;;612    				if( xTaskResumeAll() == pdFALSE )
000048  f7fffffe          BL       xTaskResumeAll
00004c  b950              CBNZ     r0,|L8.100|
;;;613    				{
;;;614    					/* Yield to wait for either a command to arrive, or the
;;;615    					block time to expire.  If a command arrived between the
;;;616    					critical section being exited and this yield then the yield
;;;617    					will not cause the task to block. */
;;;618    					portYIELD_WITHIN_API();
00004e  f04f5080          MOV      r0,#0x10000000
000052  4907              LDR      r1,|L8.112|
000054  6008              STR      r0,[r1,#0]
000056  f3bf8f4f          DSB      
00005a  f3bf8f6f          ISB      
00005e  e001              B        |L8.100|
                  |L8.96|
;;;619    				}
;;;620    				else
;;;621    				{
;;;622    					mtCOVERAGE_TEST_MARKER();
;;;623    				}
;;;624    			}
;;;625    		}
;;;626    		else
;;;627    		{
;;;628    			( void ) xTaskResumeAll();
000060  f7fffffe          BL       xTaskResumeAll
                  |L8.100|
;;;629    		}
;;;630    	}
;;;631    }
000064  bdf8              POP      {r3-r7,pc}
;;;632    /*-----------------------------------------------------------*/
                          ENDP

000066  0000              DCW      0x0000
                  |L8.104|
                          DCD      pxOverflowTimerList
                  |L8.108|
                          DCD      xTimerQueue
                  |L8.112|
                          DCD      0xe000ed04

                          AREA ||i.prvSampleTimeNow||, CODE, READONLY, ALIGN=2

                  prvSampleTimeNow PROC
;;;659    
;;;660    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
000000  b570              PUSH     {r4-r6,lr}
;;;661    {
000002  4604              MOV      r4,r0
;;;662    TickType_t xTimeNow;
;;;663    PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */
;;;664    
;;;665    	xTimeNow = xTaskGetTickCount();
000004  f7fffffe          BL       xTaskGetTickCount
000008  4605              MOV      r5,r0
;;;666    
;;;667    	if( xTimeNow < xLastTime )
00000a  4807              LDR      r0,|L9.40|
00000c  6800              LDR      r0,[r0,#0]  ; xLastTime
00000e  4285              CMP      r5,r0
000010  d204              BCS      |L9.28|
;;;668    	{
;;;669    		prvSwitchTimerLists();
000012  f7fffffe          BL       prvSwitchTimerLists
;;;670    		*pxTimerListsWereSwitched = pdTRUE;
000016  2001              MOVS     r0,#1
000018  6020              STR      r0,[r4,#0]
00001a  e001              B        |L9.32|
                  |L9.28|
;;;671    	}
;;;672    	else
;;;673    	{
;;;674    		*pxTimerListsWereSwitched = pdFALSE;
00001c  2000              MOVS     r0,#0
00001e  6020              STR      r0,[r4,#0]
                  |L9.32|
;;;675    	}
;;;676    
;;;677    	xLastTime = xTimeNow;
000020  4801              LDR      r0,|L9.40|
000022  6005              STR      r5,[r0,#0]  ; xLastTime
;;;678    
;;;679    	return xTimeNow;
000024  4628              MOV      r0,r5
;;;680    }
000026  bd70              POP      {r4-r6,pc}
;;;681    /*-----------------------------------------------------------*/
                          ENDP

                  |L9.40|
                          DCD      xLastTime

                          AREA ||i.prvSwitchTimerLists||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  prvSwitchTimerLists PROC
;;;870    
;;;871    static void prvSwitchTimerLists( void )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;872    {
;;;873    TickType_t xNextExpireTime, xReloadTime;
;;;874    List_t *pxTemp;
;;;875    Timer_t *pxTimer;
;;;876    BaseType_t xResult;
;;;877    
;;;878    	/* The tick count has overflowed.  The timer lists must be switched.
;;;879    	If there are any timers still referenced from the current timer list
;;;880    	then they must have expired and should be processed before the lists
;;;881    	are switched. */
;;;882    	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
000004  e02d              B        |L10.98|
                  |L10.6|
;;;883    	{
;;;884    		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
000006  4821              LDR      r0,|L10.140|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  6805              LDR      r5,[r0,#0]
;;;885    
;;;886    		/* Remove the timer from the list. */
;;;887    		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
00000e  481f              LDR      r0,|L10.140|
000010  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
000012  68c0              LDR      r0,[r0,#0xc]
000014  68c4              LDR      r4,[r0,#0xc]
;;;888    		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
000016  1d20              ADDS     r0,r4,#4
000018  f7fffffe          BL       uxListRemove
;;;889    		traceTIMER_EXPIRED( pxTimer );
;;;890    
;;;891    		/* Execute its callback, then send a command to restart the timer if
;;;892    		it is an auto-reload timer.  It cannot be restarted here as the lists
;;;893    		have not yet been switched. */
;;;894    		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
00001c  4620              MOV      r0,r4
00001e  6a61              LDR      r1,[r4,#0x24]
000020  4788              BLX      r1
;;;895    
;;;896    		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
000022  69e0              LDR      r0,[r4,#0x1c]
000024  2801              CMP      r0,#1
000026  d11c              BNE      |L10.98|
;;;897    		{
;;;898    			/* Calculate the reload value, and if the reload value results in
;;;899    			the timer going into the same timer list then it has already expired
;;;900    			and the timer should be re-inserted into the current list so it is
;;;901    			processed again within this loop.  Otherwise a command should be sent
;;;902    			to restart the timer to ensure it is only inserted into a list after
;;;903    			the lists have been swapped. */
;;;904    			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
000028  69a0              LDR      r0,[r4,#0x18]
00002a  1946              ADDS     r6,r0,r5
;;;905    			if( xReloadTime > xNextExpireTime )
00002c  42ae              CMP      r6,r5
00002e  d907              BLS      |L10.64|
;;;906    			{
;;;907    				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
000030  6066              STR      r6,[r4,#4]
;;;908    				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
000032  6124              STR      r4,[r4,#0x10]
;;;909    				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
000034  1d21              ADDS     r1,r4,#4
000036  4815              LDR      r0,|L10.140|
000038  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
00003a  f7fffffe          BL       vListInsert
00003e  e010              B        |L10.98|
                  |L10.64|
;;;910    			}
;;;911    			else
;;;912    			{
;;;913    				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
000040  2000              MOVS     r0,#0
000042  4603              MOV      r3,r0
000044  462a              MOV      r2,r5
000046  4601              MOV      r1,r0
000048  9000              STR      r0,[sp,#0]
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       xTimerGenericCommand
000050  4607              MOV      r7,r0
;;;914    				configASSERT( xResult );
000052  b92f              CBNZ     r7,|L10.96|
000054  f2403292          MOV      r2,#0x392
000058  a10d              ADR      r1,|L10.144|
00005a  a013              ADR      r0,|L10.168|
00005c  f7fffffe          BL       __2printf
                  |L10.96|
;;;915    				( void ) xResult;
000060  bf00              NOP      
                  |L10.98|
000062  480a              LDR      r0,|L10.140|
000064  6800              LDR      r0,[r0,#0]            ;882  ; pxCurrentTimerList
000066  6800              LDR      r0,[r0,#0]            ;882
000068  b908              CBNZ     r0,|L10.110|
00006a  2001              MOVS     r0,#1                 ;882
00006c  e000              B        |L10.112|
                  |L10.110|
00006e  2000              MOVS     r0,#0                 ;882
                  |L10.112|
000070  2800              CMP      r0,#0                 ;882
000072  d0c8              BEQ      |L10.6|
;;;916    			}
;;;917    		}
;;;918    		else
;;;919    		{
;;;920    			mtCOVERAGE_TEST_MARKER();
;;;921    		}
;;;922    	}
;;;923    
;;;924    	pxTemp = pxCurrentTimerList;
000074  4805              LDR      r0,|L10.140|
000076  f8d08000          LDR      r8,[r0,#0]  ; pxCurrentTimerList
;;;925    	pxCurrentTimerList = pxOverflowTimerList;
00007a  480f              LDR      r0,|L10.184|
00007c  6800              LDR      r0,[r0,#0]  ; pxOverflowTimerList
00007e  4903              LDR      r1,|L10.140|
000080  6008              STR      r0,[r1,#0]  ; pxCurrentTimerList
;;;926    	pxOverflowTimerList = pxTemp;
000082  480d              LDR      r0,|L10.184|
000084  f8c08000          STR      r8,[r0,#0]  ; pxOverflowTimerList
;;;927    }
000088  e8bd83f8          POP      {r3-r9,pc}
;;;928    /*-----------------------------------------------------------*/
                          ENDP

                  |L10.140|
                          DCD      pxCurrentTimerList
                  |L10.144|
000090  2e2e5c46          DCB      "..\\FreeRTOS\\timers.c",0
000094  72656552
000098  544f535c
00009c  74696d65
0000a0  72732e63
0000a4  00      
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L10.168|
0000a8  4572726f          DCB      "Error:%s,%d\r\n",0
0000ac  723a2573
0000b0  2c25640d
0000b4  0a00    
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L10.184|
                          DCD      pxOverflowTimerList

                          AREA ||i.prvTimerTask||, CODE, READONLY, ALIGN=1

                  prvTimerTask PROC
;;;537    
;;;538    static void prvTimerTask( void *pvParameters )
000000  b508              PUSH     {r3,lr}
;;;539    {
;;;540    TickType_t xNextExpireTime;
;;;541    BaseType_t xListWasEmpty;
;;;542    
;;;543    	/* Just to avoid compiler warnings. */
;;;544    	( void ) pvParameters;
;;;545    
;;;546    	#if( configUSE_DAEMON_TASK_STARTUP_HOOK == 1 )
;;;547    	{
;;;548    		extern void vApplicationDaemonTaskStartupHook( void );
;;;549    
;;;550    		/* Allow the application writer to execute some code in the context of
;;;551    		this task at the point the task starts executing.  This is useful if the
;;;552    		application includes initialisation code that would benefit from
;;;553    		executing after the scheduler has been started. */
;;;554    		vApplicationDaemonTaskStartupHook();
;;;555    	}
;;;556    	#endif /* configUSE_DAEMON_TASK_STARTUP_HOOK */
;;;557    
;;;558    	for( ;; )
000002  bf00              NOP      
                  |L11.4|
;;;559    	{
;;;560    		/* Query the timers list to see if it contains any timers, and if so,
;;;561    		obtain the time at which the next timer will expire. */
;;;562    		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
000004  4668              MOV      r0,sp
000006  f7fffffe          BL       prvGetNextExpireTime
00000a  4604              MOV      r4,r0
;;;563    
;;;564    		/* If a timer has expired, process it.  Otherwise, block this task
;;;565    		until either a timer does expire, or a command is received. */
;;;566    		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
00000c  4620              MOV      r0,r4
00000e  9900              LDR      r1,[sp,#0]
000010  f7fffffe          BL       prvProcessTimerOrBlockTask
;;;567    
;;;568    		/* Empty the command queue. */
;;;569    		prvProcessReceivedCommands();
000014  f7fffffe          BL       prvProcessReceivedCommands
000018  e7f4              B        |L11.4|
;;;570    	}
;;;571    }
;;;572    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.pvTimerGetTimerID||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  pvTimerGetTimerID PROC
;;;1001   
;;;1002   void *pvTimerGetTimerID( const TimerHandle_t xTimer )
000000  b570              PUSH     {r4-r6,lr}
;;;1003   {
000002  4604              MOV      r4,r0
;;;1004   Timer_t * const pxTimer = ( Timer_t * ) xTimer;
000004  4626              MOV      r6,r4
;;;1005   void *pvReturn;
;;;1006   
;;;1007   	configASSERT( xTimer );
000006  b92c              CBNZ     r4,|L12.20|
000008  f24032ef          MOV      r2,#0x3ef
00000c  a105              ADR      r1,|L12.36|
00000e  a00b              ADR      r0,|L12.60|
000010  f7fffffe          BL       __2printf
                  |L12.20|
;;;1008   
;;;1009   	taskENTER_CRITICAL();
000014  f7fffffe          BL       vPortEnterCritical
;;;1010   	{
;;;1011   		pvReturn = pxTimer->pvTimerID;
000018  6a35              LDR      r5,[r6,#0x20]
;;;1012   	}
;;;1013   	taskEXIT_CRITICAL();
00001a  f7fffffe          BL       vPortExitCritical
;;;1014   
;;;1015   	return pvReturn;
00001e  4628              MOV      r0,r5
;;;1016   }
000020  bd70              POP      {r4-r6,pc}
;;;1017   /*-----------------------------------------------------------*/
                          ENDP

000022  0000              DCW      0x0000
                  |L12.36|
000024  2e2e5c46          DCB      "..\\FreeRTOS\\timers.c",0
000028  72656552
00002c  544f535c
000030  74696d65
000034  72732e63
000038  00      
000039  00                DCB      0
00003a  00                DCB      0
00003b  00                DCB      0
                  |L12.60|
00003c  4572726f          DCB      "Error:%s,%d\r\n",0
000040  723a2573
000044  2c25640d
000048  0a00    
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.vTimerSetTimerID||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vTimerSetTimerID PROC
;;;1018   
;;;1019   void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
000000  b570              PUSH     {r4-r6,lr}
;;;1020   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1021   Timer_t * const pxTimer = ( Timer_t * ) xTimer;
000006  4626              MOV      r6,r4
;;;1022   
;;;1023   	configASSERT( xTimer );
000008  b92c              CBNZ     r4,|L13.22|
00000a  f24032ff          MOV      r2,#0x3ff
00000e  a105              ADR      r1,|L13.36|
000010  a00a              ADR      r0,|L13.60|
000012  f7fffffe          BL       __2printf
                  |L13.22|
;;;1024   
;;;1025   	taskENTER_CRITICAL();
000016  f7fffffe          BL       vPortEnterCritical
;;;1026   	{
;;;1027   		pxTimer->pvTimerID = pvNewID;
00001a  6235              STR      r5,[r6,#0x20]
;;;1028   	}
;;;1029   	taskEXIT_CRITICAL();
00001c  f7fffffe          BL       vPortExitCritical
;;;1030   }
000020  bd70              POP      {r4-r6,pc}
;;;1031   /*-----------------------------------------------------------*/
                          ENDP

000022  0000              DCW      0x0000
                  |L13.36|
000024  2e2e5c46          DCB      "..\\FreeRTOS\\timers.c",0
000028  72656552
00002c  544f535c
000030  74696d65
000034  72732e63
000038  00      
000039  00                DCB      0
00003a  00                DCB      0
00003b  00                DCB      0
                  |L13.60|
00003c  4572726f          DCB      "Error:%s,%d\r\n",0
000040  723a2573
000044  2c25640d
000048  0a00    
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.xTimerCreate||, CODE, READONLY, ALIGN=1

                  xTimerCreate PROC
;;;313    
;;;314    	TimerHandle_t xTimerCreate(	const char * const pcTimerName,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;315    								const TickType_t xTimerPeriodInTicks,
;;;316    								const UBaseType_t uxAutoReload,
;;;317    								void * const pvTimerID,
;;;318    								TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;319    	{
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9028          LDR      r9,[sp,#0x28]
;;;320    	Timer_t *pxNewTimer;
;;;321    
;;;322    		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
000010  202c              MOVS     r0,#0x2c
000012  f7fffffe          BL       pvPortMalloc
000016  4604              MOV      r4,r0
;;;323    
;;;324    		if( pxNewTimer != NULL )
000018  b13c              CBZ      r4,|L14.42|
;;;325    		{
;;;326    			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
00001a  4643              MOV      r3,r8
00001c  463a              MOV      r2,r7
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  e9cd9400          STRD     r9,r4,[sp,#0]
000026  f7fffffe          BL       prvInitialiseNewTimer
                  |L14.42|
;;;327    
;;;328    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;329    			{
;;;330    				/* Timers can be created statically or dynamically, so note this
;;;331    				timer was created dynamically in case the timer is later
;;;332    				deleted. */
;;;333    				pxNewTimer->ucStaticallyAllocated = pdFALSE;
;;;334    			}
;;;335    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;336    		}
;;;337    
;;;338    		return pxNewTimer;
00002a  4620              MOV      r0,r4
;;;339    	}
00002c  e8bd87fc          POP      {r2-r10,pc}
;;;340    
                          ENDP


                          AREA ||i.xTimerCreateTimerTask||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  xTimerCreateTimerTask PROC
;;;258    
;;;259    BaseType_t xTimerCreateTimerTask( void )
000000  b51c              PUSH     {r2-r4,lr}
;;;260    {
;;;261    BaseType_t xReturn = pdFAIL;
000002  2400              MOVS     r4,#0
;;;262    
;;;263    	/* This function is called when the scheduler is started if
;;;264    	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
;;;265    	timer service task has been created/initialised.  If timers have already
;;;266    	been created then the initialisation will already have been performed. */
;;;267    	prvCheckForValidListAndQueue();
000004  f7fffffe          BL       prvCheckForValidListAndQueue
;;;268    
;;;269    	if( xTimerQueue != NULL )
000008  480b              LDR      r0,|L15.56|
00000a  6800              LDR      r0,[r0,#0]  ; xTimerQueue
00000c  b158              CBZ      r0,|L15.38|
;;;270    	{
;;;271    		#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;272    		{
;;;273    			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
;;;274    			StackType_t *pxTimerTaskStackBuffer = NULL;
;;;275    			uint32_t ulTimerTaskStackSize;
;;;276    
;;;277    			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
;;;278    			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
;;;279    													"Tmr Svc",
;;;280    													ulTimerTaskStackSize,
;;;281    													NULL,
;;;282    													( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
;;;283    													pxTimerTaskStackBuffer,
;;;284    													pxTimerTaskTCBBuffer );
;;;285    
;;;286    			if( xTimerTaskHandle != NULL )
;;;287    			{
;;;288    				xReturn = pdPASS;
;;;289    			}
;;;290    		}
;;;291    		#else
;;;292    		{
;;;293    			xReturn = xTaskCreate(	prvTimerTask,
00000e  480b              LDR      r0,|L15.60|
000010  211f              MOVS     r1,#0x1f
000012  2300              MOVS     r3,#0
000014  f44f7282          MOV      r2,#0x104
000018  e9cd1000          STRD     r1,r0,[sp,#0]
00001c  a108              ADR      r1,|L15.64|
00001e  480a              LDR      r0,|L15.72|
000020  f7fffffe          BL       xTaskCreate
000024  4604              MOV      r4,r0
                  |L15.38|
;;;294    									"Tmr Svc",
;;;295    									configTIMER_TASK_STACK_DEPTH,
;;;296    									NULL,
;;;297    									( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
;;;298    									&xTimerTaskHandle );
;;;299    		}
;;;300    		#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;301    	}
;;;302    	else
;;;303    	{
;;;304    		mtCOVERAGE_TEST_MARKER();
;;;305    	}
;;;306    
;;;307    	configASSERT( xReturn );
000026  b92c              CBNZ     r4,|L15.52|
000028  f2401233          MOV      r2,#0x133
00002c  a107              ADR      r1,|L15.76|
00002e  a00d              ADR      r0,|L15.100|
000030  f7fffffe          BL       __2printf
                  |L15.52|
;;;308    	return xReturn;
000034  4620              MOV      r0,r4
;;;309    }
000036  bd1c              POP      {r2-r4,pc}
;;;310    /*-----------------------------------------------------------*/
                          ENDP

                  |L15.56|
                          DCD      xTimerQueue
                  |L15.60|
                          DCD      xTimerTaskHandle
                  |L15.64|
000040  546d7220          DCB      "Tmr Svc",0
000044  53766300
                  |L15.72|
                          DCD      prvTimerTask
                  |L15.76|
00004c  2e2e5c46          DCB      "..\\FreeRTOS\\timers.c",0
000050  72656552
000054  544f535c
000058  74696d65
00005c  72732e63
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0
                  |L15.100|
000064  4572726f          DCB      "Error:%s,%d\r\n",0
000068  723a2573
00006c  2c25640d
000070  0a00    
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.xTimerGenericCommand||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  xTimerGenericCommand PROC
;;;416    
;;;417    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;418    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8030          LDR      r8,[sp,#0x30]
;;;419    BaseType_t xReturn = pdFAIL;
000010  f04f0900          MOV      r9,#0
;;;420    DaemonTaskMessage_t xMessage;
;;;421    
;;;422    	configASSERT( xTimer );
000014  b92c              CBNZ     r4,|L16.34|
000016  f44f72d3          MOV      r2,#0x1a6
00001a  a117              ADR      r1,|L16.120|
00001c  a01c              ADR      r0,|L16.144|
00001e  f7fffffe          BL       __2printf
                  |L16.34|
;;;423    
;;;424    	/* Send a message to the timer service task to perform a particular action
;;;425    	on a particular timer definition. */
;;;426    	if( xTimerQueue != NULL )
000022  481f              LDR      r0,|L16.160|
000024  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000026  b310              CBZ      r0,|L16.110|
;;;427    	{
;;;428    		/* Send a command to the timer service task to start the xTimer timer. */
;;;429    		xMessage.xMessageID = xCommandID;
000028  9500              STR      r5,[sp,#0]
;;;430    		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
00002a  9601              STR      r6,[sp,#4]
;;;431    		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
00002c  9402              STR      r4,[sp,#8]
;;;432    
;;;433    		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
00002e  2d06              CMP      r5,#6
000030  da15              BGE      |L16.94|
;;;434    		{
;;;435    			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
000032  f7fffffe          BL       xTaskGetSchedulerState
000036  2802              CMP      r0,#2
000038  d108              BNE      |L16.76|
;;;436    			{
;;;437    				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
00003a  2300              MOVS     r3,#0
00003c  4642              MOV      r2,r8
00003e  4669              MOV      r1,sp
000040  4817              LDR      r0,|L16.160|
000042  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000044  f7fffffe          BL       xQueueGenericSend
000048  4681              MOV      r9,r0
00004a  e010              B        |L16.110|
                  |L16.76|
;;;438    			}
;;;439    			else
;;;440    			{
;;;441    				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
00004c  2300              MOVS     r3,#0
00004e  461a              MOV      r2,r3
000050  4669              MOV      r1,sp
000052  4813              LDR      r0,|L16.160|
000054  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000056  f7fffffe          BL       xQueueGenericSend
00005a  4681              MOV      r9,r0
00005c  e007              B        |L16.110|
                  |L16.94|
;;;442    			}
;;;443    		}
;;;444    		else
;;;445    		{
;;;446    			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
00005e  2300              MOVS     r3,#0
000060  463a              MOV      r2,r7
000062  4669              MOV      r1,sp
000064  480e              LDR      r0,|L16.160|
000066  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000068  f7fffffe          BL       xQueueGenericSendFromISR
00006c  4681              MOV      r9,r0
                  |L16.110|
;;;447    		}
;;;448    
;;;449    		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
;;;450    	}
;;;451    	else
;;;452    	{
;;;453    		mtCOVERAGE_TEST_MARKER();
;;;454    	}
;;;455    
;;;456    	return xReturn;
00006e  4648              MOV      r0,r9
;;;457    }
000070  b004              ADD      sp,sp,#0x10
000072  e8bd87f0          POP      {r4-r10,pc}
;;;458    /*-----------------------------------------------------------*/
                          ENDP

000076  0000              DCW      0x0000
                  |L16.120|
000078  2e2e5c46          DCB      "..\\FreeRTOS\\timers.c",0
00007c  72656552
000080  544f535c
000084  74696d65
000088  72732e63
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0
                  |L16.144|
000090  4572726f          DCB      "Error:%s,%d\r\n",0
000094  723a2573
000098  2c25640d
00009c  0a00    
00009e  00                DCB      0
00009f  00                DCB      0
                  |L16.160|
                          DCD      xTimerQueue

                          AREA ||i.xTimerGetExpiryTime||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  xTimerGetExpiryTime PROC
;;;477    
;;;478    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
000000  b570              PUSH     {r4-r6,lr}
;;;479    {
000002  4604              MOV      r4,r0
;;;480    Timer_t * pxTimer = ( Timer_t * ) xTimer;
000004  4625              MOV      r5,r4
;;;481    TickType_t xReturn;
;;;482    
;;;483    	configASSERT( xTimer );
000006  b92c              CBNZ     r4,|L17.20|
000008  f24012e3          MOV      r2,#0x1e3
00000c  a103              ADR      r1,|L17.28|
00000e  a009              ADR      r0,|L17.52|
000010  f7fffffe          BL       __2printf
                  |L17.20|
;;;484    	xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
000014  686e              LDR      r6,[r5,#4]
;;;485    	return xReturn;
000016  4630              MOV      r0,r6
;;;486    }
000018  bd70              POP      {r4-r6,pc}
;;;487    /*-----------------------------------------------------------*/
                          ENDP

00001a  0000              DCW      0x0000
                  |L17.28|
00001c  2e2e5c46          DCB      "..\\FreeRTOS\\timers.c",0
000020  72656552
000024  544f535c
000028  74696d65
00002c  72732e63
000030  00      
000031  00                DCB      0
000032  00                DCB      0
000033  00                DCB      0
                  |L17.52|
000034  4572726f          DCB      "Error:%s,%d\r\n",0
000038  723a2573
00003c  2c25640d
000040  0a00    
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.xTimerGetPeriod||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  xTimerGetPeriod PROC
;;;468    
;;;469    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
000000  b570              PUSH     {r4-r6,lr}
;;;470    {
000002  4604              MOV      r4,r0
;;;471    Timer_t *pxTimer = ( Timer_t * ) xTimer;
000004  4625              MOV      r5,r4
;;;472    
;;;473    	configASSERT( xTimer );
000006  b92c              CBNZ     r4,|L18.20|
000008  f24012d9          MOV      r2,#0x1d9
00000c  a102              ADR      r1,|L18.24|
00000e  a008              ADR      r0,|L18.48|
000010  f7fffffe          BL       __2printf
                  |L18.20|
;;;474    	return pxTimer->xTimerPeriodInTicks;
000014  69a8              LDR      r0,[r5,#0x18]
;;;475    }
000016  bd70              POP      {r4-r6,pc}
;;;476    /*-----------------------------------------------------------*/
                          ENDP

                  |L18.24|
000018  2e2e5c46          DCB      "..\\FreeRTOS\\timers.c",0
00001c  72656552
000020  544f535c
000024  74696d65
000028  72732e63
00002c  00      
00002d  00                DCB      0
00002e  00                DCB      0
00002f  00                DCB      0
                  |L18.48|
000030  4572726f          DCB      "Error:%s,%d\r\n",0
000034  723a2573
000038  2c25640d
00003c  0a00    
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.xTimerGetTimerDaemonTaskHandle||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  xTimerGetTimerDaemonTaskHandle PROC
;;;459    
;;;460    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
000000  b510              PUSH     {r4,lr}
;;;461    {
;;;462    	/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
;;;463    	started, then xTimerTaskHandle will be NULL. */
;;;464    	configASSERT( ( xTimerTaskHandle != NULL ) );
000002  4808              LDR      r0,|L19.36|
000004  6800              LDR      r0,[r0,#0]  ; xTimerTaskHandle
000006  b108              CBZ      r0,|L19.12|
000008  2001              MOVS     r0,#1
00000a  e000              B        |L19.14|
                  |L19.12|
00000c  2000              MOVS     r0,#0
                  |L19.14|
00000e  b928              CBNZ     r0,|L19.28|
000010  f44f72e8          MOV      r2,#0x1d0
000014  a104              ADR      r1,|L19.40|
000016  a00a              ADR      r0,|L19.64|
000018  f7fffffe          BL       __2printf
                  |L19.28|
;;;465    	return xTimerTaskHandle;
00001c  4801              LDR      r0,|L19.36|
00001e  6800              LDR      r0,[r0,#0]  ; xTimerTaskHandle
;;;466    }
000020  bd10              POP      {r4,pc}
;;;467    /*-----------------------------------------------------------*/
                          ENDP

000022  0000              DCW      0x0000
                  |L19.36|
                          DCD      xTimerTaskHandle
                  |L19.40|
000028  2e2e5c46          DCB      "..\\FreeRTOS\\timers.c",0
00002c  72656552
000030  544f535c
000034  74696d65
000038  72732e63
00003c  00      
00003d  00                DCB      0
00003e  00                DCB      0
00003f  00                DCB      0
                  |L19.64|
000040  4572726f          DCB      "Error:%s,%d\r\n",0
000044  723a2573
000048  2c25640d
00004c  0a00    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.xTimerIsTimerActive||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  xTimerIsTimerActive PROC
;;;980    
;;;981    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
000000  b570              PUSH     {r4-r6,lr}
;;;982    {
000002  4604              MOV      r4,r0
;;;983    BaseType_t xTimerIsInActiveList;
;;;984    Timer_t *pxTimer = ( Timer_t * ) xTimer;
000004  4626              MOV      r6,r4
;;;985    
;;;986    	configASSERT( xTimer );
000006  b92c              CBNZ     r4,|L20.20|
000008  f24032da          MOV      r2,#0x3da
00000c  a108              ADR      r1,|L20.48|
00000e  a00e              ADR      r0,|L20.72|
000010  f7fffffe          BL       __2printf
                  |L20.20|
;;;987    
;;;988    	/* Is the timer in the list of active timers? */
;;;989    	taskENTER_CRITICAL();
000014  f7fffffe          BL       vPortEnterCritical
;;;990    	{
;;;991    		/* Checking to see if it is in the NULL list in effect checks to see if
;;;992    		it is referenced from either the current or the overflow timer lists in
;;;993    		one go, but the logic has to be reversed, hence the '!'. */
;;;994    		xTimerIsInActiveList = ( BaseType_t ) !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
000018  6970              LDR      r0,[r6,#0x14]
00001a  b908              CBNZ     r0,|L20.32|
00001c  2001              MOVS     r0,#1
00001e  e000              B        |L20.34|
                  |L20.32|
000020  2000              MOVS     r0,#0
                  |L20.34|
000022  f0800501          EOR      r5,r0,#1
;;;995    	}
;;;996    	taskEXIT_CRITICAL();
000026  f7fffffe          BL       vPortExitCritical
;;;997    
;;;998    	return xTimerIsInActiveList;
00002a  4628              MOV      r0,r5
;;;999    } /*lint !e818 Can't be pointer to const due to the typedef. */
00002c  bd70              POP      {r4-r6,pc}
;;;1000   /*-----------------------------------------------------------*/
                          ENDP

00002e  0000              DCW      0x0000
                  |L20.48|
000030  2e2e5c46          DCB      "..\\FreeRTOS\\timers.c",0
000034  72656552
000038  544f535c
00003c  74696d65
000040  72732e63
000044  00      
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0
                  |L20.72|
000048  4572726f          DCB      "Error:%s,%d\r\n",0
00004c  723a2573
000050  2c25640d
000054  0a00    
000056  00                DCB      0
000057  00                DCB      0

                          AREA ||i.xTimerPendFunctionCall||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  xTimerPendFunctionCall PROC
;;;1058   
;;;1059   	BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;1060   	{
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1061   	DaemonTaskMessage_t xMessage;
;;;1062   	BaseType_t xReturn;
;;;1063   
;;;1064   		/* This function can only be called after a timer has been created or
;;;1065   		after the scheduler has been started because, until then, the timer
;;;1066   		queue does not exist. */
;;;1067   		configASSERT( xTimerQueue );
00000c  480d              LDR      r0,|L21.68|
00000e  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000010  b928              CBNZ     r0,|L21.30|
000012  f240422b          MOV      r2,#0x42b
000016  a10c              ADR      r1,|L21.72|
000018  a011              ADR      r0,|L21.96|
00001a  f7fffffe          BL       __2printf
                  |L21.30|
;;;1068   
;;;1069   		/* Complete the message with the function parameters and post it to the
;;;1070   		daemon task. */
;;;1071   		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
00001e  f04f30ff          MOV      r0,#0xffffffff
000022  9000              STR      r0,[sp,#0]
;;;1072   		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
000024  9401              STR      r4,[sp,#4]
;;;1073   		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
000026  9502              STR      r5,[sp,#8]
;;;1074   		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
000028  9603              STR      r6,[sp,#0xc]
;;;1075   
;;;1076   		xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
00002a  2300              MOVS     r3,#0
00002c  463a              MOV      r2,r7
00002e  4669              MOV      r1,sp
000030  4804              LDR      r0,|L21.68|
000032  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000034  f7fffffe          BL       xQueueGenericSend
000038  4680              MOV      r8,r0
;;;1077   
;;;1078   		tracePEND_FUNC_CALL( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
;;;1079   
;;;1080   		return xReturn;
00003a  4640              MOV      r0,r8
;;;1081   	}
00003c  b004              ADD      sp,sp,#0x10
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;1082   
                          ENDP

000042  0000              DCW      0x0000
                  |L21.68|
                          DCD      xTimerQueue
                  |L21.72|
000048  2e2e5c46          DCB      "..\\FreeRTOS\\timers.c",0
00004c  72656552
000050  544f535c
000054  74696d65
000058  72732e63
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0
                  |L21.96|
000060  4572726f          DCB      "Error:%s,%d\r\n",0
000064  723a2573
000068  2c25640d
00006c  0a00    
00006e  00                DCB      0
00006f  00                DCB      0

                          AREA ||i.xTimerPendFunctionCallFromISR||, CODE, READONLY, ALIGN=2

                  xTimerPendFunctionCallFromISR PROC
;;;1034   
;;;1035   	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;1036   	{
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1037   	DaemonTaskMessage_t xMessage;
;;;1038   	BaseType_t xReturn;
;;;1039   
;;;1040   		/* Complete the message with the function parameters and post it to the
;;;1041   		daemon task. */
;;;1042   		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
00000c  f06f0001          MVN      r0,#1
000010  9000              STR      r0,[sp,#0]
;;;1043   		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
000012  9401              STR      r4,[sp,#4]
;;;1044   		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
000014  9502              STR      r5,[sp,#8]
;;;1045   		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
000016  9603              STR      r6,[sp,#0xc]
;;;1046   
;;;1047   		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
000018  2300              MOVS     r3,#0
00001a  463a              MOV      r2,r7
00001c  4669              MOV      r1,sp
00001e  4804              LDR      r0,|L22.48|
000020  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000022  f7fffffe          BL       xQueueGenericSendFromISR
000026  4680              MOV      r8,r0
;;;1048   
;;;1049   		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
;;;1050   
;;;1051   		return xReturn;
000028  4640              MOV      r0,r8
;;;1052   	}
00002a  b004              ADD      sp,sp,#0x10
00002c  e8bd81f0          POP      {r4-r8,pc}
;;;1053   
                          ENDP

                  |L22.48|
                          DCD      xTimerQueue

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  xActiveTimerList1
                          %        20
                  xActiveTimerList2
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTimerList
                          DCD      0x00000000
                  pxOverflowTimerList
                          DCD      0x00000000
                  xTimerQueue
                          DCD      0x00000000
                  xTimerTaskHandle
                          DCD      0x00000000
                  xLastTime
                          DCD      0x00000000
