; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\raw.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\raw.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\raw.crf ..\LWIP\lwip-1.4.1\src\core\raw.c]
                          THUMB

                          AREA ||i.raw_bind||, CODE, READONLY, ALIGN=1

                  raw_bind PROC
;;;141    err_t
;;;142    raw_bind(struct raw_pcb *pcb, ip_addr_t *ipaddr)
000000  4602              MOV      r2,r0
;;;143    {
;;;144      ip_addr_set(&pcb->local_ip, ipaddr);
000002  b909              CBNZ     r1,|L1.8|
000004  2000              MOVS     r0,#0
000006  e000              B        |L1.10|
                  |L1.8|
000008  6808              LDR      r0,[r1,#0]
                  |L1.10|
00000a  6010              STR      r0,[r2,#0]
;;;145      return ERR_OK;
00000c  2000              MOVS     r0,#0
;;;146    }
00000e  4770              BX       lr
;;;147    
                          ENDP


                          AREA ||i.raw_connect||, CODE, READONLY, ALIGN=1

                  raw_connect PROC
;;;161    err_t
;;;162    raw_connect(struct raw_pcb *pcb, ip_addr_t *ipaddr)
000000  4602              MOV      r2,r0
;;;163    {
;;;164      ip_addr_set(&pcb->remote_ip, ipaddr);
000002  b909              CBNZ     r1,|L2.8|
000004  2000              MOVS     r0,#0
000006  e000              B        |L2.10|
                  |L2.8|
000008  6808              LDR      r0,[r1,#0]
                  |L2.10|
00000a  6050              STR      r0,[r2,#4]
;;;165      return ERR_OK;
00000c  2000              MOVS     r0,#0
;;;166    }
00000e  4770              BX       lr
;;;167    
                          ENDP


                          AREA ||i.raw_input||, CODE, READONLY, ALIGN=2

                  raw_input PROC
;;;75     u8_t
;;;76     raw_input(struct pbuf *p, struct netif *inp)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;77     {
000004  4605              MOV      r5,r0
000006  468a              MOV      r10,r1
;;;78       struct raw_pcb *pcb, *prev;
;;;79       struct ip_hdr *iphdr;
;;;80       s16_t proto;
;;;81       u8_t eaten = 0;
000008  2700              MOVS     r7,#0
;;;82     
;;;83       LWIP_UNUSED_ARG(inp);
;;;84     
;;;85       iphdr = (struct ip_hdr *)p->payload;
00000a  f8d58004          LDR      r8,[r5,#4]
;;;86       proto = IPH_PROTO(iphdr);
00000e  f8989009          LDRB     r9,[r8,#9]
;;;87     
;;;88       prev = NULL;
000012  2600              MOVS     r6,#0
;;;89       pcb = raw_pcbs;
000014  4814              LDR      r0,|L3.104|
000016  6804              LDR      r4,[r0,#0]  ; raw_pcbs
;;;90       /* loop through all raw pcbs until the packet is eaten by one */
;;;91       /* this allows multiple pcbs to match against the packet by design */
;;;92       while ((eaten == 0) && (pcb != NULL)) {
000018  e01f              B        |L3.90|
                  |L3.26|
;;;93         if ((pcb->protocol == proto) &&
00001a  7c20              LDRB     r0,[r4,#0x10]
00001c  4548              CMP      r0,r9
00001e  d11a              BNE      |L3.86|
;;;94             (ip_addr_isany(&pcb->local_ip) ||
000020  b134              CBZ      r4,|L3.48|
000022  6820              LDR      r0,[r4,#0]
000024  b120              CBZ      r0,|L3.48|
;;;95              ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
000026  4911              LDR      r1,|L3.108|
000028  6820              LDR      r0,[r4,#0]
00002a  6809              LDR      r1,[r1,#0]  ; current_iphdr_dest
00002c  4288              CMP      r0,r1
00002e  d112              BNE      |L3.86|
                  |L3.48|
;;;96     #if IP_SOF_BROADCAST_RECV
;;;97           /* broadcast filter? */
;;;98           if (ip_get_option(pcb, SOF_BROADCAST) || !ip_addr_isbroadcast(&current_iphdr_dest, inp))
;;;99     #endif /* IP_SOF_BROADCAST_RECV */
;;;100          {
;;;101            /* receive callback function available? */
;;;102            if (pcb->recv != NULL) {
000030  6960              LDR      r0,[r4,#0x14]
000032  b180              CBZ      r0,|L3.86|
;;;103              /* the receive callback function did not eat the packet? */
;;;104              if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
000034  4b0e              LDR      r3,|L3.112|
000036  462a              MOV      r2,r5
000038  4621              MOV      r1,r4
00003a  e9d4c005          LDRD     r12,r0,[r4,#0x14]
00003e  47e0              BLX      r12
000040  b148              CBZ      r0,|L3.86|
;;;105                /* receive function ate the packet */
;;;106                p = NULL;
000042  2500              MOVS     r5,#0
;;;107                eaten = 1;
000044  2701              MOVS     r7,#1
;;;108                if (prev != NULL) {
000046  b136              CBZ      r6,|L3.86|
;;;109                /* move the pcb to the front of raw_pcbs so that is
;;;110                   found faster next time */
;;;111                  prev->next = pcb->next;
000048  68e0              LDR      r0,[r4,#0xc]
00004a  60f0              STR      r0,[r6,#0xc]
;;;112                  pcb->next = raw_pcbs;
00004c  4806              LDR      r0,|L3.104|
00004e  6800              LDR      r0,[r0,#0]  ; raw_pcbs
000050  60e0              STR      r0,[r4,#0xc]
;;;113                  raw_pcbs = pcb;
000052  4805              LDR      r0,|L3.104|
000054  6004              STR      r4,[r0,#0]  ; raw_pcbs
                  |L3.86|
;;;114                }
;;;115              }
;;;116            }
;;;117            /* no receive callback function was set for this raw PCB */
;;;118          }
;;;119          /* drop the packet */
;;;120        }
;;;121        prev = pcb;
000056  4626              MOV      r6,r4
;;;122        pcb = pcb->next;
000058  68e4              LDR      r4,[r4,#0xc]
                  |L3.90|
00005a  b90f              CBNZ     r7,|L3.96|
00005c  2c00              CMP      r4,#0                 ;92
00005e  d1dc              BNE      |L3.26|
                  |L3.96|
;;;123      }
;;;124      return eaten;
000060  4638              MOV      r0,r7
;;;125    }
000062  e8bd87f0          POP      {r4-r10,pc}
;;;126    
                          ENDP

000066  0000              DCW      0x0000
                  |L3.104|
                          DCD      raw_pcbs
                  |L3.108|
                          DCD      current_iphdr_dest
                  |L3.112|
                          DCD      current_iphdr_src

                          AREA ||i.raw_new||, CODE, READONLY, ALIGN=2

                  raw_new PROC
;;;330    struct raw_pcb *
;;;331    raw_new(u8_t proto)
000000  b570              PUSH     {r4-r6,lr}
;;;332    {
000002  4605              MOV      r5,r0
;;;333      struct raw_pcb *pcb;
;;;334    
;;;335      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));
000004  bf00              NOP      
000006  bf00              NOP      
;;;336    
;;;337      pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       memp_malloc
00000e  4604              MOV      r4,r0
;;;338      /* could allocate RAW PCB? */
;;;339      if (pcb != NULL) {
000010  b15c              CBZ      r4,|L4.42|
;;;340        /* initialize PCB to all zeroes */
;;;341        memset(pcb, 0, sizeof(struct raw_pcb));
000012  211c              MOVS     r1,#0x1c
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       __aeabi_memclr4
;;;342        pcb->protocol = proto;
00001a  7425              STRB     r5,[r4,#0x10]
;;;343        pcb->ttl = RAW_TTL;
00001c  20ff              MOVS     r0,#0xff
00001e  72a0              STRB     r0,[r4,#0xa]
;;;344        pcb->next = raw_pcbs;
000020  4803              LDR      r0,|L4.48|
000022  6800              LDR      r0,[r0,#0]  ; raw_pcbs
000024  60e0              STR      r0,[r4,#0xc]
;;;345        raw_pcbs = pcb;
000026  4802              LDR      r0,|L4.48|
000028  6004              STR      r4,[r0,#0]  ; raw_pcbs
                  |L4.42|
;;;346      }
;;;347      return pcb;
00002a  4620              MOV      r0,r4
;;;348    }
00002c  bd70              POP      {r4-r6,pc}
;;;349    
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      raw_pcbs

                          AREA ||i.raw_recv||, CODE, READONLY, ALIGN=1

                  raw_recv PROC
;;;182    void
;;;183    raw_recv(struct raw_pcb *pcb, raw_recv_fn recv, void *recv_arg)
000000  6141              STR      r1,[r0,#0x14]
;;;184    {
;;;185      /* remember recv() callback and user data */
;;;186      pcb->recv = recv;
;;;187      pcb->recv_arg = recv_arg;
000002  6182              STR      r2,[r0,#0x18]
;;;188    }
000004  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||i.raw_remove||, CODE, READONLY, ALIGN=2

                  raw_remove PROC
;;;299    void
;;;300    raw_remove(struct raw_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;301    {
000002  4605              MOV      r5,r0
;;;302      struct raw_pcb *pcb2;
;;;303      /* pcb to be removed is first in list? */
;;;304      if (raw_pcbs == pcb) {
000004  480d              LDR      r0,|L6.60|
000006  6800              LDR      r0,[r0,#0]  ; raw_pcbs
000008  42a8              CMP      r0,r5
00000a  d105              BNE      |L6.24|
;;;305        /* make list start at 2nd pcb */
;;;306        raw_pcbs = raw_pcbs->next;
00000c  480b              LDR      r0,|L6.60|
00000e  6800              LDR      r0,[r0,#0]  ; raw_pcbs
000010  68c0              LDR      r0,[r0,#0xc]
000012  490a              LDR      r1,|L6.60|
000014  6008              STR      r0,[r1,#0]  ; raw_pcbs
000016  e00c              B        |L6.50|
                  |L6.24|
;;;307        /* pcb not 1st in list */
;;;308      } else {
;;;309        for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
000018  4808              LDR      r0,|L6.60|
00001a  6804              LDR      r4,[r0,#0]  ; raw_pcbs
00001c  e007              B        |L6.46|
                  |L6.30|
;;;310          /* find pcb in raw_pcbs list */
;;;311          if (pcb2->next != NULL && pcb2->next == pcb) {
00001e  68e0              LDR      r0,[r4,#0xc]
000020  b120              CBZ      r0,|L6.44|
000022  68e0              LDR      r0,[r4,#0xc]
000024  42a8              CMP      r0,r5
000026  d101              BNE      |L6.44|
;;;312            /* remove pcb from list */
;;;313            pcb2->next = pcb->next;
000028  68e8              LDR      r0,[r5,#0xc]
00002a  60e0              STR      r0,[r4,#0xc]
                  |L6.44|
00002c  68e4              LDR      r4,[r4,#0xc]          ;309
                  |L6.46|
00002e  2c00              CMP      r4,#0                 ;309
000030  d1f5              BNE      |L6.30|
                  |L6.50|
;;;314          }
;;;315        }
;;;316      }
;;;317      memp_free(MEMP_RAW_PCB, pcb);
000032  4629              MOV      r1,r5
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       memp_free
;;;318    }
00003a  bd70              POP      {r4-r6,pc}
;;;319    
                          ENDP

                  |L6.60|
                          DCD      raw_pcbs

                          AREA ||i.raw_send||, CODE, READONLY, ALIGN=1

                  raw_send PROC
;;;285    err_t
;;;286    raw_send(struct raw_pcb *pcb, struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;287    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;288      return raw_sendto(pcb, p, &pcb->remote_ip);
000006  1d22              ADDS     r2,r4,#4
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       raw_sendto
;;;289    }
000010  bd70              POP      {r4-r6,pc}
;;;290    
                          ENDP


                          AREA ||i.raw_sendto||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  raw_sendto PROC
;;;202    err_t
;;;203    raw_sendto(struct raw_pcb *pcb, struct pbuf *p, ip_addr_t *ipaddr)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;204    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
;;;205      err_t err;
;;;206      struct netif *netif;
;;;207      ip_addr_t *src_ip;
;;;208      struct pbuf *q; /* q will be sent down the stack */
;;;209      
;;;210      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;211      
;;;212      /* not enough space to add an IP header to first pbuf in given p chain? */
;;;213      if (pbuf_header(p, IP_HLEN)) {
00000e  2114              MOVS     r1,#0x14
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       pbuf_header
000016  b1a0              CBZ      r0,|L8.66|
;;;214        /* allocate header in new pbuf */
;;;215        q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
000018  2200              MOVS     r2,#0
00001a  4611              MOV      r1,r2
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       pbuf_alloc
000022  4606              MOV      r6,r0
;;;216        /* new header pbuf could not be allocated? */
;;;217        if (q == NULL) {
000024  b92e              CBNZ     r6,|L8.50|
;;;218          LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
000026  bf00              NOP      
000028  bf00              NOP      
;;;219          return ERR_MEM;
00002a  f04f30ff          MOV      r0,#0xffffffff
                  |L8.46|
;;;220        }
;;;221        if (p->tot_len != 0) {
;;;222          /* chain header q in front of given pbuf p */
;;;223          pbuf_chain(q, p);
;;;224        }
;;;225        /* { first pbuf q points to header pbuf } */
;;;226        LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
;;;227      }  else {
;;;228        /* first pbuf q equals given pbuf */
;;;229        q = p;
;;;230        if(pbuf_header(q, -IP_HLEN)) {
;;;231          LWIP_ASSERT("Can't restore header we just removed!", 0);
;;;232          return ERR_MEM;
;;;233        }
;;;234      }
;;;235    
;;;236      if ((netif = ip_route(ipaddr)) == NULL) {
;;;237        LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;238          ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr)));
;;;239        /* free any temporary header pbuf allocated by pbuf_header() */
;;;240        if (q != p) {
;;;241          pbuf_free(q);
;;;242        }
;;;243        return ERR_RTE;
;;;244      }
;;;245    
;;;246    #if IP_SOF_BROADCAST
;;;247      /* broadcast filter? */
;;;248      if (!ip_get_option(pcb, SOF_BROADCAST) && ip_addr_isbroadcast(ipaddr, netif)) {
;;;249        LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: SOF_BROADCAST not enabled on pcb %p\n", (void *)pcb));
;;;250        /* free any temporary header pbuf allocated by pbuf_header() */
;;;251        if (q != p) {
;;;252          pbuf_free(q);
;;;253        }
;;;254        return ERR_VAL;
;;;255      }
;;;256    #endif /* IP_SOF_BROADCAST */
;;;257    
;;;258      if (ip_addr_isany(&pcb->local_ip)) {
;;;259        /* use outgoing network interface IP address as source address */
;;;260        src_ip = &(netif->ip_addr);
;;;261      } else {
;;;262        /* use RAW PCB local IP address as source address */
;;;263        src_ip = &(pcb->local_ip);
;;;264      }
;;;265    
;;;266      NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
;;;267      err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
;;;268      NETIF_SET_HWADDRHINT(netif, NULL);
;;;269    
;;;270      /* did we chain a header earlier? */
;;;271      if (q != p) {
;;;272        /* free the header */
;;;273        pbuf_free(q);
;;;274      }
;;;275      return err;
;;;276    }
00002e  e8bd8ffe          POP      {r1-r11,pc}
                  |L8.50|
000032  8928              LDRH     r0,[r5,#8]            ;221
000034  b118              CBZ      r0,|L8.62|
000036  4629              MOV      r1,r5                 ;223
000038  4630              MOV      r0,r6                 ;223
00003a  f7fffffe          BL       pbuf_chain
                  |L8.62|
00003e  bf00              NOP                            ;226
000040  e014              B        |L8.108|
                  |L8.66|
000042  462e              MOV      r6,r5                 ;229
000044  f06f0113          MVN      r1,#0x13              ;230
000048  4630              MOV      r0,r6                 ;230
00004a  f7fffffe          BL       pbuf_header
00004e  2800              CMP      r0,#0                 ;230
000050  d00c              BEQ      |L8.108|
000052  bf00              NOP                            ;231
000054  bf00              NOP                            ;231
000056  a31a              ADR      r3,|L8.192|
000058  22e7              MOVS     r2,#0xe7              ;231
00005a  a122              ADR      r1,|L8.228|
00005c  a02b              ADR      r0,|L8.268|
00005e  f7fffffe          BL       __2printf
000062  bf00              NOP                            ;231
000064  bf00              NOP                            ;231
000066  f04f30ff          MOV      r0,#0xffffffff        ;232
00006a  e7e0              B        |L8.46|
                  |L8.108|
00006c  4648              MOV      r0,r9                 ;236
00006e  f7fffffe          BL       ip_route
000072  1e07              SUBS     r7,r0,#0              ;236
000074  d109              BNE      |L8.138|
000076  bf00              NOP                            ;237
000078  bf00              NOP                            ;237
00007a  42ae              CMP      r6,r5                 ;240
00007c  d002              BEQ      |L8.132|
00007e  4630              MOV      r0,r6                 ;241
000080  f7fffffe          BL       pbuf_free
                  |L8.132|
000084  f06f0003          MVN      r0,#3                 ;243
000088  e7d1              B        |L8.46|
                  |L8.138|
00008a  b10c              CBZ      r4,|L8.144|
00008c  6820              LDR      r0,[r4,#0]            ;258
00008e  b910              CBNZ     r0,|L8.150|
                  |L8.144|
000090  f1070804          ADD      r8,r7,#4              ;260
000094  e000              B        |L8.152|
                  |L8.150|
000096  46a0              MOV      r8,r4                 ;263
                  |L8.152|
000098  7c20              LDRB     r0,[r4,#0x10]         ;267
00009a  7a61              LDRB     r1,[r4,#9]            ;267
00009c  e9cd0701          STRD     r0,r7,[sp,#4]         ;267
0000a0  9100              STR      r1,[sp,#0]            ;267
0000a2  7aa3              LDRB     r3,[r4,#0xa]          ;267
0000a4  464a              MOV      r2,r9                 ;267
0000a6  4641              MOV      r1,r8                 ;267
0000a8  4630              MOV      r0,r6                 ;267
0000aa  f7fffffe          BL       ip_output_if
0000ae  4682              MOV      r10,r0                ;267
0000b0  42ae              CMP      r6,r5                 ;271
0000b2  d002              BEQ      |L8.186|
0000b4  4630              MOV      r0,r6                 ;273
0000b6  f7fffffe          BL       pbuf_free
                  |L8.186|
0000ba  4650              MOV      r0,r10                ;275
0000bc  e7b7              B        |L8.46|
;;;277    
                          ENDP

0000be  0000              DCW      0x0000
                  |L8.192|
0000c0  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\raw.c",0
0000c4  5749505c
0000c8  6c776970
0000cc  2d312e34
0000d0  2e315c73
0000d4  72635c63
0000d8  6f72655c
0000dc  7261772e
0000e0  6300    
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L8.228|
0000e4  43616e27          DCB      "Can't restore header we just removed!",0
0000e8  74207265
0000ec  73746f72
0000f0  65206865
0000f4  61646572
0000f8  20776520
0000fc  6a757374
000100  2072656d
000104  6f766564
000108  2100    
00010a  00                DCB      0
00010b  00                DCB      0
                  |L8.268|
00010c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000110  7274696f
000114  6e202225
000118  73222066
00011c  61696c65
000120  64206174
000124  206c696e
000128  65202564
00012c  20696e20
000130  25730d0a
000134  00      
000135  00                DCB      0
000136  00                DCB      0
000137  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  raw_pcbs
                          DCD      0x00000000
