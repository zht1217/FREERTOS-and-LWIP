; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\tcp.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\tcp.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\tcp.crf ..\LWIP\lwip-1.4.1\src\core\tcp.c]
                          THUMB

                          AREA ||i.tcp_abandon||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_abandon PROC
;;;356    void
;;;357    tcp_abandon(struct tcp_pcb *pcb, int reset)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;358    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;359      u32_t seqno, ackno;
;;;360    #if LWIP_CALLBACK_API  
;;;361      tcp_err_fn errf;
;;;362    #endif /* LWIP_CALLBACK_API */
;;;363      void *errf_arg;
;;;364    
;;;365      /* pcb->state LISTEN not allowed here */
;;;366      LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
000008  bf00              NOP      
00000a  7e20              LDRB     r0,[r4,#0x18]
00000c  2801              CMP      r0,#1
00000e  d108              BNE      |L1.34|
000010  bf00              NOP      
000012  a327              ADR      r3,|L1.176|
000014  f44f72b7          MOV      r2,#0x16e
000018  a12e              ADR      r1,|L1.212|
00001a  a03b              ADR      r0,|L1.264|
00001c  f7fffffe          BL       __2printf
000020  bf00              NOP      
                  |L1.34|
000022  bf00              NOP      
;;;367        pcb->state != LISTEN);
;;;368      /* Figure out on which TCP PCB list we are, and remove us. If we
;;;369         are in an active state, call the receive function associated with
;;;370         the PCB with a NULL argument, and send an RST to the remote end. */
;;;371      if (pcb->state == TIME_WAIT) {
000024  7e20              LDRB     r0,[r4,#0x18]
000026  280a              CMP      r0,#0xa
000028  d108              BNE      |L1.60|
;;;372        tcp_pcb_remove(&tcp_tw_pcbs, pcb);
00002a  4621              MOV      r1,r4
00002c  4841              LDR      r0,|L1.308|
00002e  f7fffffe          BL       tcp_pcb_remove
;;;373        memp_free(MEMP_TCP_PCB, pcb);
000032  4621              MOV      r1,r4
000034  2002              MOVS     r0,#2
000036  f7fffffe          BL       memp_free
00003a  e036              B        |L1.170|
                  |L1.60|
;;;374      } else {
;;;375        seqno = pcb->snd_nxt;
00003c  6d27              LDR      r7,[r4,#0x50]
;;;376        ackno = pcb->rcv_nxt;
00003e  f8d48028          LDR      r8,[r4,#0x28]
;;;377    #if LWIP_CALLBACK_API
;;;378        errf = pcb->errf;
000042  f8d4508c          LDR      r5,[r4,#0x8c]
;;;379    #endif /* LWIP_CALLBACK_API */
;;;380        errf_arg = pcb->callback_arg;
000046  f8d49010          LDR      r9,[r4,#0x10]
;;;381        TCP_PCB_REMOVE_ACTIVE(pcb);
00004a  bf00              NOP      
00004c  4621              MOV      r1,r4
00004e  483a              LDR      r0,|L1.312|
000050  f7fffffe          BL       tcp_pcb_remove
000054  2001              MOVS     r0,#1
000056  4939              LDR      r1,|L1.316|
000058  7008              STRB     r0,[r1,#0]
00005a  bf00              NOP      
;;;382        if (pcb->unacked != NULL) {
00005c  6f20              LDR      r0,[r4,#0x70]
00005e  b110              CBZ      r0,|L1.102|
;;;383          tcp_segs_free(pcb->unacked);
000060  6f20              LDR      r0,[r4,#0x70]
000062  f7fffffe          BL       tcp_segs_free
                  |L1.102|
;;;384        }
;;;385        if (pcb->unsent != NULL) {
000066  6ee0              LDR      r0,[r4,#0x6c]
000068  b110              CBZ      r0,|L1.112|
;;;386          tcp_segs_free(pcb->unsent);
00006a  6ee0              LDR      r0,[r4,#0x6c]
00006c  f7fffffe          BL       tcp_segs_free
                  |L1.112|
;;;387        }
;;;388    #if TCP_QUEUE_OOSEQ    
;;;389        if (pcb->ooseq != NULL) {
000070  6f60              LDR      r0,[r4,#0x74]
000072  b110              CBZ      r0,|L1.122|
;;;390          tcp_segs_free(pcb->ooseq);
000074  6f60              LDR      r0,[r4,#0x74]
000076  f7fffffe          BL       tcp_segs_free
                  |L1.122|
;;;391        }
;;;392    #endif /* TCP_QUEUE_OOSEQ */
;;;393        if (reset) {
00007a  b15e              CBZ      r6,|L1.148|
;;;394          LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
00007c  bf00              NOP      
00007e  bf00              NOP      
;;;395          tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
000080  8ba0              LDRH     r0,[r4,#0x1c]
000082  8b61              LDRH     r1,[r4,#0x1a]
000084  1d23              ADDS     r3,r4,#4
000086  4622              MOV      r2,r4
000088  e9cd1000          STRD     r1,r0,[sp,#0]
00008c  4641              MOV      r1,r8
00008e  4638              MOV      r0,r7
000090  f7fffffe          BL       tcp_rst
                  |L1.148|
;;;396        }
;;;397        memp_free(MEMP_TCP_PCB, pcb);
000094  4621              MOV      r1,r4
000096  2002              MOVS     r0,#2
000098  f7fffffe          BL       memp_free
;;;398        TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
00009c  bf00              NOP      
00009e  b11d              CBZ      r5,|L1.168|
0000a0  f06f0109          MVN      r1,#9
0000a4  4648              MOV      r0,r9
0000a6  47a8              BLX      r5
                  |L1.168|
0000a8  bf00              NOP      
                  |L1.170|
;;;399      }
;;;400    }
0000aa  e8bd87fc          POP      {r2-r10,pc}
;;;401    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L1.176|
0000b0  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp.c",0
0000b4  5749505c
0000b8  6c776970
0000bc  2d312e34
0000c0  2e315c73
0000c4  72635c63
0000c8  6f72655c
0000cc  7463702e
0000d0  6300    
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L1.212|
0000d4  646f6e27          DCB      "don't call tcp_abort/tcp_abandon for listen-pcbs",0
0000d8  74206361
0000dc  6c6c2074
0000e0  63705f61
0000e4  626f7274
0000e8  2f746370
0000ec  5f616261
0000f0  6e646f6e
0000f4  20666f72
0000f8  206c6973
0000fc  74656e2d
000100  70636273
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0
                  |L1.264|
000108  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
00010c  7274696f
000110  6e202225
000114  73222066
000118  61696c65
00011c  64206174
000120  206c696e
000124  65202564
000128  20696e20
00012c  25730d0a
000130  00      
000131  00                DCB      0
000132  00                DCB      0
000133  00                DCB      0
                  |L1.308|
                          DCD      tcp_tw_pcbs
                  |L1.312|
                          DCD      tcp_active_pcbs
                  |L1.316|
                          DCD      tcp_active_pcbs_changed

                          AREA ||i.tcp_abort||, CODE, READONLY, ALIGN=1

                  tcp_abort PROC
;;;412    void
;;;413    tcp_abort(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;414    {
000002  4604              MOV      r4,r0
;;;415      tcp_abandon(pcb, 1);
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       tcp_abandon
;;;416    }
00000c  bd10              POP      {r4,pc}
;;;417    
                          ENDP


                          AREA ||i.tcp_accept||, CODE, READONLY, ALIGN=1

                  tcp_accept PROC
;;;1435   void
;;;1436   tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
000000  6141              STR      r1,[r0,#0x14]
;;;1437   {
;;;1438     /* This function is allowed to be called for both listen pcbs and
;;;1439        connection pcbs. */
;;;1440     pcb->accept = accept;
;;;1441   }
000002  4770              BX       lr
;;;1442   #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_accept_null||, CODE, READONLY, ALIGN=1

                  tcp_accept_null PROC
;;;493    static err_t
;;;494    tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
000000  4603              MOV      r3,r0
;;;495    {
;;;496      LWIP_UNUSED_ARG(arg);
;;;497      LWIP_UNUSED_ARG(pcb);
;;;498      LWIP_UNUSED_ARG(err);
;;;499    
;;;500      return ERR_ABRT;
000002  f06f0009          MVN      r0,#9
;;;501    }
000006  4770              BX       lr
;;;502    #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_alloc||, CODE, READONLY, ALIGN=2

                  tcp_alloc PROC
;;;1277   struct tcp_pcb *
;;;1278   tcp_alloc(u8_t prio)
000000  b570              PUSH     {r4-r6,lr}
;;;1279   {
000002  4606              MOV      r6,r0
;;;1280     struct tcp_pcb *pcb;
;;;1281     u32_t iss;
;;;1282     
;;;1283     pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       memp_malloc
00000a  4604              MOV      r4,r0
;;;1284     if (pcb == NULL) {
00000c  b99c              CBNZ     r4,|L5.54|
;;;1285       /* Try killing oldest connection in TIME-WAIT. */
;;;1286       LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
00000e  bf00              NOP      
000010  bf00              NOP      
;;;1287       tcp_kill_timewait();
000012  f7fffffe          BL       tcp_kill_timewait
;;;1288       /* Try to allocate a tcp_pcb again. */
;;;1289       pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000016  2002              MOVS     r0,#2
000018  f7fffffe          BL       memp_malloc
00001c  4604              MOV      r4,r0
;;;1290       if (pcb == NULL) {
00001e  b94c              CBNZ     r4,|L5.52|
;;;1291         /* Try killing active connections with lower priority than the new one. */
;;;1292         LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
000020  bf00              NOP      
000022  bf00              NOP      
;;;1293         tcp_kill_prio(prio);
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       tcp_kill_prio
;;;1294         /* Try to allocate a tcp_pcb again. */
;;;1295         pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
00002a  2002              MOVS     r0,#2
00002c  f7fffffe          BL       memp_malloc
000030  4604              MOV      r4,r0
;;;1296         if (pcb != NULL) {
000032  bf00              NOP      
                  |L5.52|
;;;1297           /* adjust err stats: memp_malloc failed twice before */
;;;1298           MEMP_STATS_DEC(err, MEMP_TCP_PCB);
;;;1299         }
;;;1300       }
;;;1301       if (pcb != NULL) {
000034  bf00              NOP      
                  |L5.54|
;;;1302         /* adjust err stats: timewait PCB was freed above */
;;;1303         MEMP_STATS_DEC(err, MEMP_TCP_PCB);
;;;1304       }
;;;1305     }
;;;1306     if (pcb != NULL) {
000036  2c00              CMP      r4,#0
000038  d03a              BEQ      |L5.176|
;;;1307       memset(pcb, 0, sizeof(struct tcp_pcb));
00003a  2198              MOVS     r1,#0x98
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       __aeabi_memclr4
;;;1308       pcb->prio = prio;
000042  3414              ADDS     r4,r4,#0x14
000044  7166              STRB     r6,[r4,#5]
;;;1309       pcb->snd_buf = TCP_SND_BUF;
000046  f6403068          MOV      r0,#0xb68
00004a  f8a40052          STRH     r0,[r4,#0x52]
;;;1310       pcb->snd_queuelen = 0;
00004e  2000              MOVS     r0,#0
000050  f8a40054          STRH     r0,[r4,#0x54]
;;;1311       pcb->rcv_wnd = TCP_WND;
000054  f6403068          MOV      r0,#0xb68
000058  8320              STRH     r0,[r4,#0x18]
;;;1312       pcb->rcv_ann_wnd = TCP_WND;
00005a  8360              STRH     r0,[r4,#0x1a]
;;;1313       pcb->tos = 0;
00005c  2000              MOVS     r0,#0
00005e  f8040c0b          STRB     r0,[r4,#-0xb]
;;;1314       pcb->ttl = TCP_TTL;
000062  20ff              MOVS     r0,#0xff
000064  f8040c0a          STRB     r0,[r4,#-0xa]
;;;1315       /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;1316          The send MSS is updated when an MSS option is received. */
;;;1317       pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
000068  f44f7006          MOV      r0,#0x218
00006c  8460              STRH     r0,[r4,#0x22]
;;;1318       pcb->rto = 3000 / TCP_SLOW_INTERVAL;
00006e  2006              MOVS     r0,#6
000070  8620              STRH     r0,[r4,#0x30]
;;;1319       pcb->sa = 0;
000072  2000              MOVS     r0,#0
000074  85a0              STRH     r0,[r4,#0x2c]
;;;1320       pcb->sv = 3000 / TCP_SLOW_INTERVAL;
000076  2006              MOVS     r0,#6
000078  85e0              STRH     r0,[r4,#0x2e]
;;;1321       pcb->rtime = -1;
00007a  1fc0              SUBS     r0,r0,#7
00007c  8420              STRH     r0,[r4,#0x20]
;;;1322       pcb->cwnd = 1;
00007e  2001              MOVS     r0,#1
000080  8720              STRH     r0,[r4,#0x38]
;;;1323       iss = tcp_next_iss();
000082  f7fffffe          BL       tcp_next_iss
000086  4605              MOV      r5,r0
;;;1324       pcb->snd_wl2 = iss;
000088  6465              STR      r5,[r4,#0x44]
;;;1325       pcb->snd_nxt = iss;
00008a  63e5              STR      r5,[r4,#0x3c]
;;;1326       pcb->lastack = iss;
00008c  6365              STR      r5,[r4,#0x34]
;;;1327       pcb->snd_lbb = iss;   
00008e  64a5              STR      r5,[r4,#0x48]
;;;1328       pcb->tmr = tcp_ticks;
000090  4808              LDR      r0,|L5.180|
000092  6800              LDR      r0,[r0,#0]  ; tcp_ticks
000094  6120              STR      r0,[r4,#0x10]
;;;1329       pcb->last_timer = tcp_timer_ctr;
000096  4808              LDR      r0,|L5.184|
000098  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
00009a  7360              STRB     r0,[r4,#0xd]
;;;1330   
;;;1331       pcb->polltmr = 0;
00009c  2000              MOVS     r0,#0
00009e  72e0              STRB     r0,[r4,#0xb]
;;;1332   
;;;1333   #if LWIP_CALLBACK_API
;;;1334       pcb->recv = tcp_recv_null;
0000a0  4806              LDR      r0,|L5.188|
0000a2  66e0              STR      r0,[r4,#0x6c]
;;;1335   #endif /* LWIP_CALLBACK_API */  
;;;1336       
;;;1337       /* Init KEEPALIVE timer */
;;;1338       pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
0000a4  4806              LDR      r0,|L5.192|
0000a6  67e0              STR      r0,[r4,#0x7c]
;;;1339       
;;;1340   #if LWIP_TCP_KEEPALIVE
;;;1341       pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
;;;1342       pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
;;;1343   #endif /* LWIP_TCP_KEEPALIVE */
;;;1344   
;;;1345       pcb->keep_cnt_sent = 0;
0000a8  2000              MOVS     r0,#0
0000aa  f8840082          STRB     r0,[r4,#0x82]
0000ae  3c14              SUBS     r4,r4,#0x14
                  |L5.176|
;;;1346     }
;;;1347     return pcb;
0000b0  4620              MOV      r0,r4
;;;1348   }
0000b2  bd70              POP      {r4-r6,pc}
;;;1349   
                          ENDP

                  |L5.180|
                          DCD      tcp_ticks
                  |L5.184|
                          DCD      tcp_timer_ctr
                  |L5.188|
                          DCD      tcp_recv_null
                  |L5.192|
                          DCD      0x006ddd00

                          AREA ||i.tcp_arg||, CODE, READONLY, ALIGN=1

                  tcp_arg PROC
;;;1375   void
;;;1376   tcp_arg(struct tcp_pcb *pcb, void *arg)
000000  6101              STR      r1,[r0,#0x10]
;;;1377   {
;;;1378     /* This function is allowed to be called for both listen pcbs and
;;;1379        connection pcbs. */
;;;1380     pcb->callback_arg = arg;
;;;1381   }
000002  4770              BX       lr
;;;1382   #if LWIP_CALLBACK_API
                          ENDP


                          AREA ||i.tcp_bind||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_bind PROC
;;;432    err_t
;;;433    tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;434    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;435      int i;
;;;436      int max_pcb_list = NUM_TCP_PCB_LISTS;
00000a  f04f0904          MOV      r9,#4
;;;437      struct tcp_pcb *cpcb;
;;;438    
;;;439      LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
00000e  bf00              NOP      
000010  7e28              LDRB     r0,[r5,#0x18]
000012  2800              CMP      r0,#0
000014  d00c              BEQ      |L7.48|
000016  bf00              NOP      
000018  a323              ADR      r3,|L7.168|
00001a  f24012b7          MOV      r2,#0x1b7
00001e  a12b              ADR      r1,|L7.204|
000020  a034              ADR      r0,|L7.244|
000022  f7fffffe          BL       __2printf
000026  bf00              NOP      
000028  f06f0005          MVN      r0,#5
                  |L7.44|
;;;440    
;;;441    #if SO_REUSE
;;;442      /* Unless the REUSEADDR flag is set,
;;;443         we have to check the pcbs in TIME-WAIT state, also.
;;;444         We do not dump TIME_WAIT pcb's; they can still be matched by incoming
;;;445         packets using both local and remote IP addresses and ports to distinguish.
;;;446       */
;;;447      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;448        max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
;;;449      }
;;;450    #endif /* SO_REUSE */
;;;451    
;;;452      if (port == 0) {
;;;453        port = tcp_new_port();
;;;454        if (port == 0) {
;;;455          return ERR_BUF;
;;;456        }
;;;457      }
;;;458    
;;;459      /* Check if the address already is in use (on all lists) */
;;;460      for (i = 0; i < max_pcb_list; i++) {
;;;461        for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;462          if (cpcb->local_port == port) {
;;;463    #if SO_REUSE
;;;464            /* Omit checking for the same port if both pcbs have REUSEADDR set.
;;;465               For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
;;;466               tcp_connect. */
;;;467            if (!ip_get_option(pcb, SOF_REUSEADDR) ||
;;;468                !ip_get_option(cpcb, SOF_REUSEADDR))
;;;469    #endif /* SO_REUSE */
;;;470            {
;;;471              if (ip_addr_isany(&(cpcb->local_ip)) ||
;;;472                  ip_addr_isany(ipaddr) ||
;;;473                  ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
;;;474                return ERR_USE;
;;;475              }
;;;476            }
;;;477          }
;;;478        }
;;;479      }
;;;480    
;;;481      if (!ip_addr_isany(ipaddr)) {
;;;482        pcb->local_ip = *ipaddr;
;;;483      }
;;;484      pcb->local_port = port;
;;;485      TCP_REG(&tcp_bound_pcbs, pcb);
;;;486      LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
;;;487      return ERR_OK;
;;;488    }
00002c  e8bd87f0          POP      {r4-r10,pc}
                  |L7.48|
000030  bf00              NOP                            ;439
000032  b937              CBNZ     r7,|L7.66|
000034  f7fffffe          BL       tcp_new_port
000038  4607              MOV      r7,r0                 ;453
00003a  b917              CBNZ     r7,|L7.66|
00003c  f06f0001          MVN      r0,#1                 ;455
000040  e7f4              B        |L7.44|
                  |L7.66|
000042  f04f0800          MOV      r8,#0                 ;460
000046  e019              B        |L7.124|
                  |L7.72|
000048  4835              LDR      r0,|L7.288|
00004a  f8500028          LDR      r0,[r0,r8,LSL #2]     ;461
00004e  6806              LDR      r6,[r0,#0]            ;461
000050  e010              B        |L7.116|
                  |L7.82|
000052  8b70              LDRH     r0,[r6,#0x1a]         ;462
000054  42b8              CMP      r0,r7                 ;462
000056  d10c              BNE      |L7.114|
000058  b146              CBZ      r6,|L7.108|
00005a  6830              LDR      r0,[r6,#0]            ;471
00005c  b130              CBZ      r0,|L7.108|
00005e  b12c              CBZ      r4,|L7.108|
000060  6820              LDR      r0,[r4,#0]            ;472
000062  b118              CBZ      r0,|L7.108|
000064  6830              LDR      r0,[r6,#0]            ;473
000066  6821              LDR      r1,[r4,#0]            ;473
000068  4288              CMP      r0,r1                 ;473
00006a  d102              BNE      |L7.114|
                  |L7.108|
00006c  f06f0007          MVN      r0,#7                 ;474
000070  e7dc              B        |L7.44|
                  |L7.114|
000072  68f6              LDR      r6,[r6,#0xc]          ;461
                  |L7.116|
000074  2e00              CMP      r6,#0                 ;461
000076  d1ec              BNE      |L7.82|
000078  f1080801          ADD      r8,r8,#1              ;460
                  |L7.124|
00007c  45c8              CMP      r8,r9                 ;460
00007e  dbe3              BLT      |L7.72|
000080  b11c              CBZ      r4,|L7.138|
000082  6820              LDR      r0,[r4,#0]            ;481
000084  b108              CBZ      r0,|L7.138|
000086  6820              LDR      r0,[r4,#0]            ;482
000088  6028              STR      r0,[r5,#0]            ;482
                  |L7.138|
00008a  836f              STRH     r7,[r5,#0x1a]         ;484
00008c  bf00              NOP                            ;485
00008e  4825              LDR      r0,|L7.292|
000090  6800              LDR      r0,[r0,#0]            ;485  ; tcp_bound_pcbs
000092  60e8              STR      r0,[r5,#0xc]          ;485
000094  4823              LDR      r0,|L7.292|
000096  6005              STR      r5,[r0,#0]            ;485  ; tcp_bound_pcbs
000098  f7fffffe          BL       tcp_timer_needed
00009c  bf00              NOP                            ;485
00009e  bf00              NOP                            ;486
0000a0  bf00              NOP                            ;486
0000a2  2000              MOVS     r0,#0                 ;487
0000a4  e7c2              B        |L7.44|
;;;489    #if LWIP_CALLBACK_API
                          ENDP

0000a6  0000              DCW      0x0000
                  |L7.168|
0000a8  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp.c",0
0000ac  5749505c
0000b0  6c776970
0000b4  2d312e34
0000b8  2e315c73
0000bc  72635c63
0000c0  6f72655c
0000c4  7463702e
0000c8  6300    
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L7.204|
0000cc  7463705f          DCB      "tcp_bind: can only bind in state CLOSED",0
0000d0  62696e64
0000d4  3a206361
0000d8  6e206f6e
0000dc  6c792062
0000e0  696e6420
0000e4  696e2073
0000e8  74617465
0000ec  20434c4f
0000f0  53454400
                  |L7.244|
0000f4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000f8  7274696f
0000fc  6e202225
000100  73222066
000104  61696c65
000108  64206174
00010c  206c696e
000110  65202564
000114  20696e20
000118  25730d0a
00011c  00      
00011d  00                DCB      0
00011e  00                DCB      0
00011f  00                DCB      0
                  |L7.288|
                          DCD      tcp_pcb_lists
                  |L7.292|
                          DCD      tcp_bound_pcbs

                          AREA ||i.tcp_close||, CODE, READONLY, ALIGN=1

                  tcp_close PROC
;;;284    err_t
;;;285    tcp_close(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;286    {
000002  4604              MOV      r4,r0
;;;287    #if TCP_DEBUG
;;;288      LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
;;;289      tcp_debug_print_state(pcb->state);
;;;290    #endif /* TCP_DEBUG */
;;;291    
;;;292      if (pcb->state != LISTEN) {
000004  7e20              LDRB     r0,[r4,#0x18]
000006  2801              CMP      r0,#1
000008  d003              BEQ      |L8.18|
;;;293        /* Set a flag not to receive any more data... */
;;;294        pcb->flags |= TF_RXCLOSED;
00000a  7fa0              LDRB     r0,[r4,#0x1e]
00000c  f0400010          ORR      r0,r0,#0x10
000010  77a0              STRB     r0,[r4,#0x1e]
                  |L8.18|
;;;295      }
;;;296      /* ... and close */
;;;297      return tcp_close_shutdown(pcb, 1);
000012  2101              MOVS     r1,#1
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       tcp_close_shutdown
;;;298    }
00001a  bd10              POP      {r4,pc}
;;;299    
                          ENDP


                          AREA ||i.tcp_close_shutdown||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_close_shutdown PROC
;;;169    static err_t
;;;170    tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
000000  b57c              PUSH     {r2-r6,lr}
;;;171    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;172      err_t err;
;;;173    
;;;174      if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
000006  2e00              CMP      r6,#0
000008  d067              BEQ      |L9.218|
00000a  7e20              LDRB     r0,[r4,#0x18]
00000c  2804              CMP      r0,#4
00000e  d002              BEQ      |L9.22|
000010  7e20              LDRB     r0,[r4,#0x18]
000012  2807              CMP      r0,#7
000014  d161              BNE      |L9.218|
                  |L9.22|
;;;175        if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
000016  6fa0              LDR      r0,[r4,#0x78]
000018  b920              CBNZ     r0,|L9.36|
00001a  8da0              LDRH     r0,[r4,#0x2c]
00001c  f6403168          MOV      r1,#0xb68
000020  4288              CMP      r0,r1
000022  d05a              BEQ      |L9.218|
                  |L9.36|
;;;176          /* Not all data received by application, send RST to tell the remote
;;;177             side about this. */
;;;178          LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
000024  bf00              NOP      
000026  7fa0              LDRB     r0,[r4,#0x1e]
000028  f0000010          AND      r0,r0,#0x10
00002c  b938              CBNZ     r0,|L9.62|
00002e  bf00              NOP      
000030  a365              ADR      r3,|L9.456|
000032  22b2              MOVS     r2,#0xb2
000034  a16d              ADR      r1,|L9.492|
000036  a074              ADR      r0,|L9.520|
000038  f7fffffe          BL       __2printf
00003c  bf00              NOP      
                  |L9.62|
00003e  bf00              NOP      
;;;179    
;;;180          /* don't call tcp_abort here: we must not deallocate the pcb since
;;;181             that might not be expected when calling tcp_close */
;;;182          tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
000040  8ba0              LDRH     r0,[r4,#0x1c]
000042  8b61              LDRH     r1,[r4,#0x1a]
000044  e9cd1000          STRD     r1,r0,[sp,#0]
000048  1d23              ADDS     r3,r4,#4
00004a  4622              MOV      r2,r4
00004c  6aa1              LDR      r1,[r4,#0x28]
00004e  6d20              LDR      r0,[r4,#0x50]
000050  f7fffffe          BL       tcp_rst
;;;183            pcb->local_port, pcb->remote_port);
;;;184    
;;;185          tcp_pcb_purge(pcb);
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       tcp_pcb_purge
;;;186          TCP_RMV_ACTIVE(pcb);
00005a  bf00              NOP      
00005c  bf00              NOP      
00005e  4875              LDR      r0,|L9.564|
000060  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
000062  42a0              CMP      r0,r4
000064  d105              BNE      |L9.114|
000066  4873              LDR      r0,|L9.564|
000068  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
00006a  68c0              LDR      r0,[r0,#0xc]
00006c  4971              LDR      r1,|L9.564|
00006e  6008              STR      r0,[r1,#0]  ; tcp_active_pcbs
000070  e018              B        |L9.164|
                  |L9.114|
000072  4870              LDR      r0,|L9.564|
000074  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
000076  4970              LDR      r1,|L9.568|
000078  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
00007a  e00e              B        |L9.154|
                  |L9.124|
00007c  486e              LDR      r0,|L9.568|
00007e  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000080  68c0              LDR      r0,[r0,#0xc]
000082  42a0              CMP      r0,r4
000084  d104              BNE      |L9.144|
000086  496c              LDR      r1,|L9.568|
000088  68e0              LDR      r0,[r4,#0xc]
00008a  6809              LDR      r1,[r1,#0]  ; tcp_tmp_pcb
00008c  60c8              STR      r0,[r1,#0xc]
00008e  e008              B        |L9.162|
                  |L9.144|
000090  4869              LDR      r0,|L9.568|
000092  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000094  68c0              LDR      r0,[r0,#0xc]
000096  4968              LDR      r1,|L9.568|
000098  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
                  |L9.154|
00009a  4867              LDR      r0,|L9.568|
00009c  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
00009e  2800              CMP      r0,#0
0000a0  d1ec              BNE      |L9.124|
                  |L9.162|
0000a2  bf00              NOP      
                  |L9.164|
0000a4  2000              MOVS     r0,#0
0000a6  60e0              STR      r0,[r4,#0xc]
0000a8  bf00              NOP      
0000aa  2001              MOVS     r0,#1
0000ac  4963              LDR      r1,|L9.572|
0000ae  7008              STRB     r0,[r1,#0]
0000b0  bf00              NOP      
;;;187          if (pcb->state == ESTABLISHED) {
0000b2  7e20              LDRB     r0,[r4,#0x18]
0000b4  2804              CMP      r0,#4
0000b6  d10a              BNE      |L9.206|
;;;188            /* move to TIME_WAIT since we close actively */
;;;189            pcb->state = TIME_WAIT;
0000b8  200a              MOVS     r0,#0xa
0000ba  7620              STRB     r0,[r4,#0x18]
;;;190            TCP_REG(&tcp_tw_pcbs, pcb);
0000bc  bf00              NOP      
0000be  4860              LDR      r0,|L9.576|
0000c0  6800              LDR      r0,[r0,#0]  ; tcp_tw_pcbs
0000c2  60e0              STR      r0,[r4,#0xc]
0000c4  485e              LDR      r0,|L9.576|
0000c6  6004              STR      r4,[r0,#0]  ; tcp_tw_pcbs
0000c8  f7fffffe          BL       tcp_timer_needed
0000cc  e003              B        |L9.214|
                  |L9.206|
;;;191          } else {
;;;192            /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
;;;193            memp_free(MEMP_TCP_PCB, pcb);
0000ce  4621              MOV      r1,r4
0000d0  2002              MOVS     r0,#2
0000d2  f7fffffe          BL       memp_free
                  |L9.214|
;;;194          }
;;;195          return ERR_OK;
0000d6  2000              MOVS     r0,#0
                  |L9.216|
;;;196        }
;;;197      }
;;;198    
;;;199      switch (pcb->state) {
;;;200      case CLOSED:
;;;201        /* Closing a pcb in the CLOSED state might seem erroneous,
;;;202         * however, it is in this state once allocated and as yet unused
;;;203         * and the user needs some way to free it should the need arise.
;;;204         * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
;;;205         * or for a pcb that has been used and then entered the CLOSED state 
;;;206         * is erroneous, but this should never happen as the pcb has in those cases
;;;207         * been freed, and so any remaining handles are bogus. */
;;;208        err = ERR_OK;
;;;209        if (pcb->local_port != 0) {
;;;210          TCP_RMV(&tcp_bound_pcbs, pcb);
;;;211        }
;;;212        memp_free(MEMP_TCP_PCB, pcb);
;;;213        pcb = NULL;
;;;214        break;
;;;215      case LISTEN:
;;;216        err = ERR_OK;
;;;217        tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
;;;218        memp_free(MEMP_TCP_PCB_LISTEN, pcb);
;;;219        pcb = NULL;
;;;220        break;
;;;221      case SYN_SENT:
;;;222        err = ERR_OK;
;;;223        TCP_PCB_REMOVE_ACTIVE(pcb);
;;;224        memp_free(MEMP_TCP_PCB, pcb);
;;;225        pcb = NULL;
;;;226        snmp_inc_tcpattemptfails();
;;;227        break;
;;;228      case SYN_RCVD:
;;;229        err = tcp_send_fin(pcb);
;;;230        if (err == ERR_OK) {
;;;231          snmp_inc_tcpattemptfails();
;;;232          pcb->state = FIN_WAIT_1;
;;;233        }
;;;234        break;
;;;235      case ESTABLISHED:
;;;236        err = tcp_send_fin(pcb);
;;;237        if (err == ERR_OK) {
;;;238          snmp_inc_tcpestabresets();
;;;239          pcb->state = FIN_WAIT_1;
;;;240        }
;;;241        break;
;;;242      case CLOSE_WAIT:
;;;243        err = tcp_send_fin(pcb);
;;;244        if (err == ERR_OK) {
;;;245          snmp_inc_tcpestabresets();
;;;246          pcb->state = LAST_ACK;
;;;247        }
;;;248        break;
;;;249      default:
;;;250        /* Has already been closed, do nothing. */
;;;251        err = ERR_OK;
;;;252        pcb = NULL;
;;;253        break;
;;;254      }
;;;255    
;;;256      if (pcb != NULL && err == ERR_OK) {
;;;257        /* To ensure all data has been sent when tcp_close returns, we have
;;;258           to make sure tcp_output doesn't fail.
;;;259           Since we don't really have to ensure all data has been sent when tcp_close
;;;260           returns (unsent data is sent from tcp timer functions, also), we don't care
;;;261           for the return value of tcp_output for now. */
;;;262        /* @todo: When implementing SO_LINGER, this must be changed somehow:
;;;263           If SOF_LINGER is set, the data should be sent and acked before close returns.
;;;264           This can only be valid for sequential APIs, not for the raw API. */
;;;265        tcp_output(pcb);
;;;266      }
;;;267      return err;
;;;268    }
0000d8  bd7c              POP      {r2-r6,pc}
                  |L9.218|
0000da  7e20              LDRB     r0,[r4,#0x18]         ;199
0000dc  2808              CMP      r0,#8                 ;199
0000de  d268              BCS      |L9.434|
0000e0  e8dff000          TBB      [pc,r0]               ;199
0000e4  04343f4f          DCB      0x04,0x34,0x3f,0x4f
0000e8  5767675f          DCB      0x57,0x67,0x67,0x5f
0000ec  2500              MOVS     r5,#0                 ;208
0000ee  8b60              LDRH     r0,[r4,#0x1a]         ;209
0000f0  b330              CBZ      r0,|L9.320|
0000f2  bf00              NOP                            ;210
0000f4  4853              LDR      r0,|L9.580|
0000f6  6800              LDR      r0,[r0,#0]            ;210  ; tcp_bound_pcbs
0000f8  42a0              CMP      r0,r4                 ;210
0000fa  d105              BNE      |L9.264|
0000fc  4851              LDR      r0,|L9.580|
0000fe  6800              LDR      r0,[r0,#0]            ;210  ; tcp_bound_pcbs
000100  68c0              LDR      r0,[r0,#0xc]          ;210
000102  4950              LDR      r1,|L9.580|
000104  6008              STR      r0,[r1,#0]            ;210  ; tcp_bound_pcbs
000106  e018              B        |L9.314|
                  |L9.264|
000108  484e              LDR      r0,|L9.580|
00010a  6800              LDR      r0,[r0,#0]            ;210  ; tcp_bound_pcbs
00010c  494a              LDR      r1,|L9.568|
00010e  6008              STR      r0,[r1,#0]            ;210  ; tcp_tmp_pcb
000110  e00e              B        |L9.304|
                  |L9.274|
000112  4849              LDR      r0,|L9.568|
000114  6800              LDR      r0,[r0,#0]            ;210  ; tcp_tmp_pcb
000116  68c0              LDR      r0,[r0,#0xc]          ;210
000118  42a0              CMP      r0,r4                 ;210
00011a  d104              BNE      |L9.294|
00011c  4946              LDR      r1,|L9.568|
00011e  68e0              LDR      r0,[r4,#0xc]          ;210
000120  6809              LDR      r1,[r1,#0]            ;210  ; tcp_tmp_pcb
000122  60c8              STR      r0,[r1,#0xc]          ;210
000124  e008              B        |L9.312|
                  |L9.294|
000126  4844              LDR      r0,|L9.568|
000128  6800              LDR      r0,[r0,#0]            ;210  ; tcp_tmp_pcb
00012a  68c0              LDR      r0,[r0,#0xc]          ;210
00012c  4942              LDR      r1,|L9.568|
00012e  6008              STR      r0,[r1,#0]            ;210  ; tcp_tmp_pcb
                  |L9.304|
000130  4841              LDR      r0,|L9.568|
000132  6800              LDR      r0,[r0,#0]            ;210  ; tcp_tmp_pcb
000134  2800              CMP      r0,#0                 ;210
000136  d1ec              BNE      |L9.274|
                  |L9.312|
000138  bf00              NOP                            ;210
                  |L9.314|
00013a  2000              MOVS     r0,#0                 ;210
00013c  60e0              STR      r0,[r4,#0xc]          ;210
00013e  bf00              NOP                            ;210
                  |L9.320|
000140  4621              MOV      r1,r4                 ;212
000142  2002              MOVS     r0,#2                 ;212
000144  f7fffffe          BL       memp_free
000148  2400              MOVS     r4,#0                 ;213
00014a  e035              B        |L9.440|
00014c  2500              MOVS     r5,#0                 ;216
00014e  4621              MOV      r1,r4                 ;217
000150  483d              LDR      r0,|L9.584|
000152  f7fffffe          BL       tcp_pcb_remove
000156  4621              MOV      r1,r4                 ;218
000158  2003              MOVS     r0,#3                 ;218
00015a  f7fffffe          BL       memp_free
00015e  2400              MOVS     r4,#0                 ;219
000160  e02a              B        |L9.440|
000162  2500              MOVS     r5,#0                 ;222
000164  bf00              NOP                            ;223
000166  4621              MOV      r1,r4                 ;223
000168  4832              LDR      r0,|L9.564|
00016a  f7fffffe          BL       tcp_pcb_remove
00016e  2001              MOVS     r0,#1                 ;223
000170  4932              LDR      r1,|L9.572|
000172  7008              STRB     r0,[r1,#0]            ;223
000174  bf00              NOP                            ;223
000176  4621              MOV      r1,r4                 ;224
000178  2002              MOVS     r0,#2                 ;224
00017a  f7fffffe          BL       memp_free
00017e  2400              MOVS     r4,#0                 ;225
000180  e01a              B        |L9.440|
000182  4620              MOV      r0,r4                 ;229
000184  f7fffffe          BL       tcp_send_fin
000188  4605              MOV      r5,r0                 ;229
00018a  b90d              CBNZ     r5,|L9.400|
00018c  2005              MOVS     r0,#5                 ;232
00018e  7620              STRB     r0,[r4,#0x18]         ;232
                  |L9.400|
000190  e012              B        |L9.440|
000192  4620              MOV      r0,r4                 ;236
000194  f7fffffe          BL       tcp_send_fin
000198  4605              MOV      r5,r0                 ;236
00019a  b90d              CBNZ     r5,|L9.416|
00019c  2005              MOVS     r0,#5                 ;239
00019e  7620              STRB     r0,[r4,#0x18]         ;239
                  |L9.416|
0001a0  e00a              B        |L9.440|
0001a2  4620              MOV      r0,r4                 ;243
0001a4  f7fffffe          BL       tcp_send_fin
0001a8  4605              MOV      r5,r0                 ;243
0001aa  b90d              CBNZ     r5,|L9.432|
0001ac  2009              MOVS     r0,#9                 ;246
0001ae  7620              STRB     r0,[r4,#0x18]         ;246
                  |L9.432|
0001b0  e002              B        |L9.440|
                  |L9.434|
0001b2  2500              MOVS     r5,#0                 ;251
0001b4  2400              MOVS     r4,#0                 ;252
0001b6  bf00              NOP                            ;253
                  |L9.440|
0001b8  bf00              NOP                            ;214
0001ba  b11c              CBZ      r4,|L9.452|
0001bc  b915              CBNZ     r5,|L9.452|
0001be  4620              MOV      r0,r4                 ;265
0001c0  f7fffffe          BL       tcp_output
                  |L9.452|
0001c4  4628              MOV      r0,r5                 ;267
0001c6  e787              B        |L9.216|
;;;269    
                          ENDP

                  |L9.456|
0001c8  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp.c",0
0001cc  5749505c
0001d0  6c776970
0001d4  2d312e34
0001d8  2e315c73
0001dc  72635c63
0001e0  6f72655c
0001e4  7463702e
0001e8  6300    
0001ea  00                DCB      0
0001eb  00                DCB      0
                  |L9.492|
0001ec  7063622d          DCB      "pcb->flags & TF_RXCLOSED",0
0001f0  3e666c61
0001f4  67732026
0001f8  2054465f
0001fc  5258434c
000200  4f534544
000204  00      
000205  00                DCB      0
000206  00                DCB      0
000207  00                DCB      0
                  |L9.520|
000208  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
00020c  7274696f
000210  6e202225
000214  73222066
000218  61696c65
00021c  64206174
000220  206c696e
000224  65202564
000228  20696e20
00022c  25730d0a
000230  00      
000231  00                DCB      0
000232  00                DCB      0
000233  00                DCB      0
                  |L9.564|
                          DCD      tcp_active_pcbs
                  |L9.568|
                          DCD      tcp_tmp_pcb
                  |L9.572|
                          DCD      tcp_active_pcbs_changed
                  |L9.576|
                          DCD      tcp_tw_pcbs
                  |L9.580|
                          DCD      tcp_bound_pcbs
                  |L9.584|
                          DCD      tcp_listen_pcbs

                          AREA ||i.tcp_connect||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_connect PROC
;;;683    err_t
;;;684    tcp_connect(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;685          tcp_connected_fn connected)
;;;686    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;687      err_t ret;
;;;688      u32_t iss;
;;;689      u16_t old_local_port;
;;;690    
;;;691      LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
00000c  bf00              NOP      
00000e  7e20              LDRB     r0,[r4,#0x18]
000010  2800              CMP      r0,#0
000012  d00c              BEQ      |L10.46|
000014  bf00              NOP      
000016  a351              ADR      r3,|L10.348|
000018  f24022b3          MOV      r2,#0x2b3
00001c  a158              ADR      r1,|L10.384|
00001e  a064              ADR      r0,|L10.432|
000020  f7fffffe          BL       __2printf
000024  bf00              NOP      
000026  f06f0008          MVN      r0,#8
                  |L10.42|
;;;692    
;;;693      LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
;;;694      if (ipaddr != NULL) {
;;;695        pcb->remote_ip = *ipaddr;
;;;696      } else {
;;;697        return ERR_VAL;
;;;698      }
;;;699      pcb->remote_port = port;
;;;700    
;;;701      /* check if we have a route to the remote host */
;;;702      if (ip_addr_isany(&(pcb->local_ip))) {
;;;703        /* no local IP address set, yet. */
;;;704        struct netif *netif = ip_route(&(pcb->remote_ip));
;;;705        if (netif == NULL) {
;;;706          /* Don't even try to send a SYN packet if we have no route
;;;707             since that will fail. */
;;;708          return ERR_RTE;
;;;709        }
;;;710        /* Use the netif's IP address as local address. */
;;;711        ip_addr_copy(pcb->local_ip, netif->ip_addr);
;;;712      }
;;;713    
;;;714      old_local_port = pcb->local_port;
;;;715      if (pcb->local_port == 0) {
;;;716        pcb->local_port = tcp_new_port();
;;;717        if (pcb->local_port == 0) {
;;;718          return ERR_BUF;
;;;719        }
;;;720      }
;;;721    #if SO_REUSE
;;;722      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;723        /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
;;;724           now that the 5-tuple is unique. */
;;;725        struct tcp_pcb *cpcb;
;;;726        int i;
;;;727        /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
;;;728        for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
;;;729          for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;730            if ((cpcb->local_port == pcb->local_port) &&
;;;731                (cpcb->remote_port == port) &&
;;;732                ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
;;;733                ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
;;;734              /* linux returns EISCONN here, but ERR_USE should be OK for us */
;;;735              return ERR_USE;
;;;736            }
;;;737          }
;;;738        }
;;;739      }
;;;740    #endif /* SO_REUSE */
;;;741      iss = tcp_next_iss();
;;;742      pcb->rcv_nxt = 0;
;;;743      pcb->snd_nxt = iss;
;;;744      pcb->lastack = iss - 1;
;;;745      pcb->snd_lbb = iss - 1;
;;;746      pcb->rcv_wnd = TCP_WND;
;;;747      pcb->rcv_ann_wnd = TCP_WND;
;;;748      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;749      pcb->snd_wnd = TCP_WND;
;;;750      /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;751         The send MSS is updated when an MSS option is received. */
;;;752      pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
;;;753    #if TCP_CALCULATE_EFF_SEND_MSS
;;;754      pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
;;;755    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;756      pcb->cwnd = 1;
;;;757      pcb->ssthresh = pcb->mss * 10;
;;;758    #if LWIP_CALLBACK_API
;;;759      pcb->connected = connected;
;;;760    #else /* LWIP_CALLBACK_API */  
;;;761      LWIP_UNUSED_ARG(connected);
;;;762    #endif /* LWIP_CALLBACK_API */
;;;763    
;;;764      /* Send a SYN together with the MSS option. */
;;;765      ret = tcp_enqueue_flags(pcb, TCP_SYN);
;;;766      if (ret == ERR_OK) {
;;;767        /* SYN segment was enqueued, changed the pcbs state now */
;;;768        pcb->state = SYN_SENT;
;;;769        if (old_local_port != 0) {
;;;770          TCP_RMV(&tcp_bound_pcbs, pcb);
;;;771        }
;;;772        TCP_REG_ACTIVE(pcb);
;;;773        snmp_inc_tcpactiveopens();
;;;774    
;;;775        tcp_output(pcb);
;;;776      }
;;;777      return ret;
;;;778    }
00002a  e8bd9ff0          POP      {r4-r12,pc}
                  |L10.46|
00002e  bf00              NOP                            ;691
000030  bf00              NOP                            ;693
000032  bf00              NOP                            ;693
000034  b116              CBZ      r6,|L10.60|
000036  6830              LDR      r0,[r6,#0]            ;695
000038  6060              STR      r0,[r4,#4]            ;695
00003a  e002              B        |L10.66|
                  |L10.60|
00003c  f06f0005          MVN      r0,#5                 ;697
000040  e7f3              B        |L10.42|
                  |L10.66|
000042  f8a4801c          STRH     r8,[r4,#0x1c]         ;699
000046  b10c              CBZ      r4,|L10.76|
000048  6820              LDR      r0,[r4,#0]            ;702
00004a  b968              CBNZ     r0,|L10.104|
                  |L10.76|
00004c  1d20              ADDS     r0,r4,#4              ;704
00004e  f7fffffe          BL       ip_route
000052  4683              MOV      r11,r0                ;704
000054  f1bb0f00          CMP      r11,#0                ;705
000058  d102              BNE      |L10.96|
00005a  f06f0003          MVN      r0,#3                 ;708
00005e  e7e4              B        |L10.42|
                  |L10.96|
000060  f8db0004          LDR      r0,[r11,#4]           ;711
000064  6020              STR      r0,[r4,#0]            ;711
000066  bf00              NOP                            ;712
                  |L10.104|
000068  f8b4a01a          LDRH     r10,[r4,#0x1a]        ;714
00006c  8b60              LDRH     r0,[r4,#0x1a]         ;715
00006e  b938              CBNZ     r0,|L10.128|
000070  f7fffffe          BL       tcp_new_port
000074  8360              STRH     r0,[r4,#0x1a]         ;716
000076  8b60              LDRH     r0,[r4,#0x1a]         ;717
000078  b910              CBNZ     r0,|L10.128|
00007a  f06f0001          MVN      r0,#1                 ;718
00007e  e7d4              B        |L10.42|
                  |L10.128|
000080  f7fffffe          BL       tcp_next_iss
000084  4605              MOV      r5,r0                 ;741
000086  2000              MOVS     r0,#0                 ;742
000088  f8440f28          STR      r0,[r4,#0x28]!        ;742
00008c  62a5              STR      r5,[r4,#0x28]         ;743
00008e  1e68              SUBS     r0,r5,#1              ;744
000090  6220              STR      r0,[r4,#0x20]         ;744
000092  6360              STR      r0,[r4,#0x34]         ;745
000094  f6403068          MOV      r0,#0xb68             ;746
000098  80a0              STRH     r0,[r4,#4]            ;746
00009a  80e0              STRH     r0,[r4,#6]            ;747
00009c  6820              LDR      r0,[r4,#0]            ;748
00009e  60a0              STR      r0,[r4,#8]            ;748
0000a0  f6403068          MOV      r0,#0xb68             ;749
0000a4  8720              STRH     r0,[r4,#0x38]         ;749
0000a6  f44f7006          MOV      r0,#0x218             ;752
0000aa  81e0              STRH     r0,[r4,#0xe]          ;752
0000ac  89e0              LDRH     r0,[r4,#0xe]          ;754
0000ae  4631              MOV      r1,r6                 ;754
0000b0  f7fffffe          BL       tcp_eff_send_mss
0000b4  81e0              STRH     r0,[r4,#0xe]          ;754
0000b6  2001              MOVS     r0,#1                 ;756
0000b8  84a0              STRH     r0,[r4,#0x24]         ;756
0000ba  89e0              LDRH     r0,[r4,#0xe]          ;757
0000bc  eb000080          ADD      r0,r0,r0,LSL #2       ;757
0000c0  f64f71ff          MOV      r1,#0xffff            ;757
0000c4  ea010040          AND      r0,r1,r0,LSL #1       ;757
0000c8  84e0              STRH     r0,[r4,#0x26]         ;757
0000ca  f8c4905c          STR      r9,[r4,#0x5c]         ;759
0000ce  3c28              SUBS     r4,r4,#0x28           ;759
0000d0  2102              MOVS     r1,#2                 ;765
0000d2  4620              MOV      r0,r4                 ;765
0000d4  f7fffffe          BL       tcp_enqueue_flags
0000d8  4607              MOV      r7,r0                 ;765
0000da  2f00              CMP      r7,#0                 ;766
0000dc  d13c              BNE      |L10.344|
0000de  2002              MOVS     r0,#2                 ;768
0000e0  7620              STRB     r0,[r4,#0x18]         ;768
0000e2  f1ba0f00          CMP      r10,#0                ;769
0000e6  d026              BEQ      |L10.310|
0000e8  bf00              NOP                            ;770
0000ea  483c              LDR      r0,|L10.476|
0000ec  6800              LDR      r0,[r0,#0]            ;770  ; tcp_bound_pcbs
0000ee  42a0              CMP      r0,r4                 ;770
0000f0  d105              BNE      |L10.254|
0000f2  483a              LDR      r0,|L10.476|
0000f4  6800              LDR      r0,[r0,#0]            ;770  ; tcp_bound_pcbs
0000f6  68c0              LDR      r0,[r0,#0xc]          ;770
0000f8  4938              LDR      r1,|L10.476|
0000fa  6008              STR      r0,[r1,#0]            ;770  ; tcp_bound_pcbs
0000fc  e018              B        |L10.304|
                  |L10.254|
0000fe  4837              LDR      r0,|L10.476|
000100  6800              LDR      r0,[r0,#0]            ;770  ; tcp_bound_pcbs
000102  4937              LDR      r1,|L10.480|
000104  6008              STR      r0,[r1,#0]            ;770  ; tcp_tmp_pcb
000106  e00e              B        |L10.294|
                  |L10.264|
000108  4835              LDR      r0,|L10.480|
00010a  6800              LDR      r0,[r0,#0]            ;770  ; tcp_tmp_pcb
00010c  68c0              LDR      r0,[r0,#0xc]          ;770
00010e  42a0              CMP      r0,r4                 ;770
000110  d104              BNE      |L10.284|
000112  4933              LDR      r1,|L10.480|
000114  68e0              LDR      r0,[r4,#0xc]          ;770
000116  6809              LDR      r1,[r1,#0]            ;770  ; tcp_tmp_pcb
000118  60c8              STR      r0,[r1,#0xc]          ;770
00011a  e008              B        |L10.302|
                  |L10.284|
00011c  4830              LDR      r0,|L10.480|
00011e  6800              LDR      r0,[r0,#0]            ;770  ; tcp_tmp_pcb
000120  68c0              LDR      r0,[r0,#0xc]          ;770
000122  492f              LDR      r1,|L10.480|
000124  6008              STR      r0,[r1,#0]            ;770  ; tcp_tmp_pcb
                  |L10.294|
000126  482e              LDR      r0,|L10.480|
000128  6800              LDR      r0,[r0,#0]            ;770  ; tcp_tmp_pcb
00012a  2800              CMP      r0,#0                 ;770
00012c  d1ec              BNE      |L10.264|
                  |L10.302|
00012e  bf00              NOP                            ;770
                  |L10.304|
000130  2000              MOVS     r0,#0                 ;770
000132  60e0              STR      r0,[r4,#0xc]          ;770
000134  bf00              NOP                            ;770
                  |L10.310|
000136  bf00              NOP                            ;772
000138  bf00              NOP                            ;772
00013a  482a              LDR      r0,|L10.484|
00013c  6800              LDR      r0,[r0,#0]            ;772  ; tcp_active_pcbs
00013e  60e0              STR      r0,[r4,#0xc]          ;772
000140  4828              LDR      r0,|L10.484|
000142  6004              STR      r4,[r0,#0]            ;772  ; tcp_active_pcbs
000144  f7fffffe          BL       tcp_timer_needed
000148  bf00              NOP                            ;772
00014a  2001              MOVS     r0,#1                 ;772
00014c  4926              LDR      r1,|L10.488|
00014e  7008              STRB     r0,[r1,#0]            ;772
000150  bf00              NOP                            ;772
000152  4620              MOV      r0,r4                 ;775
000154  f7fffffe          BL       tcp_output
                  |L10.344|
000158  4638              MOV      r0,r7                 ;777
00015a  e766              B        |L10.42|
;;;779    
                          ENDP

                  |L10.348|
00015c  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp.c",0
000160  5749505c
000164  6c776970
000168  2d312e34
00016c  2e315c73
000170  72635c63
000174  6f72655c
000178  7463702e
00017c  6300    
00017e  00                DCB      0
00017f  00                DCB      0
                  |L10.384|
000180  7463705f          DCB      "tcp_connect: can only connect from state CLOSED",0
000184  636f6e6e
000188  6563743a
00018c  2063616e
000190  206f6e6c
000194  7920636f
000198  6e6e6563
00019c  74206672
0001a0  6f6d2073
0001a4  74617465
0001a8  20434c4f
0001ac  53454400
                  |L10.432|
0001b0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0001b4  7274696f
0001b8  6e202225
0001bc  73222066
0001c0  61696c65
0001c4  64206174
0001c8  206c696e
0001cc  65202564
0001d0  20696e20
0001d4  25730d0a
0001d8  00      
0001d9  00                DCB      0
0001da  00                DCB      0
0001db  00                DCB      0
                  |L10.476|
                          DCD      tcp_bound_pcbs
                  |L10.480|
                          DCD      tcp_tmp_pcb
                  |L10.484|
                          DCD      tcp_active_pcbs
                  |L10.488|
                          DCD      tcp_active_pcbs_changed

                          AREA ||i.tcp_debug_state_str||, CODE, READONLY, ALIGN=2

                  tcp_debug_state_str PROC
;;;1604   const char*
;;;1605   tcp_debug_state_str(enum tcp_state s)
000000  4601              MOV      r1,r0
;;;1606   {
;;;1607     return tcp_state_str[s];
000002  4802              LDR      r0,|L11.12|
000004  f8500021          LDR      r0,[r0,r1,LSL #2]
;;;1608   }
000008  4770              BX       lr
;;;1609   
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      tcp_state_str

                          AREA ||i.tcp_eff_send_mss||, CODE, READONLY, ALIGN=1

                  tcp_eff_send_mss PROC
;;;1585   u16_t
;;;1586   tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1587   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;1588     u16_t mss_s;
;;;1589     struct netif *outif;
;;;1590   
;;;1591     outif = ip_route(addr);
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       ip_route
00000e  4604              MOV      r4,r0
;;;1592     if ((outif != NULL) && (outif->mtu != 0)) {
000010  b154              CBZ      r4,|L12.40|
000012  8ca0              LDRH     r0,[r4,#0x24]
000014  b140              CBZ      r0,|L12.40|
;;;1593       mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
000016  8ca0              LDRH     r0,[r4,#0x24]
000018  3828              SUBS     r0,r0,#0x28
00001a  b287              UXTH     r7,r0
;;;1594       /* RFC 1122, chap 4.2.2.6:
;;;1595        * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
;;;1596        * We correct for TCP options in tcp_write(), and don't support IP options.
;;;1597        */
;;;1598       sendmss = LWIP_MIN(sendmss, mss_s);
00001c  42bd              CMP      r5,r7
00001e  da01              BGE      |L12.36|
000020  4628              MOV      r0,r5
000022  e000              B        |L12.38|
                  |L12.36|
000024  4638              MOV      r0,r7
                  |L12.38|
000026  4605              MOV      r5,r0
                  |L12.40|
;;;1599     }
;;;1600     return sendmss;
000028  4628              MOV      r0,r5
;;;1601   }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;1602   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
                          ENDP


                          AREA ||i.tcp_err||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_err PROC
;;;1420   void
;;;1421   tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
000000  b570              PUSH     {r4-r6,lr}
;;;1422   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1423     LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
000006  bf00              NOP      
000008  7e20              LDRB     r0,[r4,#0x18]
00000a  2801              CMP      r0,#1
00000c  d108              BNE      |L13.32|
00000e  bf00              NOP      
000010  a305              ADR      r3,|L13.40|
000012  f240528f          MOV      r2,#0x58f
000016  a10d              ADR      r1,|L13.76|
000018  a016              ADR      r0,|L13.116|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
                  |L13.32|
000020  bf00              NOP      
;;;1424     pcb->errf = err;
000022  f8c4508c          STR      r5,[r4,#0x8c]
;;;1425   }
000026  bd70              POP      {r4-r6,pc}
;;;1426   
                          ENDP

                  |L13.40|
000028  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp.c",0
00002c  5749505c
000030  6c776970
000034  2d312e34
000038  2e315c73
00003c  72635c63
000040  6f72655c
000044  7463702e
000048  6300    
00004a  00                DCB      0
00004b  00                DCB      0
                  |L13.76|
00004c  696e7661          DCB      "invalid socket state for err callback",0
000050  6c696420
000054  736f636b
000058  65742073
00005c  74617465
000060  20666f72
000064  20657272
000068  2063616c
00006c  6c626163
000070  6b00    
000072  00                DCB      0
000073  00                DCB      0
                  |L13.116|
000074  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000078  7274696f
00007c  6e202225
000080  73222066
000084  61696c65
000088  64206174
00008c  206c696e
000090  65202564
000094  20696e20
000098  25730d0a
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0

                          AREA ||i.tcp_fasttmr||, CODE, READONLY, ALIGN=2

                  tcp_fasttmr PROC
;;;1045   void
;;;1046   tcp_fasttmr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1047   {
;;;1048     struct tcp_pcb *pcb;
;;;1049   
;;;1050     ++tcp_timer_ctr;
000002  481c              LDR      r0,|L14.116|
000004  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
000006  1c40              ADDS     r0,r0,#1
000008  491a              LDR      r1,|L14.116|
00000a  7008              STRB     r0,[r1,#0]
;;;1051   
;;;1052   tcp_fasttmr_start:
00000c  bf00              NOP      
                  |L14.14|
;;;1053     pcb = tcp_active_pcbs;
00000e  481a              LDR      r0,|L14.120|
000010  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
;;;1054   
;;;1055     while(pcb != NULL) {
000012  e02b              B        |L14.108|
                  |L14.20|
;;;1056       if (pcb->last_timer != tcp_timer_ctr) {
000014  f8940021          LDRB     r0,[r4,#0x21]
000018  4916              LDR      r1,|L14.116|
00001a  7809              LDRB     r1,[r1,#0]  ; tcp_timer_ctr
00001c  4288              CMP      r0,r1
00001e  d025              BEQ      |L14.108|
;;;1057         struct tcp_pcb *next;
;;;1058         pcb->last_timer = tcp_timer_ctr;
000020  4814              LDR      r0,|L14.116|
000022  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
000024  f8840021          STRB     r0,[r4,#0x21]
;;;1059         /* send delayed ACKs */
;;;1060         if (pcb->flags & TF_ACK_DELAY) {
000028  7fa0              LDRB     r0,[r4,#0x1e]
00002a  f0000001          AND      r0,r0,#1
00002e  b170              CBZ      r0,|L14.78|
;;;1061           LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
000030  bf00              NOP      
000032  bf00              NOP      
;;;1062           tcp_ack_now(pcb);
000034  bf00              NOP      
000036  7fa0              LDRB     r0,[r4,#0x1e]
000038  f0400002          ORR      r0,r0,#2
00003c  77a0              STRB     r0,[r4,#0x1e]
00003e  bf00              NOP      
;;;1063           tcp_output(pcb);
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       tcp_output
;;;1064           pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
000046  7fa0              LDRB     r0,[r4,#0x1e]
000048  f0200003          BIC      r0,r0,#3
00004c  77a0              STRB     r0,[r4,#0x1e]
                  |L14.78|
;;;1065         }
;;;1066   
;;;1067         next = pcb->next;
00004e  68e5              LDR      r5,[r4,#0xc]
;;;1068   
;;;1069         /* If there is data which was previously "refused" by upper layer */
;;;1070         if (pcb->refused_data != NULL) {
000050  6fa0              LDR      r0,[r4,#0x78]
000052  b148              CBZ      r0,|L14.104|
;;;1071           tcp_active_pcbs_changed = 0;
000054  2000              MOVS     r0,#0
000056  4909              LDR      r1,|L14.124|
000058  7008              STRB     r0,[r1,#0]
;;;1072           tcp_process_refused_data(pcb);
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       tcp_process_refused_data
;;;1073           if (tcp_active_pcbs_changed) {
000060  4806              LDR      r0,|L14.124|
000062  7800              LDRB     r0,[r0,#0]  ; tcp_active_pcbs_changed
000064  b100              CBZ      r0,|L14.104|
;;;1074             /* application callback has changed the pcb list: restart the loop */
;;;1075             goto tcp_fasttmr_start;
000066  e7d2              B        |L14.14|
                  |L14.104|
;;;1076           }
;;;1077         }
;;;1078         pcb = next;
000068  462c              MOV      r4,r5
;;;1079       }
00006a  bf00              NOP      
                  |L14.108|
00006c  2c00              CMP      r4,#0                 ;1055
00006e  d1d1              BNE      |L14.20|
;;;1080     }
;;;1081   }
000070  bd70              POP      {r4-r6,pc}
;;;1082   
                          ENDP

000072  0000              DCW      0x0000
                  |L14.116|
                          DCD      tcp_timer_ctr
                  |L14.120|
                          DCD      tcp_active_pcbs
                  |L14.124|
                          DCD      tcp_active_pcbs_changed

                          AREA ||i.tcp_init||, CODE, READONLY, ALIGN=1

                  tcp_init PROC
;;;129    void
;;;130    tcp_init(void)
000000  4770              BX       lr
;;;131    {
;;;132    #if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
;;;133      tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
;;;134    #endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
;;;135    }
;;;136    
                          ENDP


                          AREA ||i.tcp_kill_prio||, CODE, READONLY, ALIGN=2

                  tcp_kill_prio PROC
;;;1216   static void
;;;1217   tcp_kill_prio(u8_t prio)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1218   {
000004  4606              MOV      r6,r0
;;;1219     struct tcp_pcb *pcb, *inactive;
;;;1220     u32_t inactivity;
;;;1221     u8_t mprio;
;;;1222   
;;;1223   
;;;1224     mprio = TCP_PRIO_MAX;
000006  f04f087f          MOV      r8,#0x7f
;;;1225     
;;;1226     /* We kill the oldest active connection that has lower priority than prio. */
;;;1227     inactivity = 0;
00000a  2700              MOVS     r7,#0
;;;1228     inactive = NULL;
00000c  2500              MOVS     r5,#0
;;;1229     for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
00000e  4810              LDR      r0,|L16.80|
000010  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
000012  e013              B        |L16.60|
                  |L16.20|
;;;1230       if (pcb->prio <= prio &&
000014  7e60              LDRB     r0,[r4,#0x19]
000016  42b0              CMP      r0,r6
000018  dc0f              BGT      |L16.58|
;;;1231          pcb->prio <= mprio &&
00001a  7e60              LDRB     r0,[r4,#0x19]
00001c  4540              CMP      r0,r8
00001e  dc0c              BGT      |L16.58|
;;;1232          (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
000020  490c              LDR      r1,|L16.84|
000022  6a60              LDR      r0,[r4,#0x24]
000024  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000026  1a08              SUBS     r0,r1,r0
000028  42b8              CMP      r0,r7
00002a  d306              BCC      |L16.58|
;;;1233         inactivity = tcp_ticks - pcb->tmr;
00002c  4909              LDR      r1,|L16.84|
00002e  6a60              LDR      r0,[r4,#0x24]
000030  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000032  1a0f              SUBS     r7,r1,r0
;;;1234         inactive = pcb;
000034  4625              MOV      r5,r4
;;;1235         mprio = pcb->prio;
000036  f8948019          LDRB     r8,[r4,#0x19]
                  |L16.58|
00003a  68e4              LDR      r4,[r4,#0xc]          ;1229
                  |L16.60|
00003c  2c00              CMP      r4,#0                 ;1229
00003e  d1e9              BNE      |L16.20|
;;;1236       }
;;;1237     }
;;;1238     if (inactive != NULL) {
000040  b125              CBZ      r5,|L16.76|
;;;1239       LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
000042  bf00              NOP      
000044  bf00              NOP      
;;;1240              (void *)inactive, inactivity));
;;;1241       tcp_abort(inactive);
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       tcp_abort
                  |L16.76|
;;;1242     }
;;;1243   }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;1244   
                          ENDP

                  |L16.80|
                          DCD      tcp_active_pcbs
                  |L16.84|
                          DCD      tcp_ticks

                          AREA ||i.tcp_kill_timewait||, CODE, READONLY, ALIGN=2

                  tcp_kill_timewait PROC
;;;1249   static void
;;;1250   tcp_kill_timewait(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1251   {
;;;1252     struct tcp_pcb *pcb, *inactive;
;;;1253     u32_t inactivity;
;;;1254   
;;;1255     inactivity = 0;
000002  2600              MOVS     r6,#0
;;;1256     inactive = NULL;
000004  2500              MOVS     r5,#0
;;;1257     /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
;;;1258     for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
000006  480c              LDR      r0,|L17.56|
000008  6804              LDR      r4,[r0,#0]  ; tcp_tw_pcbs
00000a  e00b              B        |L17.36|
                  |L17.12|
;;;1259       if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
00000c  490b              LDR      r1,|L17.60|
00000e  6a60              LDR      r0,[r4,#0x24]
000010  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000012  1a08              SUBS     r0,r1,r0
000014  42b0              CMP      r0,r6
000016  d304              BCC      |L17.34|
;;;1260         inactivity = tcp_ticks - pcb->tmr;
000018  4908              LDR      r1,|L17.60|
00001a  6a60              LDR      r0,[r4,#0x24]
00001c  6809              LDR      r1,[r1,#0]  ; tcp_ticks
00001e  1a0e              SUBS     r6,r1,r0
;;;1261         inactive = pcb;
000020  4625              MOV      r5,r4
                  |L17.34|
000022  68e4              LDR      r4,[r4,#0xc]          ;1258
                  |L17.36|
000024  2c00              CMP      r4,#0                 ;1258
000026  d1f1              BNE      |L17.12|
;;;1262       }
;;;1263     }
;;;1264     if (inactive != NULL) {
000028  b125              CBZ      r5,|L17.52|
;;;1265       LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
00002a  bf00              NOP      
00002c  bf00              NOP      
;;;1266              (void *)inactive, inactivity));
;;;1267       tcp_abort(inactive);
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       tcp_abort
                  |L17.52|
;;;1268     }
;;;1269   }
000034  bd70              POP      {r4-r6,pc}
;;;1270   
                          ENDP

000036  0000              DCW      0x0000
                  |L17.56|
                          DCD      tcp_tw_pcbs
                  |L17.60|
                          DCD      tcp_ticks

                          AREA ||i.tcp_listen_with_backlog||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_listen_with_backlog PROC
;;;518    struct tcp_pcb *
;;;519    tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
000000  b570              PUSH     {r4-r6,lr}
;;;520    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;521      struct tcp_pcb_listen *lpcb;
;;;522    
;;;523      LWIP_UNUSED_ARG(backlog);
;;;524      LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
000006  bf00              NOP      
000008  7e20              LDRB     r0,[r4,#0x18]
00000a  2800              CMP      r0,#0
00000c  d00a              BEQ      |L18.36|
00000e  bf00              NOP      
000010  a332              ADR      r3,|L18.220|
000012  f44f7203          MOV      r2,#0x20c
000016  a13a              ADR      r1,|L18.256|
000018  a042              ADR      r0,|L18.292|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
000020  2000              MOVS     r0,#0
                  |L18.34|
;;;525    
;;;526      /* already listening? */
;;;527      if (pcb->state == LISTEN) {
;;;528        return pcb;
;;;529      }
;;;530    #if SO_REUSE
;;;531      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;532        /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
;;;533           is declared (listen-/connection-pcb), we have to make sure now that
;;;534           this port is only used once for every local IP. */
;;;535        for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;536          if (lpcb->local_port == pcb->local_port) {
;;;537            if (ip_addr_cmp(&lpcb->local_ip, &pcb->local_ip)) {
;;;538              /* this address/port is already used */
;;;539              return NULL;
;;;540            }
;;;541          }
;;;542        }
;;;543      }
;;;544    #endif /* SO_REUSE */
;;;545      lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
;;;546      if (lpcb == NULL) {
;;;547        return NULL;
;;;548      }
;;;549      lpcb->callback_arg = pcb->callback_arg;
;;;550      lpcb->local_port = pcb->local_port;
;;;551      lpcb->state = LISTEN;
;;;552      lpcb->prio = pcb->prio;
;;;553      lpcb->so_options = pcb->so_options;
;;;554      ip_set_option(lpcb, SOF_ACCEPTCONN);
;;;555      lpcb->ttl = pcb->ttl;
;;;556      lpcb->tos = pcb->tos;
;;;557      ip_addr_copy(lpcb->local_ip, pcb->local_ip);
;;;558      if (pcb->local_port != 0) {
;;;559        TCP_RMV(&tcp_bound_pcbs, pcb);
;;;560      }
;;;561      memp_free(MEMP_TCP_PCB, pcb);
;;;562    #if LWIP_CALLBACK_API
;;;563      lpcb->accept = tcp_accept_null;
;;;564    #endif /* LWIP_CALLBACK_API */
;;;565    #if TCP_LISTEN_BACKLOG
;;;566      lpcb->accepts_pending = 0;
;;;567      lpcb->backlog = (backlog ? backlog : 1);
;;;568    #endif /* TCP_LISTEN_BACKLOG */
;;;569      TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
;;;570      return (struct tcp_pcb *)lpcb;
;;;571    }
000022  bd70              POP      {r4-r6,pc}
                  |L18.36|
000024  bf00              NOP                            ;524
000026  7e20              LDRB     r0,[r4,#0x18]         ;527
000028  2801              CMP      r0,#1                 ;527
00002a  d101              BNE      |L18.48|
00002c  4620              MOV      r0,r4                 ;528
00002e  e7f8              B        |L18.34|
                  |L18.48|
000030  2003              MOVS     r0,#3                 ;545
000032  f7fffffe          BL       memp_malloc
000036  4605              MOV      r5,r0                 ;545
000038  b90d              CBNZ     r5,|L18.62|
00003a  2000              MOVS     r0,#0                 ;547
00003c  e7f1              B        |L18.34|
                  |L18.62|
00003e  6920              LDR      r0,[r4,#0x10]         ;549
000040  6128              STR      r0,[r5,#0x10]         ;549
000042  8b60              LDRH     r0,[r4,#0x1a]         ;550
000044  8368              STRH     r0,[r5,#0x1a]         ;550
000046  2001              MOVS     r0,#1                 ;551
000048  7628              STRB     r0,[r5,#0x18]         ;551
00004a  7e60              LDRB     r0,[r4,#0x19]         ;552
00004c  7668              STRB     r0,[r5,#0x19]         ;552
00004e  7a20              LDRB     r0,[r4,#8]            ;553
000050  7228              STRB     r0,[r5,#8]            ;553
000052  7a28              LDRB     r0,[r5,#8]            ;554
000054  f0400002          ORR      r0,r0,#2              ;554
000058  7228              STRB     r0,[r5,#8]            ;554
00005a  7aa0              LDRB     r0,[r4,#0xa]          ;555
00005c  72a8              STRB     r0,[r5,#0xa]          ;555
00005e  7a60              LDRB     r0,[r4,#9]            ;556
000060  7268              STRB     r0,[r5,#9]            ;556
000062  6820              LDR      r0,[r4,#0]            ;557
000064  6028              STR      r0,[r5,#0]            ;557
000066  8b60              LDRH     r0,[r4,#0x1a]         ;558
000068  b330              CBZ      r0,|L18.184|
00006a  bf00              NOP                            ;559
00006c  4838              LDR      r0,|L18.336|
00006e  6800              LDR      r0,[r0,#0]            ;559  ; tcp_bound_pcbs
000070  42a0              CMP      r0,r4                 ;559
000072  d105              BNE      |L18.128|
000074  4836              LDR      r0,|L18.336|
000076  6800              LDR      r0,[r0,#0]            ;559  ; tcp_bound_pcbs
000078  68c0              LDR      r0,[r0,#0xc]          ;559
00007a  4935              LDR      r1,|L18.336|
00007c  6008              STR      r0,[r1,#0]            ;559  ; tcp_bound_pcbs
00007e  e018              B        |L18.178|
                  |L18.128|
000080  4833              LDR      r0,|L18.336|
000082  6800              LDR      r0,[r0,#0]            ;559  ; tcp_bound_pcbs
000084  4933              LDR      r1,|L18.340|
000086  6008              STR      r0,[r1,#0]            ;559  ; tcp_tmp_pcb
000088  e00e              B        |L18.168|
                  |L18.138|
00008a  4832              LDR      r0,|L18.340|
00008c  6800              LDR      r0,[r0,#0]            ;559  ; tcp_tmp_pcb
00008e  68c0              LDR      r0,[r0,#0xc]          ;559
000090  42a0              CMP      r0,r4                 ;559
000092  d104              BNE      |L18.158|
000094  492f              LDR      r1,|L18.340|
000096  68e0              LDR      r0,[r4,#0xc]          ;559
000098  6809              LDR      r1,[r1,#0]            ;559  ; tcp_tmp_pcb
00009a  60c8              STR      r0,[r1,#0xc]          ;559
00009c  e008              B        |L18.176|
                  |L18.158|
00009e  482d              LDR      r0,|L18.340|
0000a0  6800              LDR      r0,[r0,#0]            ;559  ; tcp_tmp_pcb
0000a2  68c0              LDR      r0,[r0,#0xc]          ;559
0000a4  492b              LDR      r1,|L18.340|
0000a6  6008              STR      r0,[r1,#0]            ;559  ; tcp_tmp_pcb
                  |L18.168|
0000a8  482a              LDR      r0,|L18.340|
0000aa  6800              LDR      r0,[r0,#0]            ;559  ; tcp_tmp_pcb
0000ac  2800              CMP      r0,#0                 ;559
0000ae  d1ec              BNE      |L18.138|
                  |L18.176|
0000b0  bf00              NOP                            ;559
                  |L18.178|
0000b2  2000              MOVS     r0,#0                 ;559
0000b4  60e0              STR      r0,[r4,#0xc]          ;559
0000b6  bf00              NOP                            ;559
                  |L18.184|
0000b8  4621              MOV      r1,r4                 ;561
0000ba  2002              MOVS     r0,#2                 ;561
0000bc  f7fffffe          BL       memp_free
0000c0  4825              LDR      r0,|L18.344|
0000c2  6168              STR      r0,[r5,#0x14]         ;563
0000c4  bf00              NOP                            ;569
0000c6  4825              LDR      r0,|L18.348|
0000c8  6800              LDR      r0,[r0,#0]            ;569  ; tcp_listen_pcbs
0000ca  60e8              STR      r0,[r5,#0xc]          ;569
0000cc  4823              LDR      r0,|L18.348|
0000ce  6005              STR      r5,[r0,#0]            ;569  ; tcp_listen_pcbs
0000d0  f7fffffe          BL       tcp_timer_needed
0000d4  bf00              NOP                            ;569
0000d6  4628              MOV      r0,r5                 ;570
0000d8  e7a3              B        |L18.34|
;;;572    
                          ENDP

0000da  0000              DCW      0x0000
                  |L18.220|
0000dc  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp.c",0
0000e0  5749505c
0000e4  6c776970
0000e8  2d312e34
0000ec  2e315c73
0000f0  72635c63
0000f4  6f72655c
0000f8  7463702e
0000fc  6300    
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L18.256|
000100  7463705f          DCB      "tcp_listen: pcb already connected",0
000104  6c697374
000108  656e3a20
00010c  70636220
000110  616c7265
000114  61647920
000118  636f6e6e
00011c  65637465
000120  6400    
000122  00                DCB      0
000123  00                DCB      0
                  |L18.292|
000124  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000128  7274696f
00012c  6e202225
000130  73222066
000134  61696c65
000138  64206174
00013c  206c696e
000140  65202564
000144  20696e20
000148  25730d0a
00014c  00      
00014d  00                DCB      0
00014e  00                DCB      0
00014f  00                DCB      0
                  |L18.336|
                          DCD      tcp_bound_pcbs
                  |L18.340|
                          DCD      tcp_tmp_pcb
                  |L18.344|
                          DCD      tcp_accept_null
                  |L18.348|
                          DCD      tcp_listen_pcbs

                          AREA ||i.tcp_new||, CODE, READONLY, ALIGN=1

                  tcp_new PROC
;;;1362   struct tcp_pcb *
;;;1363   tcp_new(void)
000000  b510              PUSH     {r4,lr}
;;;1364   {
;;;1365     return tcp_alloc(TCP_PRIO_NORMAL);
000002  2040              MOVS     r0,#0x40
000004  f7fffffe          BL       tcp_alloc
;;;1366   }
000008  bd10              POP      {r4,pc}
;;;1367   
                          ENDP


                          AREA ||i.tcp_new_port||, CODE, READONLY, ALIGN=2

                  tcp_new_port PROC
;;;646    static u16_t
;;;647    tcp_new_port(void)
000000  b530              PUSH     {r4,r5,lr}
;;;648    {
;;;649      u8_t i;
;;;650      u16_t n = 0;
000002  2300              MOVS     r3,#0
;;;651      struct tcp_pcb *pcb;
;;;652      
;;;653    again:
000004  bf00              NOP      
                  |L20.6|
;;;654      if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
000006  4816              LDR      r0,|L20.96|
000008  8804              LDRH     r4,[r0,#0]  ; tcp_port
00000a  8800              LDRH     r0,[r0,#0]  ; tcp_port
00000c  1c40              ADDS     r0,r0,#1
00000e  4d14              LDR      r5,|L20.96|
000010  8028              STRH     r0,[r5,#0]
000012  f64f70ff          MOV      r0,#0xffff
000016  4284              CMP      r4,r0
000018  d103              BNE      |L20.34|
;;;655        tcp_port = TCP_LOCAL_PORT_RANGE_START;
00001a  f44f4040          MOV      r0,#0xc000
00001e  462c              MOV      r4,r5
000020  8020              STRH     r0,[r4,#0]
                  |L20.34|
;;;656      }
;;;657      /* Check all PCB lists. */
;;;658      for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
000022  2100              MOVS     r1,#0
000024  e017              B        |L20.86|
                  |L20.38|
;;;659        for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
000026  480f              LDR      r0,|L20.100|
000028  f8500021          LDR      r0,[r0,r1,LSL #2]
00002c  6802              LDR      r2,[r0,#0]
00002e  e00e              B        |L20.78|
                  |L20.48|
;;;660          if (pcb->local_port == tcp_port) {
000030  8b50              LDRH     r0,[r2,#0x1a]
000032  4c0b              LDR      r4,|L20.96|
000034  8824              LDRH     r4,[r4,#0]  ; tcp_port
000036  42a0              CMP      r0,r4
000038  d108              BNE      |L20.76|
;;;661            if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
00003a  1c58              ADDS     r0,r3,#1
00003c  b280              UXTH     r0,r0
00003e  4603              MOV      r3,r0
000040  f5b04f80          CMP      r0,#0x4000
000044  db01              BLT      |L20.74|
;;;662              return 0;
000046  2000              MOVS     r0,#0
                  |L20.72|
;;;663            }
;;;664            goto again;
;;;665          }
;;;666        }
;;;667      }
;;;668      return tcp_port;
;;;669    }
000048  bd30              POP      {r4,r5,pc}
                  |L20.74|
00004a  e7dc              B        |L20.6|
                  |L20.76|
00004c  68d2              LDR      r2,[r2,#0xc]          ;659
                  |L20.78|
00004e  2a00              CMP      r2,#0                 ;659
000050  d1ee              BNE      |L20.48|
000052  1c48              ADDS     r0,r1,#1              ;658
000054  b2c1              UXTB     r1,r0                 ;658
                  |L20.86|
000056  2904              CMP      r1,#4                 ;658
000058  dbe5              BLT      |L20.38|
00005a  4801              LDR      r0,|L20.96|
00005c  8800              LDRH     r0,[r0,#0]            ;668  ; tcp_port
00005e  e7f3              B        |L20.72|
;;;670    
                          ENDP

                  |L20.96|
                          DCD      tcp_port
                  |L20.100|
                          DCD      tcp_pcb_lists

                          AREA ||i.tcp_next_iss||, CODE, READONLY, ALIGN=2

                  tcp_next_iss PROC
;;;1570   u32_t
;;;1571   tcp_next_iss(void)
000000  4804              LDR      r0,|L21.20|
;;;1572   {
;;;1573     static u32_t iss = 6510;
;;;1574     
;;;1575     iss += tcp_ticks;       /* XXX */
000002  6800              LDR      r0,[r0,#0]  ; iss
000004  4904              LDR      r1,|L21.24|
000006  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000008  4408              ADD      r0,r0,r1
00000a  4902              LDR      r1,|L21.20|
00000c  6008              STR      r0,[r1,#0]  ; iss
;;;1576     return iss;
00000e  4608              MOV      r0,r1
000010  6800              LDR      r0,[r0,#0]  ; iss
;;;1577   }
000012  4770              BX       lr
;;;1578   
                          ENDP

                  |L21.20|
                          DCD      iss
                  |L21.24|
                          DCD      tcp_ticks

                          AREA ||i.tcp_pcb_purge||, CODE, READONLY, ALIGN=1

                  tcp_pcb_purge PROC
;;;1469   void
;;;1470   tcp_pcb_purge(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;1471   {
000002  4604              MOV      r4,r0
;;;1472     if (pcb->state != CLOSED &&
000004  7e20              LDRB     r0,[r4,#0x18]
000006  2800              CMP      r0,#0
000008  d02e              BEQ      |L22.104|
;;;1473        pcb->state != TIME_WAIT &&
00000a  7e20              LDRB     r0,[r4,#0x18]
00000c  280a              CMP      r0,#0xa
00000e  d02b              BEQ      |L22.104|
;;;1474        pcb->state != LISTEN) {
000010  7e20              LDRB     r0,[r4,#0x18]
000012  2801              CMP      r0,#1
000014  d028              BEQ      |L22.104|
;;;1475   
;;;1476       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));
000016  bf00              NOP      
000018  bf00              NOP      
;;;1477   
;;;1478   #if TCP_LISTEN_BACKLOG
;;;1479       if (pcb->state == SYN_RCVD) {
;;;1480         /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
;;;1481         struct tcp_pcb_listen *lpcb;
;;;1482         LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
;;;1483           tcp_listen_pcbs.listen_pcbs != NULL);
;;;1484         for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;1485           if ((lpcb->local_port == pcb->local_port) &&
;;;1486               (ip_addr_isany(&lpcb->local_ip) ||
;;;1487                ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {
;;;1488               /* port and address of the listen pcb match the timed-out pcb */
;;;1489               LWIP_ASSERT("tcp_pcb_purge: listen pcb does not have accepts pending",
;;;1490                 lpcb->accepts_pending > 0);
;;;1491               lpcb->accepts_pending--;
;;;1492               break;
;;;1493             }
;;;1494         }
;;;1495       }
;;;1496   #endif /* TCP_LISTEN_BACKLOG */
;;;1497   
;;;1498   
;;;1499       if (pcb->refused_data != NULL) {
00001a  6fa0              LDR      r0,[r4,#0x78]
00001c  b130              CBZ      r0,|L22.44|
;;;1500         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
00001e  bf00              NOP      
000020  bf00              NOP      
;;;1501         pbuf_free(pcb->refused_data);
000022  6fa0              LDR      r0,[r4,#0x78]
000024  f7fffffe          BL       pbuf_free
;;;1502         pcb->refused_data = NULL;
000028  2000              MOVS     r0,#0
00002a  67a0              STR      r0,[r4,#0x78]
                  |L22.44|
;;;1503       }
;;;1504       if (pcb->unsent != NULL) {
00002c  6ee0              LDR      r0,[r4,#0x6c]
00002e  b108              CBZ      r0,|L22.52|
;;;1505         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: not all data sent\n"));
000030  bf00              NOP      
000032  bf00              NOP      
                  |L22.52|
;;;1506       }
;;;1507       if (pcb->unacked != NULL) {
000034  6f20              LDR      r0,[r4,#0x70]
000036  b108              CBZ      r0,|L22.60|
;;;1508         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
000038  bf00              NOP      
00003a  bf00              NOP      
                  |L22.60|
;;;1509       }
;;;1510   #if TCP_QUEUE_OOSEQ
;;;1511       if (pcb->ooseq != NULL) {
00003c  6f60              LDR      r0,[r4,#0x74]
00003e  b108              CBZ      r0,|L22.68|
;;;1512         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
000040  bf00              NOP      
000042  bf00              NOP      
                  |L22.68|
;;;1513       }
;;;1514       tcp_segs_free(pcb->ooseq);
000044  6f60              LDR      r0,[r4,#0x74]
000046  f7fffffe          BL       tcp_segs_free
;;;1515       pcb->ooseq = NULL;
00004a  2000              MOVS     r0,#0
00004c  6760              STR      r0,[r4,#0x74]
;;;1516   #endif /* TCP_QUEUE_OOSEQ */
;;;1517   
;;;1518       /* Stop the retransmission timer as it will expect data on unacked
;;;1519          queue if it fires */
;;;1520       pcb->rtime = -1;
00004e  1e40              SUBS     r0,r0,#1
000050  86a0              STRH     r0,[r4,#0x34]
;;;1521   
;;;1522       tcp_segs_free(pcb->unsent);
000052  6ee0              LDR      r0,[r4,#0x6c]
000054  f7fffffe          BL       tcp_segs_free
;;;1523       tcp_segs_free(pcb->unacked);
000058  6f20              LDR      r0,[r4,#0x70]
00005a  f7fffffe          BL       tcp_segs_free
;;;1524       pcb->unacked = pcb->unsent = NULL;
00005e  2000              MOVS     r0,#0
000060  66e0              STR      r0,[r4,#0x6c]
000062  6720              STR      r0,[r4,#0x70]
;;;1525   #if TCP_OVERSIZE
;;;1526       pcb->unsent_oversize = 0;
000064  f8a4006a          STRH     r0,[r4,#0x6a]
                  |L22.104|
;;;1527   #endif /* TCP_OVERSIZE */
;;;1528     }
;;;1529   }
000068  bd10              POP      {r4,pc}
;;;1530   
                          ENDP


                          AREA ||i.tcp_pcb_remove||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_pcb_remove PROC
;;;1537   void
;;;1538   tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;1539   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1540     TCP_RMV(pcblist, pcb);
000006  bf00              NOP      
000008  6828              LDR      r0,[r5,#0]
00000a  42a0              CMP      r0,r4
00000c  d103              BNE      |L23.22|
00000e  6828              LDR      r0,[r5,#0]
000010  68c0              LDR      r0,[r0,#0xc]
000012  6028              STR      r0,[r5,#0]
000014  e017              B        |L23.70|
                  |L23.22|
000016  492f              LDR      r1,|L23.212|
000018  6828              LDR      r0,[r5,#0]
00001a  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
00001c  e00e              B        |L23.60|
                  |L23.30|
00001e  482d              LDR      r0,|L23.212|
000020  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000022  68c0              LDR      r0,[r0,#0xc]
000024  42a0              CMP      r0,r4
000026  d104              BNE      |L23.50|
000028  492a              LDR      r1,|L23.212|
00002a  68e0              LDR      r0,[r4,#0xc]
00002c  6809              LDR      r1,[r1,#0]  ; tcp_tmp_pcb
00002e  60c8              STR      r0,[r1,#0xc]
000030  e008              B        |L23.68|
                  |L23.50|
000032  4828              LDR      r0,|L23.212|
000034  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000036  68c0              LDR      r0,[r0,#0xc]
000038  4926              LDR      r1,|L23.212|
00003a  6008              STR      r0,[r1,#0]  ; tcp_tmp_pcb
                  |L23.60|
00003c  4825              LDR      r0,|L23.212|
00003e  6800              LDR      r0,[r0,#0]  ; tcp_tmp_pcb
000040  2800              CMP      r0,#0
000042  d1ec              BNE      |L23.30|
                  |L23.68|
000044  bf00              NOP      
                  |L23.70|
000046  2000              MOVS     r0,#0
000048  60e0              STR      r0,[r4,#0xc]
00004a  bf00              NOP      
;;;1541   
;;;1542     tcp_pcb_purge(pcb);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       tcp_pcb_purge
;;;1543     
;;;1544     /* if there is an outstanding delayed ACKs, send it */
;;;1545     if (pcb->state != TIME_WAIT &&
000052  7e20              LDRB     r0,[r4,#0x18]
000054  280a              CMP      r0,#0xa
000056  d00d              BEQ      |L23.116|
;;;1546        pcb->state != LISTEN &&
000058  7e20              LDRB     r0,[r4,#0x18]
00005a  2801              CMP      r0,#1
00005c  d00a              BEQ      |L23.116|
;;;1547        pcb->flags & TF_ACK_DELAY) {
00005e  7fa0              LDRB     r0,[r4,#0x1e]
000060  f0000001          AND      r0,r0,#1
000064  b130              CBZ      r0,|L23.116|
;;;1548       pcb->flags |= TF_ACK_NOW;
000066  7fa0              LDRB     r0,[r4,#0x1e]
000068  f0400002          ORR      r0,r0,#2
00006c  77a0              STRB     r0,[r4,#0x1e]
;;;1549       tcp_output(pcb);
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       tcp_output
                  |L23.116|
;;;1550     }
;;;1551   
;;;1552     if (pcb->state != LISTEN) {
000074  7e20              LDRB     r0,[r4,#0x18]
000076  2801              CMP      r0,#1
000078  d026              BEQ      |L23.200|
;;;1553       LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
00007a  bf00              NOP      
00007c  6ee0              LDR      r0,[r4,#0x6c]
00007e  b140              CBZ      r0,|L23.146|
000080  bf00              NOP      
000082  a315              ADR      r3,|L23.216|
000084  f2406211          MOV      r2,#0x611
000088  a11c              ADR      r1,|L23.252|
00008a  a022              ADR      r0,|L23.276|
00008c  f7fffffe          BL       __2printf
000090  bf00              NOP      
                  |L23.146|
000092  bf00              NOP      
;;;1554       LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
000094  bf00              NOP      
000096  6f20              LDR      r0,[r4,#0x70]
000098  b140              CBZ      r0,|L23.172|
00009a  bf00              NOP      
00009c  a30e              ADR      r3,|L23.216|
00009e  f2406212          MOV      r2,#0x612
0000a2  a127              ADR      r1,|L23.320|
0000a4  a01b              ADR      r0,|L23.276|
0000a6  f7fffffe          BL       __2printf
0000aa  bf00              NOP      
                  |L23.172|
0000ac  bf00              NOP      
;;;1555   #if TCP_QUEUE_OOSEQ
;;;1556       LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
0000ae  bf00              NOP      
0000b0  6f60              LDR      r0,[r4,#0x74]
0000b2  b140              CBZ      r0,|L23.198|
0000b4  bf00              NOP      
0000b6  a308              ADR      r3,|L23.216|
0000b8  f2406214          MOV      r2,#0x614
0000bc  a127              ADR      r1,|L23.348|
0000be  a015              ADR      r0,|L23.276|
0000c0  f7fffffe          BL       __2printf
0000c4  bf00              NOP      
                  |L23.198|
0000c6  bf00              NOP      
                  |L23.200|
;;;1557   #endif /* TCP_QUEUE_OOSEQ */
;;;1558     }
;;;1559   
;;;1560     pcb->state = CLOSED;
0000c8  2000              MOVS     r0,#0
0000ca  7620              STRB     r0,[r4,#0x18]
;;;1561   
;;;1562     LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
0000cc  bf00              NOP      
0000ce  bf00              NOP      
;;;1563   }
0000d0  bd70              POP      {r4-r6,pc}
;;;1564   
                          ENDP

0000d2  0000              DCW      0x0000
                  |L23.212|
                          DCD      tcp_tmp_pcb
                  |L23.216|
0000d8  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp.c",0
0000dc  5749505c
0000e0  6c776970
0000e4  2d312e34
0000e8  2e315c73
0000ec  72635c63
0000f0  6f72655c
0000f4  7463702e
0000f8  6300    
0000fa  00                DCB      0
0000fb  00                DCB      0
                  |L23.252|
0000fc  756e7365          DCB      "unsent segments leaking",0
000100  6e742073
000104  65676d65
000108  6e747320
00010c  6c65616b
000110  696e6700
                  |L23.276|
000114  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000118  7274696f
00011c  6e202225
000120  73222066
000124  61696c65
000128  64206174
00012c  206c696e
000130  65202564
000134  20696e20
000138  25730d0a
00013c  00      
00013d  00                DCB      0
00013e  00                DCB      0
00013f  00                DCB      0
                  |L23.320|
000140  756e6163          DCB      "unacked segments leaking",0
000144  6b656420
000148  7365676d
00014c  656e7473
000150  206c6561
000154  6b696e67
000158  00      
000159  00                DCB      0
00015a  00                DCB      0
00015b  00                DCB      0
                  |L23.348|
00015c  6f6f7365          DCB      "ooseq segments leaking",0
000160  71207365
000164  676d656e
000168  7473206c
00016c  65616b69
000170  6e6700  
000173  00                DCB      0

                          AREA ||i.tcp_poll||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_poll PROC
;;;1451   void
;;;1452   tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
000000  b570              PUSH     {r4-r6,lr}
;;;1453   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;1454     LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
000008  bf00              NOP      
00000a  7e20              LDRB     r0,[r4,#0x18]
00000c  2801              CMP      r0,#1
00000e  d108              BNE      |L24.34|
000010  bf00              NOP      
000012  a307              ADR      r3,|L24.48|
000014  f24052ae          MOV      r2,#0x5ae
000018  a10e              ADR      r1,|L24.84|
00001a  a016              ADR      r0,|L24.116|
00001c  f7fffffe          BL       __2printf
000020  bf00              NOP      
                  |L24.34|
000022  bf00              NOP      
;;;1455   #if LWIP_CALLBACK_API
;;;1456     pcb->poll = poll;
000024  f8c46088          STR      r6,[r4,#0x88]
;;;1457   #else /* LWIP_CALLBACK_API */  
;;;1458     LWIP_UNUSED_ARG(poll);
;;;1459   #endif /* LWIP_CALLBACK_API */  
;;;1460     pcb->pollinterval = interval;
000028  f8845020          STRB     r5,[r4,#0x20]
;;;1461   }
00002c  bd70              POP      {r4-r6,pc}
;;;1462   
                          ENDP

00002e  0000              DCW      0x0000
                  |L24.48|
000030  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp.c",0
000034  5749505c
000038  6c776970
00003c  2d312e34
000040  2e315c73
000044  72635c63
000048  6f72655c
00004c  7463702e
000050  6300    
000052  00                DCB      0
000053  00                DCB      0
                  |L24.84|
000054  696e7661          DCB      "invalid socket state for poll",0
000058  6c696420
00005c  736f636b
000060  65742073
000064  74617465
000068  20666f72
00006c  20706f6c
000070  6c00    
000072  00                DCB      0
000073  00                DCB      0
                  |L24.116|
000074  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000078  7274696f
00007c  6e202225
000080  73222066
000084  61696c65
000088  64206174
00008c  206c696e
000090  65202564
000094  20696e20
000098  25730d0a
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0

                          AREA ||i.tcp_process_refused_data||, CODE, READONLY, ALIGN=1

                  tcp_process_refused_data PROC
;;;1084   err_t
;;;1085   tcp_process_refused_data(struct tcp_pcb *pcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1086   {
000004  4604              MOV      r4,r0
;;;1087     err_t err;
;;;1088     u8_t refused_flags = pcb->refused_data->flags;
000006  6fa0              LDR      r0,[r4,#0x78]
000008  7b47              LDRB     r7,[r0,#0xd]
;;;1089     /* set pcb->refused_data to NULL in case the callback frees it and then
;;;1090        closes the pcb */
;;;1091     struct pbuf *refused_data = pcb->refused_data;
00000a  6fa6              LDR      r6,[r4,#0x78]
;;;1092     pcb->refused_data = NULL;
00000c  2000              MOVS     r0,#0
00000e  67a0              STR      r0,[r4,#0x78]
;;;1093     /* Notify again application with data previously received. */
;;;1094     LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
000010  bf00              NOP      
000012  bf00              NOP      
;;;1095     TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
000014  bf00              NOP      
000016  f8d40080          LDR      r0,[r4,#0x80]
00001a  b140              CBZ      r0,|L25.46|
00001c  2300              MOVS     r3,#0
00001e  4632              MOV      r2,r6
000020  4621              MOV      r1,r4
000022  f8d4c080          LDR      r12,[r4,#0x80]
000026  6920              LDR      r0,[r4,#0x10]
000028  47e0              BLX      r12
00002a  4605              MOV      r5,r0
00002c  e006              B        |L25.60|
                  |L25.46|
00002e  2300              MOVS     r3,#0
000030  4632              MOV      r2,r6
000032  4621              MOV      r1,r4
000034  4618              MOV      r0,r3
000036  f7fffffe          BL       tcp_recv_null
00003a  4605              MOV      r5,r0
                  |L25.60|
00003c  bf00              NOP      
;;;1096     if (err == ERR_OK) {
00003e  bb05              CBNZ     r5,|L25.130|
;;;1097       /* did refused_data include a FIN? */
;;;1098       if (refused_flags & PBUF_FLAG_TCP_FIN) {
000040  f0070020          AND      r0,r7,#0x20
000044  b330              CBZ      r0,|L25.148|
;;;1099         /* correct rcv_wnd as the application won't call tcp_recved()
;;;1100            for the FIN's seqno */
;;;1101         if (pcb->rcv_wnd != TCP_WND) {
000046  8da0              LDRH     r0,[r4,#0x2c]
000048  f6403168          MOV      r1,#0xb68
00004c  4288              CMP      r0,r1
00004e  d002              BEQ      |L25.86|
;;;1102           pcb->rcv_wnd++;
000050  8da0              LDRH     r0,[r4,#0x2c]
000052  1c40              ADDS     r0,r0,#1
000054  85a0              STRH     r0,[r4,#0x2c]
                  |L25.86|
;;;1103         }
;;;1104         TCP_EVENT_CLOSED(pcb, err);
000056  bf00              NOP      
000058  f8d40080          LDR      r0,[r4,#0x80]
00005c  b140              CBZ      r0,|L25.112|
00005e  2300              MOVS     r3,#0
000060  461a              MOV      r2,r3
000062  4621              MOV      r1,r4
000064  f8d4c080          LDR      r12,[r4,#0x80]
000068  6920              LDR      r0,[r4,#0x10]
00006a  47e0              BLX      r12
00006c  4605              MOV      r5,r0
00006e  e000              B        |L25.114|
                  |L25.112|
000070  2500              MOVS     r5,#0
                  |L25.114|
000072  bf00              NOP      
;;;1105         if (err == ERR_ABRT) {
000074  f105000a          ADD      r0,r5,#0xa
000078  b960              CBNZ     r0,|L25.148|
;;;1106           return ERR_ABRT;
00007a  f06f0009          MVN      r0,#9
                  |L25.126|
;;;1107         }
;;;1108       }
;;;1109     } else if (err == ERR_ABRT) {
;;;1110       /* if err == ERR_ABRT, 'pcb' is already deallocated */
;;;1111       /* Drop incoming packets because pcb is "full" (only if the incoming
;;;1112          segment contains data). */
;;;1113       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
;;;1114       return ERR_ABRT;
;;;1115     } else {
;;;1116       /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
;;;1117       pcb->refused_data = refused_data;
;;;1118     }
;;;1119     return ERR_OK;
;;;1120   }
00007e  e8bd81f0          POP      {r4-r8,pc}
                  |L25.130|
000082  f105000a          ADD      r0,r5,#0xa            ;1109
000086  b920              CBNZ     r0,|L25.146|
000088  bf00              NOP                            ;1113
00008a  bf00              NOP                            ;1113
00008c  f06f0009          MVN      r0,#9                 ;1114
000090  e7f5              B        |L25.126|
                  |L25.146|
000092  67a6              STR      r6,[r4,#0x78]         ;1117
                  |L25.148|
000094  2000              MOVS     r0,#0                 ;1119
000096  e7f2              B        |L25.126|
;;;1121   
                          ENDP


                          AREA ||i.tcp_recv||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_recv PROC
;;;1391   void
;;;1392   tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
000000  b570              PUSH     {r4-r6,lr}
;;;1393   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1394     LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
000006  bf00              NOP      
000008  7e20              LDRB     r0,[r4,#0x18]
00000a  2801              CMP      r0,#1
00000c  d108              BNE      |L26.32|
00000e  bf00              NOP      
000010  a305              ADR      r3,|L26.40|
000012  f2405272          MOV      r2,#0x572
000016  a10d              ADR      r1,|L26.76|
000018  a016              ADR      r0,|L26.116|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
                  |L26.32|
000020  bf00              NOP      
;;;1395     pcb->recv = recv;
000022  f8c45080          STR      r5,[r4,#0x80]
;;;1396   }
000026  bd70              POP      {r4-r6,pc}
;;;1397   
                          ENDP

                  |L26.40|
000028  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp.c",0
00002c  5749505c
000030  6c776970
000034  2d312e34
000038  2e315c73
00003c  72635c63
000040  6f72655c
000044  7463702e
000048  6300    
00004a  00                DCB      0
00004b  00                DCB      0
                  |L26.76|
00004c  696e7661          DCB      "invalid socket state for recv callback",0
000050  6c696420
000054  736f636b
000058  65742073
00005c  74617465
000060  20666f72
000064  20726563
000068  76206361
00006c  6c6c6261
000070  636b00  
000073  00                DCB      0
                  |L26.116|
000074  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000078  7274696f
00007c  6e202225
000080  73222066
000084  61696c65
000088  64206174
00008c  206c696e
000090  65202564
000094  20696e20
000098  25730d0a
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0

                          AREA ||i.tcp_recv_null||, CODE, READONLY, ALIGN=1

                  tcp_recv_null PROC
;;;1196   err_t
;;;1197   tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1198   {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  461e              MOV      r6,r3
;;;1199     LWIP_UNUSED_ARG(arg);
;;;1200     if (p != NULL) {
00000c  b13c              CBZ      r4,|L27.30|
;;;1201       tcp_recved(pcb, p->tot_len);
00000e  8921              LDRH     r1,[r4,#8]
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       tcp_recved
;;;1202       pbuf_free(p);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       pbuf_free
00001c  e005              B        |L27.42|
                  |L27.30|
;;;1203     } else if (err == ERR_OK) {
00001e  b926              CBNZ     r6,|L27.42|
;;;1204       return tcp_close(pcb);
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       tcp_close
                  |L27.38|
;;;1205     }
;;;1206     return ERR_OK;
;;;1207   }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L27.42|
00002a  2000              MOVS     r0,#0                 ;1206
00002c  e7fb              B        |L27.38|
;;;1208   #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_recved||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_recved PROC
;;;610    void
;;;611    tcp_recved(struct tcp_pcb *pcb, u16_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;612    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;613      int wnd_inflation;
;;;614    
;;;615      /* pcb->state LISTEN not allowed here */
;;;616      LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
000006  bf00              NOP      
000008  7e20              LDRB     r0,[r4,#0x18]
00000a  2801              CMP      r0,#1
00000c  d108              BNE      |L28.32|
00000e  bf00              NOP      
000010  a31b              ADR      r3,|L28.128|
000012  f44f721a          MOV      r2,#0x268
000016  a123              ADR      r1,|L28.164|
000018  a02c              ADR      r0,|L28.204|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
                  |L28.32|
000020  bf00              NOP      
;;;617        pcb->state != LISTEN);
;;;618      LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
000022  bf00              NOP      
000024  8da0              LDRH     r0,[r4,#0x2c]
000026  f64f71ff          MOV      r1,#0xffff
00002a  1a08              SUBS     r0,r1,r0
00002c  42a8              CMP      r0,r5
00002e  da08              BGE      |L28.66|
000030  bf00              NOP      
000032  a313              ADR      r3,|L28.128|
000034  f240226a          MOV      r2,#0x26a
000038  a12f              ADR      r1,|L28.248|
00003a  a024              ADR      r0,|L28.204|
00003c  f7fffffe          BL       __2printf
000040  bf00              NOP      
                  |L28.66|
000042  bf00              NOP      
;;;619                  len <= 0xffff - pcb->rcv_wnd );
;;;620    
;;;621      pcb->rcv_wnd += len;
000044  8da0              LDRH     r0,[r4,#0x2c]
000046  4428              ADD      r0,r0,r5
000048  85a0              STRH     r0,[r4,#0x2c]
;;;622      if (pcb->rcv_wnd > TCP_WND) {
00004a  8da0              LDRH     r0,[r4,#0x2c]
00004c  f6403168          MOV      r1,#0xb68
000050  4288              CMP      r0,r1
000052  dd01              BLE      |L28.88|
;;;623        pcb->rcv_wnd = TCP_WND;
000054  4608              MOV      r0,r1
000056  85a0              STRH     r0,[r4,#0x2c]
                  |L28.88|
;;;624      }
;;;625    
;;;626      wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       tcp_update_rcv_ann_wnd
00005e  4606              MOV      r6,r0
;;;627    
;;;628      /* If the change in the right edge of window is significant (default
;;;629       * watermark is TCP_WND/4), then send an explicit update now.
;;;630       * Otherwise wait for a packet to be sent in the normal course of
;;;631       * events (or more window to be available later) */
;;;632      if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
000060  f24020da          MOV      r0,#0x2da
000064  4286              CMP      r6,r0
000066  db08              BLT      |L28.122|
;;;633        tcp_ack_now(pcb);
000068  bf00              NOP      
00006a  7fa0              LDRB     r0,[r4,#0x1e]
00006c  f0400002          ORR      r0,r0,#2
000070  77a0              STRB     r0,[r4,#0x1e]
000072  bf00              NOP      
;;;634        tcp_output(pcb);
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       tcp_output
                  |L28.122|
;;;635      }
;;;636    
;;;637      LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
00007a  bf00              NOP      
00007c  bf00              NOP      
;;;638             len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
;;;639    }
00007e  bd70              POP      {r4-r6,pc}
;;;640    
                          ENDP

                  |L28.128|
000080  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp.c",0
000084  5749505c
000088  6c776970
00008c  2d312e34
000090  2e315c73
000094  72635c63
000098  6f72655c
00009c  7463702e
0000a0  6300    
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L28.164|
0000a4  646f6e27          DCB      "don't call tcp_recved for listen-pcbs",0
0000a8  74206361
0000ac  6c6c2074
0000b0  63705f72
0000b4  65637665
0000b8  6420666f
0000bc  72206c69
0000c0  7374656e
0000c4  2d706362
0000c8  7300    
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L28.204|
0000cc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000d0  7274696f
0000d4  6e202225
0000d8  73222066
0000dc  61696c65
0000e0  64206174
0000e4  206c696e
0000e8  65202564
0000ec  20696e20
0000f0  25730d0a
0000f4  00      
0000f5  00                DCB      0
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L28.248|
0000f8  7463705f          DCB      "tcp_recved: len would wrap rcv_wnd\n",0
0000fc  72656376
000100  65643a20
000104  6c656e20
000108  776f756c
00010c  64207772
000110  61702072
000114  63765f77
000118  6e640a00

                          AREA ||i.tcp_seg_copy||, CODE, READONLY, ALIGN=1

                  tcp_seg_copy PROC
;;;1176   struct tcp_seg *
;;;1177   tcp_seg_copy(struct tcp_seg *seg)
000000  b570              PUSH     {r4-r6,lr}
;;;1178   {
000002  4605              MOV      r5,r0
;;;1179     struct tcp_seg *cseg;
;;;1180   
;;;1181     cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       memp_malloc
00000a  4604              MOV      r4,r0
;;;1182     if (cseg == NULL) {
00000c  b90c              CBNZ     r4,|L29.18|
;;;1183       return NULL;
00000e  2000              MOVS     r0,#0
                  |L29.16|
;;;1184     }
;;;1185     SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
;;;1186     pbuf_ref(cseg->p);
;;;1187     return cseg;
;;;1188   }
000010  bd70              POP      {r4-r6,pc}
                  |L29.18|
000012  2214              MOVS     r2,#0x14              ;1185
000014  4629              MOV      r1,r5                 ;1185
000016  4620              MOV      r0,r4                 ;1185
000018  f7fffffe          BL       __aeabi_memcpy4
00001c  6860              LDR      r0,[r4,#4]            ;1186
00001e  f7fffffe          BL       pbuf_ref
000022  4620              MOV      r0,r4                 ;1187
000024  e7f4              B        |L29.16|
;;;1189   #endif /* TCP_QUEUE_OOSEQ */
                          ENDP


                          AREA ||i.tcp_seg_free||, CODE, READONLY, ALIGN=1

                  tcp_seg_free PROC
;;;1142   void
;;;1143   tcp_seg_free(struct tcp_seg *seg)
000000  b510              PUSH     {r4,lr}
;;;1144   {
000002  4604              MOV      r4,r0
;;;1145     if (seg != NULL) {
000004  b144              CBZ      r4,|L30.24|
;;;1146       if (seg->p != NULL) {
000006  6860              LDR      r0,[r4,#4]
000008  b110              CBZ      r0,|L30.16|
;;;1147         pbuf_free(seg->p);
00000a  6860              LDR      r0,[r4,#4]
00000c  f7fffffe          BL       pbuf_free
                  |L30.16|
;;;1148   #if TCP_DEBUG
;;;1149         seg->p = NULL;
;;;1150   #endif /* TCP_DEBUG */
;;;1151       }
;;;1152       memp_free(MEMP_TCP_SEG, seg);
000010  4621              MOV      r1,r4
000012  2004              MOVS     r0,#4
000014  f7fffffe          BL       memp_free
                  |L30.24|
;;;1153     }
;;;1154   }
000018  bd10              POP      {r4,pc}
;;;1155   
                          ENDP


                          AREA ||i.tcp_segs_free||, CODE, READONLY, ALIGN=1

                  tcp_segs_free PROC
;;;1127   void
;;;1128   tcp_segs_free(struct tcp_seg *seg)
000000  b570              PUSH     {r4-r6,lr}
;;;1129   {
000002  4604              MOV      r4,r0
;;;1130     while (seg != NULL) {
000004  e005              B        |L31.18|
                  |L31.6|
;;;1131       struct tcp_seg *next = seg->next;
000006  6825              LDR      r5,[r4,#0]
;;;1132       tcp_seg_free(seg);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       tcp_seg_free
;;;1133       seg = next;
00000e  462c              MOV      r4,r5
;;;1134     }
000010  bf00              NOP      
                  |L31.18|
000012  2c00              CMP      r4,#0                 ;1130
000014  d1f7              BNE      |L31.6|
;;;1135   }
000016  bd70              POP      {r4-r6,pc}
;;;1136   
                          ENDP


                          AREA ||i.tcp_sent||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_sent PROC
;;;1405   void
;;;1406   tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
000000  b570              PUSH     {r4-r6,lr}
;;;1407   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1408     LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
000006  bf00              NOP      
000008  7e20              LDRB     r0,[r4,#0x18]
00000a  2801              CMP      r0,#1
00000c  d108              BNE      |L32.32|
00000e  bf00              NOP      
000010  a305              ADR      r3,|L32.40|
000012  f44f62b0          MOV      r2,#0x580
000016  a10d              ADR      r1,|L32.76|
000018  a016              ADR      r0,|L32.116|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
                  |L32.32|
000020  bf00              NOP      
;;;1409     pcb->sent = sent;
000022  67e5              STR      r5,[r4,#0x7c]
;;;1410   }
000024  bd70              POP      {r4-r6,pc}
;;;1411   
                          ENDP

000026  0000              DCW      0x0000
                  |L32.40|
000028  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp.c",0
00002c  5749505c
000030  6c776970
000034  2d312e34
000038  2e315c73
00003c  72635c63
000040  6f72655c
000044  7463702e
000048  6300    
00004a  00                DCB      0
00004b  00                DCB      0
                  |L32.76|
00004c  696e7661          DCB      "invalid socket state for sent callback",0
000050  6c696420
000054  736f636b
000058  65742073
00005c  74617465
000060  20666f72
000064  2073656e
000068  74206361
00006c  6c6c6261
000070  636b00  
000073  00                DCB      0
                  |L32.116|
000074  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000078  7274696f
00007c  6e202225
000080  73222066
000084  61696c65
000088  64206174
00008c  206c696e
000090  65202564
000094  20696e20
000098  25730d0a
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0

                          AREA ||i.tcp_setprio||, CODE, READONLY, ALIGN=1

                  tcp_setprio PROC
;;;1162   void
;;;1163   tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
000000  7641              STRB     r1,[r0,#0x19]
;;;1164   {
;;;1165     pcb->prio = prio;
;;;1166   }
000002  4770              BX       lr
;;;1167   
                          ENDP


                          AREA ||i.tcp_shutdown||, CODE, READONLY, ALIGN=1

                  tcp_shutdown PROC
;;;312    err_t
;;;313    tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
000000  b570              PUSH     {r4-r6,lr}
;;;314    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;315      if (pcb->state == LISTEN) {
000008  7e20              LDRB     r0,[r4,#0x18]
00000a  2801              CMP      r0,#1
00000c  d102              BNE      |L34.20|
;;;316        return ERR_CONN;
00000e  f06f000c          MVN      r0,#0xc
                  |L34.18|
;;;317      }
;;;318      if (shut_rx) {
;;;319        /* shut down the receive side: set a flag not to receive any more data... */
;;;320        pcb->flags |= TF_RXCLOSED;
;;;321        if (shut_tx) {
;;;322          /* shutting down the tx AND rx side is the same as closing for the raw API */
;;;323          return tcp_close_shutdown(pcb, 1);
;;;324        }
;;;325        /* ... and free buffered data */
;;;326        if (pcb->refused_data != NULL) {
;;;327          pbuf_free(pcb->refused_data);
;;;328          pcb->refused_data = NULL;
;;;329        }
;;;330      }
;;;331      if (shut_tx) {
;;;332        /* This can't happen twice since if it succeeds, the pcb's state is changed.
;;;333           Only close in these states as the others directly deallocate the PCB */
;;;334        switch (pcb->state) {
;;;335        case SYN_RCVD:
;;;336        case ESTABLISHED:
;;;337        case CLOSE_WAIT:
;;;338          return tcp_close_shutdown(pcb, shut_rx);
;;;339        default:
;;;340          /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
;;;341            into CLOSED state, where the PCB is deallocated. */
;;;342          return ERR_CONN;
;;;343        }
;;;344      }
;;;345      return ERR_OK;
;;;346    }
000012  bd70              POP      {r4-r6,pc}
                  |L34.20|
000014  b185              CBZ      r5,|L34.56|
000016  7fa0              LDRB     r0,[r4,#0x1e]         ;320
000018  f0400010          ORR      r0,r0,#0x10           ;320
00001c  77a0              STRB     r0,[r4,#0x1e]         ;320
00001e  b126              CBZ      r6,|L34.42|
000020  2101              MOVS     r1,#1                 ;323
000022  4620              MOV      r0,r4                 ;323
000024  f7fffffe          BL       tcp_close_shutdown
000028  e7f3              B        |L34.18|
                  |L34.42|
00002a  6fa0              LDR      r0,[r4,#0x78]         ;326
00002c  b120              CBZ      r0,|L34.56|
00002e  6fa0              LDR      r0,[r4,#0x78]         ;327
000030  f7fffffe          BL       pbuf_free
000034  2000              MOVS     r0,#0                 ;328
000036  67a0              STR      r0,[r4,#0x78]         ;328
                  |L34.56|
000038  b18e              CBZ      r6,|L34.94|
00003a  7e20              LDRB     r0,[r4,#0x18]         ;334
00003c  2803              CMP      r0,#3                 ;334
00003e  d004              BEQ      |L34.74|
000040  2804              CMP      r0,#4                 ;334
000042  d003              BEQ      |L34.76|
000044  2807              CMP      r0,#7                 ;334
000046  d107              BNE      |L34.88|
000048  e001              B        |L34.78|
                  |L34.74|
00004a  bf00              NOP                            ;336
                  |L34.76|
00004c  bf00              NOP                            ;337
                  |L34.78|
00004e  b2e9              UXTB     r1,r5                 ;338
000050  4620              MOV      r0,r4                 ;338
000052  f7fffffe          BL       tcp_close_shutdown
000056  e7dc              B        |L34.18|
                  |L34.88|
000058  f06f000c          MVN      r0,#0xc               ;342
00005c  e7d9              B        |L34.18|
                  |L34.94|
00005e  2000              MOVS     r0,#0                 ;345
000060  e7d7              B        |L34.18|
;;;347    
                          ENDP


                          AREA ||i.tcp_slowtmr||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_slowtmr PROC
;;;787    void
;;;788    tcp_slowtmr(void)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;789    {
;;;790      struct tcp_pcb *pcb, *prev;
;;;791      u16_t eff_wnd;
;;;792      u8_t pcb_remove;      /* flag if a PCB should be removed */
;;;793      u8_t pcb_reset;       /* flag if a RST should be sent when removing */
;;;794      err_t err;
;;;795    
;;;796      err = ERR_OK;
000004  2000              MOVS     r0,#0
000006  9002              STR      r0,[sp,#8]
;;;797    
;;;798      ++tcp_ticks;
000008  48e7              LDR      r0,|L35.936|
00000a  6800              LDR      r0,[r0,#0]  ; tcp_ticks
00000c  1c40              ADDS     r0,r0,#1
00000e  49e6              LDR      r1,|L35.936|
000010  6008              STR      r0,[r1,#0]  ; tcp_ticks
;;;799      ++tcp_timer_ctr;
000012  48e6              LDR      r0,|L35.940|
000014  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
000016  1c40              ADDS     r0,r0,#1
000018  49e4              LDR      r1,|L35.940|
00001a  7008              STRB     r0,[r1,#0]
;;;800    
;;;801    tcp_slowtmr_start:
00001c  bf00              NOP      
                  |L35.30|
;;;802      /* Steps through all of the active PCBs. */
;;;803      prev = NULL;
00001e  2500              MOVS     r5,#0
;;;804      pcb = tcp_active_pcbs;
000020  48e3              LDR      r0,|L35.944|
000022  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
;;;805      if (pcb == NULL) {
000024  b90c              CBNZ     r4,|L35.42|
;;;806        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
000026  bf00              NOP      
000028  bf00              NOP      
                  |L35.42|
;;;807      }
;;;808      while (pcb != NULL) {
00002a  e1ac              B        |L35.902|
                  |L35.44|
;;;809        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
00002c  bf00              NOP      
00002e  bf00              NOP      
;;;810        LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
000030  bf00              NOP      
000032  7e20              LDRB     r0,[r4,#0x18]
000034  2800              CMP      r0,#0
000036  d108              BNE      |L35.74|
000038  bf00              NOP      
00003a  a3de              ADR      r3,|L35.948|
00003c  f240322a          MOV      r2,#0x32a
000040  a1e5              ADR      r1,|L35.984|
000042  a0f0              ADR      r0,|L35.1028|
000044  f7fffffe          BL       __2printf
000048  bf00              NOP      
                  |L35.74|
00004a  bf00              NOP      
;;;811        LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
00004c  bf00              NOP      
00004e  7e20              LDRB     r0,[r4,#0x18]
000050  2801              CMP      r0,#1
000052  d108              BNE      |L35.102|
000054  bf00              NOP      
000056  a3d7              ADR      r3,|L35.948|
000058  f240322b          MOV      r2,#0x32b
00005c  a1f4              ADR      r1,|L35.1072|
00005e  a0e9              ADR      r0,|L35.1028|
000060  f7fffffe          BL       __2printf
000064  bf00              NOP      
                  |L35.102|
000066  bf00              NOP      
;;;812        LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
000068  bf00              NOP      
00006a  7e20              LDRB     r0,[r4,#0x18]
00006c  280a              CMP      r0,#0xa
00006e  d108              BNE      |L35.130|
000070  bf00              NOP      
000072  a3d0              ADR      r3,|L35.948|
000074  f44f724b          MOV      r2,#0x32c
000078  a1f8              ADR      r1,|L35.1116|
00007a  a0e2              ADR      r0,|L35.1028|
00007c  f7fffffe          BL       __2printf
000080  bf00              NOP      
                  |L35.130|
000082  bf00              NOP      
;;;813        if (pcb->last_timer == tcp_timer_ctr) {
000084  f8940021          LDRB     r0,[r4,#0x21]
000088  49c8              LDR      r1,|L35.940|
00008a  7809              LDRB     r1,[r1,#0]  ; tcp_timer_ctr
00008c  4288              CMP      r0,r1
00008e  d101              BNE      |L35.148|
;;;814          /* skip this pcb, we have already processed it */
;;;815          pcb = pcb->next;
000090  68e4              LDR      r4,[r4,#0xc]
;;;816          continue;
000092  e178              B        |L35.902|
                  |L35.148|
;;;817        }
;;;818        pcb->last_timer = tcp_timer_ctr;
000094  48c5              LDR      r0,|L35.940|
000096  7800              LDRB     r0,[r0,#0]  ; tcp_timer_ctr
000098  f8840021          STRB     r0,[r4,#0x21]
;;;819    
;;;820        pcb_remove = 0;
00009c  2600              MOVS     r6,#0
;;;821        pcb_reset = 0;
00009e  46b1              MOV      r9,r6
;;;822    
;;;823        if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
0000a0  7e20              LDRB     r0,[r4,#0x18]
0000a2  2802              CMP      r0,#2
0000a4  d107              BNE      |L35.182|
0000a6  f8940046          LDRB     r0,[r4,#0x46]
0000aa  2806              CMP      r0,#6
0000ac  d103              BNE      |L35.182|
;;;824          ++pcb_remove;
0000ae  1c70              ADDS     r0,r6,#1
0000b0  b2c6              UXTB     r6,r0
;;;825          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
0000b2  bf00              NOP      
0000b4  e072              B        |L35.412|
                  |L35.182|
;;;826        }
;;;827        else if (pcb->nrtx == TCP_MAXRTX) {
0000b6  f8940046          LDRB     r0,[r4,#0x46]
0000ba  280c              CMP      r0,#0xc
0000bc  d103              BNE      |L35.198|
;;;828          ++pcb_remove;
0000be  1c70              ADDS     r0,r6,#1
0000c0  b2c6              UXTB     r6,r0
;;;829          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
0000c2  bf00              NOP      
0000c4  e06a              B        |L35.412|
                  |L35.198|
;;;830        } else {
;;;831          if (pcb->persist_backoff > 0) {
0000c6  f8940095          LDRB     r0,[r4,#0x95]
0000ca  2800              CMP      r0,#0
0000cc  dd1b              BLE      |L35.262|
;;;832            /* If snd_wnd is zero, use persist timer to send 1 byte probes
;;;833             * instead of using the standard retransmission mechanism. */
;;;834            pcb->persist_cnt++;
0000ce  f8140f94          LDRB     r0,[r4,#0x94]!
0000d2  1c40              ADDS     r0,r0,#1
0000d4  7020              STRB     r0,[r4,#0]
;;;835            if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
0000d6  7821              LDRB     r1,[r4,#0]
0000d8  7860              LDRB     r0,[r4,#1]
0000da  3c94              SUBS     r4,r4,#0x94
0000dc  1e40              SUBS     r0,r0,#1
0000de  4aeb              LDR      r2,|L35.1164|
0000e0  5c10              LDRB     r0,[r2,r0]
0000e2  4281              CMP      r1,r0
0000e4  db5a              BLT      |L35.412|
;;;836              pcb->persist_cnt = 0;
0000e6  2000              MOVS     r0,#0
0000e8  f8840094          STRB     r0,[r4,#0x94]
;;;837              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
0000ec  f8940095          LDRB     r0,[r4,#0x95]
0000f0  2807              CMP      r0,#7
0000f2  d204              BCS      |L35.254|
;;;838                pcb->persist_backoff++;
0000f4  f8940095          LDRB     r0,[r4,#0x95]
0000f8  1c40              ADDS     r0,r0,#1
0000fa  f8840095          STRB     r0,[r4,#0x95]
                  |L35.254|
;;;839              }
;;;840              tcp_zero_window_probe(pcb);
0000fe  4620              MOV      r0,r4
000100  f7fffffe          BL       tcp_zero_window_probe
000104  e04a              B        |L35.412|
                  |L35.262|
;;;841            }
;;;842          } else {
;;;843            /* Increase the retransmission timer if it is running */
;;;844            if(pcb->rtime >= 0) {
000106  f9b40034          LDRSH    r0,[r4,#0x34]
00010a  2800              CMP      r0,#0
00010c  db03              BLT      |L35.278|
;;;845              ++pcb->rtime;
00010e  8ea0              LDRH     r0,[r4,#0x34]
000110  1c40              ADDS     r0,r0,#1
000112  b200              SXTH     r0,r0
000114  86a0              STRH     r0,[r4,#0x34]
                  |L35.278|
;;;846            }
;;;847    
;;;848            if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
000116  6f20              LDR      r0,[r4,#0x70]
000118  b3e8              CBZ      r0,|L35.406|
00011a  f9b40034          LDRSH    r0,[r4,#0x34]
00011e  f9b41044          LDRSH    r1,[r4,#0x44]
000122  4288              CMP      r0,r1
000124  db3a              BLT      |L35.412|
;;;849              /* Time for a retransmission. */
;;;850              LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_slowtmr: rtime %"S16_F
000126  bf00              NOP      
000128  bf00              NOP      
;;;851                                          " pcb->rto %"S16_F"\n",
;;;852                                          pcb->rtime, pcb->rto));
;;;853    
;;;854              /* Double retransmission time-out unless we are trying to
;;;855               * connect to somebody (i.e., we are in SYN_SENT). */
;;;856              if (pcb->state != SYN_SENT) {
00012a  7e20              LDRB     r0,[r4,#0x18]
00012c  2802              CMP      r0,#2
00012e  d00c              BEQ      |L35.330|
;;;857                pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
000130  3440              ADDS     r4,r4,#0x40
000132  8860              LDRH     r0,[r4,#2]
000134  f9b41000          LDRSH    r1,[r4,#0]
000138  eb0000e1          ADD      r0,r0,r1,ASR #3
00013c  79a1              LDRB     r1,[r4,#6]
00013e  4ad4              LDR      r2,|L35.1168|
000140  5c51              LDRB     r1,[r2,r1]
000142  4088              LSLS     r0,r0,r1
000144  b200              SXTH     r0,r0
000146  80a0              STRH     r0,[r4,#4]
000148  3c40              SUBS     r4,r4,#0x40
                  |L35.330|
;;;858              }
;;;859    
;;;860              /* Reset the retransmission timer. */
;;;861              pcb->rtime = 0;
00014a  2000              MOVS     r0,#0
00014c  86a0              STRH     r0,[r4,#0x34]
;;;862    
;;;863              /* Reduce congestion window and ssthresh. */
;;;864              eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
00014e  f8b4004c          LDRH     r0,[r4,#0x4c]
000152  f8b41060          LDRH     r1,[r4,#0x60]
000156  4288              CMP      r0,r1
000158  da02              BGE      |L35.352|
00015a  f8b4004c          LDRH     r0,[r4,#0x4c]
00015e  e001              B        |L35.356|
                  |L35.352|
000160  f8b40060          LDRH     r0,[r4,#0x60]
                  |L35.356|
000164  4682              MOV      r10,r0
;;;865              pcb->ssthresh = eff_wnd >> 1;
000166  ea4f006a          ASR      r0,r10,#1
00016a  f8a4004e          STRH     r0,[r4,#0x4e]
;;;866              if (pcb->ssthresh < (pcb->mss << 1)) {
00016e  f8b4004e          LDRH     r0,[r4,#0x4e]
000172  8ee1              LDRH     r1,[r4,#0x36]
000174  ebb00f41          CMP      r0,r1,LSL #1
000178  da06              BGE      |L35.392|
;;;867                pcb->ssthresh = (pcb->mss << 1);
00017a  8ee0              LDRH     r0,[r4,#0x36]
00017c  f64f71ff          MOV      r1,#0xffff
000180  ea010040          AND      r0,r1,r0,LSL #1
000184  f8a4004e          STRH     r0,[r4,#0x4e]
                  |L35.392|
;;;868              }
;;;869              pcb->cwnd = pcb->mss;
000188  8ee0              LDRH     r0,[r4,#0x36]
00018a  f8a4004c          STRH     r0,[r4,#0x4c]
;;;870              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"U16_F
00018e  bf00              NOP      
000190  bf00              NOP      
;;;871                                           " ssthresh %"U16_F"\n",
;;;872                                           pcb->cwnd, pcb->ssthresh));
;;;873     
;;;874              /* The following needs to be called AFTER cwnd is set to one
;;;875                 mss - STJ */
;;;876              tcp_rexmit_rto(pcb);
000192  4620              MOV      r0,r4
000194  e000              B        |L35.408|
                  |L35.406|
000196  e001              B        |L35.412|
                  |L35.408|
000198  f7fffffe          BL       tcp_rexmit_rto
                  |L35.412|
;;;877            }
;;;878          }
;;;879        }
;;;880        /* Check if this PCB has stayed too long in FIN-WAIT-2 */
;;;881        if (pcb->state == FIN_WAIT_2) {
00019c  7e20              LDRB     r0,[r4,#0x18]
00019e  2806              CMP      r0,#6
0001a0  d10d              BNE      |L35.446|
;;;882          /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
;;;883          if (pcb->flags & TF_RXCLOSED) {
0001a2  7fa0              LDRB     r0,[r4,#0x1e]
0001a4  f0000010          AND      r0,r0,#0x10
0001a8  b148              CBZ      r0,|L35.446|
;;;884            /* PCB was fully closed (either through close() or SHUT_RDWR):
;;;885               normal FIN-WAIT timeout handling. */
;;;886            if ((u32_t)(tcp_ticks - pcb->tmr) >
0001aa  497f              LDR      r1,|L35.936|
0001ac  6a60              LDR      r0,[r4,#0x24]
0001ae  6809              LDR      r1,[r1,#0]  ; tcp_ticks
0001b0  1a08              SUBS     r0,r1,r0
0001b2  2828              CMP      r0,#0x28
0001b4  d903              BLS      |L35.446|
;;;887                TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;888              ++pcb_remove;
0001b6  1c70              ADDS     r0,r6,#1
0001b8  b2c6              UXTB     r6,r0
;;;889              LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
0001ba  bf00              NOP      
0001bc  bf00              NOP      
                  |L35.446|
;;;890            }
;;;891          }
;;;892        }
;;;893    
;;;894        /* Check if KEEPALIVE should be sent */
;;;895        if(ip_get_option(pcb, SOF_KEEPALIVE) &&
0001be  7a20              LDRB     r0,[r4,#8]
0001c0  f0000008          AND      r0,r0,#8
0001c4  b3b8              CBZ      r0,|L35.566|
;;;896           ((pcb->state == ESTABLISHED) ||
0001c6  7e20              LDRB     r0,[r4,#0x18]
0001c8  2804              CMP      r0,#4
0001ca  d002              BEQ      |L35.466|
;;;897            (pcb->state == CLOSE_WAIT))) {
0001cc  7e20              LDRB     r0,[r4,#0x18]
0001ce  2807              CMP      r0,#7
0001d0  d131              BNE      |L35.566|
                  |L35.466|
;;;898          if((u32_t)(tcp_ticks - pcb->tmr) >
0001d2  49b0              LDR      r1,|L35.1172|
0001d4  f8d40090          LDR      r0,[r4,#0x90]
0001d8  4408              ADD      r0,r0,r1
0001da  f44f71fa          MOV      r1,#0x1f4
0001de  fbb0f0f1          UDIV     r0,r0,r1
0001e2  4a71              LDR      r2,|L35.936|
0001e4  6a61              LDR      r1,[r4,#0x24]
0001e6  6812              LDR      r2,[r2,#0]  ; tcp_ticks
0001e8  1a51              SUBS     r1,r2,r1
0001ea  4288              CMP      r0,r1
0001ec  d208              BCS      |L35.512|
;;;899             (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
;;;900          {
;;;901            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
0001ee  bf00              NOP      
0001f0  bf00              NOP      
;;;902                                    ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;903                                    ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;904            
;;;905            ++pcb_remove;
0001f2  1c70              ADDS     r0,r6,#1
0001f4  b2c6              UXTB     r6,r0
;;;906            ++pcb_reset;
0001f6  f1090001          ADD      r0,r9,#1
0001fa  f00009ff          AND      r9,r0,#0xff
0001fe  e01a              B        |L35.566|
                  |L35.512|
;;;907          }
;;;908          else if((u32_t)(tcp_ticks - pcb->tmr) > 
000200  f8940096          LDRB     r0,[r4,#0x96]
000204  f242429f          MOV      r2,#0x249f
000208  4350              MULS     r0,r2,r0
00020a  f8d41090          LDR      r1,[r4,#0x90]
00020e  eb0100c0          ADD      r0,r1,r0,LSL #3
000212  f44f71fa          MOV      r1,#0x1f4
000216  fbb0f0f1          UDIV     r0,r0,r1
00021a  4a63              LDR      r2,|L35.936|
00021c  6a61              LDR      r1,[r4,#0x24]
00021e  6812              LDR      r2,[r2,#0]  ; tcp_ticks
000220  1a51              SUBS     r1,r2,r1
000222  4288              CMP      r0,r1
000224  d207              BCS      |L35.566|
;;;909                  (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
;;;910                  / TCP_SLOW_INTERVAL)
;;;911          {
;;;912            tcp_keepalive(pcb);
000226  4620              MOV      r0,r4
000228  f7fffffe          BL       tcp_keepalive
;;;913            pcb->keep_cnt_sent++;
00022c  f8940096          LDRB     r0,[r4,#0x96]
000230  1c40              ADDS     r0,r0,#1
000232  f8840096          STRB     r0,[r4,#0x96]
                  |L35.566|
;;;914          }
;;;915        }
;;;916    
;;;917        /* If this PCB has queued out of sequence data, but has been
;;;918           inactive for too long, will drop the data (it will eventually
;;;919           be retransmitted). */
;;;920    #if TCP_QUEUE_OOSEQ
;;;921        if (pcb->ooseq != NULL &&
000236  6f60              LDR      r0,[r4,#0x74]
000238  b188              CBZ      r0,|L35.606|
;;;922            (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
00023a  495b              LDR      r1,|L35.936|
00023c  6a60              LDR      r0,[r4,#0x24]
00023e  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000240  1a08              SUBS     r0,r1,r0
000242  f9b41044          LDRSH    r1,[r4,#0x44]
000246  eb010141          ADD      r1,r1,r1,LSL #1
00024a  ebb00f41          CMP      r0,r1,LSL #1
00024e  d306              BCC      |L35.606|
;;;923          tcp_segs_free(pcb->ooseq);
000250  6f60              LDR      r0,[r4,#0x74]
000252  f7fffffe          BL       tcp_segs_free
;;;924          pcb->ooseq = NULL;
000256  2000              MOVS     r0,#0
000258  6760              STR      r0,[r4,#0x74]
;;;925          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
00025a  bf00              NOP      
00025c  bf00              NOP      
                  |L35.606|
;;;926        }
;;;927    #endif /* TCP_QUEUE_OOSEQ */
;;;928    
;;;929        /* Check if this PCB has stayed too long in SYN-RCVD */
;;;930        if (pcb->state == SYN_RCVD) {
00025e  7e20              LDRB     r0,[r4,#0x18]
000260  2803              CMP      r0,#3
000262  d109              BNE      |L35.632|
;;;931          if ((u32_t)(tcp_ticks - pcb->tmr) >
000264  4950              LDR      r1,|L35.936|
000266  6a60              LDR      r0,[r4,#0x24]
000268  6809              LDR      r1,[r1,#0]  ; tcp_ticks
00026a  1a08              SUBS     r0,r1,r0
00026c  2828              CMP      r0,#0x28
00026e  d903              BLS      |L35.632|
;;;932              TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;933            ++pcb_remove;
000270  1c70              ADDS     r0,r6,#1
000272  b2c6              UXTB     r6,r0
;;;934            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
000274  bf00              NOP      
000276  bf00              NOP      
                  |L35.632|
;;;935          }
;;;936        }
;;;937    
;;;938        /* Check if this PCB has stayed too long in LAST-ACK */
;;;939        if (pcb->state == LAST_ACK) {
000278  7e20              LDRB     r0,[r4,#0x18]
00027a  2809              CMP      r0,#9
00027c  d109              BNE      |L35.658|
;;;940          if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
00027e  494a              LDR      r1,|L35.936|
000280  6a60              LDR      r0,[r4,#0x24]
000282  6809              LDR      r1,[r1,#0]  ; tcp_ticks
000284  1a08              SUBS     r0,r1,r0
000286  28f0              CMP      r0,#0xf0
000288  d903              BLS      |L35.658|
;;;941            ++pcb_remove;
00028a  1c70              ADDS     r0,r6,#1
00028c  b2c6              UXTB     r6,r0
;;;942            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
00028e  bf00              NOP      
000290  bf00              NOP      
                  |L35.658|
;;;943          }
;;;944        }
;;;945    
;;;946        /* If the PCB should be removed, do it. */
;;;947        if (pcb_remove) {
000292  2e00              CMP      r6,#0
000294  d04f              BEQ      |L35.822|
;;;948          struct tcp_pcb *pcb2;
;;;949          tcp_err_fn err_fn;
;;;950          void *err_arg;
;;;951          tcp_pcb_purge(pcb);
000296  4620              MOV      r0,r4
000298  f7fffffe          BL       tcp_pcb_purge
;;;952          /* Remove PCB from tcp_active_pcbs list. */
;;;953          if (prev != NULL) {
00029c  b18d              CBZ      r5,|L35.706|
;;;954            LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
00029e  bf00              NOP      
0002a0  4843              LDR      r0,|L35.944|
0002a2  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
0002a4  4284              CMP      r4,r0
0002a6  d108              BNE      |L35.698|
0002a8  bf00              NOP      
0002aa  a342              ADR      r3,|L35.948|
0002ac  f24032ba          MOV      r2,#0x3ba
0002b0  a179              ADR      r1,|L35.1176|
0002b2  a054              ADR      r0,|L35.1028|
0002b4  f7fffffe          BL       __2printf
0002b8  bf00              NOP      
                  |L35.698|
0002ba  bf00              NOP      
;;;955            prev->next = pcb->next;
0002bc  68e0              LDR      r0,[r4,#0xc]
0002be  60e8              STR      r0,[r5,#0xc]
0002c0  e011              B        |L35.742|
                  |L35.706|
;;;956          } else {
;;;957            /* This PCB was the first. */
;;;958            LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
0002c2  bf00              NOP      
0002c4  483a              LDR      r0,|L35.944|
0002c6  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
0002c8  42a0              CMP      r0,r4
0002ca  d008              BEQ      |L35.734|
0002cc  bf00              NOP      
0002ce  a339              ADR      r3,|L35.948|
0002d0  f24032be          MOV      r2,#0x3be
0002d4  a17b              ADR      r1,|L35.1220|
0002d6  a04b              ADR      r0,|L35.1028|
0002d8  f7fffffe          BL       __2printf
0002dc  bf00              NOP      
                  |L35.734|
0002de  bf00              NOP      
;;;959            tcp_active_pcbs = pcb->next;
0002e0  4933              LDR      r1,|L35.944|
0002e2  68e0              LDR      r0,[r4,#0xc]
0002e4  6008              STR      r0,[r1,#0]  ; tcp_active_pcbs
                  |L35.742|
;;;960          }
;;;961    
;;;962          if (pcb_reset) {
0002e6  f1b90f00          CMP      r9,#0
0002ea  d009              BEQ      |L35.768|
;;;963            tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
0002ec  8ba0              LDRH     r0,[r4,#0x1c]
0002ee  8b61              LDRH     r1,[r4,#0x1a]
0002f0  e9cd1000          STRD     r1,r0,[sp,#0]
0002f4  1d23              ADDS     r3,r4,#4
0002f6  4622              MOV      r2,r4
0002f8  6aa1              LDR      r1,[r4,#0x28]
0002fa  6d20              LDR      r0,[r4,#0x50]
0002fc  f7fffffe          BL       tcp_rst
                  |L35.768|
;;;964              pcb->local_port, pcb->remote_port);
;;;965          }
;;;966    
;;;967          err_fn = pcb->errf;
000300  f8d4808c          LDR      r8,[r4,#0x8c]
;;;968          err_arg = pcb->callback_arg;
000304  f8d4b010          LDR      r11,[r4,#0x10]
;;;969          pcb2 = pcb;
000308  4627              MOV      r7,r4
;;;970          pcb = pcb->next;
00030a  68e4              LDR      r4,[r4,#0xc]
;;;971          memp_free(MEMP_TCP_PCB, pcb2);
00030c  4639              MOV      r1,r7
00030e  2002              MOVS     r0,#2
000310  f7fffffe          BL       memp_free
;;;972    
;;;973          tcp_active_pcbs_changed = 0;
000314  2000              MOVS     r0,#0
000316  4976              LDR      r1,|L35.1264|
000318  7008              STRB     r0,[r1,#0]
;;;974          TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
00031a  bf00              NOP      
00031c  f1b80f00          CMP      r8,#0
000320  d003              BEQ      |L35.810|
000322  f06f0109          MVN      r1,#9
000326  4658              MOV      r0,r11
000328  47c0              BLX      r8
                  |L35.810|
00032a  bf00              NOP      
;;;975          if (tcp_active_pcbs_changed) {
00032c  4870              LDR      r0,|L35.1264|
00032e  7800              LDRB     r0,[r0,#0]  ; tcp_active_pcbs_changed
000330  b100              CBZ      r0,|L35.820|
;;;976            goto tcp_slowtmr_start;
000332  e674              B        |L35.30|
                  |L35.820|
;;;977          }
;;;978        } else {
000334  e026              B        |L35.900|
                  |L35.822|
;;;979          /* get the 'next' element now and work with 'prev' below (in case of abort) */
;;;980          prev = pcb;
000336  4625              MOV      r5,r4
;;;981          pcb = pcb->next;
000338  68e4              LDR      r4,[r4,#0xc]
;;;982    
;;;983          /* We check if we should poll the connection. */
;;;984          ++prev->polltmr;
00033a  7fe8              LDRB     r0,[r5,#0x1f]
00033c  1c40              ADDS     r0,r0,#1
00033e  77e8              STRB     r0,[r5,#0x1f]
;;;985          if (prev->polltmr >= prev->pollinterval) {
000340  7fe8              LDRB     r0,[r5,#0x1f]
000342  f8951020          LDRB     r1,[r5,#0x20]
000346  4288              CMP      r0,r1
000348  db1c              BLT      |L35.900|
;;;986            prev->polltmr = 0;
00034a  2000              MOVS     r0,#0
00034c  77e8              STRB     r0,[r5,#0x1f]
;;;987            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
00034e  bf00              NOP      
000350  bf00              NOP      
;;;988            tcp_active_pcbs_changed = 0;
000352  4967              LDR      r1,|L35.1264|
000354  7008              STRB     r0,[r1,#0]
;;;989            TCP_EVENT_POLL(prev, err);
000356  bf00              NOP      
000358  f8d50088          LDR      r0,[r5,#0x88]
00035c  b130              CBZ      r0,|L35.876|
00035e  4629              MOV      r1,r5
000360  f8d52088          LDR      r2,[r5,#0x88]
000364  6928              LDR      r0,[r5,#0x10]
000366  4790              BLX      r2
000368  9002              STR      r0,[sp,#8]
00036a  e001              B        |L35.880|
                  |L35.876|
00036c  2000              MOVS     r0,#0
00036e  9002              STR      r0,[sp,#8]
                  |L35.880|
000370  bf00              NOP      
;;;990            if (tcp_active_pcbs_changed) {
000372  485f              LDR      r0,|L35.1264|
000374  7800              LDRB     r0,[r0,#0]  ; tcp_active_pcbs_changed
000376  b100              CBZ      r0,|L35.890|
;;;991              goto tcp_slowtmr_start;
000378  e651              B        |L35.30|
                  |L35.890|
;;;992            }
;;;993            /* if err == ERR_ABRT, 'prev' is already deallocated */
;;;994            if (err == ERR_OK) {
00037a  9802              LDR      r0,[sp,#8]
00037c  b910              CBNZ     r0,|L35.900|
;;;995              tcp_output(prev);
00037e  4628              MOV      r0,r5
000380  f7fffffe          BL       tcp_output
                  |L35.900|
000384  bf00              NOP                            ;816
                  |L35.902|
000386  2c00              CMP      r4,#0                 ;808
000388  f47fae50          BNE      |L35.44|
;;;996            }
;;;997          }
;;;998        }
;;;999      }
;;;1000   
;;;1001     
;;;1002     /* Steps through all of the TIME-WAIT PCBs. */
;;;1003     prev = NULL;
00038c  2500              MOVS     r5,#0
;;;1004     pcb = tcp_tw_pcbs;
00038e  4859              LDR      r0,|L35.1268|
000390  6804              LDR      r4,[r0,#0]  ; tcp_tw_pcbs
;;;1005     while (pcb != NULL) {
000392  e0f8              B        |L35.1414|
                  |L35.916|
;;;1006       LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
000394  bf00              NOP      
000396  7e20              LDRB     r0,[r4,#0x18]
000398  280a              CMP      r0,#0xa
00039a  d004              BEQ      |L35.934|
00039c  bf00              NOP      
00039e  a305              ADR      r3,|L35.948|
0003a0  f24032ee          MOV      r2,#0x3ee
0003a4  e0a8              B        |L35.1272|
                  |L35.934|
0003a6  e0ad              B        |L35.1284|
                  |L35.936|
                          DCD      tcp_ticks
                  |L35.940|
                          DCD      tcp_timer_ctr
                  |L35.944|
                          DCD      tcp_active_pcbs
                  |L35.948|
0003b4  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp.c",0
0003b8  5749505c
0003bc  6c776970
0003c0  2d312e34
0003c4  2e315c73
0003c8  72635c63
0003cc  6f72655c
0003d0  7463702e
0003d4  6300    
0003d6  00                DCB      0
0003d7  00                DCB      0
                  |L35.984|
0003d8  7463705f          DCB      "tcp_slowtmr: active pcb->state != CLOSED\n",0
0003dc  736c6f77
0003e0  746d723a
0003e4  20616374
0003e8  69766520
0003ec  7063622d
0003f0  3e737461
0003f4  74652021
0003f8  3d20434c
0003fc  4f534544
000400  0a00    
000402  00                DCB      0
000403  00                DCB      0
                  |L35.1028|
000404  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000408  7274696f
00040c  6e202225
000410  73222066
000414  61696c65
000418  64206174
00041c  206c696e
000420  65202564
000424  20696e20
000428  25730d0a
00042c  00      
00042d  00                DCB      0
00042e  00                DCB      0
00042f  00                DCB      0
                  |L35.1072|
000430  7463705f          DCB      "tcp_slowtmr: active pcb->state != LISTEN\n",0
000434  736c6f77
000438  746d723a
00043c  20616374
000440  69766520
000444  7063622d
000448  3e737461
00044c  74652021
000450  3d204c49
000454  5354454e
000458  0a00    
00045a  00                DCB      0
00045b  00                DCB      0
                  |L35.1116|
00045c  7463705f          DCB      "tcp_slowtmr: active pcb->state != TIME-WAIT\n",0
000460  736c6f77
000464  746d723a
000468  20616374
00046c  69766520
000470  7063622d
000474  3e737461
000478  74652021
00047c  3d205449
000480  4d452d57
000484  4149540a
000488  00      
000489  00                DCB      0
00048a  00                DCB      0
00048b  00                DCB      0
                  |L35.1164|
                          DCD      tcp_persist_backoff
                  |L35.1168|
                          DCD      tcp_backoff
                  |L35.1172|
                          DCD      0x000a4cb8
                  |L35.1176|
000498  7463705f          DCB      "tcp_slowtmr: middle tcp != tcp_active_pcbs",0
00049c  736c6f77
0004a0  746d723a
0004a4  206d6964
0004a8  646c6520
0004ac  74637020
0004b0  213d2074
0004b4  63705f61
0004b8  63746976
0004bc  655f7063
0004c0  627300  
0004c3  00                DCB      0
                  |L35.1220|
0004c4  7463705f          DCB      "tcp_slowtmr: first pcb == tcp_active_pcbs",0
0004c8  736c6f77
0004cc  746d723a
0004d0  20666972
0004d4  73742070
0004d8  6362203d
0004dc  3d207463
0004e0  705f6163
0004e4  74697665
0004e8  5f706362
0004ec  7300    
0004ee  00                DCB      0
0004ef  00                DCB      0
                  |L35.1264|
                          DCD      tcp_active_pcbs_changed
                  |L35.1268|
                          DCD      tcp_tw_pcbs
                  |L35.1272|
0004f8  a125              ADR      r1,|L35.1424|
0004fa  f2af00f8          ADR      r0,|L35.1028|
0004fe  f7fffffe          BL       __2printf
000502  bf00              NOP      
                  |L35.1284|
000504  bf00              NOP      
;;;1007       pcb_remove = 0;
000506  2600              MOVS     r6,#0
;;;1008   
;;;1009       /* Check if this PCB has stayed long enough in TIME-WAIT */
;;;1010       if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
000508  492d              LDR      r1,|L35.1472|
00050a  6a60              LDR      r0,[r4,#0x24]
00050c  6809              LDR      r1,[r1,#0]  ; tcp_ticks
00050e  1a08              SUBS     r0,r1,r0
000510  28f0              CMP      r0,#0xf0
000512  d901              BLS      |L35.1304|
;;;1011         ++pcb_remove;
000514  1c70              ADDS     r0,r6,#1
000516  b2c6              UXTB     r6,r0
                  |L35.1304|
;;;1012       }
;;;1013       
;;;1014   
;;;1015   
;;;1016       /* If the PCB should be removed, do it. */
;;;1017       if (pcb_remove) {
000518  2e00              CMP      r6,#0
00051a  d032              BEQ      |L35.1410|
;;;1018         struct tcp_pcb *pcb2;
;;;1019         tcp_pcb_purge(pcb);
00051c  4620              MOV      r0,r4
00051e  f7fffffe          BL       tcp_pcb_purge
;;;1020         /* Remove PCB from tcp_tw_pcbs list. */
;;;1021         if (prev != NULL) {
000522  b19d              CBZ      r5,|L35.1356|
;;;1022           LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
000524  bf00              NOP      
000526  4827              LDR      r0,|L35.1476|
000528  6800              LDR      r0,[r0,#0]  ; tcp_tw_pcbs
00052a  4284              CMP      r4,r0
00052c  d10a              BNE      |L35.1348|
00052e  bf00              NOP      
000530  f2af1380          ADR      r3,|L35.948|
000534  f24032fe          MOV      r2,#0x3fe
000538  a123              ADR      r1,|L35.1480|
00053a  f2af1038          ADR      r0,|L35.1028|
00053e  f7fffffe          BL       __2printf
000542  bf00              NOP      
                  |L35.1348|
000544  bf00              NOP      
;;;1023           prev->next = pcb->next;
000546  68e0              LDR      r0,[r4,#0xc]
000548  60e8              STR      r0,[r5,#0xc]
00054a  e013              B        |L35.1396|
                  |L35.1356|
;;;1024         } else {
;;;1025           /* This PCB was the first. */
;;;1026           LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
00054c  bf00              NOP      
00054e  481d              LDR      r0,|L35.1476|
000550  6800              LDR      r0,[r0,#0]  ; tcp_tw_pcbs
000552  42a0              CMP      r0,r4
000554  d00a              BEQ      |L35.1388|
000556  bf00              NOP      
000558  f2af13a8          ADR      r3,|L35.948|
00055c  f2404202          MOV      r2,#0x402
000560  a123              ADR      r1,|L35.1520|
000562  f2af1060          ADR      r0,|L35.1028|
000566  f7fffffe          BL       __2printf
00056a  bf00              NOP      
                  |L35.1388|
00056c  bf00              NOP      
;;;1027           tcp_tw_pcbs = pcb->next;
00056e  4915              LDR      r1,|L35.1476|
000570  68e0              LDR      r0,[r4,#0xc]
000572  6008              STR      r0,[r1,#0]  ; tcp_tw_pcbs
                  |L35.1396|
;;;1028         }
;;;1029         pcb2 = pcb;
000574  4627              MOV      r7,r4
;;;1030         pcb = pcb->next;
000576  68e4              LDR      r4,[r4,#0xc]
;;;1031         memp_free(MEMP_TCP_PCB, pcb2);
000578  4639              MOV      r1,r7
00057a  2002              MOVS     r0,#2
00057c  f7fffffe          BL       memp_free
;;;1032       } else {
000580  e001              B        |L35.1414|
                  |L35.1410|
;;;1033         prev = pcb;
000582  4625              MOV      r5,r4
;;;1034         pcb = pcb->next;
000584  68e4              LDR      r4,[r4,#0xc]
                  |L35.1414|
000586  2c00              CMP      r4,#0                 ;1005
000588  f47faf04          BNE      |L35.916|
;;;1035       }
;;;1036     }
;;;1037   }
00058c  e8bd8ffe          POP      {r1-r11,pc}
;;;1038   
                          ENDP

                  |L35.1424|
000590  7463705f          DCB      "tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT",0
000594  736c6f77
000598  746d723a
00059c  2054494d
0005a0  452d5741
0005a4  49542070
0005a8  63622d3e
0005ac  73746174
0005b0  65203d3d
0005b4  2054494d
0005b8  452d5741
0005bc  495400  
0005bf  00                DCB      0
                  |L35.1472|
                          DCD      tcp_ticks
                  |L35.1476|
                          DCD      tcp_tw_pcbs
                  |L35.1480|
0005c8  7463705f          DCB      "tcp_slowtmr: middle tcp != tcp_tw_pcbs",0
0005cc  736c6f77
0005d0  746d723a
0005d4  206d6964
0005d8  646c6520
0005dc  74637020
0005e0  213d2074
0005e4  63705f74
0005e8  775f7063
0005ec  627300  
0005ef  00                DCB      0
                  |L35.1520|
0005f0  7463705f          DCB      "tcp_slowtmr: first pcb == tcp_tw_pcbs",0
0005f4  736c6f77
0005f8  746d723a
0005fc  20666972
000600  73742070
000604  6362203d
000608  3d207463
00060c  705f7477
000610  5f706362
000614  7300    
000616  00                DCB      0
000617  00                DCB      0

                          AREA ||i.tcp_tmr||, CODE, READONLY, ALIGN=2

                  tcp_tmr PROC
;;;140    void
;;;141    tcp_tmr(void)
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143      /* Call tcp_fasttmr() every 250 ms */
;;;144      tcp_fasttmr();
000002  f7fffffe          BL       tcp_fasttmr
;;;145    
;;;146      if (++tcp_timer & 1) {
000006  4806              LDR      r0,|L36.32|
000008  7800              LDRB     r0,[r0,#0]  ; tcp_timer
00000a  1c40              ADDS     r0,r0,#1
00000c  b2c0              UXTB     r0,r0
00000e  4904              LDR      r1,|L36.32|
000010  7008              STRB     r0,[r1,#0]
000012  f0000001          AND      r0,r0,#1
000016  b108              CBZ      r0,|L36.28|
;;;147        /* Call tcp_tmr() every 500 ms, i.e., every other timer
;;;148           tcp_tmr() is called. */
;;;149        tcp_slowtmr();
000018  f7fffffe          BL       tcp_slowtmr
                  |L36.28|
;;;150      }
;;;151    }
00001c  bd10              POP      {r4,pc}
;;;152    
                          ENDP

00001e  0000              DCW      0x0000
                  |L36.32|
                          DCD      tcp_timer

                          AREA ||i.tcp_update_rcv_ann_wnd||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_update_rcv_ann_wnd PROC
;;;578     */
;;;579    u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;580    {
000002  4604              MOV      r4,r0
;;;581      u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
000004  8da1              LDRH     r1,[r4,#0x2c]
000006  6aa0              LDR      r0,[r4,#0x28]
000008  1845              ADDS     r5,r0,r1
;;;582    
;;;583      if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
00000a  8ee0              LDRH     r0,[r4,#0x36]
00000c  f24052b4          MOV      r2,#0x5b4
000010  6b21              LDR      r1,[r4,#0x30]
000012  4290              CMP      r0,r2
000014  dd01              BLE      |L37.26|
000016  4610              MOV      r0,r2
000018  e000              B        |L37.28|
                  |L37.26|
00001a  8ee0              LDRH     r0,[r4,#0x36]
                  |L37.28|
00001c  4408              ADD      r0,r0,r1
00001e  1a28              SUBS     r0,r5,r0
000020  d404              BMI      |L37.44|
;;;584        /* we can advertise more window */
;;;585        pcb->rcv_ann_wnd = pcb->rcv_wnd;
000022  8da0              LDRH     r0,[r4,#0x2c]
000024  85e0              STRH     r0,[r4,#0x2e]
;;;586        return new_right_edge - pcb->rcv_ann_right_edge;
000026  6b20              LDR      r0,[r4,#0x30]
000028  1a28              SUBS     r0,r5,r0
                  |L37.42|
;;;587      } else {
;;;588        if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
;;;589          /* Can happen due to other end sending out of advertised window,
;;;590           * but within actual available (but not yet advertised) window */
;;;591          pcb->rcv_ann_wnd = 0;
;;;592        } else {
;;;593          /* keep the right edge of window constant */
;;;594          u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
;;;595          LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
;;;596          pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
;;;597        }
;;;598        return 0;
;;;599      }
;;;600    }
00002a  bd70              POP      {r4-r6,pc}
                  |L37.44|
00002c  6b21              LDR      r1,[r4,#0x30]         ;588
00002e  6aa0              LDR      r0,[r4,#0x28]         ;588
000030  1a40              SUBS     r0,r0,r1              ;588
000032  2800              CMP      r0,#0                 ;588
000034  dd02              BLE      |L37.60|
000036  2000              MOVS     r0,#0                 ;591
000038  85e0              STRH     r0,[r4,#0x2e]         ;591
00003a  e012              B        |L37.98|
                  |L37.60|
00003c  6aa1              LDR      r1,[r4,#0x28]         ;594
00003e  6b20              LDR      r0,[r4,#0x30]         ;594
000040  1a46              SUBS     r6,r0,r1              ;594
000042  bf00              NOP                            ;595
000044  f5b63f80          CMP      r6,#0x10000           ;595
000048  d308              BCC      |L37.92|
00004a  bf00              NOP                            ;595
00004c  a306              ADR      r3,|L37.104|
00004e  f2402253          MOV      r2,#0x253             ;595
000052  a10e              ADR      r1,|L37.140|
000054  a014              ADR      r0,|L37.168|
000056  f7fffffe          BL       __2printf
00005a  bf00              NOP                            ;595
                  |L37.92|
00005c  bf00              NOP                            ;595
00005e  85e6              STRH     r6,[r4,#0x2e]         ;596
000060  bf00              NOP                            ;597
                  |L37.98|
000062  2000              MOVS     r0,#0                 ;598
000064  e7e1              B        |L37.42|
;;;601    
                          ENDP

000066  0000              DCW      0x0000
                  |L37.104|
000068  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\tcp.c",0
00006c  5749505c
000070  6c776970
000074  2d312e34
000078  2e315c73
00007c  72635c63
000080  6f72655c
000084  7463702e
000088  6300    
00008a  00                DCB      0
00008b  00                DCB      0
                  |L37.140|
00008c  6e65775f          DCB      "new_rcv_ann_wnd <= 0xffff",0
000090  7263765f
000094  616e6e5f
000098  776e6420
00009c  3c3d2030
0000a0  78666666
0000a4  6600    
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L37.168|
0000a8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000ac  7274696f
0000b0  6e202225
0000b4  73222066
0000b8  61696c65
0000bc  64206174
0000c0  206c696e
0000c4  65202564
0000c8  20696e20
0000cc  25730d0a
0000d0  00      
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  tcp_state_str
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x8
                          DCD      ||.conststring||+0x10
                          DCD      ||.conststring||+0x1c
                          DCD      ||.conststring||+0x28
                          DCD      ||.conststring||+0x34
                          DCD      ||.conststring||+0x40
                          DCD      ||.conststring||+0x4c
                          DCD      ||.conststring||+0x58
                          DCD      ||.conststring||+0x60
                          DCD      ||.conststring||+0x6c
                  tcp_backoff
00002c  01020304          DCB      0x01,0x02,0x03,0x04
000030  05060707          DCB      0x05,0x06,0x07,0x07
000034  07070707          DCB      0x07,0x07,0x07,0x07
000038  07                DCB      0x07
                  tcp_persist_backoff
000039  03060c            DCB      0x03,0x06,0x0c
00003c  18306078          DCB      0x18,0x30,0x60,0x78
                  tcp_pcb_lists
                          DCD      tcp_listen_pcbs
                          DCD      tcp_bound_pcbs
                          DCD      tcp_active_pcbs
                          DCD      tcp_tw_pcbs

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  434c4f53          DCB      "CLOSED",0
000004  454400  
000007  00                DCB      0
000008  4c495354          DCB      "LISTEN",0
00000c  454e00  
00000f  00                DCB      0
000010  53594e5f          DCB      "SYN_SENT",0
000014  53454e54
000018  00      
000019  00                DCB      0
00001a  00                DCB      0
00001b  00                DCB      0
00001c  53594e5f          DCB      "SYN_RCVD",0
000020  52435644
000024  00      
000025  00                DCB      0
000026  00                DCB      0
000027  00                DCB      0
000028  45535441          DCB      "ESTABLISHED",0
00002c  424c4953
000030  48454400
000034  46494e5f          DCB      "FIN_WAIT_1",0
000038  57414954
00003c  5f3100  
00003f  00                DCB      0
000040  46494e5f          DCB      "FIN_WAIT_2",0
000044  57414954
000048  5f3200  
00004b  00                DCB      0
00004c  434c4f53          DCB      "CLOSE_WAIT",0
000050  455f5741
000054  495400  
000057  00                DCB      0
000058  434c4f53          DCB      "CLOSING",0
00005c  494e4700
000060  4c415354          DCB      "LAST_ACK",0
000064  5f41434b
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
00006c  54494d45          DCB      "TIME_WAIT",0
000070  5f574149
000074  5400    

                          AREA ||.data||, DATA, ALIGN=2

                  tcp_port
000000  c000              DCW      0xc000
000002  0000              DCB      0x00,0x00
                  tcp_ticks
                          DCD      0x00000000
                  tcp_bound_pcbs
                          DCD      0x00000000
                  tcp_listen_pcbs
                          DCD      0x00000000
                  tcp_active_pcbs
                          DCD      0x00000000
                  tcp_tw_pcbs
                          DCD      0x00000000
                  tcp_tmp_pcb
                          DCD      0x00000000
                  tcp_active_pcbs_changed
00001c  00                DCB      0x00
                  tcp_timer
00001d  00                DCB      0x00
                  tcp_timer_ctr
00001e  0000              DCB      0x00,0x00
                  iss
                          DCD      0x0000196e
