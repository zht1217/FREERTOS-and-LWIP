; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\pbuf.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\pbuf.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\pbuf.crf ..\LWIP\lwip-1.4.1\src\core\pbuf.c]
                          THUMB

                          AREA ||i.pbuf_alloc||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_alloc PROC
;;;206    struct pbuf *
;;;207    pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;208    {
000004  4683              MOV      r11,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
;;;209      struct pbuf *p, *q, *r;
;;;210      u16_t offset;
;;;211      s32_t rem_len; /* remaining length */
;;;212      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;213    
;;;214      /* determine header offset */
;;;215      switch (layer) {
00000e  f1bb0f00          CMP      r11,#0
000012  d009              BEQ      |L1.40|
000014  f1bb0f01          CMP      r11,#1
000018  d008              BEQ      |L1.44|
00001a  f1bb0f02          CMP      r11,#2
00001e  d007              BEQ      |L1.48|
000020  f1bb0f03          CMP      r11,#3
000024  d108              BNE      |L1.56|
000026  e005              B        |L1.52|
                  |L1.40|
;;;216      case PBUF_TRANSPORT:
;;;217        /* add room for transport (often TCP) layer header */
;;;218        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
000028  2636              MOVS     r6,#0x36
;;;219        break;
00002a  e012              B        |L1.82|
                  |L1.44|
;;;220      case PBUF_IP:
;;;221        /* add room for IP layer header */
;;;222        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
00002c  2622              MOVS     r6,#0x22
;;;223        break;
00002e  e010              B        |L1.82|
                  |L1.48|
;;;224      case PBUF_LINK:
;;;225        /* add room for link layer header */
;;;226        offset = PBUF_LINK_HLEN;
000030  260e              MOVS     r6,#0xe
;;;227        break;
000032  e00e              B        |L1.82|
                  |L1.52|
;;;228      case PBUF_RAW:
;;;229        offset = 0;
000034  2600              MOVS     r6,#0
;;;230        break;
000036  e00c              B        |L1.82|
                  |L1.56|
;;;231      default:
;;;232        LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
000038  bf00              NOP      
00003a  bf00              NOP      
00003c  a395              ADR      r3,|L1.660|
00003e  22e8              MOVS     r2,#0xe8
000040  a19d              ADR      r1,|L1.696|
000042  a0a4              ADR      r0,|L1.724|
000044  f7fffffe          BL       __2printf
000048  bf00              NOP      
00004a  bf00              NOP      
;;;233        return NULL;
00004c  2000              MOVS     r0,#0
                  |L1.78|
;;;234      }
;;;235    
;;;236      switch (type) {
;;;237      case PBUF_POOL:
;;;238        /* allocate head of pbuf chain into p */
;;;239        p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;240        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
;;;241        if (p == NULL) {
;;;242          PBUF_POOL_IS_EMPTY();
;;;243          return NULL;
;;;244        }
;;;245        p->type = type;
;;;246        p->next = NULL;
;;;247    
;;;248        /* make the payload pointer point 'offset' bytes into pbuf data memory */
;;;249        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
;;;250        LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
;;;251                ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;252        /* the total length of the pbuf chain is the requested size */
;;;253        p->tot_len = length;
;;;254        /* set the length of the first pbuf in the chain */
;;;255        p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
;;;256        LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;257                    ((u8_t*)p->payload + p->len <=
;;;258                     (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;259        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
;;;260          (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
;;;261        /* set reference count (needed here in case we fail) */
;;;262        p->ref = 1;
;;;263    
;;;264        /* now allocate the tail of the pbuf chain */
;;;265    
;;;266        /* remember first pbuf for linkage in next iteration */
;;;267        r = p;
;;;268        /* remaining length to be allocated */
;;;269        rem_len = length - p->len;
;;;270        /* any remaining pbufs to be allocated? */
;;;271        while (rem_len > 0) {
;;;272          q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;273          if (q == NULL) {
;;;274            PBUF_POOL_IS_EMPTY();
;;;275            /* free chain so far allocated */
;;;276            pbuf_free(p);
;;;277            /* bail out unsuccesfully */
;;;278            return NULL;
;;;279          }
;;;280          q->type = type;
;;;281          q->flags = 0;
;;;282          q->next = NULL;
;;;283          /* make previous pbuf point to this pbuf */
;;;284          r->next = q;
;;;285          /* set total length of this pbuf and next in chain */
;;;286          LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
;;;287          q->tot_len = (u16_t)rem_len;
;;;288          /* this pbuf length is pool size, unless smaller sized tail */
;;;289          q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
;;;290          q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
;;;291          LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
;;;292                  ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
;;;293          LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;294                      ((u8_t*)p->payload + p->len <=
;;;295                       (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;296          q->ref = 1;
;;;297          /* calculate remaining length to be allocated */
;;;298          rem_len -= q->len;
;;;299          /* remember this pbuf for linkage in next iteration */
;;;300          r = q;
;;;301        }
;;;302        /* end of chain */
;;;303        /*r->next = NULL;*/
;;;304    
;;;305        break;
;;;306      case PBUF_RAM:
;;;307        /* If pbuf is to be allocated in RAM, allocate memory for it. */
;;;308        p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
;;;309        if (p == NULL) {
;;;310          return NULL;
;;;311        }
;;;312        /* Set up internal structure of the pbuf. */
;;;313        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
;;;314        p->len = p->tot_len = length;
;;;315        p->next = NULL;
;;;316        p->type = type;
;;;317    
;;;318        LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
;;;319               ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;320        break;
;;;321      /* pbuf references existing (non-volatile static constant) ROM payload? */
;;;322      case PBUF_ROM:
;;;323      /* pbuf references existing (externally allocated) RAM payload? */
;;;324      case PBUF_REF:
;;;325        /* only allocate memory for the pbuf structure */
;;;326        p = (struct pbuf *)memp_malloc(MEMP_PBUF);
;;;327        if (p == NULL) {
;;;328          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;329                      ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
;;;330                      (type == PBUF_ROM) ? "ROM" : "REF"));
;;;331          return NULL;
;;;332        }
;;;333        /* caller must set this field properly, afterwards */
;;;334        p->payload = NULL;
;;;335        p->len = p->tot_len = length;
;;;336        p->next = NULL;
;;;337        p->type = type;
;;;338        break;
;;;339      default:
;;;340        LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
;;;341        return NULL;
;;;342      }
;;;343      /* set reference count */
;;;344      p->ref = 1;
;;;345      /* set flags */
;;;346      p->flags = 0;
;;;347      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
;;;348      return p;
;;;349    }
00004e  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.82|
000052  bf00              NOP                            ;219
000054  f1b90f00          CMP      r9,#0                 ;236
000058  d073              BEQ      |L1.322|
00005a  f1b90f01          CMP      r9,#1                 ;236
00005e  d071              BEQ      |L1.324|
000060  f1b90f02          CMP      r9,#2                 ;236
000064  d06f              BEQ      |L1.326|
000066  f1b90f03          CMP      r9,#3                 ;236
00006a  d16d              BNE      |L1.328|
00006c  200d              MOVS     r0,#0xd               ;239
00006e  f7fffffe          BL       memp_malloc
000072  4604              MOV      r4,r0                 ;239
000074  bf00              NOP                            ;240
000076  bf00              NOP                            ;240
000078  b91c              CBNZ     r4,|L1.130|
00007a  f7fffffe          BL       pbuf_pool_is_empty
00007e  2000              MOVS     r0,#0                 ;243
000080  e7e5              B        |L1.78|
                  |L1.130|
000082  f884900c          STRB     r9,[r4,#0xc]          ;245
000086  2000              MOVS     r0,#0                 ;246
000088  6020              STR      r0,[r4,#0]            ;246
00008a  f1060010          ADD      r0,r6,#0x10           ;249
00008e  4420              ADD      r0,r0,r4              ;249
000090  1cc0              ADDS     r0,r0,#3              ;249
000092  f0200003          BIC      r0,r0,#3              ;249
000096  6060              STR      r0,[r4,#4]            ;249
000098  bf00              NOP                            ;250
00009a  7920              LDRB     r0,[r4,#4]            ;250
00009c  f0000003          AND      r0,r0,#3              ;250
0000a0  b138              CBZ      r0,|L1.178|
0000a2  bf00              NOP                            ;250
0000a4  a37b              ADR      r3,|L1.660|
0000a6  22fa              MOVS     r2,#0xfa              ;250
0000a8  a195              ADR      r1,|L1.768|
0000aa  a08a              ADR      r0,|L1.724|
0000ac  f7fffffe          BL       __2printf
0000b0  bf00              NOP                            ;250
                  |L1.178|
0000b2  bf00              NOP                            ;250
0000b4  8127              STRH     r7,[r4,#8]            ;253
0000b6  1cf0              ADDS     r0,r6,#3              ;255
0000b8  f0200003          BIC      r0,r0,#3              ;255
0000bc  f5c07000          RSB      r0,r0,#0x200          ;255
0000c0  42b8              CMP      r0,r7                 ;255
0000c2  dd01              BLE      |L1.200|
0000c4  4638              MOV      r0,r7                 ;255
0000c6  e004              B        |L1.210|
                  |L1.200|
0000c8  1cf0              ADDS     r0,r6,#3              ;255
0000ca  f0200003          BIC      r0,r0,#3              ;255
0000ce  f5c07000          RSB      r0,r0,#0x200          ;255
                  |L1.210|
0000d2  8160              STRH     r0,[r4,#0xa]          ;255
0000d4  bf00              NOP                            ;256
0000d6  8961              LDRH     r1,[r4,#0xa]          ;256
0000d8  6860              LDR      r0,[r4,#4]            ;256
0000da  4401              ADD      r1,r1,r0              ;256
0000dc  f5047004          ADD      r0,r4,#0x210          ;256
0000e0  4281              CMP      r1,r0                 ;256
0000e2  d908              BLS      |L1.246|
0000e4  bf00              NOP                            ;256
0000e6  a36b              ADR      r3,|L1.660|
0000e8  f44f7280          MOV      r2,#0x100             ;256
0000ec  a190              ADR      r1,|L1.816|
0000ee  a079              ADR      r0,|L1.724|
0000f0  f7fffffe          BL       __2printf
0000f4  bf00              NOP                            ;256
                  |L1.246|
0000f6  bf00              NOP                            ;256
0000f8  bf00              NOP                            ;259
0000fa  1cf0              ADDS     r0,r6,#3              ;259
0000fc  f0200003          BIC      r0,r0,#3              ;259
000100  f5c07000          RSB      r0,r0,#0x200          ;259
000104  2800              CMP      r0,#0                 ;259
000106  dc08              BGT      |L1.282|
000108  bf00              NOP                            ;259
00010a  a362              ADR      r3,|L1.660|
00010c  f2401203          MOV      r2,#0x103             ;259
000110  a194              ADR      r1,|L1.868|
000112  a070              ADR      r0,|L1.724|
000114  f7fffffe          BL       __2printf
000118  bf00              NOP                            ;259
                  |L1.282|
00011a  bf00              NOP                            ;259
00011c  2001              MOVS     r0,#1                 ;262
00011e  81e0              STRH     r0,[r4,#0xe]          ;262
000120  46a2              MOV      r10,r4                ;267
000122  8960              LDRH     r0,[r4,#0xa]          ;269
000124  eba70800          SUB      r8,r7,r0              ;269
000128  e05c              B        |L1.484|
                  |L1.298|
00012a  200d              MOVS     r0,#0xd               ;272
00012c  f7fffffe          BL       memp_malloc
000130  4605              MOV      r5,r0                 ;272
000132  b955              CBNZ     r5,|L1.330|
000134  f7fffffe          BL       pbuf_pool_is_empty
000138  4620              MOV      r0,r4                 ;276
00013a  f7fffffe          BL       pbuf_free
00013e  2000              MOVS     r0,#0                 ;278
000140  e785              B        |L1.78|
                  |L1.322|
000142  e053              B        |L1.492|
                  |L1.324|
000144  e07e              B        |L1.580|
                  |L1.326|
000146  e07e              B        |L1.582|
                  |L1.328|
000148  e08e              B        |L1.616|
                  |L1.330|
00014a  f885900c          STRB     r9,[r5,#0xc]          ;280
00014e  2000              MOVS     r0,#0                 ;281
000150  7368              STRB     r0,[r5,#0xd]          ;281
000152  6028              STR      r0,[r5,#0]            ;282
000154  f8ca5000          STR      r5,[r10,#0]           ;284
000158  bf00              NOP                            ;286
00015a  f64f70ff          MOV      r0,#0xffff            ;286
00015e  4580              CMP      r8,r0                 ;286
000160  db08              BLT      |L1.372|
000162  bf00              NOP                            ;286
000164  a34b              ADR      r3,|L1.660|
000166  f44f728f          MOV      r2,#0x11e             ;286
00016a  a18b              ADR      r1,|L1.920|
00016c  a059              ADR      r0,|L1.724|
00016e  f7fffffe          BL       __2printf
000172  bf00              NOP                            ;286
                  |L1.372|
000174  bf00              NOP                            ;286
000176  f8a58008          STRH     r8,[r5,#8]            ;287
00017a  fa1ff088          UXTH     r0,r8                 ;289
00017e  f5b07f00          CMP      r0,#0x200             ;289
000182  da02              BGE      |L1.394|
000184  fa1ff088          UXTH     r0,r8                 ;289
000188  e001              B        |L1.398|
                  |L1.394|
00018a  f44f7000          MOV      r0,#0x200             ;289
                  |L1.398|
00018e  8168              STRH     r0,[r5,#0xa]          ;289
000190  f1050010          ADD      r0,r5,#0x10           ;290
000194  6068              STR      r0,[r5,#4]            ;290
000196  bf00              NOP                            ;291
000198  7928              LDRB     r0,[r5,#4]            ;291
00019a  f0000003          AND      r0,r0,#3              ;291
00019e  b140              CBZ      r0,|L1.434|
0001a0  bf00              NOP                            ;291
0001a2  a33c              ADR      r3,|L1.660|
0001a4  f2401223          MOV      r2,#0x123             ;291
0001a8  a180              ADR      r1,|L1.940|
0001aa  a04a              ADR      r0,|L1.724|
0001ac  f7fffffe          BL       __2printf
0001b0  bf00              NOP                            ;291
                  |L1.434|
0001b2  bf00              NOP                            ;291
0001b4  bf00              NOP                            ;293
0001b6  8961              LDRH     r1,[r4,#0xa]          ;293
0001b8  6860              LDR      r0,[r4,#4]            ;293
0001ba  4401              ADD      r1,r1,r0              ;293
0001bc  f5047004          ADD      r0,r4,#0x210          ;293
0001c0  4281              CMP      r1,r0                 ;293
0001c2  d908              BLS      |L1.470|
0001c4  bf00              NOP                            ;293
0001c6  a333              ADR      r3,|L1.660|
0001c8  f2401225          MOV      r2,#0x125             ;293
0001cc  a158              ADR      r1,|L1.816|
0001ce  a041              ADR      r0,|L1.724|
0001d0  f7fffffe          BL       __2printf
0001d4  bf00              NOP                            ;293
                  |L1.470|
0001d6  bf00              NOP                            ;293
0001d8  2001              MOVS     r0,#1                 ;296
0001da  81e8              STRH     r0,[r5,#0xe]          ;296
0001dc  8968              LDRH     r0,[r5,#0xa]          ;298
0001de  eba80800          SUB      r8,r8,r0              ;298
0001e2  46aa              MOV      r10,r5                ;300
                  |L1.484|
0001e4  f1b80f00          CMP      r8,#0                 ;271
0001e8  dc9f              BGT      |L1.298|
0001ea  e04a              B        |L1.642|
                  |L1.492|
0001ec  f1060113          ADD      r1,r6,#0x13           ;308
0001f0  f0210203          BIC      r2,r1,#3              ;308
0001f4  1cf9              ADDS     r1,r7,#3              ;308
0001f6  f0210103          BIC      r1,r1,#3              ;308
0001fa  4411              ADD      r1,r1,r2              ;308
0001fc  b288              UXTH     r0,r1                 ;308
0001fe  f7fffffe          BL       mem_malloc
000202  4604              MOV      r4,r0                 ;308
000204  b90c              CBNZ     r4,|L1.522|
000206  2000              MOVS     r0,#0                 ;310
000208  e721              B        |L1.78|
                  |L1.522|
00020a  f1040010          ADD      r0,r4,#0x10           ;313
00020e  4430              ADD      r0,r0,r6              ;313
000210  1cc0              ADDS     r0,r0,#3              ;313
000212  f0200003          BIC      r0,r0,#3              ;313
000216  6060              STR      r0,[r4,#4]            ;313
000218  8127              STRH     r7,[r4,#8]            ;314
00021a  8167              STRH     r7,[r4,#0xa]          ;314
00021c  2000              MOVS     r0,#0                 ;315
00021e  6020              STR      r0,[r4,#0]            ;315
000220  f884900c          STRB     r9,[r4,#0xc]          ;316
000224  bf00              NOP                            ;318
000226  7920              LDRB     r0,[r4,#4]            ;318
000228  f0000003          AND      r0,r0,#3              ;318
00022c  b140              CBZ      r0,|L1.576|
00022e  bf00              NOP                            ;318
000230  a318              ADR      r3,|L1.660|
000232  f44f729f          MOV      r2,#0x13e             ;318
000236  a169              ADR      r1,|L1.988|
000238  a026              ADR      r0,|L1.724|
00023a  f7fffffe          BL       __2printf
00023e  bf00              NOP                            ;318
                  |L1.576|
000240  bf00              NOP                            ;318
000242  e01e              B        |L1.642|
                  |L1.580|
000244  bf00              NOP                            ;324
                  |L1.582|
000246  200c              MOVS     r0,#0xc               ;326
000248  f7fffffe          BL       memp_malloc
00024c  4604              MOV      r4,r0                 ;326
00024e  b91c              CBNZ     r4,|L1.600|
000250  bf00              NOP                            ;328
000252  bf00              NOP                            ;328
000254  2000              MOVS     r0,#0                 ;331
000256  e6fa              B        |L1.78|
                  |L1.600|
000258  2000              MOVS     r0,#0                 ;334
00025a  6060              STR      r0,[r4,#4]            ;334
00025c  8127              STRH     r7,[r4,#8]            ;335
00025e  8167              STRH     r7,[r4,#0xa]          ;335
000260  6020              STR      r0,[r4,#0]            ;336
000262  f884900c          STRB     r9,[r4,#0xc]          ;337
000266  e00c              B        |L1.642|
                  |L1.616|
000268  bf00              NOP                            ;340
00026a  bf00              NOP                            ;340
00026c  a309              ADR      r3,|L1.660|
00026e  f44f72aa          MOV      r2,#0x154             ;340
000272  a165              ADR      r1,|L1.1032|
000274  a017              ADR      r0,|L1.724|
000276  f7fffffe          BL       __2printf
00027a  bf00              NOP                            ;340
00027c  bf00              NOP                            ;340
00027e  2000              MOVS     r0,#0                 ;341
000280  e6e5              B        |L1.78|
                  |L1.642|
000282  bf00              NOP                            ;305
000284  2001              MOVS     r0,#1                 ;344
000286  81e0              STRH     r0,[r4,#0xe]          ;344
000288  2000              MOVS     r0,#0                 ;346
00028a  7360              STRB     r0,[r4,#0xd]          ;346
00028c  bf00              NOP                            ;347
00028e  bf00              NOP                            ;347
000290  4620              MOV      r0,r4                 ;348
000292  e6dc              B        |L1.78|
;;;350    
                          ENDP

                  |L1.660|
000294  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\pbuf.c",0
000298  5749505c
00029c  6c776970
0002a0  2d312e34
0002a4  2e315c73
0002a8  72635c63
0002ac  6f72655c
0002b0  70627566
0002b4  2e6300  
0002b7  00                DCB      0
                  |L1.696|
0002b8  70627566          DCB      "pbuf_alloc: bad pbuf layer",0
0002bc  5f616c6c
0002c0  6f633a20
0002c4  62616420
0002c8  70627566
0002cc  206c6179
0002d0  657200  
0002d3  00                DCB      0
                  |L1.724|
0002d4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0002d8  7274696f
0002dc  6e202225
0002e0  73222066
0002e4  61696c65
0002e8  64206174
0002ec  206c696e
0002f0  65202564
0002f4  20696e20
0002f8  25730d0a
0002fc  00      
0002fd  00                DCB      0
0002fe  00                DCB      0
0002ff  00                DCB      0
                  |L1.768|
000300  70627566          DCB      "pbuf_alloc: pbuf p->payload properly aligned",0
000304  5f616c6c
000308  6f633a20
00030c  70627566
000310  20702d3e
000314  7061796c
000318  6f616420
00031c  70726f70
000320  65726c79
000324  20616c69
000328  676e6564
00032c  00      
00032d  00                DCB      0
00032e  00                DCB      0
00032f  00                DCB      0
                  |L1.816|
000330  63686563          DCB      "check p->payload + p->len does not overflow pbuf",0
000334  6b20702d
000338  3e706179
00033c  6c6f6164
000340  202b2070
000344  2d3e6c65
000348  6e20646f
00034c  6573206e
000350  6f74206f
000354  76657266
000358  6c6f7720
00035c  70627566
000360  00      
000361  00                DCB      0
000362  00                DCB      0
000363  00                DCB      0
                  |L1.868|
000364  50425546          DCB      "PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",0
000368  5f504f4f
00036c  4c5f4255
000370  4653495a
000374  45206d75
000378  73742062
00037c  65206269
000380  67676572
000384  20746861
000388  6e204d45
00038c  4d5f414c
000390  49474e4d
000394  454e5400
                  |L1.920|
000398  72656d5f          DCB      "rem_len < max_u16_t",0
00039c  6c656e20
0003a0  3c206d61
0003a4  785f7531
0003a8  365f7400
                  |L1.940|
0003ac  70627566          DCB      "pbuf_alloc: pbuf q->payload properly aligned",0
0003b0  5f616c6c
0003b4  6f633a20
0003b8  70627566
0003bc  20712d3e
0003c0  7061796c
0003c4  6f616420
0003c8  70726f70
0003cc  65726c79
0003d0  20616c69
0003d4  676e6564
0003d8  00      
0003d9  00                DCB      0
0003da  00                DCB      0
0003db  00                DCB      0
                  |L1.988|
0003dc  70627566          DCB      "pbuf_alloc: pbuf->payload properly aligned",0
0003e0  5f616c6c
0003e4  6f633a20
0003e8  70627566
0003ec  2d3e7061
0003f0  796c6f61
0003f4  64207072
0003f8  6f706572
0003fc  6c792061
000400  6c69676e
000404  656400  
000407  00                DCB      0
                  |L1.1032|
000408  70627566          DCB      "pbuf_alloc: erroneous type",0
00040c  5f616c6c
000410  6f633a20
000414  6572726f
000418  6e656f75
00041c  73207479
000420  706500  
000423  00                DCB      0

                          AREA ||i.pbuf_alloced_custom||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  pbuf_alloced_custom PROC
;;;366    struct pbuf*
;;;367    pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;368                        void *payload_mem, u16_t payload_mem_len)
;;;369    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  461c              MOV      r4,r3
00000c  e9dd9a08          LDRD     r9,r10,[sp,#0x20]
;;;370      u16_t offset;
;;;371      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));
000010  bf00              NOP      
000012  bf00              NOP      
;;;372    
;;;373      /* determine header offset */
;;;374      switch (l) {
000014  b137              CBZ      r7,|L2.36|
000016  2f01              CMP      r7,#1
000018  d006              BEQ      |L2.40|
00001a  2f02              CMP      r7,#2
00001c  d006              BEQ      |L2.44|
00001e  2f03              CMP      r7,#3
000020  d108              BNE      |L2.52|
000022  e005              B        |L2.48|
                  |L2.36|
;;;375      case PBUF_TRANSPORT:
;;;376        /* add room for transport (often TCP) layer header */
;;;377        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
000024  2536              MOVS     r5,#0x36
;;;378        break;
000026  e013              B        |L2.80|
                  |L2.40|
;;;379      case PBUF_IP:
;;;380        /* add room for IP layer header */
;;;381        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
000028  2522              MOVS     r5,#0x22
;;;382        break;
00002a  e011              B        |L2.80|
                  |L2.44|
;;;383      case PBUF_LINK:
;;;384        /* add room for link layer header */
;;;385        offset = PBUF_LINK_HLEN;
00002c  250e              MOVS     r5,#0xe
;;;386        break;
00002e  e00f              B        |L2.80|
                  |L2.48|
;;;387      case PBUF_RAW:
;;;388        offset = 0;
000030  2500              MOVS     r5,#0
;;;389        break;
000032  e00d              B        |L2.80|
                  |L2.52|
;;;390      default:
;;;391        LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
000034  bf00              NOP      
000036  bf00              NOP      
000038  a316              ADR      r3,|L2.148|
00003a  f2401287          MOV      r2,#0x187
00003e  a11e              ADR      r1,|L2.184|
000040  a026              ADR      r0,|L2.220|
000042  f7fffffe          BL       __2printf
000046  bf00              NOP      
000048  bf00              NOP      
;;;392        return NULL;
00004a  2000              MOVS     r0,#0
                  |L2.76|
;;;393      }
;;;394    
;;;395      if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
;;;396        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
;;;397        return NULL;
;;;398      }
;;;399    
;;;400      p->pbuf.next = NULL;
;;;401      if (payload_mem != NULL) {
;;;402        p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
;;;403      } else {
;;;404        p->pbuf.payload = NULL;
;;;405      }
;;;406      p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
;;;407      p->pbuf.len = p->pbuf.tot_len = length;
;;;408      p->pbuf.type = type;
;;;409      p->pbuf.ref = 1;
;;;410      return &p->pbuf;
;;;411    }
00004c  e8bd87f0          POP      {r4-r10,pc}
                  |L2.80|
000050  bf00              NOP                            ;378
000052  1ce8              ADDS     r0,r5,#3              ;395
000054  f0200003          BIC      r0,r0,#3              ;395
000058  4430              ADD      r0,r0,r6              ;395
00005a  4550              CMP      r0,r10                ;395
00005c  dd03              BLE      |L2.102|
00005e  bf00              NOP                            ;396
000060  bf00              NOP                            ;396
000062  2000              MOVS     r0,#0                 ;397
000064  e7f2              B        |L2.76|
                  |L2.102|
000066  2000              MOVS     r0,#0                 ;400
000068  6020              STR      r0,[r4,#0]            ;400
00006a  f1b90f00          CMP      r9,#0                 ;401
00006e  d005              BEQ      |L2.124|
000070  1ce8              ADDS     r0,r5,#3              ;402
000072  f0200003          BIC      r0,r0,#3              ;402
000076  4448              ADD      r0,r0,r9              ;402
000078  6060              STR      r0,[r4,#4]            ;402
00007a  e001              B        |L2.128|
                  |L2.124|
00007c  2000              MOVS     r0,#0                 ;404
00007e  6060              STR      r0,[r4,#4]            ;404
                  |L2.128|
000080  2002              MOVS     r0,#2                 ;406
000082  7360              STRB     r0,[r4,#0xd]          ;406
000084  8126              STRH     r6,[r4,#8]            ;407
000086  8166              STRH     r6,[r4,#0xa]          ;407
000088  f884800c          STRB     r8,[r4,#0xc]          ;408
00008c  2001              MOVS     r0,#1                 ;409
00008e  81e0              STRH     r0,[r4,#0xe]          ;409
000090  4620              MOV      r0,r4                 ;410
000092  e7db              B        |L2.76|
;;;412    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
                          ENDP

                  |L2.148|
000094  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\pbuf.c",0
000098  5749505c
00009c  6c776970
0000a0  2d312e34
0000a4  2e315c73
0000a8  72635c63
0000ac  6f72655c
0000b0  70627566
0000b4  2e6300  
0000b7  00                DCB      0
                  |L2.184|
0000b8  70627566          DCB      "pbuf_alloced_custom: bad pbuf layer",0
0000bc  5f616c6c
0000c0  6f636564
0000c4  5f637573
0000c8  746f6d3a
0000cc  20626164
0000d0  20706275
0000d4  66206c61
0000d8  79657200
                  |L2.220|
0000dc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000e0  7274696f
0000e4  6e202225
0000e8  73222066
0000ec  61696c65
0000f0  64206174
0000f4  206c696e
0000f8  65202564
0000fc  20696e20
000100  25730d0a
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0

                          AREA ||i.pbuf_cat||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_cat PROC
;;;744    void
;;;745    pbuf_cat(struct pbuf *h, struct pbuf *t)
000000  b570              PUSH     {r4-r6,lr}
;;;746    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;747      struct pbuf *p;
;;;748    
;;;749      LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
000006  bf00              NOP      
000008  b10e              CBZ      r6,|L3.14|
00000a  2d00              CMP      r5,#0
00000c  d109              BNE      |L3.34|
                  |L3.14|
00000e  bf00              NOP      
000010  a31b              ADR      r3,|L3.128|
000012  f24022ed          MOV      r2,#0x2ed
000016  a123              ADR      r1,|L3.164|
000018  a030              ADR      r0,|L3.220|
00001a  f7fffffe          BL       __2printf
00001e  bf00              NOP      
                  |L3.32|
;;;750                 ((h != NULL) && (t != NULL)), return;);
;;;751    
;;;752      /* proceed to last pbuf of chain */
;;;753      for (p = h; p->next != NULL; p = p->next) {
;;;754        /* add total length of second chain to all totals of first chain */
;;;755        p->tot_len += t->tot_len;
;;;756      }
;;;757      /* { p is last pbuf of first h chain, p->next == NULL } */
;;;758      LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
;;;759      LWIP_ASSERT("p->next == NULL", p->next == NULL);
;;;760      /* add total length of second chain to last pbuf total of first chain */
;;;761      p->tot_len += t->tot_len;
;;;762      /* chain last pbuf of head (p) with first of tail (t) */
;;;763      p->next = t;
;;;764      /* p->next now references t, but the caller will drop its reference to t,
;;;765       * so netto there is no change to the reference count of t.
;;;766       */
;;;767    }
000020  bd70              POP      {r4-r6,pc}
                  |L3.34|
000022  bf00              NOP                            ;749
000024  4634              MOV      r4,r6                 ;753
000026  e004              B        |L3.50|
                  |L3.40|
000028  8920              LDRH     r0,[r4,#8]            ;755
00002a  8929              LDRH     r1,[r5,#8]            ;755
00002c  4408              ADD      r0,r0,r1              ;755
00002e  8120              STRH     r0,[r4,#8]            ;755
000030  6824              LDR      r4,[r4,#0]            ;753
                  |L3.50|
000032  6820              LDR      r0,[r4,#0]            ;753
000034  2800              CMP      r0,#0                 ;753
000036  d1f7              BNE      |L3.40|
000038  bf00              NOP                            ;758
00003a  8920              LDRH     r0,[r4,#8]            ;758
00003c  8961              LDRH     r1,[r4,#0xa]          ;758
00003e  4288              CMP      r0,r1                 ;758
000040  d008              BEQ      |L3.84|
000042  bf00              NOP                            ;758
000044  a30e              ADR      r3,|L3.128|
000046  f24022f6          MOV      r2,#0x2f6             ;758
00004a  a12f              ADR      r1,|L3.264|
00004c  a023              ADR      r0,|L3.220|
00004e  f7fffffe          BL       __2printf
000052  bf00              NOP                            ;758
                  |L3.84|
000054  bf00              NOP                            ;758
000056  bf00              NOP                            ;759
000058  6820              LDR      r0,[r4,#0]            ;759
00005a  b140              CBZ      r0,|L3.110|
00005c  bf00              NOP                            ;759
00005e  a308              ADR      r3,|L3.128|
000060  f24022f7          MOV      r2,#0x2f7             ;759
000064  a134              ADR      r1,|L3.312|
000066  a01d              ADR      r0,|L3.220|
000068  f7fffffe          BL       __2printf
00006c  bf00              NOP                            ;759
                  |L3.110|
00006e  bf00              NOP                            ;759
000070  8920              LDRH     r0,[r4,#8]            ;761
000072  8929              LDRH     r1,[r5,#8]            ;761
000074  4408              ADD      r0,r0,r1              ;761
000076  8120              STRH     r0,[r4,#8]            ;761
000078  6025              STR      r5,[r4,#0]            ;763
00007a  bf00              NOP      
00007c  e7d0              B        |L3.32|
;;;768    
                          ENDP

00007e  0000              DCW      0x0000
                  |L3.128|
000080  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\pbuf.c",0
000084  5749505c
000088  6c776970
00008c  2d312e34
000090  2e315c73
000094  72635c63
000098  6f72655c
00009c  70627566
0000a0  2e6300  
0000a3  00                DCB      0
                  |L3.164|
0000a4  28682021          DCB      "(h != NULL) && (t != NULL) (programmer violates API)",0
0000a8  3d204e55
0000ac  4c4c2920
0000b0  26262028
0000b4  7420213d
0000b8  204e554c
0000bc  4c292028
0000c0  70726f67
0000c4  72616d6d
0000c8  65722076
0000cc  696f6c61
0000d0  74657320
0000d4  41504929
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L3.220|
0000dc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000e0  7274696f
0000e4  6e202225
0000e8  73222066
0000ec  61696c65
0000f0  64206174
0000f4  206c696e
0000f8  65202564
0000fc  20696e20
000100  25730d0a
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0
                  |L3.264|
000108  702d3e74          DCB      "p->tot_len == p->len (of last pbuf in chain)",0
00010c  6f745f6c
000110  656e203d
000114  3d20702d
000118  3e6c656e
00011c  20286f66
000120  206c6173
000124  74207062
000128  75662069
00012c  6e206368
000130  61696e29
000134  00      
000135  00                DCB      0
000136  00                DCB      0
000137  00                DCB      0
                  |L3.312|
000138  702d3e6e          DCB      "p->next == NULL",0
00013c  65787420
000140  3d3d204e
000144  554c4c00

                          AREA ||i.pbuf_chain||, CODE, READONLY, ALIGN=1

                  pbuf_chain PROC
;;;785    void
;;;786    pbuf_chain(struct pbuf *h, struct pbuf *t)
000000  b570              PUSH     {r4-r6,lr}
;;;787    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;788      pbuf_cat(h, t);
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       pbuf_cat
;;;789      /* t is now referenced by h */
;;;790      pbuf_ref(t);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       pbuf_ref
;;;791      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
000014  bf00              NOP      
000016  bf00              NOP      
;;;792    }
000018  bd70              POP      {r4-r6,pc}
;;;793    
                          ENDP


                          AREA ||i.pbuf_clen||, CODE, READONLY, ALIGN=1

                  pbuf_clen PROC
;;;703    u8_t
;;;704    pbuf_clen(struct pbuf *p)
000000  4601              MOV      r1,r0
;;;705    {
;;;706      u8_t len;
;;;707    
;;;708      len = 0;
000002  2000              MOVS     r0,#0
;;;709      while (p != NULL) {
000004  e002              B        |L5.12|
                  |L5.6|
;;;710        ++len;
000006  1c42              ADDS     r2,r0,#1
000008  b2d0              UXTB     r0,r2
;;;711        p = p->next;
00000a  6809              LDR      r1,[r1,#0]
                  |L5.12|
00000c  2900              CMP      r1,#0                 ;709
00000e  d1fa              BNE      |L5.6|
;;;712      }
;;;713      return len;
;;;714    }
000010  4770              BX       lr
;;;715    
                          ENDP


                          AREA ||i.pbuf_coalesce||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  pbuf_coalesce PROC
;;;1009   struct pbuf*
;;;1010   pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1011   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;1012     struct pbuf *q;
;;;1013     err_t err;
;;;1014     if (p->next == NULL) {
000008  6820              LDR      r0,[r4,#0]
00000a  b910              CBNZ     r0,|L6.18|
;;;1015       return p;
00000c  4620              MOV      r0,r4
                  |L6.14|
;;;1016     }
;;;1017     q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
;;;1018     if (q == NULL) {
;;;1019       /* @todo: what do we do now? */
;;;1020       return p;
;;;1021     }
;;;1022     err = pbuf_copy(q, p);
;;;1023     LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
;;;1024     pbuf_free(p);
;;;1025     return q;
;;;1026   }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L6.18|
000012  8921              LDRH     r1,[r4,#8]            ;1017
000014  2200              MOVS     r2,#0                 ;1017
000016  4638              MOV      r0,r7                 ;1017
000018  f7fffffe          BL       pbuf_alloc
00001c  4605              MOV      r5,r0                 ;1017
00001e  b90d              CBNZ     r5,|L6.36|
000020  4620              MOV      r0,r4                 ;1020
000022  e7f4              B        |L6.14|
                  |L6.36|
000024  4621              MOV      r1,r4                 ;1022
000026  4628              MOV      r0,r5                 ;1022
000028  f7fffffe          BL       pbuf_copy
00002c  4606              MOV      r6,r0                 ;1022
00002e  bf00              NOP                            ;1023
000030  b146              CBZ      r6,|L6.68|
000032  bf00              NOP                            ;1023
000034  a306              ADR      r3,|L6.80|
000036  f24032ff          MOV      r2,#0x3ff             ;1023
00003a  a10e              ADR      r1,|L6.116|
00003c  a012              ADR      r0,|L6.136|
00003e  f7fffffe          BL       __2printf
000042  bf00              NOP                            ;1023
                  |L6.68|
000044  bf00              NOP                            ;1023
000046  4620              MOV      r0,r4                 ;1024
000048  f7fffffe          BL       pbuf_free
00004c  4628              MOV      r0,r5                 ;1025
00004e  e7de              B        |L6.14|
;;;1027   
                          ENDP

                  |L6.80|
000050  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\pbuf.c",0
000054  5749505c
000058  6c776970
00005c  2d312e34
000060  2e315c73
000064  72635c63
000068  6f72655c
00006c  70627566
000070  2e6300  
000073  00                DCB      0
                  |L6.116|
000074  70627566          DCB      "pbuf_copy failed",0
000078  5f636f70
00007c  79206661
000080  696c6564
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
                  |L6.136|
000088  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
00008c  7274696f
000090  6e202225
000094  73222066
000098  61696c65
00009c  64206174
0000a0  206c696e
0000a4  65202564
0000a8  20696e20
0000ac  25730d0a
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0

                          AREA ||i.pbuf_copy||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_copy PROC
;;;851    err_t
;;;852    pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;853    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;854      u16_t offset_to=0, offset_from=0, len;
000008  2600              MOVS     r6,#0
00000a  2700              MOVS     r7,#0
;;;855    
;;;856      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
00000c  bf00              NOP      
00000e  bf00              NOP      
;;;857        (void*)p_to, (void*)p_from));
;;;858    
;;;859      /* is the target big enough to hold the source? */
;;;860      LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
000010  bf00              NOP      
000012  b125              CBZ      r5,|L7.30|
000014  b11c              CBZ      r4,|L7.30|
000016  8928              LDRH     r0,[r5,#8]
000018  8921              LDRH     r1,[r4,#8]
00001a  4288              CMP      r0,r1
00001c  da0c              BGE      |L7.56|
                  |L7.30|
00001e  bf00              NOP      
000020  a349              ADR      r3,|L7.328|
000022  f44f7257          MOV      r2,#0x35c
000026  a151              ADR      r1,|L7.364|
000028  a05c              ADR      r0,|L7.412|
00002a  f7fffffe          BL       __2printf
00002e  bf00              NOP      
000030  f06f000d          MVN      r0,#0xd
                  |L7.52|
;;;861                 (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);
;;;862    
;;;863      /* iterate through pbuf chain */
;;;864      do
;;;865      {
;;;866        /* copy one part of the original chain */
;;;867        if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
;;;868          /* complete current p_from fits into current p_to */
;;;869          len = p_from->len - offset_from;
;;;870        } else {
;;;871          /* current p_from does not fit into current p_to */
;;;872          len = p_to->len - offset_to;
;;;873        }
;;;874        MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
;;;875        offset_to += len;
;;;876        offset_from += len;
;;;877        LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
;;;878        LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
;;;879        if (offset_from >= p_from->len) {
;;;880          /* on to next p_from (if any) */
;;;881          offset_from = 0;
;;;882          p_from = p_from->next;
;;;883        }
;;;884        if (offset_to == p_to->len) {
;;;885          /* on to next p_to (if any) */
;;;886          offset_to = 0;
;;;887          p_to = p_to->next;
;;;888          LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
;;;889        }
;;;890    
;;;891        if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
;;;892          /* don't copy more than one packet! */
;;;893          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
;;;894                     (p_from->next == NULL), return ERR_VAL;);
;;;895        }
;;;896        if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
;;;897          /* don't copy more than one packet! */
;;;898          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
;;;899                      (p_to->next == NULL), return ERR_VAL;);
;;;900        }
;;;901      } while (p_from);
;;;902      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
;;;903      return ERR_OK;
;;;904    }
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L7.56|
000038  bf00              NOP                            ;860
00003a  bf00              NOP                            ;864
                  |L7.60|
00003c  8968              LDRH     r0,[r5,#0xa]          ;867
00003e  1b80              SUBS     r0,r0,r6              ;867
000040  8961              LDRH     r1,[r4,#0xa]          ;867
000042  1bc9              SUBS     r1,r1,r7              ;867
000044  4288              CMP      r0,r1                 ;867
000046  db04              BLT      |L7.82|
000048  8960              LDRH     r0,[r4,#0xa]          ;869
00004a  1bc0              SUBS     r0,r0,r7              ;869
00004c  fa1ff880          UXTH     r8,r0                 ;869
000050  e003              B        |L7.90|
                  |L7.82|
000052  8968              LDRH     r0,[r5,#0xa]          ;872
000054  1b80              SUBS     r0,r0,r6              ;872
000056  fa1ff880          UXTH     r8,r0                 ;872
                  |L7.90|
00005a  6862              LDR      r2,[r4,#4]            ;874
00005c  19d1              ADDS     r1,r2,r7              ;874
00005e  686a              LDR      r2,[r5,#4]            ;874
000060  1990              ADDS     r0,r2,r6              ;874
000062  4642              MOV      r2,r8                 ;874
000064  f7fffffe          BL       __aeabi_memcpy
000068  eb060008          ADD      r0,r6,r8              ;875
00006c  b286              UXTH     r6,r0                 ;875
00006e  eb070008          ADD      r0,r7,r8              ;876
000072  b287              UXTH     r7,r0                 ;876
000074  bf00              NOP                            ;877
000076  8968              LDRH     r0,[r5,#0xa]          ;877
000078  42b0              CMP      r0,r6                 ;877
00007a  da08              BGE      |L7.142|
00007c  bf00              NOP                            ;877
00007e  a332              ADR      r3,|L7.328|
000080  f240326d          MOV      r2,#0x36d             ;877
000084  a150              ADR      r1,|L7.456|
000086  a045              ADR      r0,|L7.412|
000088  f7fffffe          BL       __2printf
00008c  bf00              NOP                            ;877
                  |L7.142|
00008e  bf00              NOP                            ;877
000090  bf00              NOP                            ;878
000092  8960              LDRH     r0,[r4,#0xa]          ;878
000094  42b8              CMP      r0,r7                 ;878
000096  da08              BGE      |L7.170|
000098  bf00              NOP                            ;878
00009a  a32b              ADR      r3,|L7.328|
00009c  f240326e          MOV      r2,#0x36e             ;878
0000a0  a14f              ADR      r1,|L7.480|
0000a2  a03e              ADR      r0,|L7.412|
0000a4  f7fffffe          BL       __2printf
0000a8  bf00              NOP                            ;878
                  |L7.170|
0000aa  bf00              NOP                            ;878
0000ac  8960              LDRH     r0,[r4,#0xa]          ;879
0000ae  42b8              CMP      r0,r7                 ;879
0000b0  dc01              BGT      |L7.182|
0000b2  2700              MOVS     r7,#0                 ;881
0000b4  6824              LDR      r4,[r4,#0]            ;882
                  |L7.182|
0000b6  8968              LDRH     r0,[r5,#0xa]          ;884
0000b8  42b0              CMP      r0,r6                 ;884
0000ba  d111              BNE      |L7.224|
0000bc  2600              MOVS     r6,#0                 ;886
0000be  682d              LDR      r5,[r5,#0]            ;887
0000c0  bf00              NOP                            ;888
0000c2  b965              CBNZ     r5,|L7.222|
0000c4  b15c              CBZ      r4,|L7.222|
0000c6  bf00              NOP                            ;888
0000c8  a31f              ADR      r3,|L7.328|
0000ca  f44f725e          MOV      r2,#0x378             ;888
0000ce  a14b              ADR      r1,|L7.508|
0000d0  a032              ADR      r0,|L7.412|
0000d2  f7fffffe          BL       __2printf
0000d6  bf00              NOP                            ;888
0000d8  f06f000d          MVN      r0,#0xd               ;888
0000dc  e7aa              B        |L7.52|
                  |L7.222|
0000de  bf00              NOP                            ;888
                  |L7.224|
0000e0  2c00              CMP      r4,#0                 ;891
0000e2  d013              BEQ      |L7.268|
0000e4  8960              LDRH     r0,[r4,#0xa]          ;891
0000e6  8921              LDRH     r1,[r4,#8]            ;891
0000e8  4288              CMP      r0,r1                 ;891
0000ea  d10f              BNE      |L7.268|
0000ec  bf00              NOP                            ;893
0000ee  6820              LDR      r0,[r4,#0]            ;893
0000f0  b158              CBZ      r0,|L7.266|
0000f2  bf00              NOP                            ;893
0000f4  a314              ADR      r3,|L7.328|
0000f6  f240327d          MOV      r2,#0x37d             ;893
0000fa  a144              ADR      r1,|L7.524|
0000fc  a027              ADR      r0,|L7.412|
0000fe  f7fffffe          BL       __2printf
000102  bf00              NOP                            ;893
000104  f06f0005          MVN      r0,#5                 ;893
000108  e794              B        |L7.52|
                  |L7.266|
00010a  bf00              NOP                            ;893
                  |L7.268|
00010c  2d00              CMP      r5,#0                 ;896
00010e  d013              BEQ      |L7.312|
000110  8968              LDRH     r0,[r5,#0xa]          ;896
000112  8929              LDRH     r1,[r5,#8]            ;896
000114  4288              CMP      r0,r1                 ;896
000116  d10f              BNE      |L7.312|
000118  bf00              NOP                            ;898
00011a  6828              LDR      r0,[r5,#0]            ;898
00011c  b158              CBZ      r0,|L7.310|
00011e  bf00              NOP                            ;898
000120  a309              ADR      r3,|L7.328|
000122  f2403282          MOV      r2,#0x382             ;898
000126  a139              ADR      r1,|L7.524|
000128  a01c              ADR      r0,|L7.412|
00012a  f7fffffe          BL       __2printf
00012e  bf00              NOP                            ;898
000130  f06f0005          MVN      r0,#5                 ;898
000134  e77e              B        |L7.52|
                  |L7.310|
000136  bf00              NOP                            ;898
                  |L7.312|
000138  2c00              CMP      r4,#0                 ;901
00013a  f47faf7f          BNE      |L7.60|
00013e  bf00              NOP                            ;902
000140  bf00              NOP                            ;902
000142  2000              MOVS     r0,#0                 ;903
000144  e776              B        |L7.52|
;;;905    
                          ENDP

000146  0000              DCW      0x0000
                  |L7.328|
000148  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\pbuf.c",0
00014c  5749505c
000150  6c776970
000154  2d312e34
000158  2e315c73
00015c  72635c63
000160  6f72655c
000164  70627566
000168  2e6300  
00016b  00                DCB      0
                  |L7.364|
00016c  70627566          DCB      "pbuf_copy: target not big enough to hold source",0
000170  5f636f70
000174  793a2074
000178  61726765
00017c  74206e6f
000180  74206269
000184  6720656e
000188  6f756768
00018c  20746f20
000190  686f6c64
000194  20736f75
000198  72636500
                  |L7.412|
00019c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0001a0  7274696f
0001a4  6e202225
0001a8  73222066
0001ac  61696c65
0001b0  64206174
0001b4  206c696e
0001b8  65202564
0001bc  20696e20
0001c0  25730d0a
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L7.456|
0001c8  6f666673          DCB      "offset_to <= p_to->len",0
0001cc  65745f74
0001d0  6f203c3d
0001d4  20705f74
0001d8  6f2d3e6c
0001dc  656e00  
0001df  00                DCB      0
                  |L7.480|
0001e0  6f666673          DCB      "offset_from <= p_from->len",0
0001e4  65745f66
0001e8  726f6d20
0001ec  3c3d2070
0001f0  5f66726f
0001f4  6d2d3e6c
0001f8  656e00  
0001fb  00                DCB      0
                  |L7.508|
0001fc  705f746f          DCB      "p_to != NULL",0
000200  20213d20
000204  4e554c4c
000208  00      
000209  00                DCB      0
00020a  00                DCB      0
00020b  00                DCB      0
                  |L7.524|
00020c  70627566          DCB      "pbuf_copy() does not allow packet queues!\n",0
000210  5f636f70
000214  79282920
000218  646f6573
00021c  206e6f74
000220  20616c6c
000224  6f772070
000228  61636b65
00022c  74207175
000230  65756573
000234  210a00  
000237  00                DCB      0

                          AREA ||i.pbuf_copy_partial||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_copy_partial PROC
;;;917    u16_t
;;;918    pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;919    {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
00000a  461d              MOV      r5,r3
;;;920      struct pbuf *p;
;;;921      u16_t left;
;;;922      u16_t buf_copy_len;
;;;923      u16_t copied_total = 0;
00000c  f04f0b00          MOV      r11,#0
;;;924    
;;;925      LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
000010  bf00              NOP      
000012  f1b80f00          CMP      r8,#0
000016  d10b              BNE      |L8.48|
000018  bf00              NOP      
00001a  a327              ADR      r3,|L8.184|
00001c  f240329d          MOV      r2,#0x39d
000020  a12e              ADR      r1,|L8.220|
000022  a036              ADR      r0,|L8.252|
000024  f7fffffe          BL       __2printf
000028  bf00              NOP      
00002a  2000              MOVS     r0,#0
                  |L8.44|
;;;926      LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
;;;927    
;;;928      left = 0;
;;;929    
;;;930      if((buf == NULL) || (dataptr == NULL)) {
;;;931        return 0;
;;;932      }
;;;933    
;;;934      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;935      for(p = buf; len != 0 && p != NULL; p = p->next) {
;;;936        if ((offset != 0) && (offset >= p->len)) {
;;;937          /* don't copy from this buffer -> on to the next */
;;;938          offset -= p->len;
;;;939        } else {
;;;940          /* copy from this buffer. maybe only partially. */
;;;941          buf_copy_len = p->len - offset;
;;;942          if (buf_copy_len > len)
;;;943              buf_copy_len = len;
;;;944          /* copy the necessary parts of the buffer */
;;;945          MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
;;;946          copied_total += buf_copy_len;
;;;947          left += buf_copy_len;
;;;948          len -= buf_copy_len;
;;;949          offset = 0;
;;;950        }
;;;951      }
;;;952      return copied_total;
;;;953    }
00002c  e8bd9ff0          POP      {r4-r12,pc}
                  |L8.48|
000030  bf00              NOP                            ;925
000032  bf00              NOP                            ;926
000034  f1b90f00          CMP      r9,#0                 ;926
000038  d10a              BNE      |L8.80|
00003a  bf00              NOP                            ;926
00003c  a31e              ADR      r3,|L8.184|
00003e  f240329e          MOV      r2,#0x39e             ;926
000042  a139              ADR      r1,|L8.296|
000044  a02d              ADR      r0,|L8.252|
000046  f7fffffe          BL       __2printf
00004a  bf00              NOP                            ;926
00004c  2000              MOVS     r0,#0                 ;926
00004e  e7ed              B        |L8.44|
                  |L8.80|
000050  bf00              NOP                            ;926
000052  f04f0a00          MOV      r10,#0                ;928
000056  f1b80f00          CMP      r8,#0                 ;930
00005a  d002              BEQ      |L8.98|
00005c  f1b90f00          CMP      r9,#0                 ;930
000060  d101              BNE      |L8.102|
                  |L8.98|
000062  2000              MOVS     r0,#0                 ;931
000064  e7e2              B        |L8.44|
                  |L8.102|
000066  4644              MOV      r4,r8                 ;935
000068  e020              B        |L8.172|
                  |L8.106|
00006a  b135              CBZ      r5,|L8.122|
00006c  8960              LDRH     r0,[r4,#0xa]          ;936
00006e  42a8              CMP      r0,r5                 ;936
000070  dc03              BGT      |L8.122|
000072  8960              LDRH     r0,[r4,#0xa]          ;938
000074  1a28              SUBS     r0,r5,r0              ;938
000076  b285              UXTH     r5,r0                 ;938
000078  e017              B        |L8.170|
                  |L8.122|
00007a  8960              LDRH     r0,[r4,#0xa]          ;941
00007c  1b40              SUBS     r0,r0,r5              ;941
00007e  b287              UXTH     r7,r0                 ;941
000080  42b7              CMP      r7,r6                 ;942
000082  dd00              BLE      |L8.134|
000084  4637              MOV      r7,r6                 ;943
                  |L8.134|
000086  6862              LDR      r2,[r4,#4]            ;945
000088  1951              ADDS     r1,r2,r5              ;945
00008a  eb09000a          ADD      r0,r9,r10             ;945
00008e  463a              MOV      r2,r7                 ;945
000090  f7fffffe          BL       __aeabi_memcpy
000094  eb0b0007          ADD      r0,r11,r7             ;946
000098  fa1ffb80          UXTH     r11,r0                ;946
00009c  eb0a0007          ADD      r0,r10,r7             ;947
0000a0  fa1ffa80          UXTH     r10,r0                ;947
0000a4  1bf0              SUBS     r0,r6,r7              ;948
0000a6  b286              UXTH     r6,r0                 ;948
0000a8  2500              MOVS     r5,#0                 ;949
                  |L8.170|
0000aa  6824              LDR      r4,[r4,#0]            ;935
                  |L8.172|
0000ac  b10e              CBZ      r6,|L8.178|
0000ae  2c00              CMP      r4,#0                 ;935
0000b0  d1db              BNE      |L8.106|
                  |L8.178|
0000b2  4658              MOV      r0,r11                ;952
0000b4  e7ba              B        |L8.44|
;;;954    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L8.184|
0000b8  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\pbuf.c",0
0000bc  5749505c
0000c0  6c776970
0000c4  2d312e34
0000c8  2e315c73
0000cc  72635c63
0000d0  6f72655c
0000d4  70627566
0000d8  2e6300  
0000db  00                DCB      0
                  |L8.220|
0000dc  70627566          DCB      "pbuf_copy_partial: invalid buf",0
0000e0  5f636f70
0000e4  795f7061
0000e8  72746961
0000ec  6c3a2069
0000f0  6e76616c
0000f4  69642062
0000f8  756600  
0000fb  00                DCB      0
                  |L8.252|
0000fc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000100  7274696f
000104  6e202225
000108  73222066
00010c  61696c65
000110  64206174
000114  206c696e
000118  65202564
00011c  20696e20
000120  25730d0a
000124  00      
000125  00                DCB      0
000126  00                DCB      0
000127  00                DCB      0
                  |L8.296|
000128  70627566          DCB      "pbuf_copy_partial: invalid dataptr",0
00012c  5f636f70
000130  795f7061
000134  72746961
000138  6c3a2069
00013c  6e76616c
000140  69642064
000144  61746170
000148  747200  
00014b  00                DCB      0

                          AREA ||i.pbuf_dechain||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_dechain PROC
;;;802    struct pbuf *
;;;803    pbuf_dechain(struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;804    {
000002  4604              MOV      r4,r0
;;;805      struct pbuf *q;
;;;806      u8_t tail_gone = 1;
000004  2601              MOVS     r6,#1
;;;807      /* tail */
;;;808      q = p->next;
000006  6825              LDR      r5,[r4,#0]
;;;809      /* pbuf has successor in chain? */
;;;810      if (q != NULL) {
000008  2d00              CMP      r5,#0
00000a  d022              BEQ      |L9.82|
;;;811        /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;812        LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
00000c  bf00              NOP      
00000e  8920              LDRH     r0,[r4,#8]
000010  8961              LDRH     r1,[r4,#0xa]
000012  1a40              SUBS     r0,r0,r1
000014  8929              LDRH     r1,[r5,#8]
000016  4288              CMP      r0,r1
000018  d008              BEQ      |L9.44|
00001a  bf00              NOP      
00001c  a317              ADR      r3,|L9.124|
00001e  f44f724b          MOV      r2,#0x32c
000022  a11f              ADR      r1,|L9.160|
000024  a027              ADR      r0,|L9.196|
000026  f7fffffe          BL       __2printf
00002a  bf00              NOP      
                  |L9.44|
00002c  bf00              NOP      
;;;813        /* enforce invariant if assertion is disabled */
;;;814        q->tot_len = p->tot_len - p->len;
00002e  8920              LDRH     r0,[r4,#8]
000030  8961              LDRH     r1,[r4,#0xa]
000032  1a40              SUBS     r0,r0,r1
000034  8128              STRH     r0,[r5,#8]
;;;815        /* decouple pbuf from remainder */
;;;816        p->next = NULL;
000036  2000              MOVS     r0,#0
000038  6020              STR      r0,[r4,#0]
;;;817        /* total length of pbuf p is its own length only */
;;;818        p->tot_len = p->len;
00003a  8960              LDRH     r0,[r4,#0xa]
00003c  8120              STRH     r0,[r4,#8]
;;;819        /* q is no longer referenced by p, free it */
;;;820        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
00003e  bf00              NOP      
000040  bf00              NOP      
;;;821        tail_gone = pbuf_free(q);
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       pbuf_free
000048  4606              MOV      r6,r0
;;;822        if (tail_gone > 0) {
00004a  2e00              CMP      r6,#0
00004c  dd01              BLE      |L9.82|
;;;823          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE,
00004e  bf00              NOP      
000050  bf00              NOP      
                  |L9.82|
;;;824                      ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
;;;825        }
;;;826        /* return remaining tail or NULL if deallocated */
;;;827      }
;;;828      /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;829      LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
000052  bf00              NOP      
000054  8920              LDRH     r0,[r4,#8]
000056  8961              LDRH     r1,[r4,#0xa]
000058  4288              CMP      r0,r1
00005a  d008              BEQ      |L9.110|
00005c  bf00              NOP      
00005e  a307              ADR      r3,|L9.124|
000060  f240323d          MOV      r2,#0x33d
000064  a122              ADR      r1,|L9.240|
000066  a017              ADR      r0,|L9.196|
000068  f7fffffe          BL       __2printf
00006c  bf00              NOP      
                  |L9.110|
00006e  bf00              NOP      
;;;830      return ((tail_gone > 0) ? NULL : q);
000070  2e00              CMP      r6,#0
000072  dd01              BLE      |L9.120|
000074  2000              MOVS     r0,#0
                  |L9.118|
;;;831    }
000076  bd70              POP      {r4-r6,pc}
                  |L9.120|
000078  4628              MOV      r0,r5                 ;830
00007a  e7fc              B        |L9.118|
;;;832    
                          ENDP

                  |L9.124|
00007c  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\pbuf.c",0
000080  5749505c
000084  6c776970
000088  2d312e34
00008c  2e315c73
000090  72635c63
000094  6f72655c
000098  70627566
00009c  2e6300  
00009f  00                DCB      0
                  |L9.160|
0000a0  702d3e74          DCB      "p->tot_len == p->len + q->tot_len",0
0000a4  6f745f6c
0000a8  656e203d
0000ac  3d20702d
0000b0  3e6c656e
0000b4  202b2071
0000b8  2d3e746f
0000bc  745f6c65
0000c0  6e00    
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L9.196|
0000c4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000c8  7274696f
0000cc  6e202225
0000d0  73222066
0000d4  61696c65
0000d8  64206174
0000dc  206c696e
0000e0  65202564
0000e4  20696e20
0000e8  25730d0a
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L9.240|
0000f0  702d3e74          DCB      "p->tot_len == p->len",0
0000f4  6f745f6c
0000f8  656e203d
0000fc  3d20702d
000100  3e6c656e
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0

                          AREA ||i.pbuf_free||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_free PROC
;;;617    u8_t
;;;618    pbuf_free(struct pbuf *p)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;619    {
000004  4604              MOV      r4,r0
;;;620      u16_t type;
;;;621      struct pbuf *q;
;;;622      u8_t count;
;;;623    
;;;624      if (p == NULL) {
000006  b984              CBNZ     r4,|L10.42|
;;;625        LWIP_ASSERT("p != NULL", p != NULL);
000008  bf00              NOP      
00000a  b944              CBNZ     r4,|L10.30|
00000c  bf00              NOP      
00000e  a340              ADR      r3,|L10.272|
000010  f2402271          MOV      r2,#0x271
000014  a147              ADR      r1,|L10.308|
000016  a04a              ADR      r0,|L10.320|
000018  f7fffffe          BL       __2printf
00001c  bf00              NOP      
                  |L10.30|
00001e  bf00              NOP      
;;;626        /* if assertions are disabled, proceed with debug output */
;;;627        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
000020  bf00              NOP      
000022  bf00              NOP      
;;;628          ("pbuf_free(p == NULL) was called.\n"));
;;;629        return 0;
000024  2000              MOVS     r0,#0
                  |L10.38|
;;;630      }
;;;631      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));
;;;632    
;;;633      PERF_START;
;;;634    
;;;635      LWIP_ASSERT("pbuf_free: sane type",
;;;636        p->type == PBUF_RAM || p->type == PBUF_ROM ||
;;;637        p->type == PBUF_REF || p->type == PBUF_POOL);
;;;638    
;;;639      count = 0;
;;;640      /* de-allocate all consecutive pbufs from the head of the chain that
;;;641       * obtain a zero reference count after decrementing*/
;;;642      while (p != NULL) {
;;;643        u16_t ref;
;;;644        SYS_ARCH_DECL_PROTECT(old_level);
;;;645        /* Since decrementing ref cannot be guaranteed to be a single machine operation
;;;646         * we must protect it. We put the new ref into a local variable to prevent
;;;647         * further protection. */
;;;648        SYS_ARCH_PROTECT(old_level);
;;;649        /* all pbufs in a chain are referenced at least once */
;;;650        LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
;;;651        /* decrease reference count (number of pointers to pbuf) */
;;;652        ref = --(p->ref);
;;;653        SYS_ARCH_UNPROTECT(old_level);
;;;654        /* this pbuf is no longer referenced to? */
;;;655        if (ref == 0) {
;;;656          /* remember next pbuf in chain for next iteration */
;;;657          q = p->next;
;;;658          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
;;;659          type = p->type;
;;;660    #if LWIP_SUPPORT_CUSTOM_PBUF
;;;661          /* is this a custom pbuf? */
;;;662          if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
;;;663            struct pbuf_custom *pc = (struct pbuf_custom*)p;
;;;664            LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
;;;665            pc->custom_free_function(p);
;;;666          } else
;;;667    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
;;;668          {
;;;669            /* is this a pbuf from the pool? */
;;;670            if (type == PBUF_POOL) {
;;;671              memp_free(MEMP_PBUF_POOL, p);
;;;672            /* is this a ROM or RAM referencing pbuf? */
;;;673            } else if (type == PBUF_ROM || type == PBUF_REF) {
;;;674              memp_free(MEMP_PBUF, p);
;;;675            /* type == PBUF_RAM */
;;;676            } else {
;;;677              mem_free(p);
;;;678            }
;;;679          }
;;;680          count++;
;;;681          /* proceed to next pbuf */
;;;682          p = q;
;;;683        /* p->ref > 0, this pbuf is still referenced to */
;;;684        /* (and so the remaining pbufs in chain as well) */
;;;685        } else {
;;;686          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
;;;687          /* stop walking through the chain */
;;;688          p = NULL;
;;;689        }
;;;690      }
;;;691      PERF_STOP("pbuf_free");
;;;692      /* return number of de-allocated pbufs */
;;;693      return count;
;;;694    }
000026  e8bd87f0          POP      {r4-r10,pc}
                  |L10.42|
00002a  bf00              NOP                            ;631
00002c  bf00              NOP                            ;631
00002e  bf00              NOP                            ;635
000030  7b20              LDRB     r0,[r4,#0xc]          ;635
000032  b188              CBZ      r0,|L10.88|
000034  7b20              LDRB     r0,[r4,#0xc]          ;635
000036  2801              CMP      r0,#1                 ;635
000038  d00e              BEQ      |L10.88|
00003a  7b20              LDRB     r0,[r4,#0xc]          ;635
00003c  2802              CMP      r0,#2                 ;635
00003e  d00b              BEQ      |L10.88|
000040  7b20              LDRB     r0,[r4,#0xc]          ;635
000042  2803              CMP      r0,#3                 ;635
000044  d008              BEQ      |L10.88|
000046  bf00              NOP                            ;635
000048  a331              ADR      r3,|L10.272|
00004a  f240227b          MOV      r2,#0x27b             ;635
00004e  a147              ADR      r1,|L10.364|
000050  a03b              ADR      r0,|L10.320|
000052  f7fffffe          BL       __2printf
000056  bf00              NOP                            ;635
                  |L10.88|
000058  bf00              NOP                            ;635
00005a  2600              MOVS     r6,#0                 ;639
00005c  e054              B        |L10.264|
                  |L10.94|
00005e  f7fffffe          BL       sys_arch_protect
000062  4682              MOV      r10,r0                ;648
000064  bf00              NOP                            ;650
000066  89e0              LDRH     r0,[r4,#0xe]          ;650
000068  2800              CMP      r0,#0                 ;650
00006a  dc08              BGT      |L10.126|
00006c  bf00              NOP                            ;650
00006e  a328              ADR      r3,|L10.272|
000070  f240228a          MOV      r2,#0x28a             ;650
000074  a143              ADR      r1,|L10.388|
000076  a032              ADR      r0,|L10.320|
000078  f7fffffe          BL       __2printf
00007c  bf00              NOP                            ;650
                  |L10.126|
00007e  bf00              NOP                            ;650
000080  89e0              LDRH     r0,[r4,#0xe]          ;652
000082  1e40              SUBS     r0,r0,#1              ;652
000084  fa1ff880          UXTH     r8,r0                 ;652
000088  f8a4800e          STRH     r8,[r4,#0xe]          ;652
00008c  4650              MOV      r0,r10                ;653
00008e  f7fffffe          BL       sys_arch_unprotect
000092  f1b80f00          CMP      r8,#0                 ;655
000096  d133              BNE      |L10.256|
000098  6827              LDR      r7,[r4,#0]            ;657
00009a  bf00              NOP                            ;658
00009c  bf00              NOP                            ;658
00009e  7b25              LDRB     r5,[r4,#0xc]          ;659
0000a0  7b60              LDRB     r0,[r4,#0xd]          ;662
0000a2  f0000002          AND      r0,r0,#2              ;662
0000a6  2800              CMP      r0,#0                 ;662
0000a8  d013              BEQ      |L10.210|
0000aa  46a1              MOV      r9,r4                 ;663
0000ac  bf00              NOP                            ;664
0000ae  f8d90010          LDR      r0,[r9,#0x10]         ;664
0000b2  b940              CBNZ     r0,|L10.198|
0000b4  bf00              NOP                            ;664
0000b6  a316              ADR      r3,|L10.272|
0000b8  f44f7226          MOV      r2,#0x298             ;664
0000bc  a137              ADR      r1,|L10.412|
0000be  a020              ADR      r0,|L10.320|
0000c0  f7fffffe          BL       __2printf
0000c4  bf00              NOP                            ;664
                  |L10.198|
0000c6  bf00              NOP                            ;664
0000c8  4620              MOV      r0,r4                 ;665
0000ca  f8d91010          LDR      r1,[r9,#0x10]         ;665
0000ce  4788              BLX      r1                    ;665
0000d0  e012              B        |L10.248|
                  |L10.210|
0000d2  2d03              CMP      r5,#3                 ;670
0000d4  d104              BNE      |L10.224|
0000d6  4621              MOV      r1,r4                 ;671
0000d8  200d              MOVS     r0,#0xd               ;671
0000da  f7fffffe          BL       memp_free
0000de  e00b              B        |L10.248|
                  |L10.224|
0000e0  2d01              CMP      r5,#1                 ;673
0000e2  d001              BEQ      |L10.232|
0000e4  2d02              CMP      r5,#2                 ;673
0000e6  d104              BNE      |L10.242|
                  |L10.232|
0000e8  4621              MOV      r1,r4                 ;674
0000ea  200c              MOVS     r0,#0xc               ;674
0000ec  f7fffffe          BL       memp_free
0000f0  e002              B        |L10.248|
                  |L10.242|
0000f2  4620              MOV      r0,r4                 ;677
0000f4  f7fffffe          BL       mem_free
                  |L10.248|
0000f8  1c70              ADDS     r0,r6,#1              ;680
0000fa  b2c6              UXTB     r6,r0                 ;680
0000fc  463c              MOV      r4,r7                 ;682
0000fe  e002              B        |L10.262|
                  |L10.256|
000100  bf00              NOP                            ;686
000102  bf00              NOP                            ;686
000104  2400              MOVS     r4,#0                 ;688
                  |L10.262|
000106  bf00              NOP                            ;690
                  |L10.264|
000108  2c00              CMP      r4,#0                 ;642
00010a  d1a8              BNE      |L10.94|
00010c  4630              MOV      r0,r6                 ;693
00010e  e78a              B        |L10.38|
;;;695    
                          ENDP

                  |L10.272|
000110  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\pbuf.c",0
000114  5749505c
000118  6c776970
00011c  2d312e34
000120  2e315c73
000124  72635c63
000128  6f72655c
00012c  70627566
000130  2e6300  
000133  00                DCB      0
                  |L10.308|
000134  7020213d          DCB      "p != NULL",0
000138  204e554c
00013c  4c00    
00013e  00                DCB      0
00013f  00                DCB      0
                  |L10.320|
000140  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000144  7274696f
000148  6e202225
00014c  73222066
000150  61696c65
000154  64206174
000158  206c696e
00015c  65202564
000160  20696e20
000164  25730d0a
000168  00      
000169  00                DCB      0
00016a  00                DCB      0
00016b  00                DCB      0
                  |L10.364|
00016c  70627566          DCB      "pbuf_free: sane type",0
000170  5f667265
000174  653a2073
000178  616e6520
00017c  74797065
000180  00      
000181  00                DCB      0
000182  00                DCB      0
000183  00                DCB      0
                  |L10.388|
000184  70627566          DCB      "pbuf_free: p->ref > 0",0
000188  5f667265
00018c  653a2070
000190  2d3e7265
000194  66203e20
000198  3000    
00019a  00                DCB      0
00019b  00                DCB      0
                  |L10.412|
00019c  70632d3e          DCB      "pc->custom_free_function != NULL",0
0001a0  63757374
0001a4  6f6d5f66
0001a8  7265655f
0001ac  66756e63
0001b0  74696f6e
0001b4  20213d20
0001b8  4e554c4c
0001bc  00      
0001bd  00                DCB      0
0001be  00                DCB      0
0001bf  00                DCB      0

                          AREA ||i.pbuf_free_ooseq||, CODE, READONLY, ALIGN=2

                  pbuf_free_ooseq PROC
;;;117    void
;;;118    pbuf_free_ooseq(void)
000000  b570              PUSH     {r4-r6,lr}
;;;119    {
;;;120      struct tcp_pcb* pcb;
;;;121      SYS_ARCH_DECL_PROTECT(old_level);
;;;122    
;;;123      SYS_ARCH_PROTECT(old_level);
000002  f7fffffe          BL       sys_arch_protect
000006  4605              MOV      r5,r0
;;;124      pbuf_free_ooseq_pending = 0;
000008  2000              MOVS     r0,#0
00000a  490b              LDR      r1,|L11.56|
00000c  7008              STRB     r0,[r1,#0]
;;;125      SYS_ARCH_UNPROTECT(old_level);
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       sys_arch_unprotect
;;;126    
;;;127      for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
000014  4809              LDR      r0,|L11.60|
000016  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
000018  e00a              B        |L11.48|
                  |L11.26|
;;;128        if (NULL != pcb->ooseq) {
00001a  6f60              LDR      r0,[r4,#0x74]
00001c  b138              CBZ      r0,|L11.46|
;;;129          /** Free the ooseq pbufs of one PCB only */
;;;130          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
00001e  bf00              NOP      
000020  bf00              NOP      
;;;131          tcp_segs_free(pcb->ooseq);
000022  6f60              LDR      r0,[r4,#0x74]
000024  f7fffffe          BL       tcp_segs_free
;;;132          pcb->ooseq = NULL;
000028  2000              MOVS     r0,#0
00002a  6760              STR      r0,[r4,#0x74]
                  |L11.44|
;;;133          return;
;;;134        }
;;;135      }
;;;136    }
00002c  bd70              POP      {r4-r6,pc}
                  |L11.46|
00002e  68e4              LDR      r4,[r4,#0xc]          ;127
                  |L11.48|
000030  2c00              CMP      r4,#0                 ;127
000032  d1f2              BNE      |L11.26|
000034  bf00              NOP      
000036  e7f9              B        |L11.44|
;;;137    
                          ENDP

                  |L11.56|
                          DCD      pbuf_free_ooseq_pending
                  |L11.60|
                          DCD      tcp_active_pcbs

                          AREA ||i.pbuf_free_ooseq_callback||, CODE, READONLY, ALIGN=1

                  pbuf_free_ooseq_callback PROC
;;;142    static void
;;;143    pbuf_free_ooseq_callback(void *arg)
000000  b510              PUSH     {r4,lr}
;;;144    {
000002  4604              MOV      r4,r0
;;;145      LWIP_UNUSED_ARG(arg);
;;;146      pbuf_free_ooseq();
000004  f7fffffe          BL       pbuf_free_ooseq
;;;147    }
000008  bd10              POP      {r4,pc}
;;;148    #endif /* !NO_SYS */
                          ENDP


                          AREA ||i.pbuf_get_at||, CODE, READONLY, ALIGN=1

                  pbuf_get_at PROC
;;;1076   u8_t
;;;1077   pbuf_get_at(struct pbuf* p, u16_t offset)
000000  b510              PUSH     {r4,lr}
;;;1078   {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;1079     u16_t copy_from = offset;
000006  4622              MOV      r2,r4
;;;1080     struct pbuf* q = p;
000008  4619              MOV      r1,r3
;;;1081   
;;;1082     /* get the correct pbuf */
;;;1083     while ((q != NULL) && (q->len <= copy_from)) {
00000a  e003              B        |L13.20|
                  |L13.12|
;;;1084       copy_from -= q->len;
00000c  8948              LDRH     r0,[r1,#0xa]
00000e  1a10              SUBS     r0,r2,r0
000010  b282              UXTH     r2,r0
;;;1085       q = q->next;
000012  6809              LDR      r1,[r1,#0]
                  |L13.20|
000014  b111              CBZ      r1,|L13.28|
000016  8948              LDRH     r0,[r1,#0xa]          ;1083
000018  4290              CMP      r0,r2                 ;1083
00001a  ddf7              BLE      |L13.12|
                  |L13.28|
;;;1086     }
;;;1087     /* return requested data if pbuf is OK */
;;;1088     if ((q != NULL) && (q->len > copy_from)) {
00001c  b129              CBZ      r1,|L13.42|
00001e  8948              LDRH     r0,[r1,#0xa]
000020  4290              CMP      r0,r2
000022  dd02              BLE      |L13.42|
;;;1089       return ((u8_t*)q->payload)[copy_from];
000024  6848              LDR      r0,[r1,#4]
000026  5c80              LDRB     r0,[r0,r2]
                  |L13.40|
;;;1090     }
;;;1091     return 0;
;;;1092   }
000028  bd10              POP      {r4,pc}
                  |L13.42|
00002a  2000              MOVS     r0,#0                 ;1091
00002c  e7fc              B        |L13.40|
;;;1093   
                          ENDP


                          AREA ||i.pbuf_header||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_header PROC
;;;510    u8_t
;;;511    pbuf_header(struct pbuf *p, s16_t header_size_increment)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;512    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;513      u16_t type;
;;;514      void *payload;
;;;515      u16_t increment_magnitude;
;;;516    
;;;517      LWIP_ASSERT("p != NULL", p != NULL);
000008  bf00              NOP      
00000a  b944              CBNZ     r4,|L14.30|
00000c  bf00              NOP      
00000e  a32e              ADR      r3,|L14.200|
000010  f2402205          MOV      r2,#0x205
000014  a135              ADR      r1,|L14.236|
000016  a038              ADR      r0,|L14.248|
000018  f7fffffe          BL       __2printf
00001c  bf00              NOP      
                  |L14.30|
00001e  bf00              NOP      
;;;518      if ((header_size_increment == 0) || (p == NULL)) {
000020  b105              CBZ      r5,|L14.36|
000022  b914              CBNZ     r4,|L14.42|
                  |L14.36|
;;;519        return 0;
000024  2000              MOVS     r0,#0
                  |L14.38|
;;;520      }
;;;521     
;;;522      if (header_size_increment < 0){
;;;523        increment_magnitude = -header_size_increment;
;;;524        /* Check that we aren't going to move off the end of the pbuf */
;;;525        LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
;;;526      } else {
;;;527        increment_magnitude = header_size_increment;
;;;528    #if 0
;;;529        /* Can't assert these as some callers speculatively call
;;;530             pbuf_header() to see if it's OK.  Will return 1 below instead. */
;;;531        /* Check that we've got the correct type of pbuf to work with */
;;;532        LWIP_ASSERT("p->type == PBUF_RAM || p->type == PBUF_POOL", 
;;;533                    p->type == PBUF_RAM || p->type == PBUF_POOL);
;;;534        /* Check that we aren't going to move off the beginning of the pbuf */
;;;535        LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
;;;536                    (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
;;;537    #endif
;;;538      }
;;;539    
;;;540      type = p->type;
;;;541      /* remember current payload pointer */
;;;542      payload = p->payload;
;;;543    
;;;544      /* pbuf types containing payloads? */
;;;545      if (type == PBUF_RAM || type == PBUF_POOL) {
;;;546        /* set new payload pointer */
;;;547        p->payload = (u8_t *)p->payload - header_size_increment;
;;;548        /* boundary check fails? */
;;;549        if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
;;;550          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;551            ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
;;;552            (void *)p->payload, (void *)(p + 1)));
;;;553          /* restore old payload pointer */
;;;554          p->payload = payload;
;;;555          /* bail out unsuccesfully */
;;;556          return 1;
;;;557        }
;;;558      /* pbuf types refering to external payloads? */
;;;559      } else if (type == PBUF_REF || type == PBUF_ROM) {
;;;560        /* hide a header in the payload? */
;;;561        if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
;;;562          /* increase payload pointer */
;;;563          p->payload = (u8_t *)p->payload - header_size_increment;
;;;564        } else {
;;;565          /* cannot expand payload to front (yet!)
;;;566           * bail out unsuccesfully */
;;;567          return 1;
;;;568        }
;;;569      } else {
;;;570        /* Unknown type */
;;;571        LWIP_ASSERT("bad pbuf type", 0);
;;;572        return 1;
;;;573      }
;;;574      /* modify pbuf length fields */
;;;575      p->len += header_size_increment;
;;;576      p->tot_len += header_size_increment;
;;;577    
;;;578      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
;;;579        (void *)payload, (void *)p->payload, header_size_increment));
;;;580    
;;;581      return 0;
;;;582    }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L14.42|
00002a  2d00              CMP      r5,#0                 ;522
00002c  da11              BGE      |L14.82|
00002e  4268              RSBS     r0,r5,#0              ;523
000030  b287              UXTH     r7,r0                 ;523
000032  bf00              NOP                            ;525
000034  8960              LDRH     r0,[r4,#0xa]          ;525
000036  42b8              CMP      r0,r7                 ;525
000038  da0a              BGE      |L14.80|
00003a  bf00              NOP                            ;525
00003c  a322              ADR      r3,|L14.200|
00003e  f240220d          MOV      r2,#0x20d             ;525
000042  a138              ADR      r1,|L14.292|
000044  a02c              ADR      r0,|L14.248|
000046  f7fffffe          BL       __2printf
00004a  bf00              NOP                            ;525
00004c  2001              MOVS     r0,#1                 ;525
00004e  e7ea              B        |L14.38|
                  |L14.80|
000050  e000              B        |L14.84|
                  |L14.82|
000052  b2af              UXTH     r7,r5                 ;527
                  |L14.84|
000054  7b26              LDRB     r6,[r4,#0xc]          ;540
000056  f8d48004          LDR      r8,[r4,#4]            ;542
00005a  b10e              CBZ      r6,|L14.96|
00005c  2e03              CMP      r6,#3                 ;545
00005e  d10d              BNE      |L14.124|
                  |L14.96|
000060  6860              LDR      r0,[r4,#4]            ;547
000062  1b40              SUBS     r0,r0,r5              ;547
000064  6060              STR      r0,[r4,#4]            ;547
000066  f1040010          ADD      r0,r4,#0x10           ;549
00006a  6861              LDR      r1,[r4,#4]            ;549
00006c  4281              CMP      r1,r0                 ;549
00006e  d221              BCS      |L14.180|
000070  bf00              NOP                            ;550
000072  bf00              NOP                            ;550
000074  f8c48004          STR      r8,[r4,#4]            ;554
000078  2001              MOVS     r0,#1                 ;556
00007a  e7d4              B        |L14.38|
                  |L14.124|
00007c  2e02              CMP      r6,#2                 ;559
00007e  d001              BEQ      |L14.132|
000080  2e01              CMP      r6,#1                 ;559
000082  d10a              BNE      |L14.154|
                  |L14.132|
000084  2d00              CMP      r5,#0                 ;561
000086  da06              BGE      |L14.150|
000088  8960              LDRH     r0,[r4,#0xa]          ;561
00008a  42b8              CMP      r0,r7                 ;561
00008c  db03              BLT      |L14.150|
00008e  6860              LDR      r0,[r4,#4]            ;563
000090  1b40              SUBS     r0,r0,r5              ;563
000092  6060              STR      r0,[r4,#4]            ;563
000094  e00e              B        |L14.180|
                  |L14.150|
000096  2001              MOVS     r0,#1                 ;567
000098  e7c5              B        |L14.38|
                  |L14.154|
00009a  bf00              NOP                            ;571
00009c  bf00              NOP                            ;571
00009e  a30a              ADR      r3,|L14.200|
0000a0  f240223b          MOV      r2,#0x23b             ;571
0000a4  a127              ADR      r1,|L14.324|
0000a6  a014              ADR      r0,|L14.248|
0000a8  f7fffffe          BL       __2printf
0000ac  bf00              NOP                            ;571
0000ae  bf00              NOP                            ;571
0000b0  2001              MOVS     r0,#1                 ;572
0000b2  e7b8              B        |L14.38|
                  |L14.180|
0000b4  8960              LDRH     r0,[r4,#0xa]          ;575
0000b6  4428              ADD      r0,r0,r5              ;575
0000b8  8160              STRH     r0,[r4,#0xa]          ;575
0000ba  8920              LDRH     r0,[r4,#8]            ;576
0000bc  4428              ADD      r0,r0,r5              ;576
0000be  8120              STRH     r0,[r4,#8]            ;576
0000c0  bf00              NOP                            ;578
0000c2  bf00              NOP                            ;578
0000c4  2000              MOVS     r0,#0                 ;581
0000c6  e7ae              B        |L14.38|
;;;583    
                          ENDP

                  |L14.200|
0000c8  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\pbuf.c",0
0000cc  5749505c
0000d0  6c776970
0000d4  2d312e34
0000d8  2e315c73
0000dc  72635c63
0000e0  6f72655c
0000e4  70627566
0000e8  2e6300  
0000eb  00                DCB      0
                  |L14.236|
0000ec  7020213d          DCB      "p != NULL",0
0000f0  204e554c
0000f4  4c00    
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L14.248|
0000f8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000fc  7274696f
000100  6e202225
000104  73222066
000108  61696c65
00010c  64206174
000110  206c696e
000114  65202564
000118  20696e20
00011c  25730d0a
000120  00      
000121  00                DCB      0
000122  00                DCB      0
000123  00                DCB      0
                  |L14.292|
000124  696e6372          DCB      "increment_magnitude <= p->len",0
000128  656d656e
00012c  745f6d61
000130  676e6974
000134  75646520
000138  3c3d2070
00013c  2d3e6c65
000140  6e00    
000142  00                DCB      0
000143  00                DCB      0
                  |L14.324|
000144  62616420          DCB      "bad pbuf type",0
000148  70627566
00014c  20747970
000150  6500    
000152  00                DCB      0
000153  00                DCB      0

                          AREA ||i.pbuf_memcmp||, CODE, READONLY, ALIGN=1

                  pbuf_memcmp PROC
;;;1103   u16_t
;;;1104   pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1105   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  469a              MOV      r10,r3
;;;1106     u16_t start = offset;
00000c  4646              MOV      r6,r8
;;;1107     struct pbuf* q = p;
00000e  463c              MOV      r4,r7
;;;1108   
;;;1109     /* get the correct pbuf */
;;;1110     while ((q != NULL) && (q->len <= start)) {
000010  e003              B        |L15.26|
                  |L15.18|
;;;1111       start -= q->len;
000012  8960              LDRH     r0,[r4,#0xa]
000014  1a30              SUBS     r0,r6,r0
000016  b286              UXTH     r6,r0
;;;1112       q = q->next;
000018  6824              LDR      r4,[r4,#0]
                  |L15.26|
00001a  b114              CBZ      r4,|L15.34|
00001c  8960              LDRH     r0,[r4,#0xa]          ;1110
00001e  42b0              CMP      r0,r6                 ;1110
000020  ddf7              BLE      |L15.18|
                  |L15.34|
;;;1113     }
;;;1114     /* return requested data if pbuf is OK */
;;;1115     if ((q != NULL) && (q->len > start)) {
000022  b1d4              CBZ      r4,|L15.90|
000024  8960              LDRH     r0,[r4,#0xa]
000026  42b0              CMP      r0,r6
000028  dd17              BLE      |L15.90|
;;;1116       u16_t i;
;;;1117       for(i = 0; i < n; i++) {
00002a  2500              MOVS     r5,#0
00002c  e011              B        |L15.82|
                  |L15.46|
;;;1118         u8_t a = pbuf_get_at(q, start + i);
00002e  1970              ADDS     r0,r6,r5
000030  b281              UXTH     r1,r0
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       pbuf_get_at
000038  4683              MOV      r11,r0
;;;1119         u8_t b = ((u8_t*)s2)[i];
00003a  f8190005          LDRB     r0,[r9,r5]
00003e  9000              STR      r0,[sp,#0]
;;;1120         if (a != b) {
000040  9800              LDR      r0,[sp,#0]
000042  4583              CMP      r11,r0
000044  d003              BEQ      |L15.78|
;;;1121           return i+1;
000046  1c68              ADDS     r0,r5,#1
000048  b280              UXTH     r0,r0
                  |L15.74|
;;;1122         }
;;;1123       }
;;;1124       return 0;
;;;1125     }
;;;1126     return 0xffff;
;;;1127   }
00004a  e8bd8ff8          POP      {r3-r11,pc}
                  |L15.78|
00004e  1c68              ADDS     r0,r5,#1              ;1117
000050  b285              UXTH     r5,r0                 ;1117
                  |L15.82|
000052  4555              CMP      r5,r10                ;1117
000054  dbeb              BLT      |L15.46|
000056  2000              MOVS     r0,#0                 ;1124
000058  e7f7              B        |L15.74|
                  |L15.90|
00005a  f64f70ff          MOV      r0,#0xffff            ;1126
00005e  e7f4              B        |L15.74|
;;;1128   
                          ENDP


                          AREA ||i.pbuf_memfind||, CODE, READONLY, ALIGN=1

                  pbuf_memfind PROC
;;;1139   u16_t
;;;1140   pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1141   {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;1142     u16_t i;
;;;1143     u16_t max = p->tot_len - mem_len;
00000c  8930              LDRH     r0,[r6,#8]
00000e  1b40              SUBS     r0,r0,r5
000010  fa1ffa80          UXTH     r10,r0
;;;1144     if (p->tot_len >= mem_len + start_offset) {
000014  8930              LDRH     r0,[r6,#8]
000016  19e9              ADDS     r1,r5,r7
000018  4288              CMP      r0,r1
00001a  db14              BLT      |L16.70|
;;;1145       for(i = start_offset; i <= max; ) {
00001c  463c              MOV      r4,r7
00001e  e010              B        |L16.66|
                  |L16.32|
;;;1146         u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
000020  462b              MOV      r3,r5
000022  4642              MOV      r2,r8
000024  4621              MOV      r1,r4
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       pbuf_memcmp
00002c  4681              MOV      r9,r0
;;;1147         if (plus == 0) {
00002e  f1b90f00          CMP      r9,#0
000032  d102              BNE      |L16.58|
;;;1148           return i;
000034  4620              MOV      r0,r4
                  |L16.54|
;;;1149         } else {
;;;1150           i += plus;
;;;1151         }
;;;1152       }
;;;1153     }
;;;1154     return 0xFFFF;
;;;1155   }
000036  e8bd87f0          POP      {r4-r10,pc}
                  |L16.58|
00003a  eb040009          ADD      r0,r4,r9              ;1150
00003e  b284              UXTH     r4,r0                 ;1150
000040  bf00              NOP                            ;1152
                  |L16.66|
000042  4554              CMP      r4,r10                ;1145
000044  ddec              BLE      |L16.32|
                  |L16.70|
000046  f64f70ff          MOV      r0,#0xffff            ;1154
00004a  e7f4              B        |L16.54|
;;;1156   
                          ENDP


                          AREA ||i.pbuf_pool_is_empty||, CODE, READONLY, ALIGN=2

                  pbuf_pool_is_empty PROC
;;;151    static void
;;;152    pbuf_pool_is_empty(void)
000000  b570              PUSH     {r4-r6,lr}
;;;153    {
;;;154    #ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
;;;155      SYS_ARCH_DECL_PROTECT(old_level);
;;;156      SYS_ARCH_PROTECT(old_level);
;;;157      pbuf_free_ooseq_pending = 1;
;;;158      SYS_ARCH_UNPROTECT(old_level);
;;;159    #else /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
;;;160      u8_t queued;
;;;161      SYS_ARCH_DECL_PROTECT(old_level);
;;;162      SYS_ARCH_PROTECT(old_level);
000002  f7fffffe          BL       sys_arch_protect
000006  4605              MOV      r5,r0
;;;163      queued = pbuf_free_ooseq_pending;
000008  480d              LDR      r0,|L17.64|
00000a  7804              LDRB     r4,[r0,#0]  ; pbuf_free_ooseq_pending
;;;164      pbuf_free_ooseq_pending = 1;
00000c  2001              MOVS     r0,#1
00000e  490c              LDR      r1,|L17.64|
000010  7008              STRB     r0,[r1,#0]
;;;165      SYS_ARCH_UNPROTECT(old_level);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       sys_arch_unprotect
;;;166    
;;;167      if(!queued) {
000018  b984              CBNZ     r4,|L17.60|
;;;168        /* queue a call to pbuf_free_ooseq if not already queued */
;;;169        PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
00001a  bf00              NOP      
00001c  2200              MOVS     r2,#0
00001e  4611              MOV      r1,r2
000020  4808              LDR      r0,|L17.68|
000022  f7fffffe          BL       tcpip_callback_with_block
000026  b140              CBZ      r0,|L17.58|
000028  f7fffffe          BL       sys_arch_protect
00002c  4605              MOV      r5,r0
00002e  2000              MOVS     r0,#0
000030  4903              LDR      r1,|L17.64|
000032  7008              STRB     r0,[r1,#0]
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       sys_arch_unprotect
                  |L17.58|
00003a  bf00              NOP      
                  |L17.60|
;;;170      }
;;;171    #endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
;;;172    }
00003c  bd70              POP      {r4-r6,pc}
;;;173    #endif /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */
                          ENDP

00003e  0000              DCW      0x0000
                  |L17.64|
                          DCD      pbuf_free_ooseq_pending
                  |L17.68|
                          DCD      pbuf_free_ooseq_callback

                          AREA ||i.pbuf_realloc||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_realloc PROC
;;;429    void
;;;430    pbuf_realloc(struct pbuf *p, u16_t new_len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;431    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;432      struct pbuf *q;
;;;433      u16_t rem_len; /* remaining length */
;;;434      s32_t grow;
;;;435    
;;;436      LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
000008  bf00              NOP      
00000a  b945              CBNZ     r5,|L18.30|
00000c  bf00              NOP      
00000e  a33a              ADR      r3,|L18.248|
000010  f44f72da          MOV      r2,#0x1b4
000014  a141              ADR      r1,|L18.284|
000016  a047              ADR      r0,|L18.308|
000018  f7fffffe          BL       __2printf
00001c  bf00              NOP      
                  |L18.30|
00001e  bf00              NOP      
;;;437      LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
000020  bf00              NOP      
000022  7b28              LDRB     r0,[r5,#0xc]
000024  2803              CMP      r0,#3
000026  d010              BEQ      |L18.74|
000028  7b28              LDRB     r0,[r5,#0xc]
00002a  2801              CMP      r0,#1
00002c  d00d              BEQ      |L18.74|
00002e  7b28              LDRB     r0,[r5,#0xc]
000030  b158              CBZ      r0,|L18.74|
000032  7b28              LDRB     r0,[r5,#0xc]
000034  2802              CMP      r0,#2
000036  d008              BEQ      |L18.74|
000038  bf00              NOP      
00003a  a32f              ADR      r3,|L18.248|
00003c  f24012b5          MOV      r2,#0x1b5
000040  a147              ADR      r1,|L18.352|
000042  a03c              ADR      r0,|L18.308|
000044  f7fffffe          BL       __2printf
000048  bf00              NOP      
                  |L18.74|
00004a  bf00              NOP      
;;;438                  p->type == PBUF_ROM ||
;;;439                  p->type == PBUF_RAM ||
;;;440                  p->type == PBUF_REF);
;;;441    
;;;442      /* desired length larger than current length? */
;;;443      if (new_len >= p->tot_len) {
00004c  8928              LDRH     r0,[r5,#8]
00004e  42b8              CMP      r0,r7
000050  dc01              BGT      |L18.86|
                  |L18.82|
;;;444        /* enlarging not yet supported */
;;;445        return;
;;;446      }
;;;447    
;;;448      /* the pbuf chain grows by (new_len - p->tot_len) bytes
;;;449       * (which may be negative in case of shrinking) */
;;;450      grow = new_len - p->tot_len;
;;;451    
;;;452      /* first, step over any pbufs that should remain in the chain */
;;;453      rem_len = new_len;
;;;454      q = p;
;;;455      /* should this pbuf be kept? */
;;;456      while (rem_len > q->len) {
;;;457        /* decrease remaining length by pbuf length */
;;;458        rem_len -= q->len;
;;;459        /* decrease total length indicator */
;;;460        LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
;;;461        q->tot_len += (u16_t)grow;
;;;462        /* proceed to next pbuf in chain */
;;;463        q = q->next;
;;;464        LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
;;;465      }
;;;466      /* we have now reached the new last pbuf (in q) */
;;;467      /* rem_len == desired length for pbuf q */
;;;468    
;;;469      /* shrink allocated memory for PBUF_RAM */
;;;470      /* (other types merely adjust their length fields */
;;;471      if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
;;;472        /* reallocate and adjust the length of the pbuf that will be split */
;;;473        q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
;;;474        LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
;;;475      }
;;;476      /* adjust length fields for new last pbuf */
;;;477      q->len = rem_len;
;;;478      q->tot_len = q->len;
;;;479    
;;;480      /* any remaining pbufs in chain? */
;;;481      if (q->next != NULL) {
;;;482        /* free remaining pbufs in chain */
;;;483        pbuf_free(q->next);
;;;484      }
;;;485      /* q is last packet in chain */
;;;486      q->next = NULL;
;;;487    
;;;488    }
000052  e8bd81f0          POP      {r4-r8,pc}
                  |L18.86|
000056  8928              LDRH     r0,[r5,#8]            ;450
000058  eba70800          SUB      r8,r7,r0              ;450
00005c  463e              MOV      r6,r7                 ;453
00005e  462c              MOV      r4,r5                 ;454
000060  e021              B        |L18.166|
                  |L18.98|
000062  8960              LDRH     r0,[r4,#0xa]          ;458
000064  1a30              SUBS     r0,r6,r0              ;458
000066  b286              UXTH     r6,r0                 ;458
000068  bf00              NOP                            ;460
00006a  f64f70ff          MOV      r0,#0xffff            ;460
00006e  4580              CMP      r8,r0                 ;460
000070  db08              BLT      |L18.132|
000072  bf00              NOP                            ;460
000074  a320              ADR      r3,|L18.248|
000076  f44f72e6          MOV      r2,#0x1cc             ;460
00007a  a140              ADR      r1,|L18.380|
00007c  a02d              ADR      r0,|L18.308|
00007e  f7fffffe          BL       __2printf
000082  bf00              NOP                            ;460
                  |L18.132|
000084  bf00              NOP                            ;460
000086  8920              LDRH     r0,[r4,#8]            ;461
000088  4440              ADD      r0,r0,r8              ;461
00008a  8120              STRH     r0,[r4,#8]            ;461
00008c  6824              LDR      r4,[r4,#0]            ;463
00008e  bf00              NOP                            ;464
000090  b944              CBNZ     r4,|L18.164|
000092  bf00              NOP                            ;464
000094  a318              ADR      r3,|L18.248|
000096  f44f72e8          MOV      r2,#0x1d0             ;464
00009a  a13d              ADR      r1,|L18.400|
00009c  a025              ADR      r0,|L18.308|
00009e  f7fffffe          BL       __2printf
0000a2  bf00              NOP                            ;464
                  |L18.164|
0000a4  bf00              NOP                            ;464
                  |L18.166|
0000a6  8960              LDRH     r0,[r4,#0xa]          ;456
0000a8  42b0              CMP      r0,r6                 ;456
0000aa  dbda              BLT      |L18.98|
0000ac  7b20              LDRB     r0,[r4,#0xc]          ;471
0000ae  2800              CMP      r0,#0                 ;471
0000b0  d116              BNE      |L18.224|
0000b2  8960              LDRH     r0,[r4,#0xa]          ;471
0000b4  42b0              CMP      r0,r6                 ;471
0000b6  d013              BEQ      |L18.224|
0000b8  88a0              LDRH     r0,[r4,#4]            ;473
0000ba  1b00              SUBS     r0,r0,r4              ;473
0000bc  4430              ADD      r0,r0,r6              ;473
0000be  b281              UXTH     r1,r0                 ;473
0000c0  4620              MOV      r0,r4                 ;473
0000c2  f7fffffe          BL       mem_trim
0000c6  4604              MOV      r4,r0                 ;473
0000c8  bf00              NOP                            ;474
0000ca  b944              CBNZ     r4,|L18.222|
0000cc  bf00              NOP                            ;474
0000ce  a30a              ADR      r3,|L18.248|
0000d0  f44f72ed          MOV      r2,#0x1da             ;474
0000d4  a134              ADR      r1,|L18.424|
0000d6  a017              ADR      r0,|L18.308|
0000d8  f7fffffe          BL       __2printf
0000dc  bf00              NOP                            ;474
                  |L18.222|
0000de  bf00              NOP                            ;474
                  |L18.224|
0000e0  8166              STRH     r6,[r4,#0xa]          ;477
0000e2  8960              LDRH     r0,[r4,#0xa]          ;478
0000e4  8120              STRH     r0,[r4,#8]            ;478
0000e6  6820              LDR      r0,[r4,#0]            ;481
0000e8  b110              CBZ      r0,|L18.240|
0000ea  6820              LDR      r0,[r4,#0]            ;483
0000ec  f7fffffe          BL       pbuf_free
                  |L18.240|
0000f0  2000              MOVS     r0,#0                 ;486
0000f2  6020              STR      r0,[r4,#0]            ;486
0000f4  bf00              NOP      
0000f6  e7ac              B        |L18.82|
;;;489    
                          ENDP

                  |L18.248|
0000f8  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\pbuf.c",0
0000fc  5749505c
000100  6c776970
000104  2d312e34
000108  2e315c73
00010c  72635c63
000110  6f72655c
000114  70627566
000118  2e6300  
00011b  00                DCB      0
                  |L18.284|
00011c  70627566          DCB      "pbuf_realloc: p != NULL",0
000120  5f726561
000124  6c6c6f63
000128  3a207020
00012c  213d204e
000130  554c4c00
                  |L18.308|
000134  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000138  7274696f
00013c  6e202225
000140  73222066
000144  61696c65
000148  64206174
00014c  206c696e
000150  65202564
000154  20696e20
000158  25730d0a
00015c  00      
00015d  00                DCB      0
00015e  00                DCB      0
00015f  00                DCB      0
                  |L18.352|
000160  70627566          DCB      "pbuf_realloc: sane p->type",0
000164  5f726561
000168  6c6c6f63
00016c  3a207361
000170  6e652070
000174  2d3e7479
000178  706500  
00017b  00                DCB      0
                  |L18.380|
00017c  67726f77          DCB      "grow < max_u16_t",0
000180  203c206d
000184  61785f75
000188  31365f74
00018c  00      
00018d  00                DCB      0
00018e  00                DCB      0
00018f  00                DCB      0
                  |L18.400|
000190  70627566          DCB      "pbuf_realloc: q != NULL",0
000194  5f726561
000198  6c6c6f63
00019c  3a207120
0001a0  213d204e
0001a4  554c4c00
                  |L18.424|
0001a8  6d656d5f          DCB      "mem_trim returned q == NULL",0
0001ac  7472696d
0001b0  20726574
0001b4  75726e65
0001b8  64207120
0001bc  3d3d204e
0001c0  554c4c00

                          AREA ||i.pbuf_ref||, CODE, READONLY, ALIGN=1

                  pbuf_ref PROC
;;;722    void
;;;723    pbuf_ref(struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;724    {
000002  4604              MOV      r4,r0
;;;725      SYS_ARCH_DECL_PROTECT(old_level);
;;;726      /* pbuf given? */
;;;727      if (p != NULL) {
000004  b144              CBZ      r4,|L19.24|
;;;728        SYS_ARCH_PROTECT(old_level);
000006  f7fffffe          BL       sys_arch_protect
00000a  4605              MOV      r5,r0
;;;729        ++(p->ref);
00000c  89e0              LDRH     r0,[r4,#0xe]
00000e  1c40              ADDS     r0,r0,#1
000010  81e0              STRH     r0,[r4,#0xe]
;;;730        SYS_ARCH_UNPROTECT(old_level);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       sys_arch_unprotect
                  |L19.24|
;;;731      }
;;;732    }
000018  bd70              POP      {r4-r6,pc}
;;;733    
                          ENDP


                          AREA ||i.pbuf_strstr||, CODE, READONLY, ALIGN=1

                  pbuf_strstr PROC
;;;1167   u16_t
;;;1168   pbuf_strstr(struct pbuf* p, const char* substr)
000000  b570              PUSH     {r4-r6,lr}
;;;1169   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;1170     size_t substr_len;
;;;1171     if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
000006  b134              CBZ      r4,|L20.22|
000008  7820              LDRB     r0,[r4,#0]
00000a  b120              CBZ      r0,|L20.22|
00000c  8930              LDRH     r0,[r6,#8]
00000e  f64f71ff          MOV      r1,#0xffff
000012  4288              CMP      r0,r1
000014  d102              BNE      |L20.28|
                  |L20.22|
;;;1172       return 0xFFFF;
000016  f64f70ff          MOV      r0,#0xffff
                  |L20.26|
;;;1173     }
;;;1174     substr_len = strlen(substr);
;;;1175     if (substr_len >= 0xFFFF) {
;;;1176       return 0xFFFF;
;;;1177     }
;;;1178     return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
;;;1179   }
00001a  bd70              POP      {r4-r6,pc}
                  |L20.28|
00001c  4620              MOV      r0,r4                 ;1174
00001e  f7fffffe          BL       strlen
000022  4605              MOV      r5,r0                 ;1174
000024  f64f70ff          MOV      r0,#0xffff            ;1175
000028  4285              CMP      r5,r0                 ;1175
00002a  d300              BCC      |L20.46|
00002c  e7f5              B        |L20.26|
                  |L20.46|
00002e  b2aa              UXTH     r2,r5                 ;1178
000030  2300              MOVS     r3,#0                 ;1178
000032  4621              MOV      r1,r4                 ;1178
000034  4630              MOV      r0,r6                 ;1178
000036  f7fffffe          BL       pbuf_memfind
00003a  e7ee              B        |L20.26|
                          ENDP


                          AREA ||i.pbuf_take||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_take PROC
;;;965    err_t
;;;966    pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;967    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;968      struct pbuf *p;
;;;969      u16_t buf_copy_len;
;;;970      u16_t total_copy_len = len;
00000a  4646              MOV      r6,r8
;;;971      u16_t copied_total = 0;
00000c  f04f0a00          MOV      r10,#0
;;;972    
;;;973      LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
000010  bf00              NOP      
000012  b95d              CBNZ     r5,|L21.44|
000014  bf00              NOP      
000016  a32b              ADR      r3,|L21.196|
000018  f24032cd          MOV      r2,#0x3cd
00001c  a132              ADR      r1,|L21.232|
00001e  a038              ADR      r0,|L21.256|
000020  f7fffffe          BL       __2printf
000024  bf00              NOP      
000026  2000              MOVS     r0,#0
                  |L21.40|
;;;974      LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
;;;975    
;;;976      if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
;;;977        return ERR_ARG;
;;;978      }
;;;979    
;;;980      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;981      for(p = buf; total_copy_len != 0; p = p->next) {
;;;982        LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
;;;983        buf_copy_len = total_copy_len;
;;;984        if (buf_copy_len > p->len) {
;;;985          /* this pbuf cannot hold all remaining data */
;;;986          buf_copy_len = p->len;
;;;987        }
;;;988        /* copy the necessary parts of the buffer */
;;;989        MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
;;;990        total_copy_len -= buf_copy_len;
;;;991        copied_total += buf_copy_len;
;;;992      }
;;;993      LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
;;;994      return ERR_OK;
;;;995    }
000028  e8bd87f0          POP      {r4-r10,pc}
                  |L21.44|
00002c  bf00              NOP                            ;973
00002e  bf00              NOP                            ;974
000030  b957              CBNZ     r7,|L21.72|
000032  bf00              NOP                            ;974
000034  a323              ADR      r3,|L21.196|
000036  f24032ce          MOV      r2,#0x3ce             ;974
00003a  a13c              ADR      r1,|L21.300|
00003c  a030              ADR      r0,|L21.256|
00003e  f7fffffe          BL       __2printf
000042  bf00              NOP                            ;974
000044  2000              MOVS     r0,#0                 ;974
000046  e7ef              B        |L21.40|
                  |L21.72|
000048  bf00              NOP                            ;974
00004a  b11d              CBZ      r5,|L21.84|
00004c  b117              CBZ      r7,|L21.84|
00004e  8928              LDRH     r0,[r5,#8]            ;976
000050  4540              CMP      r0,r8                 ;976
000052  da02              BGE      |L21.90|
                  |L21.84|
000054  f06f000d          MVN      r0,#0xd               ;977
000058  e7e6              B        |L21.40|
                  |L21.90|
00005a  462c              MOV      r4,r5                 ;981
00005c  e01f              B        |L21.158|
                  |L21.94|
00005e  bf00              NOP                            ;982
000060  b944              CBNZ     r4,|L21.116|
000062  bf00              NOP                            ;982
000064  a317              ADR      r3,|L21.196|
000066  f24032d6          MOV      r2,#0x3d6             ;982
00006a  a137              ADR      r1,|L21.328|
00006c  a024              ADR      r0,|L21.256|
00006e  f7fffffe          BL       __2printf
000072  bf00              NOP                            ;982
                  |L21.116|
000074  bf00              NOP                            ;982
000076  46b1              MOV      r9,r6                 ;983
000078  8960              LDRH     r0,[r4,#0xa]          ;984
00007a  4548              CMP      r0,r9                 ;984
00007c  da01              BGE      |L21.130|
00007e  f8b4900a          LDRH     r9,[r4,#0xa]          ;986
                  |L21.130|
000082  eb07010a          ADD      r1,r7,r10             ;989
000086  464a              MOV      r2,r9                 ;989
000088  6860              LDR      r0,[r4,#4]            ;989
00008a  f7fffffe          BL       __aeabi_memcpy
00008e  eba60009          SUB      r0,r6,r9              ;990
000092  b286              UXTH     r6,r0                 ;990
000094  eb0a0009          ADD      r0,r10,r9             ;991
000098  fa1ffa80          UXTH     r10,r0                ;991
00009c  6824              LDR      r4,[r4,#0]            ;981
                  |L21.158|
00009e  2e00              CMP      r6,#0                 ;981
0000a0  d1dd              BNE      |L21.94|
0000a2  bf00              NOP                            ;993
0000a4  b90e              CBNZ     r6,|L21.170|
0000a6  45c2              CMP      r10,r8                ;993
0000a8  d008              BEQ      |L21.188|
                  |L21.170|
0000aa  bf00              NOP                            ;993
0000ac  a305              ADR      r3,|L21.196|
0000ae  f24032e1          MOV      r2,#0x3e1             ;993
0000b2  a12b              ADR      r1,|L21.352|
0000b4  a012              ADR      r0,|L21.256|
0000b6  f7fffffe          BL       __2printf
0000ba  bf00              NOP                            ;993
                  |L21.188|
0000bc  bf00              NOP                            ;993
0000be  2000              MOVS     r0,#0                 ;994
0000c0  e7b2              B        |L21.40|
;;;996    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L21.196|
0000c4  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\pbuf.c",0
0000c8  5749505c
0000cc  6c776970
0000d0  2d312e34
0000d4  2e315c73
0000d8  72635c63
0000dc  6f72655c
0000e0  70627566
0000e4  2e6300  
0000e7  00                DCB      0
                  |L21.232|
0000e8  70627566          DCB      "pbuf_take: invalid buf",0
0000ec  5f74616b
0000f0  653a2069
0000f4  6e76616c
0000f8  69642062
0000fc  756600  
0000ff  00                DCB      0
                  |L21.256|
000100  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000104  7274696f
000108  6e202225
00010c  73222066
000110  61696c65
000114  64206174
000118  206c696e
00011c  65202564
000120  20696e20
000124  25730d0a
000128  00      
000129  00                DCB      0
00012a  00                DCB      0
00012b  00                DCB      0
                  |L21.300|
00012c  70627566          DCB      "pbuf_take: invalid dataptr",0
000130  5f74616b
000134  653a2069
000138  6e76616c
00013c  69642064
000140  61746170
000144  747200  
000147  00                DCB      0
                  |L21.328|
000148  70627566          DCB      "pbuf_take: invalid pbuf",0
00014c  5f74616b
000150  653a2069
000154  6e76616c
000158  69642070
00015c  62756600
                  |L21.352|
000160  64696420          DCB      "did not copy all data",0
000164  6e6f7420
000168  636f7079
00016c  20616c6c
000170  20646174
000174  6100    
000176  00                DCB      0
000177  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=0

                  pbuf_free_ooseq_pending
000000  00                DCB      0x00
