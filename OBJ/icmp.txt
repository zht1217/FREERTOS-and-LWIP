; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\icmp.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\icmp.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I..\LWIP\lwip-1.4.1\src\include -I..\LWIP\lwip-1.4.1\src\include\ipv4 -I..\LWIP\lwip-1.4.1\src\include\netif -I..\LWIP -I..\LWIP\arch -I..\LWIP\lwip_app\lwip_comm -I..\HARDWARE\DM9000 -I..\HARDWARE\SRAM -I..\LWIP\lwip-1.4.1\src\api -I.\RTE\_FreeRTOS -ID:\MDK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\MDK\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_HD -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\icmp.crf ..\LWIP\lwip-1.4.1\src\core\ipv4\icmp.c]
                          THUMB

                          AREA ||i.icmp_dest_unreach||, CODE, READONLY, ALIGN=1

                  icmp_dest_unreach PROC
;;;261    void
;;;262    icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
000000  b570              PUSH     {r4-r6,lr}
;;;263    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;264      icmp_send_response(p, ICMP_DUR, t);
000006  4622              MOV      r2,r4
000008  2103              MOVS     r1,#3
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       icmp_send_response
;;;265    }
000010  bd70              POP      {r4-r6,pc}
;;;266    
                          ENDP


                          AREA ||i.icmp_input||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  icmp_input PROC
;;;77     void
;;;78     icmp_input(struct pbuf *p, struct netif *inp)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;79     {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
;;;80     
;;;81       u8_t type;
;;;82     #ifdef LWIP_DEBUG
;;;83       u8_t code;
;;;84     #endif /* LWIP_DEBUG */
;;;85       struct icmp_echo_hdr *iecho;
;;;86       struct ip_hdr *iphdr;
;;;87       s16_t hlen;
;;;88     
;;;89       ICMP_STATS_INC(icmp.recv);
;;;90       snmp_inc_icmpinmsgs();
;;;91       iphdr = (struct ip_hdr *)p->payload;
000008  6866              LDR      r6,[r4,#4]
;;;92       hlen = IPH_HL(iphdr) * 4;
00000a  7830              LDRB     r0,[r6,#0]
00000c  0700              LSLS     r0,r0,#28
00000e  ea4f6890          LSR      r8,r0,#26
;;;93       if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
000012  f1c80100          RSB      r1,r8,#0
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       pbuf_header
00001c  b910              CBNZ     r0,|L2.36|
00001e  8920              LDRH     r0,[r4,#8]
000020  2804              CMP      r0,#4
000022  d202              BCS      |L2.42|
                  |L2.36|
;;;94         LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
000024  bf00              NOP      
000026  bf00              NOP      
;;;95         goto lenerr;
000028  e0e7              B        |L2.506|
                  |L2.42|
;;;96       }
;;;97     
;;;98       type = *((u8_t *)p->payload);
00002a  6860              LDR      r0,[r4,#4]
00002c  f890a000          LDRB     r10,[r0,#0]
;;;99     #ifdef LWIP_DEBUG
;;;100      code = *(((u8_t *)p->payload)+1);
000030  6860              LDR      r0,[r4,#4]
000032  f890b001          LDRB     r11,[r0,#1]
;;;101    #endif /* LWIP_DEBUG */
;;;102      switch (type) {
000036  f1ba0f00          CMP      r10,#0
00003a  d003              BEQ      |L2.68|
00003c  f1ba0f08          CMP      r10,#8
000040  d177              BNE      |L2.306|
000042  e000              B        |L2.70|
                  |L2.68|
;;;103      case ICMP_ER:
;;;104        /* This is OK, echo reply might have been parsed by a raw PCB
;;;105           (as obviously, an echo request has been sent, too). */
;;;106        break; 
000044  e0d4              B        |L2.496|
                  |L2.70|
;;;107      case ICMP_ECHO:
;;;108    #if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
;;;109        {
;;;110          int accepted = 1;
000046  2701              MOVS     r7,#1
;;;111    #if !LWIP_MULTICAST_PING
;;;112          /* multicast destination address? */
;;;113          if (ip_addr_ismulticast(&current_iphdr_dest)) {
000048  4870              LDR      r0,|L2.524|
00004a  7800              LDRB     r0,[r0,#0]  ; current_iphdr_dest
00004c  f00000f0          AND      r0,r0,#0xf0
000050  28e0              CMP      r0,#0xe0
000052  d100              BNE      |L2.86|
;;;114            accepted = 0;
000054  2700              MOVS     r7,#0
                  |L2.86|
;;;115          }
;;;116    #endif /* LWIP_MULTICAST_PING */
;;;117    #if !LWIP_BROADCAST_PING
;;;118          /* broadcast destination address? */
;;;119          if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
000056  496d              LDR      r1,|L2.524|
000058  6808              LDR      r0,[r1,#0]  ; current_iphdr_dest
00005a  4649              MOV      r1,r9
00005c  f7fffffe          BL       ip4_addr_isbroadcast
000060  b100              CBZ      r0,|L2.100|
;;;120            accepted = 0;
000062  2700              MOVS     r7,#0
                  |L2.100|
;;;121          }
;;;122    #endif /* LWIP_BROADCAST_PING */
;;;123          /* broadcast or multicast destination address not acceptd? */
;;;124          if (!accepted) {
000064  b937              CBNZ     r7,|L2.116|
;;;125            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
000066  bf00              NOP      
000068  bf00              NOP      
;;;126            ICMP_STATS_INC(icmp.err);
;;;127            pbuf_free(p);
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       pbuf_free
                  |L2.112|
;;;128            return;
;;;129          }
;;;130        }
;;;131    #endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
;;;132        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
;;;133        if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
;;;134          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
;;;135          goto lenerr;
;;;136        }
;;;137        if (inet_chksum_pbuf(p) != 0) {
;;;138          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
;;;139          pbuf_free(p);
;;;140          ICMP_STATS_INC(icmp.chkerr);
;;;141          snmp_inc_icmpinerrors();
;;;142          return;
;;;143        }
;;;144    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;145        if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
;;;146          /* p is not big enough to contain link headers
;;;147           * allocate a new one and copy p into it
;;;148           */
;;;149          struct pbuf *r;
;;;150          /* switch p->payload to ip header */
;;;151          if (pbuf_header(p, hlen)) {
;;;152            LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
;;;153            goto memerr;
;;;154          }
;;;155          /* allocate new packet buffer with space for link headers */
;;;156          r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
;;;157          if (r == NULL) {
;;;158            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
;;;159            goto memerr;
;;;160          }
;;;161          LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
;;;162                      (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
;;;163          /* copy the whole packet including ip header */
;;;164          if (pbuf_copy(r, p) != ERR_OK) {
;;;165            LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
;;;166            goto memerr;
;;;167          }
;;;168          iphdr = (struct ip_hdr *)r->payload;
;;;169          /* switch r->payload back to icmp header */
;;;170          if (pbuf_header(r, -hlen)) {
;;;171            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
;;;172            goto memerr;
;;;173          }
;;;174          /* free the original p */
;;;175          pbuf_free(p);
;;;176          /* we now have an identical copy of p that has room for link headers */
;;;177          p = r;
;;;178        } else {
;;;179          /* restore p->payload to point to icmp header */
;;;180          if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
;;;181            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
;;;182            goto memerr;
;;;183          }
;;;184        }
;;;185    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;186        /* At this point, all checks are OK. */
;;;187        /* We generate an answer by switching the dest and src ip addresses,
;;;188         * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
;;;189        iecho = (struct icmp_echo_hdr *)p->payload;
;;;190        ip_addr_copy(iphdr->src, *ip_current_dest_addr());
;;;191        ip_addr_copy(iphdr->dest, *ip_current_src_addr());
;;;192        ICMPH_TYPE_SET(iecho, ICMP_ER);
;;;193    
;;;194    #if CHECKSUM_GEN_ICMP
;;;195        /* adjust the checksum */
;;;196        if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
;;;197          iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
;;;198        } else {
;;;199          iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
;;;200        }
;;;201    #else /* CHECKSUM_GEN_ICMP */
;;;202        iecho->chksum = 0;
;;;203    #endif /* CHECKSUM_GEN_ICMP */
;;;204    
;;;205        /* Set the correct TTL and recalculate the header checksum. */
;;;206        IPH_TTL_SET(iphdr, ICMP_TTL);
;;;207        IPH_CHKSUM_SET(iphdr, 0);
;;;208    #if CHECKSUM_GEN_IP
;;;209        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
;;;210    #endif /* CHECKSUM_GEN_IP */
;;;211    
;;;212        ICMP_STATS_INC(icmp.xmit);
;;;213        /* increase number of messages attempted to send */
;;;214        snmp_inc_icmpoutmsgs();
;;;215        /* increase number of echo replies attempted to send */
;;;216        snmp_inc_icmpoutechoreps();
;;;217    
;;;218        if(pbuf_header(p, hlen)) {
;;;219          LWIP_ASSERT("Can't move over header in packet", 0);
;;;220        } else {
;;;221          err_t ret;
;;;222          /* send an ICMP packet, src addr is the dest addr of the curren packet */
;;;223          ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
;;;224                       ICMP_TTL, 0, IP_PROTO_ICMP, inp);
;;;225          if (ret != ERR_OK) {
;;;226            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
;;;227          }
;;;228        }
;;;229        break;
;;;230      default:
;;;231        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
;;;232                    (s16_t)type, (s16_t)code));
;;;233        ICMP_STATS_INC(icmp.proterr);
;;;234        ICMP_STATS_INC(icmp.drop);
;;;235      }
;;;236      pbuf_free(p);
;;;237      return;
;;;238    lenerr:
;;;239      pbuf_free(p);
;;;240      ICMP_STATS_INC(icmp.lenerr);
;;;241      snmp_inc_icmpinerrors();
;;;242      return;
;;;243    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;244    memerr:
;;;245      pbuf_free(p);
;;;246      ICMP_STATS_INC(icmp.err);
;;;247      snmp_inc_icmpinerrors();
;;;248      return;
;;;249    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;250    }
000070  e8bd8ffe          POP      {r1-r11,pc}
                  |L2.116|
000074  bf00              NOP                            ;132
000076  bf00              NOP                            ;132
000078  8920              LDRH     r0,[r4,#8]            ;133
00007a  2808              CMP      r0,#8                 ;133
00007c  d202              BCS      |L2.132|
00007e  bf00              NOP                            ;134
000080  bf00              NOP                            ;134
000082  e0ba              B        |L2.506|
                  |L2.132|
000084  4620              MOV      r0,r4                 ;137
000086  f7fffffe          BL       inet_chksum_pbuf
00008a  b128              CBZ      r0,|L2.152|
00008c  bf00              NOP                            ;138
00008e  bf00              NOP                            ;138
000090  4620              MOV      r0,r4                 ;139
000092  f7fffffe          BL       pbuf_free
000096  e7eb              B        |L2.112|
                  |L2.152|
000098  2122              MOVS     r1,#0x22              ;145
00009a  4620              MOV      r0,r4                 ;145
00009c  f7fffffe          BL       pbuf_header
0000a0  2800              CMP      r0,#0                 ;145
0000a2  d053              BEQ      |L2.332|
0000a4  4641              MOV      r1,r8                 ;151
0000a6  4620              MOV      r0,r4                 ;151
0000a8  f7fffffe          BL       pbuf_header
0000ac  2800              CMP      r0,#0                 ;151
0000ae  d00a              BEQ      |L2.198|
0000b0  bf00              NOP                            ;152
0000b2  bf00              NOP                            ;152
0000b4  a356              ADR      r3,|L2.528|
0000b6  2298              MOVS     r2,#0x98              ;152
0000b8  a15f              ADR      r1,|L2.568|
0000ba  a06c              ADR      r0,|L2.620|
0000bc  f7fffffe          BL       __2printf
0000c0  bf00              NOP                            ;152
0000c2  bf00              NOP                            ;152
0000c4  e09d              B        |L2.514|
                  |L2.198|
0000c6  8921              LDRH     r1,[r4,#8]            ;156
0000c8  2200              MOVS     r2,#0                 ;156
0000ca  2002              MOVS     r0,#2                 ;156
0000cc  f7fffffe          BL       pbuf_alloc
0000d0  4607              MOV      r7,r0                 ;156
0000d2  b917              CBNZ     r7,|L2.218|
0000d4  bf00              NOP                            ;158
0000d6  bf00              NOP                            ;158
0000d8  e093              B        |L2.514|
                  |L2.218|
0000da  bf00              NOP                            ;161
0000dc  8979              LDRH     r1,[r7,#0xa]          ;161
0000de  f1080008          ADD      r0,r8,#8              ;161
0000e2  4281              CMP      r1,r0                 ;161
0000e4  d207              BCS      |L2.246|
0000e6  bf00              NOP                            ;161
0000e8  a349              ADR      r3,|L2.528|
0000ea  22a1              MOVS     r2,#0xa1              ;161
0000ec  a16a              ADR      r1,|L2.664|
0000ee  a05f              ADR      r0,|L2.620|
0000f0  f7fffffe          BL       __2printf
0000f4  bf00              NOP                            ;161
                  |L2.246|
0000f6  bf00              NOP                            ;161
0000f8  4621              MOV      r1,r4                 ;164
0000fa  4638              MOV      r0,r7                 ;164
0000fc  f7fffffe          BL       pbuf_copy
000100  b150              CBZ      r0,|L2.280|
000102  bf00              NOP                            ;165
000104  bf00              NOP                            ;165
000106  a342              ADR      r3,|L2.528|
000108  22a5              MOVS     r2,#0xa5              ;165
00010a  a171              ADR      r1,|L2.720|
00010c  a057              ADR      r0,|L2.620|
00010e  f7fffffe          BL       __2printf
000112  bf00              NOP                            ;165
000114  bf00              NOP                            ;165
000116  e074              B        |L2.514|
                  |L2.280|
000118  687e              LDR      r6,[r7,#4]            ;168
00011a  f1c80000          RSB      r0,r8,#0              ;170
00011e  b201              SXTH     r1,r0                 ;170
000120  4638              MOV      r0,r7                 ;170
000122  f7fffffe          BL       pbuf_header
000126  b160              CBZ      r0,|L2.322|
000128  bf00              NOP                            ;171
00012a  bf00              NOP                            ;171
00012c  a338              ADR      r3,|L2.528|
00012e  22ab              MOVS     r2,#0xab              ;171
000130  e000              B        |L2.308|
                  |L2.306|
000132  e05a              B        |L2.490|
                  |L2.308|
000134  a170              ADR      r1,|L2.760|
000136  a04d              ADR      r0,|L2.620|
000138  f7fffffe          BL       __2printf
00013c  bf00              NOP                            ;171
00013e  bf00              NOP                            ;171
000140  e05f              B        |L2.514|
                  |L2.322|
000142  4620              MOV      r0,r4                 ;175
000144  f7fffffe          BL       pbuf_free
000148  463c              MOV      r4,r7                 ;177
00014a  e010              B        |L2.366|
                  |L2.332|
00014c  f06f0121          MVN      r1,#0x21              ;180
000150  4620              MOV      r0,r4                 ;180
000152  f7fffffe          BL       pbuf_header
000156  b150              CBZ      r0,|L2.366|
000158  bf00              NOP                            ;181
00015a  bf00              NOP                            ;181
00015c  a32c              ADR      r3,|L2.528|
00015e  22b5              MOVS     r2,#0xb5              ;181
000160  a165              ADR      r1,|L2.760|
000162  a042              ADR      r0,|L2.620|
000164  f7fffffe          BL       __2printf
000168  bf00              NOP                            ;181
00016a  bf00              NOP                            ;181
00016c  e049              B        |L2.514|
                  |L2.366|
00016e  6865              LDR      r5,[r4,#4]            ;189
000170  4826              LDR      r0,|L2.524|
000172  6800              LDR      r0,[r0,#0]            ;190  ; current_iphdr_dest
000174  60f0              STR      r0,[r6,#0xc]          ;190
000176  486d              LDR      r0,|L2.812|
000178  6800              LDR      r0,[r0,#0]            ;191  ; current_iphdr_src
00017a  6130              STR      r0,[r6,#0x10]         ;191
00017c  2000              MOVS     r0,#0                 ;192
00017e  7028              STRB     r0,[r5,#0]            ;192
000180  8868              LDRH     r0,[r5,#2]            ;196
000182  f64f71f7          MOV      r1,#0xfff7            ;196
000186  4288              CMP      r0,r1                 ;196
000188  d303              BCC      |L2.402|
00018a  8868              LDRH     r0,[r5,#2]            ;197
00018c  3009              ADDS     r0,r0,#9              ;197
00018e  8068              STRH     r0,[r5,#2]            ;197
000190  e002              B        |L2.408|
                  |L2.402|
000192  8868              LDRH     r0,[r5,#2]            ;199
000194  3008              ADDS     r0,r0,#8              ;199
000196  8068              STRH     r0,[r5,#2]            ;199
                  |L2.408|
000198  20ff              MOVS     r0,#0xff              ;206
00019a  7230              STRB     r0,[r6,#8]            ;206
00019c  2000              MOVS     r0,#0                 ;207
00019e  8170              STRH     r0,[r6,#0xa]          ;207
0001a0  2114              MOVS     r1,#0x14              ;209
0001a2  4630              MOV      r0,r6                 ;209
0001a4  f7fffffe          BL       inet_chksum
0001a8  8170              STRH     r0,[r6,#0xa]          ;209
0001aa  4641              MOV      r1,r8                 ;218
0001ac  4620              MOV      r0,r4                 ;218
0001ae  f7fffffe          BL       pbuf_header
0001b2  b148              CBZ      r0,|L2.456|
0001b4  bf00              NOP                            ;219
0001b6  bf00              NOP                            ;219
0001b8  a315              ADR      r3,|L2.528|
0001ba  22db              MOVS     r2,#0xdb              ;219
0001bc  a15c              ADR      r1,|L2.816|
0001be  a02b              ADR      r0,|L2.620|
0001c0  f7fffffe          BL       __2printf
0001c4  bf00              NOP                            ;219
0001c6  e00f              B        |L2.488|
                  |L2.456|
0001c8  2001              MOVS     r0,#1                 ;223
0001ca  2100              MOVS     r1,#0                 ;223
0001cc  23ff              MOVS     r3,#0xff              ;223
0001ce  460a              MOV      r2,r1                 ;223
0001d0  e9cd0901          STRD     r0,r9,[sp,#4]         ;223
0001d4  9100              STR      r1,[sp,#0]            ;223
0001d6  490d              LDR      r1,|L2.524|
0001d8  4620              MOV      r0,r4                 ;223
0001da  f7fffffe          BL       ip_output_if
0001de  4607              MOV      r7,r0                 ;223
0001e0  b10f              CBZ      r7,|L2.486|
0001e2  bf00              NOP                            ;226
0001e4  bf00              NOP                            ;226
                  |L2.486|
0001e6  bf00              NOP                            ;228
                  |L2.488|
0001e8  e002              B        |L2.496|
                  |L2.490|
0001ea  bf00              NOP                            ;231
0001ec  bf00              NOP                            ;231
0001ee  bf00              NOP                            ;102
                  |L2.496|
0001f0  bf00              NOP                            ;106
0001f2  4620              MOV      r0,r4                 ;236
0001f4  f7fffffe          BL       pbuf_free
0001f8  e73a              B        |L2.112|
                  |L2.506|
0001fa  4620              MOV      r0,r4                 ;239
0001fc  f7fffffe          BL       pbuf_free
000200  e736              B        |L2.112|
                  |L2.514|
000202  4620              MOV      r0,r4                 ;245
000204  f7fffffe          BL       pbuf_free
000208  bf00              NOP                            ;248
00020a  e731              B        |L2.112|
;;;251    
                          ENDP

                  |L2.524|
                          DCD      current_iphdr_dest
                  |L2.528|
000210  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\ipv4\\icmp.c",0
000214  5749505c
000218  6c776970
00021c  2d312e34
000220  2e315c73
000224  72635c63
000228  6f72655c
00022c  69707634
000230  5c69636d
000234  702e6300
                  |L2.568|
000238  69636d70          DCB      "icmp_input: moving p->payload to ip header failed\n",0
00023c  5f696e70
000240  75743a20
000244  6d6f7669
000248  6e672070
00024c  2d3e7061
000250  796c6f61
000254  6420746f
000258  20697020
00025c  68656164
000260  65722066
000264  61696c65
000268  640a00  
00026b  00                DCB      0
                  |L2.620|
00026c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
000270  7274696f
000274  6e202225
000278  73222066
00027c  61696c65
000280  64206174
000284  206c696e
000288  65202564
00028c  20696e20
000290  25730d0a
000294  00      
000295  00                DCB      0
000296  00                DCB      0
000297  00                DCB      0
                  |L2.664|
000298  63686563          DCB      "check that first pbuf can hold struct the ICMP header",0
00029c  6b207468
0002a0  61742066
0002a4  69727374
0002a8  20706275
0002ac  66206361
0002b0  6e20686f
0002b4  6c642073
0002b8  74727563
0002bc  74207468
0002c0  65204943
0002c4  4d502068
0002c8  65616465
0002cc  7200    
0002ce  00                DCB      0
0002cf  00                DCB      0
                  |L2.720|
0002d0  69636d70          DCB      "icmp_input: copying to new pbuf failed\n",0
0002d4  5f696e70
0002d8  75743a20
0002dc  636f7079
0002e0  696e6720
0002e4  746f206e
0002e8  65772070
0002ec  62756620
0002f0  6661696c
0002f4  65640a00
                  |L2.760|
0002f8  69636d70          DCB      "icmp_input: restoring original p->payload failed\n",0
0002fc  5f696e70
000300  75743a20
000304  72657374
000308  6f72696e
00030c  67206f72
000310  6967696e
000314  616c2070
000318  2d3e7061
00031c  796c6f61
000320  64206661
000324  696c6564
000328  0a00    
00032a  00                DCB      0
00032b  00                DCB      0
                  |L2.812|
                          DCD      current_iphdr_src
                  |L2.816|
000330  43616e27          DCB      "Can't move over header in packet",0
000334  74206d6f
000338  7665206f
00033c  76657220
000340  68656164
000344  65722069
000348  6e207061
00034c  636b6574
000350  00      
000351  00                DCB      0
000352  00                DCB      0
000353  00                DCB      0

                          AREA ||i.icmp_send_response||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  icmp_send_response PROC
;;;291    static void
;;;292    icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;293    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;294    	
;;;295      struct pbuf *q;
;;;296      struct ip_hdr *iphdr;
;;;297      /* we can use the echo header here */
;;;298      struct icmp_echo_hdr *icmphdr;
;;;299      ip_addr_t iphdr_src;
;;;300    
;;;301      /* ICMP header + IP header + 8 bytes of data */
;;;302      q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
00000a  2200              MOVS     r2,#0
00000c  2124              MOVS     r1,#0x24
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       pbuf_alloc
000014  4605              MOV      r5,r0
;;;303                     PBUF_RAM);
;;;304      if (q == NULL) {
000016  b91d              CBNZ     r5,|L3.32|
;;;305        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L3.28|
;;;306        return;
;;;307      }
;;;308      LWIP_ASSERT("check that first pbuf can hold icmp message",
;;;309                 (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));
;;;310    
;;;311      iphdr = (struct ip_hdr *)p->payload;
;;;312      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded from "));
;;;313      ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
;;;314      LWIP_DEBUGF(ICMP_DEBUG, (" to "));
;;;315      ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
;;;316      LWIP_DEBUGF(ICMP_DEBUG, ("\n"));
;;;317    
;;;318      icmphdr = (struct icmp_echo_hdr *)q->payload;
;;;319      icmphdr->type = type;
;;;320      icmphdr->code = code;
;;;321      icmphdr->id = 0;
;;;322      icmphdr->seqno = 0;
;;;323    
;;;324      /* copy fields from original packet */
;;;325      SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
;;;326              IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);
;;;327    
;;;328      /* calculate checksum */
;;;329      icmphdr->chksum = 0;
;;;330      icmphdr->chksum = inet_chksum(icmphdr, q->len);
;;;331      ICMP_STATS_INC(icmp.xmit);
;;;332      /* increase number of messages attempted to send */
;;;333      snmp_inc_icmpoutmsgs();
;;;334      /* increase number of destination unreachable messages attempted to send */
;;;335      snmp_inc_icmpouttimeexcds();
;;;336      ip_addr_copy(iphdr_src, iphdr->src);
;;;337      ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
;;;338      pbuf_free(q);
;;;339    
;;;340    }
00001c  e8bd83fe          POP      {r1-r9,pc}
                  |L3.32|
000020  bf00              NOP                            ;308
000022  8968              LDRH     r0,[r5,#0xa]          ;308
000024  2824              CMP      r0,#0x24              ;308
000026  d208              BCS      |L3.58|
000028  bf00              NOP                            ;308
00002a  a31d              ADR      r3,|L3.160|
00002c  f44f729a          MOV      r2,#0x134             ;308
000030  a125              ADR      r1,|L3.200|
000032  a030              ADR      r0,|L3.244|
000034  f7fffffe          BL       __2printf
000038  bf00              NOP                            ;308
                  |L3.58|
00003a  bf00              NOP                            ;308
00003c  f8d69004          LDR      r9,[r6,#4]            ;311
000040  bf00              NOP                            ;312
000042  bf00              NOP                            ;312
000044  bf00              NOP                            ;313
000046  bf00              NOP                            ;313
000048  bf00              NOP                            ;314
00004a  bf00              NOP                            ;314
00004c  bf00              NOP                            ;315
00004e  bf00              NOP                            ;315
000050  bf00              NOP                            ;316
000052  bf00              NOP                            ;316
000054  686c              LDR      r4,[r5,#4]            ;318
000056  7027              STRB     r7,[r4,#0]            ;319
000058  f8848001          STRB     r8,[r4,#1]            ;320
00005c  2000              MOVS     r0,#0                 ;321
00005e  80a0              STRH     r0,[r4,#4]            ;321
000060  80e0              STRH     r0,[r4,#6]            ;322
000062  6871              LDR      r1,[r6,#4]            ;325
000064  686a              LDR      r2,[r5,#4]            ;325
000066  f1020008          ADD      r0,r2,#8              ;325
00006a  221c              MOVS     r2,#0x1c              ;325
00006c  f7fffffe          BL       __aeabi_memcpy
000070  2000              MOVS     r0,#0                 ;329
000072  8060              STRH     r0,[r4,#2]            ;329
000074  8969              LDRH     r1,[r5,#0xa]          ;330
000076  4620              MOV      r0,r4                 ;330
000078  f7fffffe          BL       inet_chksum
00007c  8060              STRH     r0,[r4,#2]            ;330
00007e  f8d9000c          LDR      r0,[r9,#0xc]          ;336
000082  9002              STR      r0,[sp,#8]            ;336
000084  2001              MOVS     r0,#1                 ;337
000086  2100              MOVS     r1,#0                 ;337
000088  23ff              MOVS     r3,#0xff              ;337
00008a  aa02              ADD      r2,sp,#8              ;337
00008c  e9cd1000          STRD     r1,r0,[sp,#0]         ;337
000090  4628              MOV      r0,r5                 ;337
000092  f7fffffe          BL       ip_output
000096  4628              MOV      r0,r5                 ;338
000098  f7fffffe          BL       pbuf_free
00009c  bf00              NOP      
00009e  e7bd              B        |L3.28|
;;;341    
                          ENDP

                  |L3.160|
0000a0  2e2e5c4c          DCB      "..\\LWIP\\lwip-1.4.1\\src\\core\\ipv4\\icmp.c",0
0000a4  5749505c
0000a8  6c776970
0000ac  2d312e34
0000b0  2e315c73
0000b4  72635c63
0000b8  6f72655c
0000bc  69707634
0000c0  5c69636d
0000c4  702e6300
                  |L3.200|
0000c8  63686563          DCB      "check that first pbuf can hold icmp message",0
0000cc  6b207468
0000d0  61742066
0000d4  69727374
0000d8  20706275
0000dc  66206361
0000e0  6e20686f
0000e4  6c642069
0000e8  636d7020
0000ec  6d657373
0000f0  61676500
                  |L3.244|
0000f4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\r\n",0
0000f8  7274696f
0000fc  6e202225
000100  73222066
000104  61696c65
000108  64206174
00010c  206c696e
000110  65202564
000114  20696e20
000118  25730d0a
00011c  00      
00011d  00                DCB      0
00011e  00                DCB      0
00011f  00                DCB      0

                          AREA ||i.icmp_time_exceeded||, CODE, READONLY, ALIGN=1

                  icmp_time_exceeded PROC
;;;275    void
;;;276    icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
000000  b570              PUSH     {r4-r6,lr}
;;;277    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;278      icmp_send_response(p, ICMP_TE, t);
000006  4622              MOV      r2,r4
000008  210b              MOVS     r1,#0xb
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       icmp_send_response
;;;279    }
000010  bd70              POP      {r4-r6,pc}
;;;280    
                          ENDP

